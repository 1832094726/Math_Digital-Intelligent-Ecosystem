{
    "1.1 1 a)": {
        "question": "下列哪些语句是命题？这些是命题的语句的真值是什么？波士顿是马萨诸塞州首府。",
        "answer": "是，T",
        "answer_symbols": []
    },
    "1.1 1 b)": {
        "question": "下列哪些语句是命题？这些是命题的语句的真值是什么？迈阿密是佛罗里达州首府。",
        "answer": "是，F",
        "answer_symbols": []
    },
    "1.1 1 c)": {
        "question": "下列哪些语句是命题？这些是命题的语句的真值是什么？2 + 3 = 5。",
        "answer": "是，T",
        "answer_symbols": []
    },
    "1.1 1 d)": {
        "question": "下列哪些语句是命题？这些是命题的语句的真值是什么？5 + 7 = 10。",
        "answer": "是，F",
        "answer_symbols": []
    },
    "1.1 1 e)": {
        "question": "下列哪些语句是命题？这些是命题的语句的真值是什么？x + 2 = 11。",
        "answer": "不是",
        "answer_symbols": []
    },
    "1.1 1 f)": {
        "question": "下列哪些语句是命题？这些是命题的语句的真值是什么？回答这个问题。",
        "answer": "不是",
        "answer_symbols": []
    },
    "1.1 2 a)": {
        "question": "下列哪些是命题？这些命题的真值是什么？别过去。",
        "answer": "这不是一个命题；这是一个命令。",
        "answer_symbols": []
    },
    "1.1 2 b)": {
        "question": "下列哪些是命题？这些命题的真值是什么？几点了？",
        "answer": "这不是一个命题；这是一个问题。",
        "answer_symbols": []
    },
    "1.1 2 c)": {
        "question": "下列哪些是命题？这些命题的真值是什么？在缅因州没有黑苍蝇。",
        "answer": "这是一个假命题，因为任何去过缅因州的人都知道。",
        "answer_symbols": []
    },
    "1.1 2 d)": {
        "question": "下列哪些是命题？这些命题的真值是什么？4 + x = 5。",
        "answer": "这不是一个命题；其真值取决于 x 的值。",
        "answer_symbols": [
            "x"
        ]
    },
    "1.1 2 e)": {
        "question": "下列哪些是命题？这些命题的真值是什么？月亮是由绿色的奶酪构成的。",
        "answer": "这是一个假命题。",
        "answer_symbols": []
    },
    "1.1 2 f)": {
        "question": "下列哪些是命题？这些命题的真值是什么？2^² = 100。",
        "answer": "这不是一个命题；其真值取决于 n 的值。",
        "answer_symbols": [
            "n"
        ]
    },
    "1.1 3 a)": {
        "question": "下列各命题的否定是什么？Mei 有一台 MP3 播放器。",
        "answer": "梅没有MP3播放器。",
        "answer_symbols": []
    },
    "1.1 3 b)": {
        "question": "下列各命题的否定是什么？新泽西没有污染。",
        "answer": "新泽西州有污染。",
        "answer_symbols": []
    },
    "1.1 3 c)": {
        "question": "下列各命题的否定是什么？2+1=3。",
        "answer": "2 + 1 ≠ 3。",
        "answer_symbols": [
            "+",
            "≠"
        ]
    },
    "1.1 3 d)": {
        "question": "下列各命题的否定是什么？缅因州的夏天又热又晒。",
        "answer": "缅因州的夏天不热或不晴朗。",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.1 4 a)": {
        "question": "下列各命题的否定是什么？Jennifer 和 Teja 是朋友。",
        "answer": "Jennifer 和 Teja 不是朋友。",
        "answer_symbols": []
    },
    "1.1 4 b)": {
        "question": "下列各命题的否定是什么？面包师说的一打有13个。",
        "answer": "一个面包师的一打不包含 13 个项目。（或者：面包师的一打中的项目数量不等于 13。）",
        "answer_symbols": [
            "≠"
        ]
    },
    "1.1 4 c)": {
        "question": "下列各命题的否定是什么？Abby每天发送100多条文本信息",
        "answer": "Abby 昨天发送的短信少于 101 条。或者，Abby 昨天发送的短信不超过 100 条。注意：本书第一版中将此练习中的“昨天”误写为“每天”。这使它成为一个更难的问题，因为日期被量化了，而量化命题在后续章节中才会涉及。说“Abby 每天发送的短信不超过 100 条”是不正确的。正确的否定应该是“存在某一天，Abby 发送的短信不超过 100 条。”说“Abby 并非每天发送超过 100 条短信”有些模棱两可——我们是意味着 ¬∀ 还是 ∀¬？",
        "answer_symbols": [
            "<",
            "≤",
            "¬",
            "∀"
        ]
    },
    "1.1 4 d)": {
        "question": "下列各命题的否定是什么？121 是一个完全平方数。",
        "answer": "121 不是一个完全平方数。",
        "answer_symbols": []
    },
    "1.1 5 a)": {
        "question": "下列各命题的否定是什么？Steve 的笔记本电脑有大于 100GB 的空闲磁盘空间。",
        "answer": "史蒂夫在他的笔记本电脑上没有超过100 GB的空闲磁盘空间。",
        "answer_symbols": []
    },
    "1.1 5 b)": {
        "question": "下列各命题的否定是什么？Zach 阻止来自 Jennifer 的邮件和短信。",
        "answer": "扎克没有屏蔽詹妮弗的邮件，或者他没有屏蔽詹妮弗的短信。",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.1 5 c)": {
        "question": "下列各命题的否定是什么？7 * 11 * 13 = 999。",
        "answer": "7 × 11 × 13 = 999。",
        "answer_symbols": [
            "×",
            "="
        ]
    },
    "1.1 5 d)": {
        "question": "下列各命题的否定是什么？Diane 周日骑自行车骑了 100 英里。",
        "answer": "黛安星期天没有骑自行车100英里。",
        "answer_symbols": []
    },
    "1.1 6 d)": {
        "question": "智能手机 A 有 256MB RAM 和 32GB ROM，并且其照相机的分辨率是 8MP；智能手机 B 有 288MB RAM 和 64GB ROM，并且其照相机的分辨率是 4MP；而智能手机 C 有 128MB RAM 和 32GB ROM，并且其照相机的分辨率是 5MP。试判定下面每个命题的真值。如果智能手机 B 比智能手机 C 具有更多的 RAM 和更多的 ROM，则它也具有更高分辨率的相机。",
        "answer": "假，因为这个条件语句的假设部分为真，结论部分为假。",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 6 e)": {
        "question": "智能手机 A 有 256MB RAM 和 32GB ROM，并且其照相机的分辨率是 8MP；智能手机 B 有 288MB RAM 和 64GB ROM，并且其照相机的分辨率是 4MP；而智能手机 C 有 128MB RAM 和 32GB ROM，并且其照相机的分辨率是 5MP。试判定下面每个命题的真值。智能手机 A 比智能手机 B 具有更多的 RAM 当且仅当智能手机 B 比智能手机 A 具有更多的 RAM。",
        "answer": "假，因为这个双条件语句的第一部分为假，第二部分为真。",
        "answer_symbols": [
            "↔"
        ]
    },
    "1.1 6 b)": {
        "question": "智能手机 A 有 256MB RAM 和 32GB ROM，并且其照相机的分辨率是 8MP；智能手机 B 有 288MB RAM 和 64GB ROM，并且其照相机的分辨率是 4MP；而智能手机 C 有 128MB RAM 和 32GB ROM，并且其照相机的分辨率是 5MP。试判定下面每个命题的真值。智能手机 C 比智能手机 B 具有更多的 ROM 或者更高分辨率的相机。",
        "answer": "真，因为 C 的分辨率为 500 万像素，而 B 的分辨率为 400 万像素。注意，由于使用了“或”这个词，这两个条件中的任何一个满足即可。",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.1 6 c)": {
        "question": "智能手机 A 有 256MB RAM 和 32GB ROM，并且其照相机的分辨率是 8MP；智能手机 B 有 288MB RAM 和 64GB ROM，并且其照相机的分辨率是 4MP；而智能手机 C 有 128MB RAM 和 32GB ROM，并且其照相机的分辨率是 5MP。试判定下面每个命题的真值。智能手机 B 比智能手机 A 具有更多的 RAM、更多的 ROM 和更高分辨率的相机。",
        "answer": "假，因为它的分辨率并不更高（所有的陈述都必须为真，合取才能为真）。",
        "answer_symbols": [
            "∧"
        ]
    },
    "1.1 7 a)": {
        "question": "试判定有关最近财年的每个命题的真值。Quixote 媒体的年收入最多。",
        "answer": "F",
        "answer_symbols": []
    },
    "1.1 7 b)": {
        "question": "试判定有关最近财年的每个命题的真值。Nadir 软件公司的净利润最少并且 Acme 计算机公司的年收入最多。",
        "answer": "T",
        "answer_symbols": []
    },
    "1.1 7 c)": {
        "question": "试判定有关最近财年的每个命题的真值。Acme 计算机公司的净利润最多或者 Quixote 媒体的净利润最多。",
        "answer": "T",
        "answer_symbols": []
    },
    "1.1 7 d)": {
        "question": "试判定有关最近财年的每个命题的真值。如果 Quixote 媒体的净利润最少，则 Acme 计算机公司的年收入最多。",
        "answer": "T",
        "answer_symbols": []
    },
    "1.1 7 e)": {
        "question": "试判定有关最近财年的每个命题的真值。Nadir 软件公司的净利润最少当且仅当 Acme 计算机公司的年收入最多。",
        "answer": "T",
        "answer_symbols": []
    },
    "1.1 6 a)": {
        "question": "智能手机 B 的 RAM 是三款手机中最多的。",
        "answer": "真，因为 288 > 256 且 288 > 128。",
        "answer_symbols": [
            ">",
            "∧"
        ]
    },
    "1.1 8 a)": {
        "question": "令 p、q 为如下命题：p: 本周我买了一张彩票。q: 我赢得了百万元大奖。试用汉语表达下列各命题。¬p",
        "answer": "我这周没有买彩票。",
        "answer_symbols": [
            "¬"
        ]
    },
    "1.1 8 b)": {
        "question": "令 p、q 为如下命题：p: 本周我买了一张彩票。q: 我赢得了百万元大奖。试用汉语表达下列各命题。p ∨ q",
        "answer": "我这周要么买了彩票，要么（在包含意义上）周五中了一百万美元的大奖。",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.1 8 c)": {
        "question": "令 p、q 为如下命题：p: 本周我买了一张彩票。q: 我赢得了百万元大奖。试用汉语表达下列各命题。p → q",
        "answer": "如果我这周买了彩票，那么我周五中了一百万美元的大奖。",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 8 d)": {
        "question": "令 p、q 为如下命题：p: 本周我买了一张彩票。q: 我赢得了百万元大奖。试用汉语表达下列各命题。p ∧ q",
        "answer": "我这周买了彩票并且中了一百万美元的大奖。",
        "answer_symbols": [
            "∧"
        ]
    },
    "1.1 8 e)": {
        "question": "令 p、q 为如下命题：p: 本周我买了一张彩票。q: 我赢得了百万元大奖。试用汉语表达下列各命题。p ↔ q",
        "answer": "我这周买了彩票当且仅当我周五中了一百万美元的大奖。",
        "answer_symbols": [
            "↔"
        ]
    },
    "1.1 8 f)": {
        "question": "令 p、q 为如下命题：p: 本周我买了一张彩票。q: 我赢得了百万元大奖。试用汉语表达下列各命题。¬p → ¬q",
        "answer": "如果我这周没有买彩票，那么我没有中一百万美元的大奖。",
        "answer_symbols": [
            "¬",
            "→"
        ]
    },
    "1.1 8 g)": {
        "question": "令 p、q 为如下命题：p: 本周我买了一张彩票。q: 我赢得了百万元大奖。试用汉语表达下列各命题。¬p ∧ ¬q",
        "answer": "这个星期我没有买彩票，也没有在周五赢得一百万美元的头奖",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.1 8 h)": {
        "question": "令 p、q 为如下命题：p: 本周我买了一张彩票。q: 我赢得了百万元大奖。试用汉语表达下列各命题。¬p ∨ (p ∧ q)",
        "answer": "要么这个星期我没有买彩票，要么我买了并且在周五赢得了百万美元的头奖",
        "answer_symbols": [
            "∨",
            "∧"
        ]
    },
    "1.1 9 a)": {
        "question": "令 p 和 q 分别表示命题“在新泽西海岸游泳是允许的”和“在海岸附近发现过鲨鱼”。试用汉语表达下列每个复合命题。（a）¬q",
        "answer": "没有鲨鱼在海岸附近被发现。",
        "answer_symbols": []
    },
    "1.1 9 b)": {
        "question": "令 p 和 q 分别表示命题“在新泽西海岸游泳是允许的”和“在海岸附近发现过鲨鱼”。试用汉语表达下列每个复合命题。（b）p ∧ q",
        "answer": "允许在新泽西州海岸游泳，并且有鲨鱼在海岸附近被发现。",
        "answer_symbols": [
            "∧"
        ]
    },
    "1.1 9 c)": {
        "question": "令 p 和 q 分别表示命题“在新泽西海岸游泳是允许的”和“在海岸附近发现过鲨鱼”。试用汉语表达下列每个复合命题。（c）¬p ∨ q",
        "answer": "不允许在新泽西州海岸游泳，或者有鲨鱼在海岸附近被发现。",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.1 9 d)": {
        "question": "令 p 和 q 分别表示命题“在新泽西海岸游泳是允许的”和“在海岸附近发现过鲨鱼”。试用汉语表达下列每个复合命题。（d）p → ¬q",
        "answer": "如果允许在新泽西州海岸游泳，那么没有鲨鱼在海岸附近被发现。",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 9 e)": {
        "question": "令 p 和 q 分别表示命题“在新泽西海岸游泳是允许的”和“在海岸附近发现过鲨鱼”。试用汉语表达下列每个复合命题。（e）¬q → p",
        "answer": "如果没有鲨鱼在海岸附近被发现，那么允许在新泽西州海岸游泳。",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 9 f)": {
        "question": "令 p 和 q 分别表示命题“在新泽西海岸游泳是允许的”和“在海岸附近发现过鲨鱼”。试用汉语表达下列每个复合命题。（f）¬p → ¬q",
        "answer": "如果不允许在新泽西州海岸游泳，那么没有鲨鱼在海岸附近被发现。",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 9 g)": {
        "question": "令 p 和 q 分别表示命题“在新泽西海岸游泳是允许的”和“在海岸附近发现过鲨鱼”。试用汉语表达下列每个复合命题。（g）p ↔ ¬q",
        "answer": "允许在新泽西州海岸游泳当且仅当没有鲨鱼在海岸附近被发现。",
        "answer_symbols": [
            "↔"
        ]
    },
    "1.1 9 h)": {
        "question": "令 p 和 q 分别表示命题“在新泽西海岸游泳是允许的”和“在海岸附近发现过鲨鱼”。试用汉语表达下列每个复合命题。（h）¬p ∧ (p ∨ ¬q)",
        "answer": "不允许在新泽西州海岸游泳，并且允许在新泽西州海岸游泳或没有鲨鱼在海岸附近被发现。",
        "answer_symbols": [
            "∧",
            "∨"
        ]
    },
    "1.1 10 a)": {
        "question": "令 p 和 q 分别表示命题“选举已经有了结果”和“选票已经计数完毕”。试用汉语表达下列各命题。（a）¬p",
        "answer": "选举尚未决定",
        "answer_symbols": [
            "¬"
        ]
    },
    "1.1 10 b)": {
        "question": "令 p 和 q 分别表示命题“选举已经有了结果”和“选票已经计数完毕”。试用汉语表达下列各命题。（b）p ∨ q",
        "answer": "选举已经决定，或者选票已经被计数",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.1 10 c)": {
        "question": "令 p 和 q 分别表示命题“选举已经有了结果”和“选票已经计数完毕”。试用汉语表达下列各命题。（c）¬p ∧ q",
        "answer": "选举尚未决定，并且选票已经被计数",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.1 10 d)": {
        "question": "令 p 和 q 分别表示命题“选举已经有了结果”和“选票已经计数完毕”。试用汉语表达下列各命题。（d）q → p",
        "answer": "如果选票已经被计数，那么选举已经决定",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 10 e)": {
        "question": "令 p 和 q 分别表示命题“选举已经有了结果”和“选票已经计数完毕”。试用汉语表达下列各命题。（e）¬q → ¬p",
        "answer": "如果选票尚未被计数，那么选举尚未决定",
        "answer_symbols": [
            "→",
            "¬"
        ]
    },
    "1.1 10 f)": {
        "question": "令 p 和 q 分别表示命题“选举已经有了结果”和“选票已经计数完毕”。试用汉语表达下列各命题。（f）¬p → ¬q",
        "answer": "如果选举尚未决定，那么选票尚未被计数",
        "answer_symbols": [
            "→",
            "¬"
        ]
    },
    "1.1 10 g)": {
        "question": "令 p 和 q 分别表示命题“选举已经有了结果”和“选票已经计数完毕”。试用汉语表达下列各命题。（g）p ↔ q",
        "answer": "选举已经决定当且仅当选票已经被计数",
        "answer_symbols": [
            "↔"
        ]
    },
    "1.1 10 h)": {
        "question": "令 p 和 q 分别表示命题“选举已经有了结果”和“选票已经计数完毕”。试用汉语表达下列各命题。（h）¬q ∨ (¬p ∧ q)",
        "answer": "要么选票尚未被计数，要么选举尚未决定并且选票已经被计数",
        "answer_symbols": [
            "∨",
            "∧",
            "¬"
        ]
    },
    "1.1 11 a)": {
        "question": "令 p、q 为如下命题：p：气温在零度以下。q：正在下雪。用 p、q 和逻辑联结词（包括否定）写出下列各命题。（a）气温在零度以下且正下着雪。",
        "answer": "p ∧ q",
        "answer_symbols": [
            "∧"
        ]
    },
    "1.1 11 b)": {
        "question": "令 p、q 为如下命题：p：气温在零度以下。q：正在下雪。用 p、q 和逻辑联结词（包括否定）写出下列各命题。（b）气温在零度以下，但没有下雪。",
        "answer": "p ∧ ¬q",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.1 11 c)": {
        "question": "令 p、q 为如下命题：p：气温在零度以下。q：正在下雪。用 p、q 和逻辑联结词（包括否定）写出下列各命题。（c）气温不在零度以下，并且没有下雪。",
        "answer": "¬p ∧ ¬q",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.1 11 d)": {
        "question": "令 p、q 为如下命题：p：气温在零度以下。q：正在下雪。用 p、q 和逻辑联结词（包括否定）写出下列各命题。（d）也许正下着雪，也许在零度以下（也许两者兼有）。",
        "answer": "p ∨ q",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.1 11 e)": {
        "question": "令 p、q 为如下命题：p：气温在零度以下。q：正在下雪。用 p、q 和逻辑联结词（包括否定）写出下列各命题。（e）如果气温在零度以下，则也下着雪。",
        "answer": "p → q",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 11 f)": {
        "question": "令 p、q 为如下命题：p：气温在零度以下。q：正在下雪。用 p、q 和逻辑联结词（包括否定）写出下列各命题。（f）也许气温在零度以下，也许下着雪；但如果在零度以下，就没有下雪。",
        "answer": "(p ∨ q) ∧ (p → ¬q)",
        "answer_symbols": [
            "∨",
            "∧",
            "→",
            "¬"
        ]
    },
    "1.1 11 g)": {
        "question": "令 p、q 为如下命题：p：气温在零度以下。q：正在下雪。用 p、q 和逻辑联结词（包括否定）写出下列各命题。（g）气温在零度以下是下雪的充分必要条件。",
        "answer": "q ↔ p",
        "answer_symbols": [
            "↔"
        ]
    },
    "1.1 12 a)": {
        "question": "令 p、q 和 r 为如下命题：p：你得流感了。q：你错过了期末考试。r：这门课你及格了。将下列各命题用汉语表示。（a）p → q",
        "answer": "如果你得了流感，那么你会错过期末考试",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 12 b)": {
        "question": "令 p、q 和 r 为如下命题：p：你得流感了。q：你错过了期末考试。r：这门课你及格了。将下列各命题用汉语表示。（b）¬q ↔ r",
        "answer": "你不会错过期末考试当且仅当你通过了这门课程",
        "answer_symbols": [
            "↔",
            "¬"
        ]
    },
    "1.1 12 c)": {
        "question": "令 p、q 和 r 为如下命题：p：你得流感了。q：你错过了期末考试。r：这门课你及格了。将下列各命题用汉语表示。（c）q → ¬r",
        "answer": "如果你错过了期末考试，那么你没有通过这门课程",
        "answer_symbols": [
            "→",
            "¬"
        ]
    },
    "1.1 12 d)": {
        "question": "令 p、q 和 r 为如下命题：p：你得流感了。q：你错过了期末考试。r：这门课你及格了。将下列各命题用汉语表示。（d）p ∨ q ∨ r",
        "answer": "你得了流感，或者错过了期末考试，或者通过了这门课程",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.1 12 e)": {
        "question": "令 p、q 和 r 为如下命题：p：你得流感了。q：你错过了期末考试。r：这门课你及格了。将下列各命题用汉语表示。（e）(p → ¬r) ∨ (q → ¬r)",
        "answer": "要么是你得了流感然后没有通过这门课程，要么是你错过了期末考试然后没有通过这门课程（或两者都有）",
        "answer_symbols": [
            "∨",
            "∧",
            "¬"
        ]
    },
    "1.1 12 f)": {
        "question": "令 p、q 和 r 为如下命题：p：你得流感了。q：你错过了期末考试。r：这门课你及格了。将下列各命题用汉语表示。（f）(p ∧ q) ∨ (¬q ∧ r)",
        "answer": "要么你得了流感并且错过了期末考试，要么你没有错过期末考试并且通过了这门课程",
        "answer_symbols": [
            "∨",
            "∧",
            "¬"
        ]
    },
    "1.1 13 a)": {
        "question": "令 p、q 为如下命题：p：你的车速超过每小时 65 英里（1 英里 = 1.6 公里）。q：你接到一张超速罚单。用 p、q 和逻辑联结词（包括否定）写出下列命题。（a）你的车速没有超过每小时 65 英里。",
        "answer": "¬p",
        "answer_symbols": [
            "¬"
        ]
    },
    "1.1 13 b)": {
        "question": "令 p、q 为如下命题：p：你的车速超过每小时 65 英里（1 英里 = 1.6 公里）。q：你接到一张超速罚单。用 p、q 和逻辑联结词（包括否定）写出下列命题。（b）你的车速超过每小时 65 英里，但没接到超速罚单。",
        "answer": "p ∧ ¬q",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.1 13 c)": {
        "question": "令 p、q 为如下命题：p：你的车速超过每小时 65 英里（1 英里 = 1.6 公里）。q：你接到一张超速罚单。用 p、q 和逻辑联结词（包括否定）写出下列命题。（c）如果你的车速超过每小时 65 英里，你将接到一张超速罚单。",
        "answer": "p → q",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 13 d)": {
        "question": "令 p、q 为如下命题：p：你的车速超过每小时 65 英里（1 英里 = 1.6 公里）。q：你接到一张超速罚单。用 p、q 和逻辑联结词（包括否定）写出下列命题。（d）如果你的车速不超过每小时 65 英里，你就不会接到超速罚单。",
        "answer": "¬p → ¬q",
        "answer_symbols": [
            "→",
            "¬"
        ]
    },
    "1.1 13 e)": {
        "question": "令 p、q 为如下命题：p：你的车速超过每小时 65 英里（1 英里 = 1.6 公里）。q：你接到一张超速罚单。用 p、q 和逻辑联结词（包括否定）写出下列命题。（e）车速超过每小时 65 英里足以接到超速罚单。",
        "answer": "p → q",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 13 f)": {
        "question": "令 p、q 为如下命题：p：你的车速超过每小时 65 英里（1 英里 = 1.6 公里）。q：你接到一张超速罚单。用 p、q 和逻辑联结词（包括否定）写出下列命题。（f）你接到一张超速罚单，但你的车速没超过每小时 65 英里。",
        "answer": "q ∧ ¬p",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.1 13 g)": {
        "question": "令 p、q 为如下命题：p：你的车速超过每小时 65 英里（1 英里 = 1.6 公里）。q：你接到一张超速罚单。用 p、q 和逻辑联结词（包括否定）写出下列命题。（g）只要你接到一张超速罚单，你的车速就超过每小时 65 英里。",
        "answer": "q → p",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 14 a)": {
        "question": "令 p、q、r 为如下命题：p：你的期末考试得了 A。q：你做了这本书每一道练习。r：这门课你得了 A。用 p、q、r 和逻辑联结词（包括否定）写出下列命题。（a）这门课你得了 A，但你并没做本书的每道练习。",
        "answer": "r ∧ ¬q",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.1 14 b)": {
        "question": "令 p、q、r 为如下命题：p：你的期末考试得了 A。q：你做了这本书每一道练习。r：这门课你得了 A。用 p、q、r 和逻辑联结词（包括否定）写出下列命题。（b）你的期末考试得了 A，你做了本书的每一道练习，并且这门课你得了 A。",
        "answer": "p ∧ q ∧ r",
        "answer_symbols": [
            "∧"
        ]
    },
    "1.1 14 c)": {
        "question": "令 p、q、r 为如下命题：p：你的期末考试得了 A。q：你做了这本书每一道练习。r：这门课你得了 A。用 p、q、r 和逻辑联结词（包括否定）写出下列命题。（c）想在这门课得 A，你必须在期末考试得 A。",
        "answer": "r → p",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 14 d)": {
        "question": "令 p、q、r 为如下命题：p：你的期末考试得了 A。q：你做了这本书每一道练习。r：这门课你得了 A。用 p、q、r 和逻辑联结词（包括否定）写出下列命题。（d）你的期末考试得了 A，你没有做本书的每道练习；然而这门课你还是得了 A。",
        "answer": "p ∧ ¬q ∧ r",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.1 14 e)": {
        "question": "令 p、q、r 为如下命题：p：你的期末考试得了 A。q：你做了这本书每一道练习。r：这门课你得了 A。用 p、q、r 和逻辑联结词（包括否定）写出下列命题。（e）期末考试得 A 并且做本书的每道练习，足以使你这门课得 A。",
        "answer": "(p ∧ q) → r",
        "answer_symbols": [
            "∧",
            "→"
        ]
    },
    "1.1 14 f)": {
        "question": "令 p、q、r 为如下命题：p：你的期末考试得了 A。q：你做了这本书每一道练习。r：这门课你得了 A。用 p、q、r 和逻辑联结词（包括否定）写出下列命题。（f）这门课得 A 当且仅当你做本书的每道练习或期末考试得 A。",
        "answer": "r ↔ (q ∨ p)",
        "answer_symbols": [
            "↔",
            "∨"
        ]
    },
    "1.1 15 a)": {
        "question": "令 p、q、r 为如下命题：用 p、q、r 和逻辑联结词（包括否定）写出下列命题。乡间小路两旁的草莓成熟了，但在这个地区没有发现过灰熊。",
        "answer": "r ∧ ¬p",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.1 15 b)": {
        "question": "令 p、q、r 为如下命题：用 p、q、r 和逻辑联结词（包括否定）写出下列命题。在这个地区没有发现过灰熊，且在乡间小路上徒步旅行是安全的，但乡间小路两旁的草莓成熟了。",
        "answer": "¬p ∧ q ∧ r",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.1 15 c)": {
        "question": "令 p、q、r 为如下命题：用 p、q、r 和逻辑联结词（包括否定）写出下列命题。如果乡间小路两旁的草莓成熟了，徒步旅行是安全的当且仅当在这个地区没有发现过灰熊。",
        "answer": "r → (q ↔ ¬p)",
        "answer_symbols": [
            "→",
            "↔",
            "¬"
        ]
    },
    "1.1 15 d)": {
        "question": "令 p、q、r 为如下命题：用 p、q、r 和逻辑联结词（包括否定）写出下列命题。在乡间小路上徒步旅行是不安全的，但在这个地区没有发现过灰熊且小路两旁的草莓成熟了。",
        "answer": "¬q ∧ ¬p ∧ r",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.1 15 e)": {
        "question": "令 p、q、r 为如下命题：用 p、q、r 和逻辑联结词（包括否定）写出下列命题。为了使在乡间小路上旅行很安全，其必要但非充分条件是乡间小路两旁的草莓没有成熟且在这个地区没有发现过灰熊。",
        "answer": "(q → (¬r ∧ ¬p)) ∧ ¬((¬r ∧ ¬p) → q)",
        "answer_symbols": [
            "→",
            "∧",
            "¬"
        ]
    },
    "1.1 15 f)": {
        "question": "令 p、q、r 为如下命题：用 p、q、r 和逻辑联结词（包括否定）写出下列命题。无论何时在这个地区发现过灰熊且乡间小路两旁的草莓成熟了，在乡间小路上徒步旅行就不安全。",
        "answer": "(p ∧ r) → ¬q",
        "answer_symbols": [
            "→",
            "∧",
            "¬"
        ]
    },
    "1.1 16 a)": {
        "question": "判断下列这些双条件语句是真是假。2 + 2 = 4 当且仅当 1 + 1 = 2。",
        "answer": "这是 T ↔ T，这是真的",
        "answer_symbols": [
            "↔"
        ]
    },
    "1.1 16 b)": {
        "question": "判断下列这些双条件语句是真是假。1 + 1 = 2 当且仅当 2 + 3 = 4。",
        "answer": "这是 T ↔ F，这是假的",
        "answer_symbols": [
            "↔"
        ]
    },
    "1.1 16 c)": {
        "question": "判断下列这些双条件语句是真是假。1 + 1 = 3 当且仅当猴子会飞。",
        "answer": "这是 F ↔ F，这是真的",
        "answer_symbols": [
            "↔"
        ]
    },
    "1.1 16 d)": {
        "question": "判断下列这些双条件语句是真是假。0 > 1 当且仅当 2 > 1。",
        "answer": "这是 F ↔ T，这是假的",
        "answer_symbols": [
            "↔"
        ]
    },
    "1.1 17 a)": {
        "question": "判断下列这些条件语句是真是假。如果 1 + 1 = 2，则 2 + 2 = 5。",
        "answer": "假",
        "answer_symbols": []
    },
    "1.1 17 b)": {
        "question": "判断下列这些条件语句是真是假。如果 1 + 1 = 3，则 2 + 2 = 4。",
        "answer": "真",
        "answer_symbols": []
    },
    "1.1 17 c)": {
        "question": "判断下列这些条件语句是真是假。如果 1 + 1 = 3，则 2 + 2 = 5。",
        "answer": "真",
        "answer_symbols": []
    },
    "1.1 18 a)": {
        "question": "判断下列这些条件语句是真是假。如果 1 + 1 = 3，那么独角兽存在。",
        "answer": "这是 F → F，这是真的",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 18 b)": {
        "question": "判断下列这些条件语句是真是假。如果 1 + 1 = 3，狗就能飞。",
        "answer": "这是 F → F，这是真的",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 18 c)": {
        "question": "判断下列这些条件语句是真是假。如果 1 + 1 = 2，狗就能飞。",
        "answer": "这是 T → F，这是假的",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 19 a)": {
        "question": "下面各语句，判断其中想表达的是兼或还是异或。晚餐有咖啡或者茶。",
        "answer": "排他或：你只能得到一种饮料。",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.1 19 b)": {
        "question": "下面各语句，判断其中想表达的是兼或还是异或。口令必须至少包含 3 个数字或至少 8 个字符长。",
        "answer": "包含或：长密码可以有任意组合的符号。",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.1 19 c)": {
        "question": "下面各语句，判断其中想表达的是兼或还是异或。这门课程的先修课程是数论课程或者密码课程。",
        "answer": "包含或：同时修两门课的学生更有资格。",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.1 19 d)": {
        "question": "下面各语句，判断其中想表达的是兼或还是异或。你可以用美元或者欧元支付。",
        "answer": "两种解释都可能；旅行者可能希望用两种货币的混合支付，或者商店不允许这样做。",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.1 20 a)": {
        "question": "下面各语句，判断其中想表达的是兼或还是异或。要求有 C++ 或 Java 的经验。",
        "answer": "提出此要求的雇主如果申请人会这两种语言，将会很高兴，因此这显然是一个包容性的“或”",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.1 20 b)": {
        "question": "下面各语句，判断其中想表达的是兼或还是异或。午餐包括汤或沙拉。",
        "answer": "如果用餐者想要这两样东西，餐厅可能会额外收费，因此这是一个排他的“或”",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.1 20 c)": {
        "question": "下面各语句，判断其中想表达的是兼或还是异或。你必须持护照或选民登记卡才能入境。",
        "answer": "如果一个人碰巧有这两种身份证明，那就更好了，因此这显然是一个包容性的“或”",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.1 20 d)": {
        "question": "下面各语句，判断其中想表达的是兼或还是异或。出版或销毁。",
        "answer": "这可以争论，但包容性解释似乎更合适。这句话的意思是，在试用期内不发表研究论文的教员可能会被解雇。另一方面，即使他们发表了论文，也可能被解雇（例如，如果他们的教学很差）",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.1 21 a)": {
        "question": "要选修离散数学课，你必须已经选修了微积分或一门计算机科学的课程。",
        "answer": "包含或：如果你学过微积分或计算机科学，或两者都有，就可以选修离散数学。排他或：如果你学过微积分或计算机科学，但不是两者都有，就可以选修离散数学。很可能指的是包含或。",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.1 21 b)": {
        "question": "当你从 Acme 汽车公司购买一部新车时，你就能得到 2000 美元现金折扣或 2% 的汽车贷款。",
        "answer": "包含或：你可以选择退税，或者获得低息贷款，或者两者都可以。排他或：你可以选择退税，或者获得低息贷款，但不能同时选择退税和低息贷款。很可能指的是排他或。",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.1 21 c)": {
        "question": "两人套餐包括 A 栏中的两道菜或 B 栏中的三道菜。",
        "answer": "包含或：你可以从A栏订购两件商品，或从B栏订购三件商品，或总共订购五件商品，包括A栏两件和B栏三件。排他或：你可以从A栏订购两件商品，或从B栏订购三件商品，但不能两者都有。几乎肯定是排他或。",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.1 21 d)": {
        "question": "如果下雪超过两英尺或寒风指数低于 -100，学校就停课。",
        "answer": "包含或：积雪超过2英尺或风寒低于-100度，或两者都有，将关闭学校。排他或：积雪超过2英尺或风寒低于-100度，但不是两者都有，将关闭学校。肯定是包含或。",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.1 22 a)": {
        "question": "把下列语句写成“如果p，则q”的形式.要想晋升，帮老板洗车是很有必要的。",
        "answer": "必要条件是结论：如果你得到晋升，那么你洗了老板的车",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 22 b)": {
        "question": "把下列语句写成“如果p，则q”的形式.吹南风预示着春天要来了。",
        "answer": "如果风来自南方，那么将会有春天的融雪",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 23 a)": {
        "question": "把下列语句写成“如果 p，那么 q”的形式。[提示：参考条件语句的常用表达方式。]（a）只要吹东北风，就会下雪。",
        "answer": "如果风从东北方向吹，那么会下雪。",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 23 b)": {
        "question": "把下列语句写成“如果 p，那么 q”的形式。[提示：参考条件语句的常用表达方式。]（b）苹果树会开花，如果天暖持续一周。",
        "answer": "如果暖和一周，那么苹果树会开花。",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 23 c)": {
        "question": "把下列语句写成“如果 p，那么 q”的形式。[提示：参考条件语句的常用表达方式。]（c）活塞队赢得冠军就意味着他们打败了湖人队。",
        "answer": "如果活塞队赢得冠军，那么他们击败了湖人队。",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 23 d)": {
        "question": "把下列语句写成“如果 p，那么 q”的形式。[提示：参考条件语句的常用表达方式。]（d）必须走 8 英里才能到达朗峰的顶峰。",
        "answer": "如果你到达朗斯峰顶，那么你必须走了8英里。",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 23 e)": {
        "question": "把下列语句写成“如果 p，那么 q”的形式。[提示：参考条件语句的常用表达方式。]（e）想要得到终身教授职位，只要能世界闻名就够了。",
        "answer": "如果你是世界著名的，那么你会作为教授获得终身职位。",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 23 f)": {
        "question": "把下列语句写成“如果 p，那么 q”的形式。[提示：参考条件语句的常用表达方式。]（f）如果你驾车超过 400 英里，就需要买汽油了。",
        "answer": "如果你驾驶超过400英里，那么你需要买汽油。",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 23 g)": {
        "question": "把下列语句写成“如果 p，那么 q”的形式。[提示：参考条件语句的常用表达方式。]（g）你的保修单是有效的，只有当你购买的 CD 机不超过 90 天。",
        "answer": "如果你的保修有效，那么你必须是在90天内购买的CD播放机。",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 23 h)": {
        "question": "把下列语句写成“如果 p，那么 q”的形式。[提示：参考条件语句的常用表达方式。]（h）Jan 要去游泳，除非水太凉了。",
        "answer": "如果水不太冷，那么简会去游泳。",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 24 a)": {
        "question": "把下列语句写成“如果 p，那么 q”的形式。[提示：参考本节列出的条件语句的常用表达方式。]（a）我会记得把地址发给你，仅当你给我发一封电子邮件。",
        "answer": "如果我记住给你发地址，那么你将不得不给我发一封电子邮件。",
        "answer_symbols": []
    },
    "1.1 24 b)": {
        "question": "把下列语句写成“如果 p，那么 q”的形式。[提示：参考本节列出的条件语句的常用表达方式。]（b）要成为美国公民，只要你生在美国就行了。",
        "answer": "如果你在美国出生，那么你是这个国家的公民。",
        "answer_symbols": []
    },
    "1.1 24 c)": {
        "question": "把下列语句写成“如果 p，那么 q”的形式。[提示：参考本节列出的条件语句的常用表达方式。]（c）如果你保存好课本，它会是你未来其他课程有用的参考书。",
        "answer": "如果你保留你的教科书，那么它将在你未来的课程中成为有用的参考。",
        "answer_symbols": []
    },
    "1.1 24 d)": {
        "question": "把下列语句写成“如果 p，那么 q”的形式。[提示：参考本节列出的条件语句的常用表达方式。]（d）红翼队将赢得斯坦利杯，如果其守门员表现出色。",
        "answer": "如果他们的守门员表现良好，那么红翼队将赢得斯坦利杯。",
        "answer_symbols": []
    },
    "1.1 24 e)": {
        "question": "把下列语句写成“如果 p，那么 q”的形式。[提示：参考本节列出的条件语句的常用表达方式。]（e）你获得这一职位，表明你有最好的信誉。",
        "answer": "如果你得到这份工作，那么你有最好的资历。",
        "answer_symbols": []
    },
    "1.1 24 f)": {
        "question": "把下列语句写成“如果 p，那么 q”的形式。[提示：参考本节列出的条件语句的常用表达方式。]（f）有风暴时沙滩会受到侵蚀。",
        "answer": "如果有风暴，那么海滩会侵蚀。",
        "answer_symbols": []
    },
    "1.1 24 g)": {
        "question": "把下列语句写成“如果 p，那么 q”的形式。[提示：参考本节列出的条件语句的常用表达方式。]（g）必须有一个有效的口令才能登录到服务器。",
        "answer": "如果你登录服务器，那么你有一个有效的密码。",
        "answer_symbols": []
    },
    "1.1 24 h)": {
        "question": "把下列语句写成“如果 p，那么 q”的形式。[提示：参考本节列出的条件语句的常用表达方式。]（h）你能登顶，除非你太晚才开始爬山。",
        "answer": "如果你不要太晚开始攀登，那么你会到达顶峰。",
        "answer_symbols": []
    },
    "1.1 25 a)": {
        "question": "把下列命题写成“p 当且仅当 q”的形式。（a）如果外边热你就买冰激凌蛋卷；并且如果你买冰激凌蛋卷，外边就热。",
        "answer": "当且仅当外面很热时，你才会买冰淇淋。",
        "answer_symbols": [
            "↔"
        ]
    },
    "1.1 25 b)": {
        "question": "把下列命题写成“p 当且仅当 q”的形式。（b）你赢得竞赛的充分必要条件是你有唯一的获胜券。",
        "answer": "当且仅当你持有唯一的中奖彩票时，你才会赢得比赛。",
        "answer_symbols": [
            "↔"
        ]
    },
    "1.1 25 c)": {
        "question": "把下列命题写成“p 当且仅当 q”的形式。（c）你能得到提拔，只有当你有关系网；并且你有关系网，只有当你得到了提拔。",
        "answer": "当且仅当你有关系时，你才会升职。",
        "answer_symbols": [
            "↔"
        ]
    },
    "1.1 25 d)": {
        "question": "把下列命题写成“p 当且仅当 q”的形式。（d）如果你看电视，心智会衰退；反之亦然。",
        "answer": "当且仅当你看电视时，你的大脑才会衰退。",
        "answer_symbols": [
            "↔"
        ]
    },
    "1.1 25 e)": {
        "question": "把下列命题写成“p 当且仅当 q”的形式。（e）火车恰恰在我乘坐的那些日子晚点。",
        "answer": "当且仅当我坐火车的日子，火车才会晚点。",
        "answer_symbols": [
            "↔"
        ]
    },
    "1.1 26 a)": {
        "question": "把下列命题写成“p 当且仅当 q”的形式。（a）你能在这门课得 A 的充分必要条件是学会解离散数学问题。",
        "answer": "你将在本课程中获得A，当且仅当你学会解决离散数学问题。",
        "answer_symbols": []
    },
    "1.1 26 b)": {
        "question": "把下列命题写成“p 当且仅当 q”的形式。（b）如果你每天看报，你就了解情况；反之亦然。",
        "answer": "你将被通知，当且仅当你每天阅读报纸。",
        "answer_symbols": []
    },
    "1.1 26 c)": {
        "question": "把下列命题写成“p 当且仅当 q”的形式。（c）如果是周末，天就下雨；如果天天下雨，就是周末。",
        "answer": "下雨当且仅如果是周末。",
        "answer_symbols": []
    },
    "1.1 26 d)": {
        "question": "把下列命题写成“p 当且仅当 q”的形式。（d）仅当巫师不在家时你能看到巫师，仅当你能看到巫师时巫师不在家。",
        "answer": "你可以见到巫师，当且仅当他不在。",
        "answer_symbols": []
    },
    "1.1 27 a)": {
        "question": "给出下列各条件语句的逆命题、逆否命题和反命题。（a）如果今天下雪，我明天就去滑雪。",
        "answer": "逆命题：“如果今天下雪，那么我明天滑雪。” 逆否命题：“如果我不滑雪，那么今天不会下雪。” 反命题：“如果今天不下雪，那么我明天不会滑雪。",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 27 b)": {
        "question": "给出下列各条件语句的逆命题、逆否命题和反命题。（b）只要有测验，我就来上课。",
        "answer": "逆命题：“如果我来上课，那么会有测验。” 逆否命题：“如果我不来上课，那么不会有测验。” 反命题：“如果没有测验，那么我不来上课。",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 27 c)": {
        "question": "给出下列各条件语句的逆命题、逆否命题和反命题。（c）一个正整数是素数，仅当它没有 1 和自身以外的因子。",
        "answer": "逆命题：“如果一个正整数没有除1和它本身以外的其他因数，那么它是质数。” 逆否命题：“如果一个正整数有除1和它本身以外的其他因数，那么它不是质数。” 反命题：“如果一个正整数不是质数，那么它有除1和它本身以外的其他因数。",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 28 a)": {
        "question": "给出下列条件语句关系的逆命题、逆否命题和反命题。（a）如果今晚下雪，我将待在家里。",
        "answer": "逆命题：如果我待在家里，那么今晚会下雪。逆否命题：如果我不待在家里，那么今晚不会下雪。逆命题：如果今晚不下雪，那么我不会待在家里。",
        "answer_symbols": []
    },
    "1.1 28 b)": {
        "question": "给出下列条件语句关系的逆命题、逆否命题和反命题。（b）只要是阳光充足的夏天，我就去海滩。",
        "answer": "逆命题：每当我去海滩时，都是晴朗的夏日。逆否命题：每当我不去海滩时，都不是晴朗的夏日。逆命题：每当不是晴朗的日子，我就不去海滩。",
        "answer_symbols": []
    },
    "1.1 28 c)": {
        "question": "给出下列条件语句关系的逆命题、逆否命题和反命题。（c）如果我工作到很晚，那我就有必要睡到中午。",
        "answer": "逆命题：如果我睡到中午，那么我熬夜了。逆否命题：如果我没有睡到中午，那么我没有熬夜。逆命题：如果我不熬夜，那么我不睡到中午。",
        "answer_symbols": []
    },
    "1.1 29 a)": {
        "question": "下列各复合命题的真值表会有多少行？（a）p → ¬p",
        "answer": "2",
        "answer_symbols": []
    },
    "1.1 29 b)": {
        "question": "下列各复合命题的真值表会有多少行？（b）(p ∨ ¬r) ∧ (q ∨ ¬s)",
        "answer": "16",
        "answer_symbols": []
    },
    "1.1 29 c)": {
        "question": "下列各复合命题的真值表会有多少行？（c）q ∨ p ∨ ¬s ∨ ¬r ∨ ¬t ∨ u",
        "answer": "64",
        "answer_symbols": []
    },
    "1.1 29 d)": {
        "question": "下列各复合命题的真值表会有多少行？（d）(p ∧ r ∧ t) ↔ (q ∧ t)",
        "answer": "16",
        "answer_symbols": []
    },
    "1.1 30 a)": {
        "question": "下列各复合命题的真值表会有多少行? (p → ¬p) ∨ (¬p → ¬q)",
        "answer": "2^2=4",
        "answer_symbols": [
            "^"
        ]
    },
    "1.1 30 b)": {
        "question": "下列各复合命题的真值表会有多少行? (p ∨ ¬t) ∧ (p ∨ ¬s)",
        "answer": "2^3=8",
        "answer_symbols": [
            "^"
        ]
    },
    "1.1 30 c)": {
        "question": "下列各复合命题的真值表会有多少行? (p → r) ∨ (¬s → ¬t) ∨ (¬u → ¬v)",
        "answer": "2^6=64",
        "answer_symbols": [
            "^"
        ]
    },
    "1.1 30 d)": {
        "question": "下列各复合命题的真值表会有多少行? (p ∧ r ∧ s) ∨ (q ∧ t) ∨ (r ∧ ¬t)",
        "answer": "2^5=32",
        "answer_symbols": [
            "^"
        ]
    },
    "1.1 31 a)": {
        "question": "构造下列各复合命题的真值表。 p ∧ ¬p",
        "answer": "p | ¬p | p ∧ ¬p | | ---|---|---| | T | F | F | | F | T | F |",
        "answer_symbols": [
            "|",
            "¬",
            "∧"
        ]
    },
    "1.1 31 b)": {
        "question": "构造下列各复合命题的真值表。 p ∨ ¬p",
        "answer": "p | ¬p | p ∨ ¬p | | ---|---|---| | T | F | T | | F | T | T |",
        "answer_symbols": [
            "|",
            "¬",
            "∨"
        ]
    },
    "1.1 31 c)": {
        "question": "构造下列各复合命题的真值表。 (p ∨ ¬q) → q",
        "answer": "p q | ¬q | p ∨ ¬q | (p ∨ ¬q) → q | | ---|---|---|---| | T T | F | T | F | | T F | T | T | F | | F T | F | F | T | | F F | T | T | F |",
        "answer_symbols": [
            "|",
            "¬",
            "∨",
            "→"
        ]
    },
    "1.1 31 d)": {
        "question": "构造下列各复合命题的真值表。 (p ∧ q) → (p ∨ q)",
        "answer": "p q | p ∨ q | p ∧ q | (p ∨ q) → (p ∧ q) | | ---|---|---|---| | T T | T | T | T | | T F | T | F | F | | F T | T | F | F | | F F | F | F | T |",
        "answer_symbols": [
            "|",
            "∨",
            "∧",
            "→"
        ]
    },
    "1.1 31 e)": {
        "question": "构造下列各复合命题的真值表。 (p → q) ↔ (¬q → ¬p)",
        "answer": "| p | q | p → q | ¬q | ¬p | ¬q → ¬p | (p → q) ↔ (¬q → ¬p) || --- | --- | --- | --- | --- | --- | --- || T | T | T | F | F | T | T || T | F | F | T | F | T | T || F | T | T | F | T | F | T || F | F | T | T | T | T | T",
        "answer_symbols": [
            "→",
            "¬",
            "↔"
        ]
    },
    "1.1 31 f)": {
        "question": "构造下列各复合命题的真值表。 (p → q) → (q → p)",
        "answer": "(p → q) → p q p → q q → p (q → p) || --- | --- | --- | --- | --- || T | T | T | T | T || T | F | F | T | T || F | T | T | F | F || F | F | T | T | T",
        "answer_symbols": [
            "→"
        ]
    },
    "1.1 32 a)": {
        "question": "构造下列各复合命题的真值表。 p → ¬p",
        "answer": "| p | ¬p | p → ¬p | p ↔ ¬p |\n|---|----|--------|--------|\n| T | F | F | F |\n| F | T | T | F |",
        "answer_symbols": [
            "¬",
            "→",
            "↔"
        ]
    },
    "1.1 32 b)": {
        "question": "构造下列各复合命题的真值表。 p → ¬p",
        "answer": "| p | ¬p | p → ¬p | p ↔ ¬p |\n|---|----|--------|--------|\n| T | F | F | F |\n| F | T | T | F |",
        "answer_symbols": [
            "¬",
            "→",
            "↔"
        ]
    },
    "1.1 32 c)": {
        "question": "构造下列各复合命题的真值表。 p ⊕ (p ∨ q)",
        "answer": "| p | q | p ∨ q | p ∧ q | p ⊕ (p ∨ q) | (p ∧ q) → (p ∨ q) |\n|---|---|-------|-------|-------------|-------------------|\n| T | T | T | T | F | T |\n| T | F | T | F | F | T |\n| F | T | T | F | T | T |\n| F | F | F | F | F | T |",
        "answer_symbols": [
            "∨",
            "∧",
            "⊕",
            "→"
        ]
    },
    "1.1 32 d)": {
        "question": "构造下列各复合命题的真值表。 (p ∧ q) ⊕ (¬p ∧ ¬q)",
        "answer": "| p | q | p ∨ q | p ∧ q | p ⊕ (p ∨ q) | (p ∧ q) → (p ∨ q) |\n|---|---|-------|-------|-------------|-------------------|\n| T | T | T | T | F | T |\n| T | F | T | F | F | T |\n| F | T | T | F | T | T |\n| F | F | F | F | F | T |",
        "answer_symbols": [
            "∨",
            "∧",
            "⊕",
            "→"
        ]
    },
    "1.1 32 e)": {
        "question": "构造下列各复合命题的真值表。 (q → ¬p) ↔ (p → ¬q)",
        "answer": "| p | q | ¬p | q → ¬p | p ↔ q | (q → ¬p) ↔ (p ↔ q) |\n|---|---|----|--------|-------|---------------------|\n| T | T | F | F | T | F |\n| T | F | F | T | F | F |\n| F | T | T | T | F | F |\n| F | F | T | T | T | T |",
        "answer_symbols": [
            "¬",
            "→",
            "↔"
        ]
    },
    "1.1 32 f)": {
        "question": "构造下列各复合命题的真值表。 (p ↔ q) ⊕ (p ↔ ¬q)",
        "answer": "| p | q | ¬q | p ↔ q | p ↔ ¬q | (p ↔ q) ⊕ (p ↔ ¬q) |\n|---|---|----|-------|--------|---------------------|\n| T | T | F | T | F | T |\n| T | F | T | F | T | T |\n| F | T | F | F | T | T |\n| F | F | T | T | F | T |",
        "answer_symbols": [
            "¬",
            "↔",
            "⊕"
        ]
    },
    "1.1 33 a)": {
        "question": "构造下列各复合命题的真值表。 (p ∨ q) → (p ⊕ q)",
        "answer": "对于部分(a)，(b)，(c)，(d)，和(f)，我们有这个表格。| p | q | (p ∨ q) → (p ⊕ q) | (p ⊕ q) → (p ∧ q) | (p ∨ q) ⊕ (p ∧ q) | (p ↔ q) ⊕ (¬p ↔ q) | (p ⊕ q) → (p ⊕ ¬q) || --- | --- | --- | --- | --- | --- | --- || T | T | F | T | F | T | T || T | F | T | F | T | T | F || F | T | T | F | T | T | T || F | F | T | T | F | T | T",
        "answer_symbols": [
            "∨",
            "⊕",
            "→",
            "∧",
            "↔",
            "¬"
        ]
    },
    "1.1 33 b)": {
        "question": "构造下列各复合命题的真值表。 (p ⊕ q) → (p ∧ q)",
        "answer": "对于部分(a)，(b)，(c)，(d)，和(f)，我们有这个表格。| p | q | (p ∨ q) → (p ⊕ q) | (p ⊕ q) → (p ∧ q) | (p ∨ q) ⊕ (p ∧ q) | (p ↔ q) ⊕ (¬p ↔ q) | (p ⊕ q) → (p ⊕ ¬q) || --- | --- | --- | --- | --- | --- | --- || T | T | F | T | F | T | T || T | F | T | F | T | T | F || F | T | T | F | T | T | T || F | F | T | T | F | T | T",
        "answer_symbols": [
            "∨",
            "⊕",
            "→",
            "∧",
            "↔",
            "¬"
        ]
    },
    "1.1 33 c)": {
        "question": "构造下列各复合命题的真值表。 (p ∨ q) ⊕ (p ∧ q)",
        "answer": "对于部分(a)，(b)，(c)，(d)，和(f)，我们有这个表格。| p | q | (p ∨ q) → (p ⊕ q) | (p ⊕ q) → (p ∧ q) | (p ∨ q) ⊕ (p ∧ q) | (p ↔ q) ⊕ (¬p ↔ q) | (p ⊕ q) → (p ⊕ ¬q) || --- | --- | --- | --- | --- | --- | --- || T | T | F | T | F | T | T || T | F | T | F | T | T | F || F | T | T | F | T | T | T || F | F | T | T | F | T | T",
        "answer_symbols": [
            "∨",
            "⊕",
            "→",
            "∧",
            "↔",
            "¬"
        ]
    },
    "1.1 33 d)": {
        "question": "构造下列各复合命题的真值表。 (p ↔ q) ⊕ (¬p ↔ ¬q)",
        "answer": "对于部分(a)，(b)，(c)，(d)，和(f)，我们有这个表格。| p | q | (p ∨ q) → (p ⊕ q) | (p ⊕ q) → (p ∧ q) | (p ∨ q) ⊕ (p ∧ q) | (p ↔ q) ⊕ (¬p ↔ q) | (p ⊕ q) → (p ⊕ ¬q) || --- | --- | --- | --- | --- | --- | --- || T | T | F | T | F | T | T || T | F | T | F | T | T | F || F | T | T | F | T | T | T || F | F | T | T | F | T | T",
        "answer_symbols": [
            "∨",
            "⊕",
            "→",
            "∧",
            "↔",
            "¬"
        ]
    },
    "1.1 33 e)": {
        "question": "构造下列各复合命题的真值表。 (p ↔ q) ⊕ (¬p ↔ ¬q)",
        "answer": "对于部分(e)，我们有这个表格。| p | q | r | ¬p | ¬r | p ↔ q | ¬p ↔ ¬r | (p ↔ q) ⊕ (¬p ↔ ¬r) || --- | --- | --- | --- | --- | --- | --- | --- || T | T | T | F | F | T | T | F || T | T | F | F | T | T | F | T || T | F | T | F | F | F | F | T || T | F | F | F | T | F | T | T || F | T | T | T | F | F | F | T || F | T | F | T | T | F | T | F || F | F | T | T | F | T | T | F || F | F | F | T | T | T | T | F",
        "answer_symbols": [
            "↔",
            "⊕",
            "¬"
        ]
    },
    "1.1 34 a)": {
        "question": "构造下列各复合命题的真值表。 p ⊕ p",
        "answer": "| p | p ⊕ p | ¬p | p ⊕ ¬p |\n|---|-------|----|--------|\n| T | F | F | T |\n| F | F | T | T |",
        "answer_symbols": [
            "⊕",
            "¬"
        ]
    },
    "1.1 34 b)": {
        "question": "构造下列各复合命题的真值表。 p ⊕ ¬p",
        "answer": "| p | p ⊕ p | ¬p | p ⊕ ¬p |\n|---|-------|----|--------|\n| T | F | F | T |\n| F | F | T | T |",
        "answer_symbols": [
            "⊕",
            "¬"
        ]
    },
    "1.1 34 c)": {
        "question": "构造下列各复合命题的真值表。 p ⊕ ¬q",
        "answer": "| p | q | ¬p | ¬q | p ⊕ ¬q | ¬p ⊕ ¬q |\n|---|---|----|----|--------|---------|\n| T | T | F | F | T | F |\n| T | F | F | T | F | T |\n| F | T | T | F | F | T |\n| F | F | T | T | T | F |",
        "answer_symbols": [
            "⊕",
            "¬"
        ]
    },
    "1.1 34 d)": {
        "question": "构造下列各复合命题的真值表。 ¬p ⊕ ¬q",
        "answer": "| p | q | ¬p | ¬q | p ⊕ ¬q | ¬p ⊕ ¬q |\n|---|---|----|----|--------|---------|\n| T | T | F | F | T | F |\n| T | F | F | T | F | T |\n| F | T | T | F | F | T |\n| F | F | T | T | T | F |",
        "answer_symbols": [
            "⊕",
            "¬"
        ]
    },
    "1.1 34 e)": {
        "question": "构造下列各复合命题的真值表。 (p ⊕ q) ∨ (p ⊕ ¬q)",
        "answer": "| p | q | p ⊕ q | p ⊕ ¬q | (p ⊕ q) ∨ (p ⊕ ¬q) | (p ⊕ q) ∧ (p ⊕ ¬q) |\n|---|---|-------|--------|--------------------|--------------------|\n| T | T | F | T | T | F |\n| T | F | T | F | T | F |\n| F | T | T | F | T | F |\n| F | F | F | T | T | F |",
        "answer_symbols": [
            "⊕",
            "∨",
            "∧",
            "¬"
        ]
    },
    "1.1 35 a)": {
        "question": "构造下列各复合命题构造真值表。 p → ¬q",
        "answer": "(p → q) ∨ (p → q) ∧ (p ↔ q) ∨ (¬p ↔ ¬q) ↔| p | q | p → ¬q | ¬p ↔ q | (¬p → q) | (¬p → q) | (¬p ↔ q) | (p ↔ q) || --- | --- | --- | --- | --- | --- | --- | --- || T | T | F | F | T | T | T | T || T | F | T | T | T | F | T | T || F | T | T | T | T | T | T | T || F | F | T | F | T | T | F | T",
        "answer_symbols": [
            "→",
            "∨",
            "∧",
            "↔",
            "¬"
        ]
    },
    "1.1 35 b)": {
        "question": "构造下列各复合命题构造真值表。 ¬p ↔ q",
        "answer": "(p → q) ∨ (p → q) ∧ (p ↔ q) ∨ (¬p ↔ ¬q) ↔| p | q | p → ¬q | ¬p ↔ q | (¬p → q) | (¬p → q) | (¬p ↔ q) | (p ↔ q) || --- | --- | --- | --- | --- | --- | --- | --- || T | T | F | F | T | T | T | T || T | F | T | T | T | F | T | T || F | T | T | T | T | T | T | T || F | F | T | F | T | T | F | T",
        "answer_symbols": [
            "→",
            "∨",
            "∧",
            "↔",
            "¬"
        ]
    },
    "1.1 35 c)": {
        "question": "构造下列各复合命题构造真值表。 (p → q) ∨ (¬p → ¬q)",
        "answer": "(p → q) ∨ (p → q) ∧ (p ↔ q) ∨ (¬p ↔ ¬q) ↔| p | q | p → ¬q | ¬p ↔ q | (¬p → q) | (¬p → q) | (¬p ↔ q) | (p ↔ q) || --- | --- | --- | --- | --- | --- | --- | --- || T | T | F | F | T | T | T | T || T | F | T | T | T | F | T | T || F | T | T | T | T | T | T | T || F | F | T | F | T | T | F | T",
        "answer_symbols": [
            "→",
            "∨",
            "∧",
            "↔",
            "¬"
        ]
    },
    "1.1 35 d)": {
        "question": "构造下列各复合命题构造真值表。 (p → q) ∧ (¬p → ¬q)",
        "answer": "(p → q) ∨ (p → q) ∧ (p ↔ q) ∨ (¬p ↔ ¬q) ↔| p | q | p → ¬q | ¬p ↔ q | (¬p → q) | (¬p → q) | (¬p ↔ q) | (p ↔ q) || --- | --- | --- | --- | --- | --- | --- | --- || T | T | F | F | T | T | T | T || T | F | T | T | T | F | T | T || F | T | T | T | T | T | T | T || F | F | T | F | T | T | F | T",
        "answer_symbols": [
            "→",
            "∨",
            "∧",
            "↔",
            "¬"
        ]
    },
    "1.1 35 e)": {
        "question": "构造下列各复合命题构造真值表。 (p ↔ q) ∨ (¬p ↔ ¬q)",
        "answer": "(p → q) ∨ (p → q) ∧ (p ↔ q) ∨ (¬p ↔ ¬q) ↔| p | q | p → ¬q | ¬p ↔ q | (¬p → q) | (¬p → q) | (¬p ↔ q) | (p ↔ q) || --- | --- | --- | --- | --- | --- | --- | --- || T | T | F | F | T | T | T | T || T | F | T | T | T | F | T | T || F | T | T | T | T | T | T | T || F | F | T | F | T | T | F | T",
        "answer_symbols": [
            "→",
            "∨",
            "∧",
            "↔",
            "¬"
        ]
    },
    "1.1 36 a)": {
        "question": "构造下列各复合命题的真值表。 (p ∨ q) ∨ r",
        "answer": "| p | q | r | p ∨ q | (p ∨ q) ∨ r | (p ∨ q) ∧ r |\n|---|---|---|-------|-------------|-------------|\n| T | T | T | T | T | T |\n| T | T | F | T | T | F |\n| T | F | T | T | T | T |\n| T | F | F | T | T | F |\n| F | T | T | T | T | T |\n| F | T | F | T | T | F |\n| F | F | T | F | T | F |\n| F | F | F | F | F | F |",
        "answer_symbols": [
            "∨",
            "∧"
        ]
    },
    "1.1 36 b)": {
        "question": "构造下列各复合命题的真值表。 (p ∧ q) ∧ r",
        "answer": "| p | q | r | p ∨ q | (p ∨ q) ∨ r | (p ∨ q) ∧ r |\n|---|---|---|-------|-------------|-------------|\n| T | T | T | T | T | T |\n| T | T | F | T | T | F |\n| T | F | T | T | T | T |\n| T | F | F | T | T | F |\n| F | T | T | T | T | T |\n| F | T | F | T | T | F |\n| F | F | T | F | T | F |\n| F | F | F | F | F | F |",
        "answer_symbols": [
            "∨",
            "∧"
        ]
    },
    "1.1 36 c)": {
        "question": "构造下列各复合命题的真值表。 (p ∧ q) ∨ r",
        "answer": "| p | q | r | p ∨ q | (p ∨ q) ∨ r | (p ∨ q) ∧ r |\n|---|---|---|-------|-------------|-------------|\n| T | T | T | T | T | T |\n| T | T | F | T | T | F |\n| T | F | T | T | T | T |\n| T | F | F | T | T | F |\n| F | T | T | T | T | T |\n| F | T | F | T | T | F |\n| F | F | T | F | T | F |\n| F | F | F | F | F | F |",
        "answer_symbols": [
            "∨",
            "∧"
        ]
    },
    "1.1 36 d)": {
        "question": "构造下列各复合命题的真值表。 (p ∧ q) ∨ ¬r",
        "answer": "| p | q | r | p ∨ q | (p ∨ q) ∨ r | (p ∨ q) ∧ r |\n|---|---|---|-------|-------------|-------------|\n| T | T | T | T | T | T |\n| T | T | F | T | T | F |\n| T | F | T | T | T | T |\n| T | F | F | T | T | F |\n| F | T | T | T | T | T |\n| F | T | F | T | T | F |\n| F | F | T | F | T | F |\n| F | F | F | F | F | F |",
        "answer_symbols": [
            "∨",
            "∧"
        ]
    },
    "1.1 37 a)": {
        "question": "构造下列各复合命题的真值表。 p → (¬q ∨ r)",
        "answer": "(p → q) ∨ (p → q) ∧ (p ↔ q) ∨ (¬p ↔ ¬q) ↔| p | q | r | p → (¬q ∨ r) | ¬p → (q → r) | (¬p → r) | (¬p → r) | (¬q ↔ r) | (q ↔ r) || --- | --- | --- | --- | --- | --- | --- | --- | --- || T | T | T | T | T | T | T | T | T || T | T | F | F | T | T | T | T | F || T | F | T | T | T | T | T | T | F || T | F | F | T | T | T | T | F | T || F | T | T | T | T | T | T | T | T || F | T | F | T | T | T | T | T | F || F | F | T | T | T | T | T | F | T || F | F | F | T | T | T | T | T | T",
        "answer_symbols": [
            "→",
            "∨",
            "∧",
            "↔",
            "¬"
        ]
    },
    "1.1 37 b)": {
        "question": "构造下列各复合命题的真值表。 ¬p → (q → r)",
        "answer": "(p → q) ∨ (p → q) ∧ (p ↔ q) ∨ (¬p ↔ ¬q) ↔| p | q | r | p → (¬q ∨ r) | ¬p → (q → r) | (¬p → r) | (¬p → r) | (¬q ↔ r) | (q ↔ r) || --- | --- | --- | --- | --- | --- | --- | --- | --- || T | T | T | T | T | T | T | T | T || T | T | F | F | T | T | T | T | F || T | F | T | T | T | T | T | T | F || T | F | F | T | T | T | T | F | T || F | T | T | T | T | T | T | T | T || F | T | F | T | T | T | T | T | F || F | F | T | T | T | T | T | F | T || F | F | F | T | T | T | T | T | T",
        "answer_symbols": [
            "→",
            "∨",
            "∧",
            "↔",
            "¬"
        ]
    },
    "1.1 37 c)": {
        "question": "构造下列各复合命题的真值表。 (p → q) ∨ (¬p → r)",
        "answer": "(p → q) ∨ (p → q) ∧ (p ↔ q) ∨ (¬p ↔ ¬q) ↔| p | q | r | p → (¬q ∨ r) | ¬p → (q → r) | (¬p → r) | (¬p → r) | (¬q ↔ r) | (q ↔ r) || --- | --- | --- | --- | --- | --- | --- | --- | --- || T | T | T | T | T | T | T | T | T || T | T | F | F | T | T | T | T | F || T | F | T | T | T | T | T | T | F || T | F | F | T | T | T | T | F | T || F | T | T | T | T | T | T | T | T || F | T | F | T | T | T | T | T | F || F | F | T | T | T | T | T | F | T || F | F | F | T | T | T | T | T | T",
        "answer_symbols": [
            "→",
            "∨",
            "∧",
            "↔",
            "¬"
        ]
    },
    "1.1 37 d)": {
        "question": "构造下列各复合命题的真值表。 (p → q) ∧ (¬p → r)",
        "answer": "(p → q) ∨ (p → q) ∧ (p ↔ q) ∨ (¬p ↔ ¬q) ↔| p | q | r | p → (¬q ∨ r) | ¬p → (q → r) | (¬p → r) | (¬p → r) | (¬q ↔ r) | (q ↔ r) || --- | --- | --- | --- | --- | --- | --- | --- | --- || T | T | T | T | T | T | T | T | T || T | T | F | F | T | T | T | T | F || T | F | T | T | T | T | T | T | F || T | F | F | T | T | T | T | F | T || F | T | T | T | T | T | T | T | T || F | T | F | T | T | T | T | T | F || F | F | T | T | T | T | T | F | T || F | F | F | T | T | T | T | T | T",
        "answer_symbols": [
            "→",
            "∨",
            "∧",
            "↔",
            "¬"
        ]
    },
    "1.1 37 e)": {
        "question": "构造下列各复合命题的真值表。 (p → q) ↔ (¬p → r)",
        "answer": "(p → q) ∨ (p → q) ∧ (p ↔ q) ∨ (¬p ↔ ¬q) ↔| p | q | r | p → (¬q ∨ r) | ¬p → (q → r) | (¬p → r) | (¬p → r) | (¬q ↔ r) | (q ↔ r) || --- | --- | --- | --- | --- | --- | --- | --- | --- || T | T | T | T | T | T | T | T | T || T | T | F | F | T | T | T | T | F || T | F | T | T | T | T | T | T | F || T | F | F | T | T | T | T | F | T || F | T | T | T | T | T | T | T | T || F | T | F | T | T | T | T | T | F || F | F | T | T | T | T | T | F | T || F | F | F | T | T | T | T | T | T",
        "answer_symbols": [
            "→",
            "∨",
            "∧",
            "↔",
            "¬"
        ]
    },
    "1.1 38": {
        "question": "构造 ((p → q) → r) → s 的真值表。",
        "answer": "This time the truth table needs 2^4 = 16 rows. | p | q | r | s | p → q | (p → q) → r | ((p → q) → r) → s |\n|---|---|---|---|-------|-------------|-------------------|\n| T | T | T | T | T | T |T|\n| T | T | T | F | T | T | F |\n| T | T | F | T | T | F | T |\n| T | T | F | F | T | F | T |\n| T | F | T | T | F | T | T |\n| T | F | T | F | F | T | T |\n| T | F | F | T | F | T | T |\n| T | F | F | F | F | T | T |\n| F | T | T | T | T | T |  T  |\n| F | T | T | F | T | T | F |\n| F | T | F | T | T | F | T |\n| F | T | F | F | T | F | T |\n| F | F | T | T | T | T | T |\n| F | F | T | F | T | T | F |\n| F | F | F | T | T | T | T |\n| F | F | F | F | T | T | T |",
        "answer_symbols": [
            "|",
            "→",
            "^"
        ]
    },
    "1.1 39": {
        "question": "构造 (p → q) ↔ (r → s) 的真值表。",
        "answer": "| p q r s | p ↔ q | r ↔ s | (p ↔ q) ↔ (r ↔ s) |\n| --- | --- | --- | --- | --- |\n| T T T T | T | T | T |\n| T T T F | T | F | F |\n| T T F T | T | F | F |\n| T T F F | T | F | F |\n| T F T T | F | T | F |\n| T F T F | F | F | T |\n| T F F T | F | F | T |\n| T F F F | F | F | T |\n| F T T T | F | T | F |\n| F T T F | F | F | T |\n| F T F T | F | F | T |\n| F T F F | F | F | T |\n| F F T T | T | T | T |\n| F F T F | T | F | F |\n| F F F T | T | F | F |\n| F F F F | T | T | T |",
        "answer_symbols": [
            "↔"
        ]
    },
    "1.1 40": {
        "question": "不借助于真值表，试解释为什么在 p、q 和 r 真值相同时 (p ∨ ¬q) ∧ (q ∨ ¬r) ∧ (r ∨ ¬p) 为真，而在其他情况下为假。",
        "answer": "This statement is true if and only if all three clauses, p ∨ ¬q, q ∨ ¬r, and r ∨ ¬p are true. Suppose p, q, and r are all true. Because each clause has an unnegated variable, each clause is true. Similarly, if p, q, and r are all false, then because each clause has a negated variable, each clause is true. On the other hand, if one of the variables is true and the other two false, then the clause containing the negation of that variable will be false, making the entire conjunction false; and similarly, if one of the variables is false and the other two true, then the clause containing that variable unnegated will be false, again making the entire conjunction false.",
        "answer_symbols": [
            "∨",
            "¬",
            "∧"
        ]
    },
    "1.1 41": {
        "question": "不借助于真值表，试解释为什么在 p、q 和 r 至少有一个为真并且至少有一个为假时 (p ∨ q ∨ r) ∧ (¬p ∨ ¬q ∨ ¬r) 为真，而当三个变量具有相同真值时为假。",
        "answer": "第一个子句为真当且仅当 p, q 和 r 中至少有一个为真。第二个子句为真当且仅当三个变量中至少有一个为假。因此整个陈述为真当且仅当这些变量的真值不全相同。",
        "answer_symbols": [
            "∨",
            "↔"
        ]
    },
    "1.1 42 a)": {
        "question": "假定在计算机程序中，执行下列语句之前 x=1，在执行之后 x 的值是什么? if x+2=3 then x := x+1",
        "answer": "Since the condition is true, the statement is executed, so x is incremented and now has the value 2.",
        "answer_symbols": []
    },
    "1.1 42 b)": {
        "question": "假定在计算机程序中，执行下列语句之前 x=1，在执行之后 x 的值是什么? if (x+1=3) OR (2x+2=3) then x := x+1",
        "answer": "Since the condition is false, the statement is not executed, so x is not incremented and now still has the value 1.",
        "answer_symbols": []
    },
    "1.1 42 c)": {
        "question": "假定在计算机程序中，执行下列语句之前 x=1，在执行之后 x 的值是什么? if (2x+3=5) AND (3x+4=7) then x := x+1",
        "answer": "Since the condition is true, the statement is executed, so x is incremented and now has the value 2.",
        "answer_symbols": []
    },
    "1.1 42 d)": {
        "question": "假定在计算机程序中，执行下列语句之前 x=1，在执行之后 x 的值是什么? if (x+1=2) XOR (x+2=3) then x := x+1",
        "answer": "Since the condition is false, the statement is not executed, so x is not incremented and now still has the value 1.",
        "answer_symbols": []
    },
    "1.1 42 e)": {
        "question": "假定在计算机程序中，执行下列语句之前 x=1，在执行之后 x 的值是什么? if x<2 then x := x+1",
        "answer": "Since the condition is true when it is encountered (since x = 1), the statement is executed, so x is incremented and now has the value 2. (It is irrelevant that the condition is now false.)",
        "answer_symbols": []
    },
    "1.1 43 a)": {
        "question": "求下列各对位串的按位 OR、按位 AND 及按位 XOR。 1011 1110, 0100 0001",
        "answer": "按位或运算结果是 111 1111；按位与运算结果是 000 0000；按位异或运算结果是 111 1111。 ",
        "answer_symbols": [
            "∨",
            "⊕",
            "∧"
        ]
    },
    "1.1 43 b)": {
        "question": "求下列各对位串的按位 OR、按位 AND 及按位 XOR。 1111 0000, 1010 1010",
        "answer": "按位或运算结果是 1111 1010；按位与运算结果是 1010 0000；按位异或运算结果是 0101 1010。 ",
        "answer_symbols": [
            "∨",
            "⊕",
            "∧"
        ]
    },
    "1.1 43 c)": {
        "question": "求下列各对位串的按位 OR、按位 AND 及按位 XOR。 00 0111 0001, 10 0100 1000",
        "answer": "按位或运算结果是 10 0111 1001；按位与运算结果是 00 0100 0000；按位异或运算结果是 10 0011 1001。 ",
        "answer_symbols": [
            "∨",
            "⊕",
            "∧"
        ]
    },
    "1.1 43 d)": {
        "question": "求下列各对位串的按位 OR、按位 AND 及按位 XOR。 11 1111 1111, 00 0000 0000",
        "answer": "按位或运算结果是 11 1111 1111；按位与运算结果是 00 0000 0000；按位异或运算结果是 11 1111 1111。",
        "answer_symbols": [
            "∨",
            "⊕",
            "∧"
        ]
    },
    "1.1 44 a)": {
        "question": "计算下列表达式。 1 1000 ∧ (0 1011 ∨ 1 1011)",
        "answer": "1 1000 且 (0 1011 或 1 1011) = 1 1000 且 1 1011 = 1 1000",
        "answer_symbols": [
            "且",
            "或"
        ]
    },
    "1.1 44 b)": {
        "question": "计算下列表达式。 (0 1111 ∧ 1 0101) ∨ 0 1000",
        "answer": "(0 1111 且 1 0101) 或 0 1000 = 0 0101 或 0 1000 = 0 1101",
        "answer_symbols": [
            "且",
            "或"
        ]
    },
    "1.1 44 c)": {
        "question": "计算下列表达式。 (0 1010 ⊕ 1 1011) ⊕ 0 1000",
        "answer": "(0 1010 异或 1 1011) 异或 0 1000 = 1 0001 异或 0 1000 = 1 1001",
        "answer_symbols": [
            "异或"
        ]
    },
    "1.1 44 d)": {
        "question": "计算下列表达式。 (1 1011 ∨ 0 1010) ∧ (1 0001 ∨ 1 1011)",
        "answer": "(1 1011 或 0 1010) 且 (1 0001 或 1 1011) = 1 1011 且 1 1011 = 1 1011",
        "answer_symbols": [
            "且",
            "或"
        ]
    },
    "1.1 45": {
        "question": "模糊逻辑中命题否定的真值是1减去该命题的真值。语句“Fred不幸福”和“John不幸福”的真值是什么？",
        "answer": "0.2, 0.647. 0.8, 0.649. a) 第 99 条陈述为真，其余均为假。 b) 陈述 1 至 50 均为真，陈述 51 至 100 均为假。 c) 这不可能发生；这是一个悖论，表明这些不能是陈述。",
        "answer_symbols": []
    },
    "1.1 46": {
        "question": "模糊逻辑中两个命题合取的真值是两个命题真值的最小值。语句“Fred和John都幸福”和“Fred和John都不觉得幸福”的真值是什么？",
        "answer": "“Fred 和 John 很高兴”的真值是 min(0.8, 0.4) = 0.4。 “Fred 和 John 都不高兴”的真值是 min(0.2, 0.6) = 0.2，因为这个陈述的意思是“Fred 不高兴，John 也不高兴”，我们在练习 45 中计算了这个合取命题中两个命题的真值。",
        "answer_symbols": [
            "min",
            "="
        ]
    },
    "1.1 48": {
        "question": "断言“本语句为假”是命题吗？",
        "answer": "这不能是一个命题，因为它不能有真值。事实上，如果它是真的，那么它就在真正断言它是假的，这是一个矛盾；另一方面，如果它是假的，那么它的断言它是假的必须是假的，所以它会是真的——这又是一个矛盾。因此，这一串字母虽然看起来像是一个命题，但实际上是没有意义的。",
        "answer_symbols": []
    },
    "1.1 50": {
        "question": "古老的西西里传说中有一个理发师住在边远小镇上，人们要穿越危险的山路才能找到他。理发师只给那些自己不刮胡子的人刮胡子。有这样的理发师吗？",
        "answer": "不行。这是一个经典的悖论。（在下文中我们将使用男性代词，假设我们谈论的是刮胡子的男性，并假设所有男性都有面部毛发。如果我们限制自己只讨论胡子并允许女性理发师，那么理发师可以是女性，不会产生矛盾。）如果存在这样的理发师，谁会刮理发师的胡子？如果理发师自己刮胡子，那么他就违反了他只刮那些不刮自己胡子的人的规则。另一方面，如果他不刮自己的胡子，那么规则说他必须刮自己的胡子。两者都不可能，所以不可能有这样的理发师。",
        "answer_symbols": []
    },
    "1.2 1": {
        "question": "你不能编辑一个受保护的维基百科条目，除非你是一名管理员。用 e: “你不能编辑一个受保护的维基百科条目” 和 a: “你是一名管理员” 来表达你的答案。",
        "answer": "e → a",
        "answer_symbols": [
            "→"
        ]
    },
    "1.2 2": {
        "question": "你可以看这部电影仅当你已经年满 18 岁或得到父母同意。用 m: “你可以看这部电影”，e: “你已经年满 18 岁” 和 p: “你已经得到父母同意” 来表达你的答案。",
        "answer": "回想一下，p 只有在 q 成立时才成立，这意味着 p → q。在这种情况下，如果你能看电影，那么你必须满足两个要求中的一个。因此，该陈述是 m → (e ∨ p)。请注意，在日常生活中，人们可能会说“如果你满足这些条件之一，你就可以看电影”，但从逻辑上讲，这并不是规则真正所说的。",
        "answer_symbols": [
            "→",
            "∨"
        ]
    },
    "1.2 3": {
        "question": "你能够毕业仅当你已经完成了专业的要求并且你不欠大学学费并且你没有逾期不归还图书馆的书。用 g: “你能够毕业”，m: “你不欠大学学费”，r: “你已经完成了专业的要求” 和 b: “你没有逾期不归还图书馆的书” 来表达你的答案。",
        "answer": "g → (r ∧ (¬m) ∧ (¬b))",
        "answer_symbols": [
            "→",
            "∧",
            "¬"
        ]
    },
    "1.2 4": {
        "question": "要想使用机场的无线网络，你必须支付每日的使用费，除非你是该服务的一个订户。用 w: “你能使用机场的无线网络”，d: “你支付每日的使用费” 和 s: “你是该服务的一个订户” 来表达你的答案。",
        "answer": "这里陈述的条件是，如果你使用网络，那么你支付费用或你是订阅者。因此符号表示的命题是 w → (d ∨ s)。",
        "answer_symbols": [
            "→",
            "∨"
        ]
    },
    "1.2 5": {
        "question": "你有资格当美国总统仅当你已年满 35 岁、出生在美国或者你出生时你的双亲是美国公民并且你在这个国家至少生活了 14 年。用 e: “你有资格当美国总统”，a: “你已年满 35 岁”，b: “你出生在美国”，p: “在你出生的时候，你的双亲均是美国公民” 和 r: “你在美国至少生活了 14 年” 来表达你的答案。",
        "answer": "e → (a ∧ (b ∨ p) ∧ r)",
        "answer_symbols": [
            "→",
            "∧",
            "∨"
        ]
    },
    "1.2 6": {
        "question": "你能升级操作系统仅当你有一个 32 位的处理器且主频在 1GHz 或以上、至少 1GB 内存、16GB 空闲硬盘空间，或者一个 64 位处理器且主频在 2GHz 或以上、至少 2GB 内存、至少 32GB 空闲硬盘空间。用",
        "answer": "这类似于练习 2：u → (b32 ∧ g1 ∧ r1 ∧ h16) ∨ (b64 ∧ g2 ∧ r2 ∧ h32)。",
        "answer_symbols": [
            "→",
            "∧",
            "∨"
        ]
    },
    "1.2 7 a)": {
        "question": "使用命题“对消息进行病毒扫描”和“消息来自一个未知的系统”以及逻辑联结词(包括否定)来表达下列系统规范说明。（a）“每当消息来自一个未知的系统时，就对消息进行病毒扫描。”",
        "answer": "q → p ",
        "answer_symbols": [
            "→",
            "∧",
            "¬"
        ]
    },
    "1.2 7 b)": {
        "question": "使用命题“对消息进行病毒扫描”和“消息来自一个未知的系统”以及逻辑联结词(包括否定)来表达下列系统规范说明。（b）“消息来自一个未知的系统，但不对消息进行病毒扫描。”",
        "answer": "q ∧ ¬p ",
        "answer_symbols": [
            "→",
            "∧",
            "¬"
        ]
    },
    "1.2 7 c)": {
        "question": "使用命题“对消息进行病毒扫描”和“消息来自一个未知的系统”以及逻辑联结词(包括否定)来表达下列系统规范说明。（c）“每当消息来自一个未知的系统时，就有必要对消息进行病毒扫描。”",
        "answer": "q → p ",
        "answer_symbols": [
            "→",
            "∧",
            "¬"
        ]
    },
    "1.2 7 d)": {
        "question": "使用命题“对消息进行病毒扫描”和“消息来自一个未知的系统”以及逻辑联结词(包括否定)来表达下列系统规范说明。（d）“当消息不是来自一个未知的系统时，就不对消息进行病毒扫描。”",
        "answer": "¬q → ¬p",
        "answer_symbols": [
            "→",
            "∧",
            "¬"
        ]
    },
    "1.2 8 a)": {
        "question": "使用命题“用户输入有效的口令”、“访问被授权”、“用户已经支付了订阅费”以及逻辑联结词(包括否定)来表达下列系统规范说明。（a）“用户已经支付了订阅费，但没有输入有效的口令。”",
        "answer": "“但是”意味着“和”：r ∧ ¬p。",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.2 8 b)": {
        "question": "使用命题“用户输入有效的口令”、“访问被授权”、“用户已经支付了订阅费”以及逻辑联结词(包括否定)来表达下列系统规范说明。（b）“每当用户已经支付了订阅费并输入有效的口令，访问就被授权。”",
        "answer": "“每当”意味着“如果”：(r ∧ p) → q。",
        "answer_symbols": [
            "∧",
            "→"
        ]
    },
    "1.2 8 c)": {
        "question": "使用命题“用户输入有效的口令”、“访问被授权”、“用户已经支付了订阅费”以及逻辑联结词(包括否定)来表达下列系统规范说明。（c）“如果用户没有支付订阅费，访问将被拒绝。”",
        "answer": "被拒绝访问是 q 的否定，所以我们有 ¬r → ¬q。",
        "answer_symbols": [
            "¬",
            "→"
        ]
    },
    "1.2 8 d)": {
        "question": "使用命题“用户输入有效的口令”、“访问被授权”、“用户已经支付了订阅费”以及逻辑联结词(包括否定)来表达下列系统规范说明。（d）“如果用户没有输入有效的口令但已经支付了订阅费，访问将被授权。”",
        "answer": "假设是一个合取式：(¬p ∧ r) → q。",
        "answer_symbols": [
            "¬",
            "∧",
            "→"
        ]
    },
    "1.2 9": {
        "question": "下列系统规范说明一致吗?“系统处于多用户状态当且仅当系统运行正常。如果系统运行正常，则它的核心程序起作用。核心程序不起作用，或者系统处于中断模式。如果系统不处于多用户状态，它就处于中断模式。系统不处于中断模式。”",
        "answer": "不一致",
        "answer_symbols": []
    },
    "1.2 10": {
        "question": "下列系统规范说明一致吗?“每当对系统软件进行升级时，用户不能访问文件系统。如果用户能访问文件系统，那么他们能保存新文件。如果用户不能保存新文件，那么系统软件未被升级。”",
        "answer": "我们用符号表示：u → ¬a, a → s, ¬s → ¬u。注意，我们可以通过使 a 为假，s 为真，u 为假来使所有结论为真。因此，如果用户无法访问文件系统，他们可以保存新文件，并且系统没有升级，那么所有条件语句都是正确的。因此，系统是一致的。",
        "answer_symbols": [
            "→",
            "¬"
        ]
    },
    "1.2 11": {
        "question": "下列系统规范说明一致吗?“路由器能向边缘系统发送分组仅当它支持新的地址空间时。路由器要支持新的地址空间，就必须安装最新版本的软件。如果安装了最新版本的软件，路由器就能向边缘系统发送分组。路由器不支持新的地址空间。”",
        "answer": "一致",
        "answer_symbols": []
    },
    "1.2 12": {
        "question": "下列系统规范说明一致吗?“如果文件系统未加锁，那么新消息将被排队。如果文件系统未加锁，则系统正常运行；反之亦然。如果新消息未排队，就会送入消息缓冲区。如果文件系统未加锁，那么新消息将被送入消息缓冲区。新消息不会被送入消息缓冲区。”",
        "answer": "This system is consistent. We use L, Q, N, and B to stand for the basic propositions here: - \"The file system is locked\" - \"New messages will be queued\" - \"New messages will be sent to the message buffer\" - \"The system is functioning normally\" The given specifications are: - ¬L → Q - ¬L ↔ N - ¬Q → B - ¬L → B - ¬B If we want consistency, then we had better have B false in order that ¬B be true. This requires that both L and Q be true, by the two conditional statements that have B as their consequence. The first conditional statement is therefore of the form F → T, which is true. Finally, the biconditional ¬L ↔ N can be satisfied by taking N to be false. Thus this set of specifications is consistent. Note that there is just this one satisfying truth assignment.",
        "answer_symbols": [
            "¬",
            "→",
            "↔"
        ]
    },
    "1.2 13": {
        "question": "你会用什么样的布尔搜索来寻找关于新泽西州(New Jersey)海滩的网页？如果你想找关于(位于英吉利海峡的)泽西岛(the isle of Jersey)海滩的网页呢？",
        "answer": "NEW AND JER-SEY AND BEACHES, (JERSEY AND BEACHES) NOT NEW",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.2 14": {
        "question": "你会用什么样的布尔搜索来寻找关于在西弗吉尼亚(West Virginia)徒步旅行的网页？如果你想找关于在弗吉尼亚(Virginia)而非西弗吉尼亚徒步旅行的网页呢？",
        "answer": "This is similar to Example 6, about universities in New Mexico. To search for hiking in West Virginia, we could enter WEST AND VIRGINIA AND HIKING. If we enter (VIRGINIA AND HIKING) NOT WEST, then we’ll get websites about hiking in Virginia but not in West Virginia, except for sites that happen to use the word “west” in a different context (e.g., “Follow the stream west until you come to a clearing”).",
        "answer_symbols": []
    },
    "1.2 15": {
        "question": "一个边远村庄的每个人要么总说真话，要么总说谎。村民对于旅游者的提问总是只用一个“是”或“否”来回答。假定你在这个地区旅游，走到了一个岔路口。一条岔路通向你想去的遗址，另一条岔路通向丛林深处。一村民恰好站在岔路口。问村民一个什么问题就能决定走哪条路？",
        "answer": "“如果我问你右边的路是否通向废墟，你会回答‘是’吗？”",
        "answer_symbols": []
    },
    "1.2 16 a)": {
        "question": "一个探险者被一帮食人族抓住了。有两种食人族：总是说谎的和永不说谎的。除非探险者能判断出一位指定的食人者是说谎者还是说真话者，否则就要被食人族烤了吃。探险者只被允许问这位食人者一个问题。（a）解释为什么问“你说谎吗”是不行的。",
        "answer": "If the explorer (a woman, so that our pronouns will not get confused here—the cannibals will be male) encounters a truth-teller, then he will honestly answer “no” to her question. If she encounters a liar, then the honest answer to her question is “yes,” so he will lie and answer “no.” Thus everybody will answer “no” to the question, and the explorer will have no way to determine which type of cannibal she is speaking to.",
        "answer_symbols": []
    },
    "1.2 16 b)": {
        "question": "一个探险者被一帮食人族抓住了。有两种食人族：总是说谎的和永不说谎的。除非探险者能判断出一位指定的食人者是说谎者还是说真话者，否则就要被食人族烤了吃。探险者只被允许问这位食人者一个问题。（b）找出一个使探险者可以用来判断该食人者是说谎者还是说真话者的问题。",
        "answer": "There are several possible correct answers. One is the following question: “If I were to ask you if you always told the truth, would you say that you did?” Then if the cannibal is a truth-teller, he will answer yes (truthfully), while if he is a liar, then, since in fact he would have said that he did tell the truth if questioned, he will now lie and answer no.",
        "answer_symbols": []
    },
    "1.2 17": {
        "question": "当三位教授在一家餐厅落座时，女主人问他们：“大家是否要咖啡?”第一位教授说：“我不知道。”第二个教授接着说：“我不知道。”最后，第三教授说：“不，不是每个人都想要咖啡。”女主人回来并将咖啡递给想要咖啡的教授。她是如何找出谁想要咖啡的？",
        "answer": "如果第一位教授不想喝咖啡，那么他就会知道女主人的问题的答案是“否”。因此女主人和剩下的教授都知道第一位教授想喝咖啡。同样地，第二位教授也必须想喝咖啡。当第三位教授说“否”时，女主人知道第三位教授不想喝咖啡。",
        "answer_symbols": []
    },
    "1.2 18": {
        "question": "当你规划一个聚会时需要知道该邀请些什么人。在你可能邀请的人中有三个棘手的朋友。你知道如果 Jasmine 参加，她对 Samir 在场会感到不快；Samir 仅当 Kanti 到场才会出席；而 Kanti 不会出席除非 Jasmine 也在场。你如何邀请三人的组合而不使某人不愉快？",
        "answer": "We will translate these conditions into statements in symbolic logic, using j, s, and k for the propositions that Jasmine, Samir, and Kanti attend, respectively. The first statement is j → ¬s. The second statement is s → k. The last statement is ¬k ∨ j, because “unless” means “or.” (We could also translate this as k → j. From the comments following Definition 5 in the text, we know that p → q is equivalent to “q unless ¬p. In this case p is ¬j and q is ¬k.) First, suppose that s is true. Then the second statement tells us that k is also true, and then the last statement forces j to be true. But now the first statement forces s to be false. So we conclude that s must be false; Samir cannot attend. On the other hand, if s is false, then the first two statements are automatically true, not matter what the truth values of k and j are. If we look at the last statement, we see that it will be true as long as it is not the case that k is true and j is false. So the only combinations of friends that make everybody happy are Jasmine and Kanti, or Jasmine alone (or no one!).",
        "answer_symbols": [
            "→",
            "¬",
            "∨"
        ]
    },
    "1.2 19": {
        "question": "A 说：“我们中至少有一个是无赖”，B 什么都没说。",
        "answer": "A 是骑士，B 是无赖。",
        "answer_symbols": []
    },
    "1.2 20": {
        "question": "A 说：“我们两个都是骑士”，B 说：“A 是无赖”。",
        "answer": "If A is a knight, then his statement that both of them are knights is true, and both will be telling the truth. But that is impossible, because B is asserting otherwise (that A is a knave). If A is a knave, then B’s assertion is true, so he must be a knight, and A’s assertion is false, as it should be. Thus we conclude that A is a knave and B is a knight.",
        "answer_symbols": []
    },
    "1.2 21": {
        "question": "A 说：“我是无赖或者 B 是骑士”，B 什么都没说。",
        "answer": "A 是骑士，B 是骑士。",
        "answer_symbols": []
    },
    "1.2 22": {
        "question": "A 和 B 都说：“我是骑士”。",
        "answer": "We can draw no conclusions. A knight will declare himself to be a knight, telling the truth. A knave will lie and assert that he is a knight. Since everyone will say “I am a knight,” we can determine nothing.",
        "answer_symbols": []
    },
    "1.2 23": {
        "question": "A 说：“我们都是无赖”，B 什么都没说。",
        "answer": "A 是无赖，B 是骑士。",
        "answer_symbols": []
    },
    "1.2 24": {
        "question": "A 说“C 是无赖”，B 说“A 是骑士”，而 C 说“我是间谍”。",
        "answer": "Suppose that A is the knight. Then because he told the truth, C is the knave and therefore B is the spy. In this case both B and C are lying, which is consistent with their identities. To see that this is the only solution, first note that B cannot be the knight, because of his claim that A is the knight (which would then have to be a lie). Similarly, C cannot be the knight, because he would be lying when stating that he is the spy.",
        "answer_symbols": []
    },
    "1.2 25": {
        "question": "A 说“我是骑士”，B 说“我是无赖”，而 C 说“B 是骑士”。",
        "answer": "A 是骑士，B 是间谍，C 是无赖。",
        "answer_symbols": []
    },
    "1.2 26": {
        "question": "A 说“我是无赖”，B 说“我是无赖”，而 C 说“我是无赖”。",
        "answer": "There is no solution, because neither a knight nor a knave would ever claim to be the knave.",
        "answer_symbols": []
    },
    "1.2 27": {
        "question": "A 说“我是骑士”，B 说“A 说的是真话”，而 C 说“我是间谍”。",
        "answer": "A 是骑士，B 是间谍，C 是无赖。",
        "answer_symbols": []
    },
    "1.2 28": {
        "question": "A 说“我是骑士”，B 说“A 不是无赖”，而 C 说“B 不是无赖”。",
        "answer": "Assume A is a knight. Then B's statement is true, so he must be a spy, which means C's statement is also true, but this is impossible because C must be a thief. Therefore A is not a knight. Next assume B is a knight. His true statement forces A to be a spy, which in turn forces C to be a thief; again, this is impossible because C says something true. The only other possibility is that C is a knight, which forces B to be a spy and A to be a thief. This works because A is lying and B is telling the truth.",
        "answer_symbols": []
    },
    "1.2 29": {
        "question": "A 说“我是骑士”，B 说“我是骑士”，而 C 说“我是骑士”。",
        "answer": "三者中的任何一个可以是骑士，任何一个可以是间谍，任何一个可以是无赖。",
        "answer_symbols": []
    },
    "1.2 30": {
        "question": "A 说“我不是间谍”，B 说“我不是间谍”，而 C 说“A 是间谍”。",
        "answer": "A and B cannot both be thieves because a thief cannot make a true statement saying he is not a spy. Therefore C is the thief, so A is not a spy. It follows that A is a knight and B is a spy. This works because both A and B are telling the truth while C is lying.",
        "answer_symbols": []
    },
    "1.2 31": {
        "question": "A 说“我不是间谍”，B 说“我不是间谍”，而 C 说“我不是间谍”。",
        "answer": "无解",
        "answer_symbols": []
    },
    "1.2 32 a)": {
        "question": "三人中有一人是凶手，清白的那两个人说的是真话，但凶手说的话不一定为真。",
        "answer": "We consider the three possibilities of who might be innocent. If Smith and Jones are innocent (and therefore telling the truth), then we immediately get a contradiction because Smith says Jones is Cooper's friend, but Jones says he doesn't even know Cooper. If Jones and Williams are the innocent truth-tellers, then we again get a contradiction because Jones says he doesn't know Cooper and is not in town, but Williams says he saw Jones with Cooper (obviously if he was in town and if he was with him, then he knows him). Therefore, it must be that Smith and Williams are telling the truth. Their statements do not contradict each other. From Williams' statement, we know Jones is lying because he claims he doesn't know Cooper, but actually he was with Cooper. Therefore, Jones is the murderer.",
        "answer_symbols": []
    },
    "1.2 32 b)": {
        "question": "清白者没有撒谎。",
        "answer": "This is like part (a) except that we are not told beforehand that one of them is guilty. Are none of them guilty? If so, then they are all telling the truth, but this is impossible because we just saw that some statements are contradictory. Are more than one of them guilty? For example, if all of them are guilty, then their statements provide no information. So this is certainly possible.",
        "answer_symbols": []
    },
    "1.2 33": {
        "question": "Steve 想用两个事实来判断三位合作伙伴的相对薪水。首先，他知道如果 Fred 的薪水不是三人中最高的，那么 Janice 的薪水最高。其次，他知道如果 Janice 的薪水不是最低的，那么 Maggie 的薪水最高。从以上 Steve 所知道的事实，是否有可能确定 Fred、Maggie 和 Janice 的相对薪水？如果能，谁的最高谁的最低？解释你的推理过程。",
        "answer": "薪水从高到低：Fred, Maggie, Janice",
        "answer_symbols": []
    },
    "1.2 34": {
        "question": "五个朋友都能进入聊天室。如果知道下面这些信息，能确定谁在聊天吗？Kevin 或 Heather 或两人都在聊天。Randi 或 Vijay 但不是两人同时在聊天。如果 Abby 在聊天，那么 Randi 也在聊天。Vijay 和 Kevin 或者两人都在聊天，或者都不聊天。如果 Heather 在聊天，那么 Abby 和 Kevin 也在聊天。解释你的推理过程。",
        "answer": "This information is sufficient to determine the entire system. Let each letter represent the statement that the person whose name starts with that letter is chatting. Then the given information can be symbolized as follows: ¬K → H, R → ¬V, ¬R → V, A → R, V → K, K → V, H → A, H → K. Note that we can convert all these statements into conditional statements. In the following process, we sometimes use the contrapositive of these conditional statements. First assume H is true. Then we can deduce that A and K are true, which in turn implies that R and V are true. But R means V is false, so we get a contradiction. Therefore H must be false. From this, we can deduce that K is true; then V is true, so R is false, and A is also false. We can now check that this assignment makes each conditional statement true. Therefore, we conclude that Kevin and Vijay are chatting, while Heather, Randy, and Abby are not.",
        "answer_symbols": [
            "¬",
            "→"
        ]
    },
    "1.2 35": {
        "question": "一位侦探访谈了罪案的四位证人。从证人的话中侦探得出的结论是：如果男管家说的是真话，那么厨师说的也是真话；厨师和园丁说的不可能都是真话；园丁和杂役不可能都在说谎；如果杂役说真话，那么厨师就在说谎。侦探能分别判定这四位证人是在说真话还是撒谎？解释你的推理过程。",
        "answer": "侦探可以确定管家和厨师在撒谎，但无法确定园丁是否在说实话，也无法确定手艺人是否在说实话。",
        "answer_symbols": []
    },
    "1.2 36 a)": {
        "question": "如果当局还知道四个嫌疑人中恰有一人在说真话，那么是谁作案？解释你的推理过程。",
        "answer": "John did it. There are four cases to consider. If Alice is the only truth-teller, then Carlos did it; but this means John is telling the truth, which is a contradiction. If John is the only truth-teller, then Diana must be lying, so she did it, but this makes Carlos truthful, another contradiction. If Carlos is the only truth-teller, then Diana did it, but this makes John honest, again a contradiction. Therefore, the only possibility is that Diana is the only truth-teller. This means John is lying when he denies, so he did it. Note that in this case, Alice and Carlos are indeed lying.",
        "answer_symbols": []
    },
    "1.2 36 b)": {
        "question": "如果当局还知道恰有一人在说谎，那么是谁作案？解释你的推理过程。",
        "answer": "Again, there are four cases to consider. Since Carlos and Diana's statements contradict each other, the liar must be one of them (we could have used this method in part (a) as well). Therefore, Alice is telling the truth, so Carlos did it. Note that in this case, John and Diana are also telling the truth, while Carlos is lying.",
        "answer_symbols": []
    },
    "1.2 37": {
        "question": "假设在通往两个房间的门上均写着提示。第一扇门上的提示为“在这个房间里有一位美女，而在另一个房间里则是一只老虎”；在第二扇门上写着“在两个房间中有一个是美女，并且有一个是老虎”。假定你知道其中一个提示是真的，另一个是假的。那么哪扇门后面是美女呢？",
        "answer": "日本人拥有斑马，挪威人喝水。",
        "answer_symbols": []
    },
    "1.2 38": {
        "question": "试求解下面这个由爱因斯坦提出的著名的逻辑谜题，也称为斑马谜题。五位具有不同国籍和不同工作的人居住在一条街上挨着的5所房子里。每所房子刷着不同的颜色。他们养着不同的宠物，喜欢喝不同的饮料。根据以下提示，试确定谁养斑马（zebra）、谁喜欢喝（饮料之一的）矿泉水。英国人住在红色的房子里。西班牙人养了一条狗。日本人是一个油漆工。意大利人喜欢喝茶。挪威人住在左边的第一所房子里。绿房子紧挨着白房子的右边。摄影师养了一只蜗牛。外交官住在黄房子里。中间那个房子里的人喜欢喝牛奶。绿房子的主人喜欢喝咖啡。挪威人的房子紧挨着蓝色房子。小提琴家喜欢喝橘子汁。养狐狸的人所住的房子与医生的房子相邻。养马的人所住的房子与外交官的房子相邻。",
        "answer": "这通常被作为约束编程中的练习给出，手动解决非常困难。以下是表显示了一个与所有线索一致的解决方案，房屋从左到右列出。据报道，该解决方案是唯一的。\n\n国籍 | 颜色 | 宠物 | 职业 | 饮料\n--- | --- | --- | --- | ---\n挪威人 | 黄色 | 狐狸 | 外交官 | 水\n意大利人 | 蓝色 | 马 | 医生 | 茶\n英国人 | 红色 | 蜗牛 | 摄影师 | 牛奶\n西班牙人 | 白色 | 狗 | 小提琴家 | 果汁\n日本人 | 绿色 | 斑马 | 画家 | 咖啡\n\n在这个解决方案中，日本人拥有斑马，挪威人喝水。解决这个问题所需的逻辑推理相当广泛，读者可以参考以下网站，该网站包含类似问题的解决方案：mathforum.org/library/drmath/view/55627.html.",
        "answer_symbols": []
    },
    "1.2 39": {
        "question": "弗里多尼亚有50名参议员。每名参议员或者诚实的或者不诚实的。假设你知道，至少有一个弗里多尼亚参议员是诚实的，并且任何两个弗里多尼亚参议员中至少有一个是不诚实的。基于这些事实，你是否能确定有多少弗里多尼亚参议员是诚实的？有多少是不诚实的？",
        "answer": "一个诚实，49 个腐败",
        "answer_symbols": []
    },
    "1.2 40 a)": {
        "question": "找出每个组合电路的输出。",
        "answer": "p 和 q 都被否定并输入到 OR 门。因此输出是 (¬p) ∨ (¬q)。",
        "answer_symbols": [
            "¬",
            "∨"
        ]
    },
    "1.2 40 b)": {
        "question": "找出每个组合电路的输出。",
        "answer": "¬(p ∨ ((¬p) ∧ q)))",
        "answer_symbols": [
            "¬",
            "∨",
            "∧"
        ]
    },
    "1.2 41 a)": {
        "question": "找出每个组合电路的输出。",
        "answer": "a) ¬(p ∧ (q ∨ ¬r))",
        "answer_symbols": [
            "¬",
            "∧",
            "∨"
        ]
    },
    "1.2 41 b)": {
        "question": "找出每个组合电路的输出。",
        "answer": "b) ((¬p) ∧ (¬q)) ∨ (p ∧ r)",
        "answer_symbols": [
            "¬",
            "∧",
            "∨"
        ]
    },
    "1.2 42": {
        "question": "试用逆变器、或门、与门构造一个组合电路，从输入位 p、q 和 r 产生输出 (p ∧ ¬r) ∨ (¬q ∧ r)。",
        "answer": "输入从左侧进入，在某些情况下通过反相器形成它们的否定。某些对输入进入 AND 门，这些门的输出进入最终的 OR 门。",
        "answer_symbols": [
            "¬",
            "∧",
            "∨"
        ]
    },
    "1.2 43": {
        "question": "试用逆变器、或门、与门构造一个组合电路，从输入位 p、q 和 r 产生输出 ((¬p ∨ ¬r) ∧ ¬q) ∨ (¬p ∧ (q ∨ r))。",
        "answer": "p r q p q r",
        "answer_symbols": []
    },
    "1.3 1 a)": {
        "question": "用真值表验证下列等价式. p ∧ T ≡ p",
        "answer": "等价关系可以通过显示该表中适当列对的一致性来得出。p p ∧ T p ∨ F p ∧ F p ∨ T p ∨ p p ∧ p\nT T T F T T T\nF F F F T F F",
        "answer_symbols": []
    },
    "1.3 1 b)": {
        "question": "用真值表验证下列等价式. p ∨ F ≡ p",
        "answer": "等价关系可以通过显示该表中适当列对的一致性来得出。p p ∧ T p ∨ F p ∧ F p ∨ T p ∨ p p ∧ p\nT T T F T T T\nF F F F T F F",
        "answer_symbols": []
    },
    "1.3 1 c)": {
        "question": "用真值表验证下列等价式. p ∧ F ≡ F",
        "answer": "等价关系可以通过显示该表中适当列对的一致性来得出。p p ∧ T p ∨ F p ∧ F p ∨ T p ∨ p p ∧ p\nT T T F T T T\nF F F F T F F",
        "answer_symbols": []
    },
    "1.3 1 d)": {
        "question": "用真值表验证下列等价式. p ∨ T ≡ T",
        "answer": "等价关系可以通过显示该表中适当列对的一致性来得出。p p ∧ T p ∨ F p ∧ F p ∨ T p ∨ p p ∧ p\nT T T F T T T\nF F F F T F F",
        "answer_symbols": []
    },
    "1.3 1 e)": {
        "question": "用真值表验证下列等价式. p ∨ p ≡ p",
        "answer": "等价关系可以通过显示该表中适当列对的一致性来得出。p p ∧ T p ∨ F p ∧ F p ∨ T p ∨ p p ∧ p\nT T T F T T T\nF F F F T F F",
        "answer_symbols": []
    },
    "1.3 1 f)": {
        "question": "用真值表验证下列等价式. p ∧ p ≡ p",
        "answer": "等价关系可以通过显示该表中适当列对的一致性来得出。p p ∧ T p ∨ F p ∧ F p ∨ T p ∨ p p ∧ p\nT T T F T T T\nF F F F T F F",
        "answer_symbols": []
    },
    "1.3 2": {
        "question": "证明 ¬(¬p) 和 p 是逻辑等价的",
        "answer": "有两种情况。如果 p 为真，那么 ¬(¬p) 是一个假命题的否定，因此为真。同样地，如果 p 为假，那么 ¬(¬p) 也为假。因此这两个命题在逻辑上是等价的。",
        "answer_symbols": [
            "¬"
        ]
    },
    "1.3 3 a)": {
        "question": "用真值表验证交换律. p ∨ q ≡ q ∨ p",
        "answer": "p q p ∨ q q ∨ p T T T T T F T T F T T T F F F F ",
        "answer_symbols": [
            "∨",
            "∧"
        ]
    },
    "1.3 3 b)": {
        "question": "用真值表验证交换律. p ∧ q ≡ q ∧ p",
        "answer": "p q p ∧ q q ∧ p T T T T T F F F F T F F F F F F",
        "answer_symbols": [
            "∨",
            "∧"
        ]
    },
    "1.3 4 a)": {
        "question": "用真值表验证结合律. (p ∨ q) ∨ r ≡ p ∨ (q ∨ r)",
        "answer": "我们构建相关的真值表，并注意到第五列和第七列是相同的。p | q | r | p ∨ q | (p ∨ q) ∨ r | q ∨ r | p ∨ (q ∨ r)\n--|---|---|-------|-------------|-------|--------------\nT | T | T | T     | T           | T     | T\nT | T | F | T     | T           | T     | T\nT | F | T | T     | T           | T     | T\nT | F | F | T     | T           | F     | T\nF | T | T | T     | T           | T     | T\nF | T | F | T     | T           | T     | T\nF | F | T | F     | T           | T     | T\nF | F | F | F     | F           | F     | F",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.3 4 b)": {
        "question": "用真值表验证结合律. (p ∧ q) ∧ r ≡ p ∧ (q ∧ r)",
        "answer": "再次构建相关的真值表，并注意到第五列和第七列是相同的。| p | q | r | p ∧ q | (p ∧ q)∧ r | q ∧ r | p ∧(q ∧ r) |\n|---|---|---|-------|------------|-------|------------|\n| T | T | T |   T   |     T      |   T   |     T      |\n| T | T | F |   T   |     F      |   F   |     F      |\n| T | F | T |   F   |     F      |   F   |     F      |\n| T | F | F |   F   |     F      |   F   |     F      |\n| F | T | T |   F   |     F      |   T   |     F      |\n| F | T | F |   F   |     F      |   F   |     F      |\n| F | F | T |   F   |     F      |   F   |     F      |\n| F | F | F |   F   |     F      |   F   |     F      |",
        "answer_symbols": [
            "∧",
            "∨",
            "¬",
            "→"
        ]
    },
    "1.3 5": {
        "question": "用真值表验证分配律. p ∧ (q ∨ r) ≡ (p ∧ q) ∨ (p ∧ r)",
        "answer": "(p ∧ q) ∨ p q r q ∨ r p ∧ (q ∨ r) p ∧ q p ∧ r (p ∧ r) T T T T T T T T T F T T T T F T T T F T T T F F F F F F F F T T T F F F F F T F T F F F F F F T F F F F F F F F F F F F F",
        "answer_symbols": [
            "∧",
            "∨"
        ]
    },
    "1.3 6": {
        "question": "用真值表证明德·摩根第一定律. ¬(p ∧ q) ≡ ¬p ∨ ¬q",
        "answer": "从第四列和第七列可以看出它们是相同的。\n\n| p | q | p ∧ q | ¬(p ∧ q) | ¬p | ¬q | ¬p ∨ ¬q |\n|---|---|-------|----------|----|----|---------|\n| T | T |   T   |    F     |  F |  F |    F    |\n| T | F |   F   |    T     |  F |  T |    T    |\n| F | T |   F   |    T     |  T |  F |    T    |\n| F | F |   F   |    T     |  T |  T |    T    |",
        "answer_symbols": [
            "∧",
            "∨",
            "¬",
            "→"
        ]
    },
    "1.3 7 a)": {
        "question": "用德·摩根律求下列命题的否定. Jan 是富裕的，并且是快乐的",
        "answer": "Jan 不富有，或者 Jan 不快乐。 ",
        "answer_symbols": [
            "∨",
            "∧",
            "¬"
        ]
    },
    "1.3 7 b)": {
        "question": "用德·摩根律求下列命题的否定. Carlos 明天骑自行车或者跑步",
        "answer": "Carlos 明天不会骑自行车，也不会跑步。 ",
        "answer_symbols": [
            "∨",
            "∧",
            "¬"
        ]
    },
    "1.3 7 c)": {
        "question": "用德·摩根律求下列命题的否定. Mei 步行或乘公共汽车去上课",
        "answer": "Mei 不步行去上课，也不乘公共汽车去上课。 ",
        "answer_symbols": [
            "∨",
            "∧",
            "¬"
        ]
    },
    "1.3 7 d)": {
        "question": "用德·摩根律求下列命题的否定. Ibrahim 既聪明又用功",
        "answer": "Ibrahim 不聪明，或者 Ibrahim 不勤奋。",
        "answer_symbols": [
            "∨",
            "∧",
            "¬"
        ]
    },
    "1.3 8 a)": {
        "question": "用德·摩根律求下列命题的否定. Kwame 将在工业界找一份工作或者去研究生院读书",
        "answer": "Kwame 不会在工业界工作，也不会去读研究生。",
        "answer_symbols": []
    },
    "1.3 8 b)": {
        "question": "用德·摩根律求下列命题的否定. Yoshiko 掌握 Java 和微积分",
        "answer": "Yoshiko 不知道 Java 或不知道微积分。",
        "answer_symbols": []
    },
    "1.3 8 c)": {
        "question": "用德·摩根律求下列命题的否定. James 年轻并且强壮",
        "answer": "James 不年轻，或者他不强壮。",
        "answer_symbols": []
    },
    "1.3 8 d)": {
        "question": "用德·摩根律求下列命题的否定. Rita 将搬到俄勒冈州或华盛顿去",
        "answer": "Rita 不会搬到俄勒冈州，也不会搬到华盛顿州。",
        "answer_symbols": []
    },
    "1.3 9 a)": {
        "question": "用真值表证明下列各条件语句为永真式. (p ∧ q) → p",
        "answer": "p q p ∧ q (p ∧ q) → p T T T T T F F T F T F T F F F T",
        "answer_symbols": [
            "∧",
            "→"
        ]
    },
    "1.3 9 b)": {
        "question": "用真值表证明下列各条件语句为永真式. p → (p ∨ q)",
        "answer": "p q | p ∨ q | p → (p ∨ q) T T | T | T T F | T | T F T | T | T F F | F | T",
        "answer_symbols": [
            "∨",
            "→"
        ]
    },
    "1.3 9 c)": {
        "question": "用真值表证明下列各条件语句为永真式. ¬p → (p → q)",
        "answer": "p q | ¬p | p → q | ¬p → (p → q) T T | F | T | T T F | F | F | T F T | T | T | T F F | T | T | T",
        "answer_symbols": [
            "¬",
            "→"
        ]
    },
    "1.3 9 d)": {
        "question": "用真值表证明下列各条件语句为永真式. (p ∧ q) → (p → q)",
        "answer": "p q | p ∧ q | p → q | (p ∧ q) → (p → q) T T | T | T | T T F | F | F | T F T | F | T | T F F | F | T | T",
        "answer_symbols": [
            "∧",
            "→"
        ]
    },
    "1.3 9 e)": {
        "question": "用真值表证明下列各条件语句为永真式. ¬(p → q) → p",
        "answer": "p q | p → q | ¬(p → q) | ¬(p → q) → p T T | T | F | T T F | F | T | T F T | T | F | T F F | T | F | T",
        "answer_symbols": [
            "→",
            "¬"
        ]
    },
    "1.3 10 a)": {
        "question": "用真值表证明下列各条件语句为永真式. [¬p ∧ (p ∨ q)] → q",
        "answer": "我们为每个条件语句构造一个真值表，并注意到相关列只包含 T。对于 (a) 部分，我们有以下表格。| p | q | ¬p | p ∨ q | ¬p ∧(p ∨ q) | [¬p ∧(p ∨ q)]→ q |\n|---|---|----|-------|-------------|------------------|\n| T | T |  F |   T   |      F      |        T         |\n| T | F |  F |   T   |      F      |        T         |\n| F | T |  T |   T   |      T      |        T         |\n| F | F |  T |   F   |      F      |        T         |",
        "answer_symbols": [
            "¬",
            "∧",
            "∨"
        ]
    },
    "1.3 10 b)": {
        "question": "用真值表证明下列各条件语句为永真式. [(p → q) ∧ (q → r)] → (p → r)",
        "answer": "对于 (b) 部分，我们有以下表格。为了使表格适合页面，省略了显示 p→ q 和 q→ r 的列。| p | q | r | (p→ q)→(q→ r) | q→ r | [(p→ q)→(q→ r)]→(p→ r) |\n|---|---|---|---------------|------|------------------------|\n| T | T | T |       T       |  T   |           T            |\n| T | T | F |       F       |  T   |           T            |\n| T | F | T |       T       |  T   |           F            |\n| T | F | F |       F       |  T   |           T            |\n| F | T | T |       T       |  F   |           T            |\n| F | T | F |       F       |  F   |           T            |\n| F | F | T |       T       |  T   |           T            |\n| F | F | F |       T       |  T   |           T            |",
        "answer_symbols": [
            "→",
            "∧",
            "∨",
            "¬"
        ]
    },
    "1.3 10 c)": {
        "question": "用真值表证明下列各条件语句为永真式. [(p ∨ q) ∧ (p → r) ∧ (q → r)] → r",
        "answer": "对于 (c) 部分，我们有以下表格。| p | q | p→ q | p ∧(p→ q) | [p ∧(p→ q)]→ q |\n|---|---|------|-----------|----------------|\n| T | T |  T   |     T     |        T       |\n| T | F |  F   |     F     |        T       |\n| F | T |  T   |     F     |        T       |\n| F | F |  T   |     F     |        T       |",
        "answer_symbols": [
            "→",
            "∧",
            "∨",
            "¬"
        ]
    },
    "1.3 12": {
        "question": "不用真值表证明练习10中的各条件语句为永真式",
        "answer": "我们通过直接论证来证明如果假设为真，则结论也为真。另一种方法（仅在 (a) 部分展示）是使用本节列出的等价关系进行符号化处理。",
        "answer_symbols": []
    },
    "1.3 14": {
        "question": "判断 (¬p ∧ (p → q)) → ¬q 是否为永真式",
        "answer": "这不是一个重言式。它表示知道一个条件语句的假设为假允许我们得出结论也为假，而我们知道这是无效的推理。为了证明这不是一个重言式，我们需要找到 p 和 q 的真值赋值，使得整个命题为假。由于这只有在结论为假时才可能，我们希望让 q 为真；并且由于我们希望假设为真，我们必须也让 p 为假。很容易检查，如果 p 为假且 q 为真，那么条件语句为假。因此，这不是一个重言式。",
        "answer_symbols": [
            "→",
            "∧"
        ]
    },
    "1.3 15": {
        "question": "判断 (¬q ∧ (p → q)) → ¬p 是否为永真式",
        "answer": "这是一个重言式",
        "answer_symbols": []
    },
    "1.3 16": {
        "question": "证明 p ↔ q 和 (p ∧ q) ∨ (¬p ∧ ¬q) 逻辑等价",
        "answer": "这些命题中的第一个为真当且仅当 p 和 q 具有相同的真值。第二个为真当且仅当 p 和 q 都为真或 p 和 q 都为假。显然这两个条件说的是同一件事。",
        "answer_symbols": [
            "∧",
            "∨"
        ]
    },
    "1.3 17": {
        "question": "证明 ¬(p ↔ q) 和 p ↔ ¬q 逻辑等价",
        "answer": "每个命题在 p 和 q 具有相反的真值时都为真",
        "answer_symbols": []
    },
    "1.3 18": {
        "question": "证明 p → q 和 ¬q → ¬p 逻辑等价",
        "answer": "从条件语句和否定的定义中很容易看出，每个命题在 p 为真且 q 为假的情况下为假，在其他三种情况下为真。因此，这两个命题在逻辑上是等价的。",
        "answer_symbols": [
            "→",
            "∧",
            "∨",
            "¬"
        ]
    },
    "1.3 19": {
        "question": "证明 ¬p → q 和 p ↔ q 逻辑等价",
        "answer": "命题 ¬p ↔ q 为真当 ¬p 和 q 具有相同的真值，这意味着 p 和 q 具有不同的真值。同样地，p ↔ ¬q 也在完全相同的情况下为真。因此，这两个表达式在逻辑上是等价的",
        "answer_symbols": [
            "¬",
            "↔"
        ]
    },
    "1.3 20": {
        "question": "证明 ¬(p ⊕ q) 和 p ↔ q 逻辑等价",
        "answer": "从这里涉及的逻辑运算的定义中很容易看出，每个命题在 p 和 q 具有相同真值的情况下为真，在 p 和 q 具有相反真值的情况下为假。因此，这两个命题在逻辑上是等价的。",
        "answer_symbols": [
            "∧",
            "∨",
            "¬"
        ]
    },
    "1.3 21": {
        "question": "证明 ¬(p ↔ q) 和 ¬p ↔ q 逻辑等价",
        "answer": "命题 ¬(p ↔ q) 为真当 p ↔ q 为假，这意味着 p 和 q 具有不同的真值。因为这正是 ¬p ↔ q 为真的时候，所以这两个表达式在逻辑上是等价的",
        "answer_symbols": [
            "¬",
            "↔"
        ]
    },
    "1.3 11 a)": {
        "question": "不用真值表证明练习9中的各条件语句为永真式. (p ∧ q) → p",
        "answer": "如果假设 p ∧ q 为真，那么根据合取的定义，结论 p 也必须为真",
        "answer_symbols": [
            "∧"
        ]
    },
    "1.3 11 b)": {
        "question": "不用真值表证明练习9中的各条件语句为永真式. p → (p ∨ q)",
        "answer": "如果假设 p 为真，那么根据析取的定义，结论 p ∨ q 也为真",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.3 11 c)": {
        "question": "不用真值表证明练习9中的各条件语句为永真式. ¬p → (p → q)",
        "answer": "如果假设 ¬p 为真，即 p 为假，那么结论 p → q 为真",
        "answer_symbols": [
            "¬",
            "→"
        ]
    },
    "1.3 11 d)": {
        "question": "不用真值表证明练习9中的各条件语句为永真式. (p ∧ q) → (p → q)",
        "answer": "如果假设 p ∧ q 为真，那么 p 和 q 都为真，所以结论 p → q 也为真",
        "answer_symbols": [
            "∧",
            "→"
        ]
    },
    "1.3 11 e)": {
        "question": "不用真值表证明练习9中的各条件语句为永真式. ¬(p → q) → p",
        "answer": "如果假设 ¬(p → q) 为真，那么 p → q 为假，所以结论 p 为真（且 q 为假）",
        "answer_symbols": [
            "¬",
            "→"
        ]
    },
    "1.3 12 a)": {
        "question": "不用真值表证明练习10中的各条件语句为永真式. [¬p ∧ (p ∨ q)] → q",
        "answer": "假设假设为真。那么 p 是假的。由于 p ∨ q 为真，我们得出 q 必须为真。这里是一个更“代数”的解法： [¬p ∧ (p ∨ q)] → q ≡ ¬[¬p ∧ (p ∨ q)] ∨ q ≡ ¬¬p ∨ ¬(p ∨ q) ∨ q ≡ p ∨ ¬(p ∨ q) ∨ q ≡ (p ∨ q) ∨ ¬(p ∨ q) ≡ T。这些逻辑等价的原因分别是：表 7 第 1 行；德摩根定律；双重否定；交换律和结合律；否定律。",
        "answer_symbols": [
            "→",
            "∧",
            "∨",
            "¬",
            "≡"
        ]
    },
    "1.3 12 b)": {
        "question": "不用真值表证明练习10中的各条件语句为永真式. [(p → q) ∧ (q → r)] → (p → r)",
        "answer": "我们要证明如果整个假设为真，则结论 p → r 为真。为此，我们只需要证明如果 p 为真，则 r 为真。假设 p 为真。根据假设的第一部分，我们得出 q 为真。现在从假设的第二部分得出 r 为真，如所需。",
        "answer_symbols": [
            "→",
            "∧"
        ]
    },
    "1.3 12 c)": {
        "question": "不用真值表证明练习10中的各条件语句为永真式. [(p ∨ q) ∧ (p → r) ∧ (q → r)] → r",
        "answer": "假设假设为真。那么 p 为真，由于假设的第二部分为真，我们得出 q 也为真，如所需。",
        "answer_symbols": [
            "→",
            "∧"
        ]
    },
    "1.3 22": {
        "question": "证明 (p → q) ∧ (p → r) 和 p → (q ∧ r) 逻辑等价。",
        "answer": "假设 (p → q) ∧ (p → r) 为真。我们要证明 p → (q ∧ r) 为真，这意味着我们要证明每当 p 为真时，q ∧ r 也为真。如果 p 为真，由于我们假设 p → q 和 p → r 都为真，我们可以得出 q 为真且 r 为真。因此，q ∧ r 为真，如所需。反之，假设 p → (q ∧ r) 为真。我们需要证明 p → q 为真且 p → r 为真，这意味着如果 p 为真，那么 q 和 r 也必须为真。但这可以从 p → (q ∧ r) 得出。",
        "answer_symbols": [
            "∨",
            "→",
            "∧"
        ]
    },
    "1.3 23": {
        "question": "证明 (p → r) ∧ (q → r) 和 (p ∨ q) → r 逻辑等价。",
        "answer": "对于 (p → r) ∧ (q → r) 要为假，两个条件语句中的一个必须为假，这发生在 r 为假且 p 和 q 中至少有一个为真的时候。但这正是 p ∨ q 为真且 r 为假的情况，这正是 (p ∨ q) → r 为假的时候。因为这两个命题在完全相同的情况下为假，所以它们在逻辑上是等价的",
        "answer_symbols": [
            "∧",
            "∨",
            "→"
        ]
    },
    "1.3 24": {
        "question": "证明 (p → q) ∨ (p → r) 和 p → (q ∨ r) 逻辑等价。",
        "answer": "我们确切地确定真值表中哪些行将有T作为其条目。现在（p→q）∨（p→r）在任何一个条件语句为真时为真。如果p为假，或在一种情况下q或在另一种情况下r为真，即当q ∨ r为真时，这正是p→（q ∨ r）为真的时候。由于这两个命题在完全相同的情况下为真，因此它们是逻辑等价的。",
        "answer_symbols": [
            "→",
            "∨",
            "∧"
        ]
    },
    "1.3 25": {
        "question": "证明 (p → r) ∨ (q → r) 和 (p ∧ q) → r 逻辑等价。",
        "answer": "对于 (p → r) ∨ (q → r) 要为假，两个条件语句都必须为假，这发生在 r 为假且 p 和 q 都为真的时候。但这正是 p ∧ q 为真且 r 为假的情况，这正是 (p ∧ q) → r 为假的时候。因为这两个命题在完全相同的情况下为假，所以它们在逻辑上是等价的",
        "answer_symbols": [
            "∨",
            "∧",
            "→"
        ]
    },
    "1.3 26": {
        "question": "证明 ¬p → (q → r) 和 q → (p ∨ r) 逻辑等价。",
        "answer": "应用表7中的第三和第一个等价性，我们有¬p→（q→r）≡ p ∨（q→r）≡ p ∨ ¬q ∨ r。应用表7中的第一个等价性到q→（p ∨ r），显示¬q ∨ p ∨ r与之等价。但这些通过交换律和结合律是等价的。",
        "answer_symbols": [
            "¬",
            "→",
            "∨",
            "≡"
        ]
    },
    "1.3 27": {
        "question": "证明 p ↔ q 和 (p → q) ∧ (q → p) 逻辑等价。",
        "answer": "这个事实是在首次定义双条件语句时观察到的。每个命题在 p 和 q 具有相同的真值时都为真",
        "answer_symbols": [
            "↔"
        ]
    },
    "1.3 28": {
        "question": "证明 p ↔ q 和 ¬p ↔ ¬q 逻辑等价。",
        "answer": "我们知道p ↔ q 当且仅当p和q具有相同的真值时为真。但这发生在¬p和¬q具有相同的真值时，即¬p ↔ ¬q。",
        "answer_symbols": [
            "↔",
            "¬"
        ]
    },
    "1.3 29": {
        "question": "证明 (p → q) ∧ (q → r) → (p → r) 是永真式。",
        "answer": "最后一列全是 T",
        "answer_symbols": []
    },
    "1.3 30": {
        "question": "证明 (p ∨ q) ∧ (¬p ∨ r) → (q ∨ r) 是永真式。",
        "answer": "结论q ∨ r将在每种情况下为真，除非q和r都为假。但如果q和r都为假，那么p ∨ q 或 ¬p ∨ r 中的一个为假，因为p或¬p中的一个为假。因此在这种情况下假设（p ∨ q）∧（¬p ∨ r）为假。当结论为真或假设为假时，条件语句为真，这就完成了论证。",
        "answer_symbols": [
            "∨",
            "∧",
            "¬"
        ]
    },
    "1.3 31": {
        "question": "证明 (p → q) → r 和 p → (q → r) 不是逻辑等价的。",
        "answer": "这些不是逻辑等价的，因为当 p、q 和 r 都为假时，(p → q) → r 为假，但 p → (q → r) 为真",
        "answer_symbols": [
            "→"
        ]
    },
    "1.3 32": {
        "question": "证明 (p ∧ q) → r 和 (p → r) ∧ (q → r) 不是逻辑等价的。",
        "answer": "我们只需要找到一个使其中一个命题为真而另一个为假的真值赋值。我们可以让p为真，其他两个变量为假。那么第一个陈述将是F→F，这是真的，但第二个将是F ∧ T，这是假的。",
        "answer_symbols": [
            "→",
            "∧"
        ]
    },
    "1.3 33": {
        "question": "证明 (p → q) → (r → s) 和 (p → r) → (q → s) 不是逻辑等价的。",
        "answer": "可以有许多答案。如果我们让 r 为真而 p、q 和 s 为假，那么 (p → q) → (r → s) 将为假，但 (p → r) → (q → s) 将为真",
        "answer_symbols": [
            "→"
        ]
    },
    "1.3 34 a)": {
        "question": "求下列命题的对偶式。（a）p ∨ ¬q",
        "answer": "我们应用引言中所述的规则。a) p ∧ ¬q",
        "answer_symbols": [
            "∧",
            "∨",
            "¬",
            "F",
            "T"
        ]
    },
    "1.3 34 b)": {
        "question": "求下列命题的对偶式。（b）p ∧ (q ∨ (r ∧ T))",
        "answer": "我们应用引言中所述的规则。b) p ∨（q ∧（r ∨ F）） ",
        "answer_symbols": [
            "∧",
            "∨",
            "¬",
            "F",
            "T"
        ]
    },
    "1.3 34 c)": {
        "question": "求下列命题的对偶式。（c）(p ∧ ¬q) ∨ (q ∧ F)",
        "answer": "我们应用引言中所述的规则。c)（p ∨ ¬q）∧（q ∨ T）",
        "answer_symbols": [
            "∧",
            "∨",
            "¬",
            "F",
            "T"
        ]
    },
    "1.3 35 a)": {
        "question": "求下列命题的对偶式。（a）p ∧ ¬q ∧ ¬r",
        "answer": "p ∨ ¬q ∨ ¬r",
        "answer_symbols": [
            "∨",
            "¬"
        ]
    },
    "1.3 35 b)": {
        "question": "求下列命题的对偶式。（b）(p ∧ q ∧ r) ∨ s",
        "answer": "(p ∨ q ∨ r) ∧ s",
        "answer_symbols": [
            "∨",
            "∧"
        ]
    },
    "1.3 35 c)": {
        "question": "求下列命题的对偶式。（c）(p ∨ F) ∧ (q ∨ T)",
        "answer": "(p ∧ T) ∨ (q ∧ F)",
        "answer_symbols": [
            "∧",
            "∨"
        ]
    },
    "1.3 36": {
        "question": "什么情况下 s* = s 成立（其中 s 是一个复合命题）？",
        "answer": "如果s有任何出现的∧，∨，T或F，那么形成对偶的过程将改变它。因此s* = s当且仅当s只是一个命题变量（如p）。一个更难的问题是确定何时s*将与s逻辑等价。例如，p ∨ F与其对偶p ∧ T逻辑等价，因为两者都与p逻辑等价。",
        "answer_symbols": [
            "∧",
            "∨",
            "T",
            "F",
            "≡"
        ]
    },
    "1.3 37": {
        "question": "当 s 是一个复合命题时，证明 (s*)* = s。",
        "answer": "如果我们两次取对偶，每个 ∨ 都会变成 ∧ 然后再变回 ∨，每个 ∧ 都会变成 ∨ 然后再变回 ∧，每个 T 都会变成 F 然后再变回 T，每个 F 都会变成 T 然后再变回 F。因此，(s *) * = s",
        "answer_symbols": [
            "∨",
            "∧",
            "*",
            "="
        ]
    },
    "1.3 38": {
        "question": "表 6 中的逻辑等价式除了双重否定律外都是成对的，证明每一对所包含的复合命题都是互为对偶的。",
        "answer": "表格实际上是展示对偶性的。两个恒等律是对偶的，两个支配律是对偶的，等等。唯一没有与另一个一起列出的定律是双重否定律，它是自己的对偶，因为没有∧，∨，T或F的发生可以替换。",
        "answer_symbols": [
            "∧",
            "∨",
            "T",
            "F"
        ]
    },
    "1.3 39": {
        "question": "为什么只含运算符 ∧、∨ 和 ¬ 的两个等价的复合命题的对偶式也是等价的？",
        "answer": "设 p 和 q 是仅涉及运算符 ∧、∨ 和 ¬ 以及 T 和 F 的等价复合命题。注意 ¬p 和 ¬q 也是等价的。使用德摩根定律尽可能多地将否定推入这些复合命题中，将 ∨ 改为 ∧，反之亦然，并将 T 改为 F，反之亦然。这表明 ¬p 和 ¬q 与 p * 和 q * 相同，只是其中的每个原子命题 p i 被其否定所替换。从这一点我们可以得出结论，p * 和 q * 是等价的，因为 ¬p 和 ¬q 也是如此",
        "answer_symbols": [
            "∧",
            "∨",
            "¬",
            "*",
            "="
        ]
    },
    "1.3 40": {
        "question": "试找出一个含命题变元 p、q 和 r 的复合命题，当 p 和 q 为真而 r 为假时该命题为真，否则为假。[提示：试用每个命题变元或其否定的合取式。]",
        "answer": "跟随提示，我们很容易看到答案是p ∧ q ∧ ¬r。",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.3 41": {
        "question": "试找出一个含命题变元 p、q 和 r 的复合命题，在 p、q 和 r 中恰有两个为真时该命题为真，否则为假。[提示：构造合取式的析取。将使命题为真的每一种真值组合构成一个合取式。每个合取式都应包含三个命题变元或它们的否定。]",
        "answer": "(p ∧ q ∧ ¬r) ∨ (p ∧ ¬q ∧ r) ∨ (¬p ∧ q ∧ r)",
        "answer_symbols": [
            "∧",
            "∨",
            "¬"
        ]
    },
    "1.3 42": {
        "question": "假设给定一个有 n 个命题变元的真值表。试证明可通过下面的方法构造一个与此表一致的复合命题：即取各命题变元或其否定的合取式的析取式，其中的每个合取式对应一组真值组合，从而使得该复合命题为真。这样得到的复合命题称为析取范式。",
        "answer": "问题的陈述实际上就是解决方案。真值表的每一行对应n个原子命题的真值组合。我们可以写下恰好在此情况下为真的合取式，即所有为真的原子命题的合取式和所有为假的原子命题的否定的合取式。如果我们对真值表中复合命题值应为真的每一行这样做，并取结果命题的析取式，那么我们就得到了以析取范式表示的所需命题。",
        "answer_symbols": [
            "∨",
            "∧",
            "¬"
        ]
    },
    "1.3 43": {
        "question": "证明 ¬、∧ 和 ∨ 构成一个逻辑运算符的功能完备集。[提示：利用练习 42 中给出的事实，即每个复合命题都逻辑等价于一个析取范式。]",
        "answer": "给定一个复合命题 p，构造其真值表，然后写出一个析取范式形式的命题 q，使其与 p 在逻辑上等价。因为 q 只涉及 ¬, ∧, 和 ∨，这表明这三个运算符构成了一组功能完备的集合。",
        "answer_symbols": [
            "¬",
            "∧",
            "∨"
        ]
    },
    "1.3 44": {
        "question": "证明 ¬ 和 ∧ 构成一个逻辑运算符的功能完备集。[提示：首先用德·摩根律证明 p ∨ q 逻辑等价于 ¬(¬p ∧ ¬q)。]",
        "answer": "给定一个复合命题p，我们可以通过练习43写出一个与p逻辑等价并仅使用¬，∧和∨的命题q。现在通过德摩根律，我们可以去掉所有的∨，方法是将每个p1 ∨ p2 ∨ ... ∨ pn的出现替换为¬（¬p1 ∧ ¬p2 ∧ ... ∧ ¬pn）。",
        "answer_symbols": [
            "∨",
            "∧",
            "¬",
            "≡"
        ]
    },
    "1.3 45": {
        "question": "证明 ¬ 和 ∨ 构成一个逻辑运算符的功能完备集。",
        "answer": "根据练习 43，给定一个复合命题 p，我们可以写出一个在逻辑上等价于 p 的命题 q，并且 q 只涉及 ¬, ∧, 和 ∨。通过德摩根定律，我们可以消除所有的 ∧，将每个出现的 p1 ∧ p2 ∧ ... ∧ pn 替换为 ¬(¬p1 ∨ ¬p2 ∨ ... ∨ ¬pn)。",
        "answer_symbols": [
            "¬",
            "∧",
            "∨"
        ]
    },
    "1.3 46": {
        "question": "试为逻辑运算符 NAND 构造真值表。",
        "answer": "我们写下对应的定义的真值表。p q p | q\nT T F\nT F T\nF T T\nF F T",
        "answer_symbols": [
            "|"
        ]
    },
    "1.3 47": {
        "question": "证明 p | q 逻辑等价于 ¬(p ∧ q)。",
        "answer": "¬(p ∧ q) 当 p 或 q 中至少有一个为假时为真，当 p 和 q 都为真时为假。因为这正是 p | q 的定义，所以这两个复合命题在逻辑上是等价的。",
        "answer_symbols": [
            "¬",
            "∧",
            "|"
        ]
    },
    "1.3 48": {
        "question": "试为逻辑运算符 NOR 构造真值表。",
        "answer": "我们根据定义写下真值表。| p | q | p ↓ q |\n|---|---|-------|\n| T | T |   F   |\n| T | F |   F   |\n| F | T |   F   |\n| F | F |   T   |",
        "answer_symbols": [
            "|",
            "T",
            "F"
        ]
    },
    "1.3 49": {
        "question": "证明 p ↓ q 逻辑等价于 ¬(p ∨ q)。",
        "answer": "¬(p ∨ q) 当 p 和 q 都为假时为真，其他情况下为假。因为这正是 p ↓ q 的定义，所以两者在逻辑上是等价的。",
        "answer_symbols": [
            "¬",
            "∨",
            "↓"
        ]
    },
    "1.3 50 a)": {
        "question": "本练习将证明 {↓} 是一个逻辑运算符的功能完备集。（a）证明 p ↓ p 逻辑等价于 ¬p。",
        "answer": "根据定义（或从第48题构建的真值表中可以看出），当p为真时，p ↓ p 为假；当p为假时，p ↓ p 为真，这与 ¬p 完全相同；因此两者在逻辑上是等价的。",
        "answer_symbols": [
            "↓",
            "¬"
        ]
    },
    "1.3 50 b)": {
        "question": "本练习将证明 {↓} 是一个逻辑运算符的功能完备集。（b）证明 (p ↓ q) ↓ (p ↓ q) 逻辑等价于 p ∨ q。",
        "answer": "命题 (p ↓ q) ↓ (p ↓ q) 等价于 ¬(p ↓ q)，而根据定义（或真值表或第49题）可知，这显然等价于 p ∨ q。",
        "answer_symbols": [
            "↓",
            "¬",
            "∨"
        ]
    },
    "1.3 50 c)": {
        "question": "本练习将证明 {↓} 是一个逻辑运算符的功能完备集。（c）由 a) 和 b)，以及练习 49 可得 {↓} 是一个逻辑运算符的功能完备的集。",
        "answer": "根据第45题，每个复合命题都等价于仅使用 ¬ 和 ∨ 的复合命题。但根据本题的 (a) 和 (b) 部分，我们可以用 NOR 替换所有的否定和析取。因此，每个复合命题都可以转换成仅使用 NOR 的逻辑等价复合命题。",
        "answer_symbols": [
            "¬",
            "∨",
            "↓"
        ]
    },
    "1.3 51": {
        "question": "只用运算符↓构造一个等价于 p→q 的命题。",
        "answer": "((p ↓ p) ↓ q) ↓ ((p ↓ p) ↓ q)",
        "answer_symbols": [
            "↓"
        ]
    },
    "1.3 52": {
        "question": "证明 {↓} 是一个逻辑运算符的功能完备集。",
        "answer": "这个练习类似于第50题。首先，从真值表中可以看出 (p | p) ≡ (¬p) 且 ((p | p) | (q | q)) ≡ (p ∨ q)。然后我们像第50题的 (c) 部分那样进行论证：根据第45题，每个复合命题都等价于仅使用 ¬ 和 ∨ 的复合命题。但根据本题开头的观察，我们可以用 NAND 替换所有的否定和析取。因此，每个复合命题都可以转换成仅使用 NAND 的逻辑等价复合命题。",
        "answer_symbols": [
            "|",
            "¬",
            "∨",
            "≡"
        ]
    },
    "1.3 53": {
        "question": "证明 p↓q 和 q↓p 等价。",
        "answer": "这个结论可以直接从 p | q 的真值表或定义得出。",
        "answer_symbols": [
            "|"
        ]
    },
    "1.3 54": {
        "question": "证明 p↓(q↓r)和(p↓q)↓r 不等价。(因此，逻辑运算符↓不满足结合律。)",
        "answer": "要证明这些不是逻辑等价的，我们只需要找到一个对 p、q 和 r 的真值赋值，使得 p | (q | r) 和 (p | q) | r 的真值不同。一个这样的赋值是 p 为真，q 和 r 为假。通过计算真值表（或定义），我们可以看到 p | (q | r) 为假，而 (p | q) | r 为真。",
        "answer_symbols": [
            "|",
            "T",
            "F"
        ]
    },
    "1.3 56": {
        "question": "证明如果 p、q 和 r 是复合命题，且 p 与 q 是逻辑等价的，q 与 r 是逻辑等价的，则 p 与 r 是逻辑等价的。",
        "answer": "说 p 和 q 是逻辑等价的是指 p 和 q 的真值表是相同的；同样地，说 q 和 r 是逻辑等价的是指 q 和 r 的真值表是相同的。显然，如果 p 和 q 的真值表相同，q 和 r 的真值表也相同，那么 p 和 r 的真值表也相同（这是等价概念的一个基本公理）。因此，p 和 r 是逻辑等价的。（我们假设——这样做没有一般性的损失——这三个命题中出现的是相同的原子变量。）",
        "answer_symbols": [
            "≡"
        ]
    },
    "1.3 57": {
        "question": "下面的语句取自一个电话系统的规范说明：“如果目录数据库是打开的，那么监控程序被置于关闭状态，如果系统不在其初始状态。”这句话有两个条件语句，使规范说明很难懂。找一个等价的易懂的规范说明，使其只涉及析取和否定，而不涉及条件句。",
        "answer": "如果数据库是打开的，那么系统要么处于初始状态，要么监控器被置于关闭状态。",
        "answer_symbols": []
    },
    "1.3 58": {
        "question": "通过对 p、q、r 赋一组真值，析取式 p∨¬q、¬p∨q、q∨¬r、q∨¬r、¬q∨¬r 中有多少个可以同时为真？",
        "answer": "如果我们希望前两个表达式为真，那么 p 和 q 必须具有相同的真值。如果 q 为真，则第三个和第四个表达式将为真，如果 r 为假，最后一个表达式将为真。因此，如果我们设置 p 和 q 为真，r 为假，所有五个析取式都将为真。",
        "answer_symbols": [
            "∨",
            "T",
            "F"
        ]
    },
    "1.3 59": {
        "question": "通过对 p、q、r、s 赋一组真值，析取式 p∨¬q∨s、¬p∨¬r∨s、¬p∨¬r∨¬s、¬p∨q∨¬s、q∨¬r∨¬s、q∨¬r∨¬s、p∨¬q∨¬s、p∨¬r∨¬s 中有多少个可以同时为真？",
        "answer": "全部九个",
        "answer_symbols": []
    },
    "1.3 60": {
        "question": "试证明一个不可满足的复合命题的否定是永真式，一个永真的复合命题的否定是不可满足的。",
        "answer": "这些直接来自定义。一个不可满足的复合命题是指没有任何真值赋值使其为真的命题，也就是说，它对所有真值赋值都是假的，也就是说它的否定对所有真值赋值都是真的。这就是重言式的定义。相反，重言式的否定（即对所有真值赋值都为真的命题）将对所有真值赋值都是假的，因此将是不可满足的。",
        "answer_symbols": [
            "¬",
            "∨"
        ]
    },
    "1.3 61 a)": {
        "question": "试判定下列复合命题是否是可满足的。（a）(p∨¬q)∧(¬p∨q)∧(¬p∨¬q)",
        "answer": "可满足 ",
        "answer_symbols": []
    },
    "1.3 61 b)": {
        "question": "试判定下列复合命题是否是可满足的。（b）(p→q)∧(p→¬q)∧(¬p→q)∧(¬p→¬q)",
        "answer": "不可满足 ",
        "answer_symbols": []
    },
    "1.3 61 c)": {
        "question": "试判定下列复合命题是否是可满足的。（c）(p→q)∧(¬p→q)",
        "answer": "不可满足",
        "answer_symbols": []
    },
    "1.3 62 a)": {
        "question": "试判断下列复合命题是否是可满足的。（a）(p∨q∨¬r)∧(p∨¬q∨¬s)∧(p∨¬r∨¬s)∧(¬p∨¬q∨¬s)∧(¬p∨¬r∨¬s)",
        "answer": "由于 p 出现在五个析取式中的四个中，我们可以使 p 为真，然后使 q 为假（并且使 r 和 s 为我们喜欢的任何值）。因此这个命题是可以满足的。",
        "answer_symbols": [
            "∨",
            "F",
            "T"
        ]
    },
    "1.3 62 b)": {
        "question": "试判断下列复合命题是否是可满足的。（b）(¬p∨¬q∨¬r)∧(¬p∨¬q∨¬s)∧(¬p∨¬r∨¬s)∧(¬p∨¬q∨¬r)∧(¬p∨¬r∨¬s)",
        "answer": "这个命题可以通过例如将 p 设为假（这样处理了第一个、第二个和第四个析取项），将 s 设为假（用于第三个和第六个析取项），将 q 设为真（用于第五个析取项），而 r 可以是任意值来满足。",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.3 62 c)": {
        "question": "试判断下列复合命题是否是可满足的。（c）(p∨q∨¬r)∧(p∨¬q∨¬s)∧(q∨¬r∨¬s)∧(¬p∨¬q∨¬s)∧(¬p∨¬r∨¬s)",
        "answer": "找到一个满足的真值指派并不难，例如 p、q 和 s 为真，而 r 为假。",
        "answer_symbols": []
    },
    "1.3 63": {
        "question": "试证明如何通过求解一个可满足性问题来获得一个给定的 4×4 数独谜题的解。",
        "answer": "使用文本中给出的 9 × 9 数独谜题的相同命题，变量索引从 1 到 4，而不是从 1 到 9，并对 2 × 2 区块的命题进行类似的更改：∧1 r=0 ∧1 s=0 ∧4 n=1 ∨2 i=1 ∨2 j=1 p(2r+ i, 2s+ j, n)",
        "answer_symbols": [
            "∧",
            "∨"
        ]
    },
    "1.3 64": {
        "question": "试构造一个复合命题断言一个 9×9 数独谜题的每个单元至少包含一个数。",
        "answer": "回想一下，p(i, j, n) 断言第 i 行第 j 列的单元格包含数字 n。因此 ∨9 n=1 p(i, j, n) 断言这个单元格至少包含一个数字。为了断言每个单元格至少包含一个数字，我们对所有单元格取这些陈述的合取：∧9 i=1∧ 9 j=1∨ 9 n=1 p(i, j, n)。",
        "answer_symbols": [
            "∨",
            "∧"
        ]
    },
    "1.3 65": {
        "question": "试解释书中给出的复合命题的构造步骤，该命题断言 9×9 数独谜题的每一列包含了每一个数。",
        "answer": "∨9 i=1 p(i, j, n) 表示列 j 包含数字 n，因此 ∧9 n=1 ∨9 i=1 p(i, j, n) 表示列 j 包含所有 9 个数字；因此 ∧9 j=1 ∧9 n=1 ∨9 i=1 p(i, j, n) 表示每一列都包含所有数字。",
        "answer_symbols": [
            "∨",
            "∧"
        ]
    },
    "1.3 66": {
        "question": "试解释书中给出的复合命题的构造步骤，该命题断言 9×9 数独谜题的每个 3×3 九宫格包含了每一个数。",
        "answer": "有九个块，分为三行三列。设 r 和 s 分别索引块的行和列，其中我们从 0 开始计数，所以 0 ≤ r ≤ 2 且 0 ≤ s ≤ 2。（例如，r = 0, s = 1 对应于块的第一行第二列。）关键点是注意到对应于对 (r, s) 的块包含第 3r + 1, 3r + 2, 和 3r + 3 行以及第 3s + 1, 3s + 2, 和 3s + 3 列的单元格。因此 p(3r + i, 3s + j, n) 断言该块中的某个特定单元格包含数字 n，其中 1 ≤ i ≤ 3 且 1 ≤ j ≤ 3。如果我们对所有这些 i 和 j 的值取析取，那么我们得到 ∨3 i=1∨ 3 j=1 p(3r + i, 3s + j, n)，断言该块中的某个单元格包含数字 n。因为我们要这个对每个数字和每个块都成立，所以我们形成文本中给出的三重索引合取。",
        "answer_symbols": [
            "∨",
            "∧",
            "+",
            "≤"
        ]
    },
    "1.4 1 a)": {
        "question": "令 P(x) 表示语句“x≤4”。下列各项的真值是什么？ a) P(0)",
        "answer": "T",
        "answer_symbols": []
    },
    "1.4 1 b)": {
        "question": "令 P(x) 表示语句“x≤4”。下列各项的真值是什么？ b) P(4)",
        "answer": "T",
        "answer_symbols": []
    },
    "1.4 1 c)": {
        "question": "令 P(x) 表示语句“x≤4”。下列各项的真值是什么？ c) P(6)",
        "answer": "F",
        "answer_symbols": []
    },
    "1.4 2 a)": {
        "question": "令 P(x) 表示语句“单词 x 含字母 a。”下列各项的真值是什么？ a) P(orange)",
        "answer": "这是真的，因为橙色中有 a。",
        "answer_symbols": []
    },
    "1.4 2 b)": {
        "question": "令 P(x) 表示语句“单词 x 含字母 a。”下列各项的真值是什么？ b) P(lemon)",
        "answer": "这是假的，因为柠檬中没有 a。",
        "answer_symbols": []
    },
    "1.4 2 c)": {
        "question": "令 P(x) 表示语句“单词 x 含字母 a。”下列各项的真值是什么？ c) P(true)",
        "answer": "这是假的，因为真中没有 a。",
        "answer_symbols": []
    },
    "1.4 3 a)": {
        "question": "令 Q(x, y) 表示语句“x 是 y 的首府。”下列各项的真值是什么？ a) Q(丹佛，科罗拉多)",
        "answer": "T",
        "answer_symbols": []
    },
    "1.4 3 b)": {
        "question": "令 Q(x, y) 表示语句“x 是 y 的首府。”下列各项的真值是什么？ b) Q(底特律，密歇根)",
        "answer": "F",
        "answer_symbols": []
    },
    "1.4 3 c)": {
        "question": "令 Q(x, y) 表示语句“x 是 y 的首府。”下列各项的真值是什么？ c) Q(马萨诸塞，波士顿)",
        "answer": "F",
        "answer_symbols": []
    },
    "1.4 3 d)": {
        "question": "令 Q(x, y) 表示语句“x 是 y 的首府。”下列各项的真值是什么？ d) Q(纽约，纽约)",
        "answer": "F",
        "answer_symbols": []
    },
    "1.4 4 a)": {
        "question": "给出执行 if P(x) then x := 1 语句以后 x 的值，其中 P(x) 为语句“x>1”，如果执行到上述语句时 x 的值是： a) x=0",
        "answer": "这里 x 仍然等于 0，因为条件是假的。",
        "answer_symbols": []
    },
    "1.4 4 b)": {
        "question": "给出执行 if P(x) then x := 1 语句以后 x 的值，其中 P(x) 为语句“x>1”，如果执行到上述语句时 x 的值是： b) x=1",
        "answer": "这里 x 仍然等于 1，因为条件是假的。",
        "answer_symbols": []
    },
    "1.4 4 c)": {
        "question": "给出执行 if P(x) then x := 1 语句以后 x 的值，其中 P(x) 为语句“x>1”，如果执行到上述语句时 x 的值是： c) x=2",
        "answer": "这次 x 在最后等于 1，因为条件是真的，所以执行了语句 x := 1。",
        "answer_symbols": [
            ":="
        ]
    },
    "1.4 5 a)": {
        "question": "令 P(x) 为语句“x 在每个工作日都花 5 个多小时上课”，其中 x 的论域是全体学生。用汉语表达下列各量化式。 a) ∃x P(x)",
        "answer": "有一名学生每天在课堂上花费超过 5 小时。",
        "answer_symbols": []
    },
    "1.4 5 b)": {
        "question": "令 P(x) 为语句“x 在每个工作日都花 5 个多小时上课”，其中 x 的论域是全体学生。用汉语表达下列各量化式。 b) ∀x P(x)",
        "answer": "每个学生每天在课堂上花费超过 5 小时。",
        "answer_symbols": []
    },
    "1.4 5 c)": {
        "question": "令 P(x) 为语句“x 在每个工作日都花 5 个多小时上课”，其中 x 的论域是全体学生。用汉语表达下列各量化式。 c) ∃x ¬P(x)",
        "answer": "有一名学生每天在课堂上不花费超过 5 小时。",
        "answer_symbols": []
    },
    "1.4 5 d)": {
        "question": "令 P(x) 为语句“x 在每个工作日都花 5 个多小时上课”，其中 x 的论域是全体学生。用汉语表达下列各量化式。 d) ∀x ¬P(x)",
        "answer": "没有学生每天在课堂上花费超过 5 小时。",
        "answer_symbols": []
    },
    "1.4 6 a)": {
        "question": "令 N(x) 为语句“x 已经去过北达科他”，论域是你所在学校的所有学生。用汉语表达下列各量化式。 a) ∃x N(x)",
        "answer": "学校中有些学生访问过北达科他州。（或者，学校中存在一个学生访问过北达科他州。）",
        "answer_symbols": [
            "∃"
        ]
    },
    "1.4 6 b)": {
        "question": "令 N(x) 为语句“x 已经去过北达科他”，论域是你所在学校的所有学生。用汉语表达下列各量化式。 b) ∀x N(x)",
        "answer": "学校中的每个学生都访问过北达科他州。（或者，学校中的所有学生都访问过北达科他州。）",
        "answer_symbols": [
            "∀"
        ]
    },
    "1.4 6 c)": {
        "question": "令 N(x) 为语句“x 已经去过北达科他”，论域是你所在学校的所有学生。用汉语表达下列各量化式。 c) ¬∃x N(x)",
        "answer": "这是部分 (a) 的否定：学校中没有学生访问过北达科他州。（或者，学校中不存在一个学生访问过北达科他州。）",
        "answer_symbols": [
            "¬",
            "∃"
        ]
    },
    "1.4 6 d)": {
        "question": "令 N(x) 为语句“x 已经去过北达科他”，论域是你所在学校的所有学生。用汉语表达下列各量化式。 d) ¬∀x N(x)",
        "answer": "学校中有些学生没有访问过北达科他州。（或者，学校中存在一个学生没有访问过北达科他州。）",
        "answer_symbols": [
            "∃",
            "¬"
        ]
    },
    "1.4 7 a)": {
        "question": "将下列语句翻译成汉语，其中 C(x) 是“x 是一个喜剧演员”，F(x) 是“x 很有趣”，论域是所有人。 a) ∀x (C(x) → F(x))",
        "answer": "每个喜剧演员都很有趣。",
        "answer_symbols": []
    },
    "1.4 7 b)": {
        "question": "将下列语句翻译成汉语，其中 C(x) 是“x 是一个喜剧演员”，F(x) 是“x 很有趣”，论域是所有人。 b) ∀x (C(x) ∧ F(x))",
        "answer": "每个人都是有趣的喜剧演员。",
        "answer_symbols": []
    },
    "1.4 7 c)": {
        "question": "将下列语句翻译成汉语，其中 C(x) 是“x 是一个喜剧演员”，F(x) 是“x 很有趣”，论域是所有人。 c) ∃x (C(x) → F(x))",
        "answer": "存在一个这样的人，如果他是喜剧演员，那么他很有趣。",
        "answer_symbols": []
    },
    "1.4 7 d)": {
        "question": "将下列语句翻译成汉语，其中 C(x) 是“x 是一个喜剧演员”，F(x) 是“x 很有趣”，论域是所有人。 d) ∃x (C(x) ∧ F(x))",
        "answer": "有些喜剧演员很有趣。",
        "answer_symbols": []
    },
    "1.4 8 a)": {
        "question": "将下列语句翻译成汉语，其中 R(x) 是“x 是一只兔子”，H(x) 是“x 跳跃”，论域是所有动物。 a) ∀x (R(x) → H(x))",
        "answer": "If an animal is a rabbit, then that animal hops. (Alternatively, every rabbit hops.)",
        "answer_symbols": [
            "→",
            "∀"
        ]
    },
    "1.4 8 b)": {
        "question": "将下列语句翻译成汉语，其中 R(x) 是“x 是一只兔子”，H(x) 是“x 跳跃”，论域是所有动物。 b) ∀x (R(x) ∧ H(x))",
        "answer": "Every animal is a rabbit and hops.",
        "answer_symbols": [
            "∀",
            "∧"
        ]
    },
    "1.4 8 c)": {
        "question": "将下列语句翻译成汉语，其中 R(x) 是“x 是一只兔子”，H(x) 是“x 跳跃”，论域是所有动物。 c) ∃x (R(x) → H(x))",
        "answer": "There exists an animal such that if it is a rabbit, then it hops. (Note that this is trivially true, satisfied, for example, by lions, so it is not the sort of thing one would say.)",
        "answer_symbols": [
            "∃",
            "→"
        ]
    },
    "1.4 8 d)": {
        "question": "将下列语句翻译成汉语，其中 R(x) 是“x 是一只兔子”，H(x) 是“x 跳跃”，论域是所有动物。 d) ∃x (R(x) ∧ H(x))",
        "answer": "There exists an animal that is a rabbit and hops. (Alternatively, some rabbits hop. Alternatively, some hopping animals are rabbits.)",
        "answer_symbols": [
            "∃",
            "∧"
        ]
    },
    "1.4 9 a)": {
        "question": "令 P(x) 为语句“x 会说俄语”，Q(x) 为语句“x 了解计算机语言 C++”。用 P(x)、Q(x)、量词和逻辑联结词表示下列各句子。量词的论域为你校全体学生的集合。 a) 你校有个学生既会说俄语又了解 C++。",
        "answer": "∃x(P(x) ∧ Q(x))",
        "answer_symbols": [
            "∃",
            "∧"
        ]
    },
    "1.4 9 b)": {
        "question": "令 P(x) 为语句“x 会说俄语”，Q(x) 为语句“x 了解计算机语言 C++”。用 P(x)、Q(x)、量词和逻辑联结词表示下列各句子。量词的论域为你校全体学生的集合。 b) 你校有个学生会说俄语但不了解 C++。",
        "answer": "∃x(P(x) ∧ ¬Q(x))",
        "answer_symbols": [
            "∃",
            "∧",
            "¬"
        ]
    },
    "1.4 10 a)": {
        "question": "班上的一个学生有一只猫、一只狗和一只雪貂。",
        "answer": "We assume that this means that one student has all three animals: ∃x(C(x) ∧ D(x) ∧ F(x)).",
        "answer_symbols": [
            "∃",
            "∧"
        ]
    },
    "1.4 10 b)": {
        "question": "班上的所有学生有一只猫、一只狗或一只雪貂。",
        "answer": "∀x(C(x) ∨ D(x) ∨ F(x))",
        "answer_symbols": [
            "∀",
            "∨"
        ]
    },
    "1.4 10 c)": {
        "question": "班上的一些学生有一只猫和一只雪貂，但没有狗。",
        "answer": "∃x(C(x) ∧ F(x) ∧ ¬D(x))",
        "answer_symbols": [
            "∃",
            "∧",
            "¬"
        ]
    },
    "1.4 10 d)": {
        "question": "班上没有学生同时有一只猫、一只狗和一只雪貂。",
        "answer": "This is the negation of part (a): ¬∃x(C(x) ∧ D(x) ∧ F(x)).",
        "answer_symbols": [
            "¬",
            "∃",
            "∧"
        ]
    },
    "1.4 10 e)": {
        "question": "对猫、狗和雪貂这三种动物的任意一种，班上都有学生将其作为宠物。",
        "answer": "Here the owners of these pets can be different: (∃x C(x)) ∧ (∃x D(x)) ∧ (∃x F(x)). There is no harm in using the same dummy variable, but this could also be written, for example, as (∃x C(x)) ∧ (∃y D(y)) ∧ (∃z F(z)).",
        "answer_symbols": [
            "∃",
            "∧"
        ]
    },
    "1.4 11 a)": {
        "question": "P(0)",
        "answer": "T",
        "answer_symbols": []
    },
    "1.4 11 b)": {
        "question": "P(1)",
        "answer": "T",
        "answer_symbols": []
    },
    "1.4 11 c)": {
        "question": "P(2)",
        "answer": "F",
        "answer_symbols": []
    },
    "1.4 11 d)": {
        "question": "P(-1)",
        "answer": "F",
        "answer_symbols": []
    },
    "1.4 11 e)": {
        "question": "∃x P(x)",
        "answer": "T",
        "answer_symbols": []
    },
    "1.4 11 f)": {
        "question": "∀x P(x)",
        "answer": "F",
        "answer_symbols": []
    },
    "1.4 12 a)": {
        "question": "Q(0)",
        "answer": "Since 0 + 1 > 2 · 0, we know that Q(0) is true.",
        "answer_symbols": [
            "+",
            ">",
            "·"
        ]
    },
    "1.4 12 b)": {
        "question": "Q(-1)",
        "answer": "Since (-1) + 1 > 2 · (-1), we know that Q(-1) is true.",
        "answer_symbols": [
            "+",
            ">",
            "·"
        ]
    },
    "1.4 12 c)": {
        "question": "Q(1)",
        "answer": "Since 1 + 1 > 2 · 1, we know that Q(1) is false.",
        "answer_symbols": [
            "+",
            ">",
            "·"
        ]
    },
    "1.4 12 d)": {
        "question": "∃x Q(x)",
        "answer": "From part (a) we know that there is at least one x that makes Q(x) true, so ∃x Q(x) is true.",
        "answer_symbols": [
            "∃"
        ]
    },
    "1.4 12 e)": {
        "question": "∀x Q(x)",
        "answer": "From part (c) we know that there is at least one x that makes Q(x) false, so ∀x Q(x) is false.",
        "answer_symbols": [
            "∀"
        ]
    },
    "1.4 12 f)": {
        "question": "∃x ¬Q(x)",
        "answer": "From part (c) we know that there is at least one x that makes Q(x) false, so ∃x ¬Q(x) is true.",
        "answer_symbols": [
            "∃",
            "¬"
        ]
    },
    "1.4 12 g)": {
        "question": "∀x ¬Q(x)",
        "answer": "From part (a) we know that there is at least one x that makes Q(x) true, so ∀x ¬Q(x) is false.",
        "answer_symbols": [
            "∀",
            "¬"
        ]
    },
    "1.4 13 a)": {
        "question": "∀n (n + 1 > n)",
        "answer": "T",
        "answer_symbols": []
    },
    "1.4 13 b)": {
        "question": "∃n (2n = 3n)",
        "answer": "T",
        "answer_symbols": []
    },
    "1.4 13 c)": {
        "question": "∀n (n = -n)",
        "answer": "T",
        "answer_symbols": []
    },
    "1.4 13 d)": {
        "question": "∃n (3n ≤ 4n)",
        "answer": "T",
        "answer_symbols": []
    },
    "1.4 14 a)": {
        "question": "∃x (x^² = -1)",
        "answer": "Since (-1)^3 = -1, this is true.",
        "answer_symbols": [
            "^",
            "="
        ]
    },
    "1.4 14 b)": {
        "question": "∃x (x^² < x^²)",
        "answer": "Since (1/2)^4 < (1/2)^2, this is true.",
        "answer_symbols": [
            "^",
            "<"
        ]
    },
    "1.4 14 c)": {
        "question": "∀x ((-x)^² = x^²)",
        "answer": "Since (-x)^2 = ((-1)x)^2 = (-1)^2 x^2 = x^2, we know that ∀x((-x)^2 = x^2) is true.",
        "answer_symbols": [
            "^",
            "=",
            "·"
        ]
    },
    "1.4 14 d)": {
        "question": "∀x (2x > x)",
        "answer": "Twice a positive number is larger than the number, but this inequality is not true for negative numbers or 0. Therefore ∀x(2x > x) is false.",
        "answer_symbols": [
            ">"
        ]
    },
    "1.4 15 a)": {
        "question": "∀n (n^² ≥ 0)",
        "answer": "T",
        "answer_symbols": []
    },
    "1.4 15 b)": {
        "question": "∃n (n^² = 2)",
        "answer": "F",
        "answer_symbols": []
    },
    "1.4 15 c)": {
        "question": "∀n (n^² ≥ n)",
        "answer": "T",
        "answer_symbols": []
    },
    "1.4 15 d)": {
        "question": "∃n (n^² < 0)",
        "answer": "F",
        "answer_symbols": []
    },
    "1.4 16 a)": {
        "question": "∃x (x^² = 2)",
        "answer": "true (x = √2)",
        "answer_symbols": [
            "√"
        ]
    },
    "1.4 16 b)": {
        "question": "∃x (x^² = -1)",
        "answer": "false (√-1 is not a real number)",
        "answer_symbols": [
            "√"
        ]
    },
    "1.4 16 c)": {
        "question": "∀x (x^² + 2 ≥ 1)",
        "answer": "true (the left-hand side is always at least 2)",
        "answer_symbols": [
            "≥"
        ]
    },
    "1.4 16 d)": {
        "question": "∀x (x^² ≠ x)",
        "answer": "false (not true for x = 1 or x = 0)",
        "answer_symbols": [
            "="
        ]
    },
    "1.4 17 a)": {
        "question": "∃x P(x)",
        "answer": "P(0) ∨ P(1) ∨ P(2) ∨ P(3) ∨ P(4)",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.4 17 b)": {
        "question": "∀x P(x)",
        "answer": "P(0) ∧ P(1) ∧ P(2) ∧ P(3) ∧ P(4)",
        "answer_symbols": [
            "∧"
        ]
    },
    "1.4 17 c)": {
        "question": "∃x ¬P(x)",
        "answer": "¬P(0) ∨ ¬P(1) ∨ ¬P(2) ∨ ¬P(3) ∨ ¬P(4)",
        "answer_symbols": [
            "¬",
            "∨"
        ]
    },
    "1.4 17 d)": {
        "question": "∀x ¬P(x)",
        "answer": "¬P(0) ∧ ¬P(1) ∧ ¬P(2) ∧ ¬P(3) ∧ ¬P(4)",
        "answer_symbols": [
            "¬",
            "∧"
        ]
    },
    "1.4 17 e)": {
        "question": "¬∃x P(x)",
        "answer": "¬(P(0) ∨ P(1) ∨ P(2) ∨ P(3) ∨ P(4))",
        "answer_symbols": [
            "¬",
            "∨"
        ]
    },
    "1.4 17 f)": {
        "question": "¬∀x P(x)",
        "answer": "¬(P(0) ∧ P(1) ∧ P(2) ∧ P(3) ∧ P(4))",
        "answer_symbols": [
            "¬",
            "∧"
        ]
    },
    "1.4 18 a)": {
        "question": "∃x P(x)",
        "answer": "We want to assert that P(x) is true for some x in the domain, so either P(-2) is true or P(-1) is true or P(0) is true or P(1) is true or P(2) is true. Thus the answer is P(-2) ∨ P(-1) ∨ P(0) ∨ P(1) ∨ P(2). The other parts of this exercise are similar. Note that by De Morgan’s laws, the expression in part (c) is logically equivalent to the expression in part (f), and the expression in part (d) is logically equivalent to the expression in part (e).",
        "answer_symbols": [
            "∨",
            "∧",
            "¬"
        ]
    },
    "1.4 18 b)": {
        "question": "∀x P(x)",
        "answer": "P(-2) ∧ P(-1) ∧ P(0) ∧ P(1) ∧ P(2)",
        "answer_symbols": [
            "∧"
        ]
    },
    "1.4 18 c)": {
        "question": "∃x ¬P(x)",
        "answer": "¬P(-2) ∨ ¬P(-1) ∨ ¬P(0) ∨ ¬P(1) ∨ ¬P(2)",
        "answer_symbols": [
            "∨",
            "¬"
        ]
    },
    "1.4 18 d)": {
        "question": "∀x ¬P(x)",
        "answer": "¬P(-2) ∧ ¬P(-1) ∧ ¬P(0) ∧ ¬P(1) ∧ ¬P(2)",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.4 18 e)": {
        "question": "¬∃x P(x)",
        "answer": "This is just the negation of part (a): ¬(P(-2) ∨ P(-1) ∨ P(0) ∨ P(1) ∨ P(2))",
        "answer_symbols": [
            "∨",
            "¬"
        ]
    },
    "1.4 18 f)": {
        "question": "¬∀x P(x)",
        "answer": "This is just the negation of part (b): ¬(P(-2) ∧ P(-1) ∧ P(0) ∧ P(1) ∧ P(2))",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.4 19 a)": {
        "question": "∃x P(x)",
        "answer": "P(1) ∨ P(2) ∨ P(3) ∨ P(4) ∨ P(5)",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.4 19 b)": {
        "question": "∀x P(x)",
        "answer": "P(1) ∧ P(2) ∧ P(3) ∧ P(4) ∧ P(5)",
        "answer_symbols": [
            "∧"
        ]
    },
    "1.4 19 c)": {
        "question": "¬∃x P(x)",
        "answer": "¬(P(1) ∨ P(2) ∨ P(3) ∨ P(4) ∨ P(5))",
        "answer_symbols": [
            "¬",
            "∨"
        ]
    },
    "1.4 19 d)": {
        "question": "¬∀x P(x)",
        "answer": "¬(P(1) ∧ P(2) ∧ P(3) ∧ P(4) ∧ P(5))",
        "answer_symbols": [
            "¬",
            "∧"
        ]
    },
    "1.4 19 e)": {
        "question": "∀x ((x ≠ 3) → P(x)) ∨ ∃x ¬P(x)",
        "answer": "(P(1) ∧ P(2) ∧ P(4) ∧ P(5)) ∨ (¬P(1) ∨ ¬P(2) ∨ ¬P(3) ∨ ¬P(4) ∨ ¬P(5))",
        "answer_symbols": [
            "∧",
            "∨",
            "¬"
        ]
    },
    "1.4 20 a)": {
        "question": "∃x P(x)",
        "answer": "我们希望断言在域中的某个 x 使 P(x) 为真，因此 P(-5) 为真或 P(-3) 为真或 P(-1) 为真或 P(1) 为真或 P(3) 为真或 P(5) 为真。所以答案是 P(-5) 或 P(-3) 或 P(-1) 或 P(1) 或 P(3) 或 P(5)。\n",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.4 20 b)": {
        "question": "∀x P(x)",
        "answer": "P(-5) 且 P(-3) 且 P(-1) 且 P(1) 且 P(3) 且 P(5)",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.4 20 c)": {
        "question": "∀x ((x ≠ 1) → P(x))",
        "answer": "正式的翻译如下：((−5 不等于 1) → P(-5)) 且 ((−3 不等于 1) → P(-3)) 且 ((−1 不等于 1) → P(-1)) 且 ((1 不等于 1) → P(1)) 且 ((3 不等于 1) → P(3)) 且 ((5 不等于 1) → P(5))。然而，由于当 x 为 1 时假设 x 不等于 1 是假的，而当 x 为任何其他值时是真的，我们有更简单的表达式 P(-5) 且 P(-3) 且 P(-1) 且 P(3) 且 P(5)。\n",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.4 20 d)": {
        "question": "∃x ((x ≥ 0) ∧ P(x))",
        "answer": "正式的翻译如下：((−5 大于等于 0) 且 P(-5)) 或 ((−3 大于等于 0) 且 P(-3)) 或 ((−1 大于等于 0) 且 P(-1)) 或 ((1 大于等于 0) 且 P(1)) 或 ((3 大于等于 0) 且 P(3)) 或 ((5 大于等于 0) 且 P(5))。由于域中只有三个 x 满足条件，答案等价于 P(1) 或 P(3) 或 P(5)。\n",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.4 20 e)": {
        "question": "∃x (¬P(x)) ∧ ∀x ((x < 0) → P(x))",
        "answer": "对于第二部分，我们再次限制域：(非 P(-5) 或 非 P(-3) 或 非 P(-1) 或 非 P(1) 或 非 P(3) 或 非 P(5)) 且 (P(-1) 且 P(-3) 且 P(-5))。这等价于 (非 P(1) 或 非 P(3) 或 非 P(5)) 且 (P(-1) 且 P(-3) 且 P(-5))。\n.",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.4 21 a)": {
        "question": "每一个人都在学离散数学。",
        "answer": "你离散数学课上的所有学生；世界上所有的学生",
        "answer_symbols": []
    },
    "1.4 21 b)": {
        "question": "每一个人的年龄都超过 21 岁。",
        "answer": "所有的美国参议员；所有的大学美式橄榄球运动员",
        "answer_symbols": []
    },
    "1.4 21 c)": {
        "question": "每两个人都有相同的妈妈。",
        "answer": "乔治·W·布什和杰布·布什；美国的所有政治家",
        "answer_symbols": []
    },
    "1.4 21 d)": {
        "question": "没有两个不同的人有相同的祖母。",
        "answer": "比尔·克林顿和乔治·W·布什；美国的所有政治家",
        "answer_symbols": []
    },
    "1.4 22 a)": {
        "question": "每一个人都说印地语。",
        "answer": "如果域是一些印度特定地区的成年人，则会使这个命题为真。如果域是美国的所有居民，那么这显然是假的。",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.4 22 b)": {
        "question": "有某个人的年龄超过 21 岁。",
        "answer": "如果域是美国的所有居民，那么这是真的。如果域是一年级学生的集合，它是假的。",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.4 22 c)": {
        "question": "每两个人都有相同的名字 (first name)。",
        "answer": "如果域是所有姓布什的美国总统，那么这个命题是真的。如果域是所有美国总统，那么这个命题是假的。",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.4 22 d)": {
        "question": "某个人认识两个以上的其他人。",
        "answer": "如果域是美国的所有居民，那么这显然是真的。如果域是过去五分钟内出生的所有婴儿，人们会认为这个命题是假的（甚至不清楚这些婴儿是否“认识”他们的母亲）。",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.4 23 a)": {
        "question": "班上有人会说印地语。",
        "answer": "∃x H(x) 和 ∃x(C(x) ∧ H(x))，其中 H(x) 是 “x 会说印地语”",
        "answer_symbols": [
            "∃",
            "∧"
        ]
    },
    "1.4 23 b)": {
        "question": "班上的每个人都很友好。",
        "answer": "∀x F(x) 和 ∀x(C(x) → F(x))，其中 F(x) 是 “x 很友好”",
        "answer_symbols": [
            "∀",
            "→"
        ]
    },
    "1.4 23 c)": {
        "question": "班上有个学生不是出生在加利福尼亚。",
        "answer": "∃x ¬B(x) 和 ∃x(C(x) ∧ ¬B(x))，其中 B(x) 是 “x 出生在加利福尼亚”",
        "answer_symbols": [
            "∃",
            "∧",
            "¬"
        ]
    },
    "1.4 23 d)": {
        "question": "班上有个学生曾演过电影。",
        "answer": "∃x M(x) 和 ∃x(C(x) ∧ M(x))，其中 M(x) 是 “x 曾经出演过电影”",
        "answer_symbols": [
            "∃",
            "∧"
        ]
    },
    "1.4 23 e)": {
        "question": "班上没有学生上过逻辑编程课程。",
        "answer": "∀x ¬L(x) 和 ∀x(C(x) → ¬L(x))，其中 L(x) 是 “x 上过逻辑编程课程”",
        "answer_symbols": [
            "∀",
            "→",
            "¬"
        ]
    },
    "1.4 24 a)": {
        "question": "班上的每个学生都有移动电话。",
        "answer": "让 P(x) 表示“x 有一部手机。” 那么我们有 ∀x P(x) 第一种方式，或 ∀x(C(x) → P(x)) 第二种方式。",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.4 24 b)": {
        "question": "班上的某个学生曾看过外国影片。",
        "answer": "让 F(x) 表示“x 看过一部外国电影。” 那么我们有 ∃x F(x) 第一种方式，或 ∃x(C(x) ∧ F(x)) 第二种方式。",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.4 24 c)": {
        "question": "班上的某个学生不会游泳。",
        "answer": "让 S(x) 表示“x 会游泳。” 那么我们有 ∃x ¬S(x) 第一种方式，或 ∃x(C(x) ∧ ¬S(x)) 第二种方式。",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.4 24 d)": {
        "question": "班上的所有学生都会求解二次方程。",
        "answer": "让 Q(x) 表示“x 会解二次方程。” 那么我们有 ∀x Q(x) 第一种方式，或 ∀x(C(x) → Q(x)) 第二种方式。",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.4 24 e)": {
        "question": "班上的某个学生不想变富。",
        "answer": "让 R(x) 表示“x 想要变得富有。” 那么我们有 ∃x ¬R(x) 第一种方式，或 ∃x(C(x) ∧ ¬R(x)) 第二种方式。",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.4 25 a)": {
        "question": "没有人是完美的。",
        "answer": "∀x ¬P(x)",
        "answer_symbols": [
            "∀",
            "¬"
        ]
    },
    "1.4 25 b)": {
        "question": "不是每个人都是完美的。",
        "answer": "¬∀x P(x)",
        "answer_symbols": [
            "¬",
            "∀"
        ]
    },
    "1.4 25 c)": {
        "question": "你的所有朋友都是完美的。",
        "answer": "∀x(F(x) → P(x))",
        "answer_symbols": [
            "∀",
            "→"
        ]
    },
    "1.4 25 d)": {
        "question": "你的某个朋友是完美的。",
        "answer": "∃x(F(x) ∧ P(x))",
        "answer_symbols": [
            "∃",
            "∧"
        ]
    },
    "1.4 25 e)": {
        "question": "每个人都是你的朋友并且是完美的。",
        "answer": "∀x(F(x) ∧ P(x)) 或 (∀x F(x)) ∧ (∀x P(x))",
        "answer_symbols": [
            "∀",
            "∧",
            "∨"
        ]
    },
    "1.4 25 f)": {
        "question": "不是每个人都是你的朋友或有人并不是完美的。",
        "answer": "(¬∀x F(x)) ∨ (∃x ¬P(x))",
        "answer_symbols": [
            "¬",
            "∨",
            "∃",
            "∀"
        ]
    },
    "1.4 26 a)": {
        "question": "学校中的某个人去过乌兹别克斯坦。",
        "answer": "如果我们让 U(x) 表示“x 去过乌兹别克斯坦”，那么我们有 ∃x U(x) 如果域只是你的同学，或 ∃x(Y(x) ∧ U(x)) 如果域是所有人。如果我们让 V(x, y) 表示人 x 去过国家 y，那么我们可以将最后一个重写为 ∃x(Y(x) ∧ V(x, 乌兹别克斯坦))。\n",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.4 26 b)": {
        "question": "班上的每个人都学过微积分和 C++。",
        "answer": "如果我们让 C(x) 和 P(x) 分别表示命题函数 x 学过微积分和 C++，那么我们有 ∀x(C(x) ∧ P(x)) 如果域只是你的同学，或 ∀x(Y(x) → (C(x) ∧ P(x))) 如果域是所有人。如果我们让 S(x, y) 表示人 x 学过科目 y，那么我们可以将最后一个重写为 ∀x(Y(x) → (S(x, 微积分) ∧ S(x, C++)))。\n",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.4 26 c)": {
        "question": "学校里没有人同时拥有摩托车和自行车。",
        "answer": "如果我们让 M(x) 表示“x 是一个摩托车手”，那么我们可以将“没有人同时拥有自行车和摩托车”表示为 ∀x(Y(x) → ¬(O(x, bicycle) ∧ O(x, motorcycle)))。这里 Y(x) 表示“x 是一个人”，O(x, y) 表示“人 x 拥有物品 y”。\n",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.4 26 d)": {
        "question": "学校里有某个人不快乐。",
        "answer": "如果我们让 H(x) 表示“x 是快乐的”，那么我们可以将“在你的同学中存在一个不快乐的人”表示为 ∃x ¬H(x)，或者在所有人的范围内表示为 ∃x(Y(x) ∧ ¬H(x))。如果 E(x, y) 表示“人 x 处于精神状态 y”，那么可以重写为 ∃x(Y(x) ∧ ¬E(x, happy))。\n",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.4 26 e)": {
        "question": "学校里的每个人都生于 20 世纪。",
        "answer": "如果我们让 T(x) 表示“x 出生在二十世纪”，那么我们可以将“在你的同学中每个人都是出生在二十世纪的”表示为 ∀x T(x)，或者在所有人的范围内表示为 ∀x(Y(x) → T(x))。如果 B(x, y) 表示“人 x 出生在 y 世纪”，那么可以重写为 ∀x(Y(x) → B(x, 20))。\n",
        "answer_symbols": [
            "∧",
            "¬"
        ]
    },
    "1.4 27 a)": {
        "question": "学校里的某个学生曾在越南居住过。",
        "answer": "如果我们设 V(x) 为 “x 曾经住在越南”，那么当域仅限于你的同学时，我们有 ∃x V(x)，或者当域为所有人时，我们有 ∃x(Y(x) ∧ V(x))。如果我们设 D(x, y) 表示人 x 曾经住在国家 y，那么我们可以将最后一个重写为 ∃x(Y(x) ∧ D(x, 越南))。",
        "answer_symbols": [
            "∃",
            "∧"
        ]
    },
    "1.4 27 b)": {
        "question": "学校里的有个学生不会说印地语。",
        "answer": "如果我们设 H(x) 为 “x 会说印地语”，那么当域仅限于你的同学时，我们有 ∃x ¬H(x)，或者当域为所有人时，我们有 ∃x(Y(x) ∧ ¬H(x))。如果我们设 S(x, y) 表示人 x 会说语言 y，那么我们可以将最后一个重写为 ∃x(Y(x) ∧ ¬S(x, 印地语))。",
        "answer_symbols": [
            "∃",
            "∧",
            "¬"
        ]
    },
    "1.4 27 c)": {
        "question": "学校里的某个学生会用 Java、Prolog 和 C++。",
        "answer": "如果我们设 J(x)，P(x)，和 C(x) 分别表示 x 对 Java、Prolog 和 C++ 的掌握程度，那么当域仅限于你的同学时，我们有 ∃x(J(x) ∧ P(x) ∧ C(x))，或者当域为所有人时，我们有 ∃x(Y(x) ∧ J(x) ∧ P(x) ∧ C(x))。如果我们设 K(x, y) 表示人 x 掌握编程语言 y，那么我们可以将最后一个重写为 ∃x(Y(x) ∧ K(x, Java) ∧ K(x, Prolog) ∧ K(x, C++))。",
        "answer_symbols": [
            "∃",
            "∧"
        ]
    },
    "1.4 27 d)": {
        "question": "班上的每个学生都喜欢泰国食物。",
        "answer": "如果我们设 T(x) 为 “x 喜欢泰国菜”，那么当域仅限于你的同学时，我们有 ∀x T(x)，或者当域为所有人时，我们有 ∀x(Y(x) → T(x))。如果我们设 E(x, y) 表示人 x 喜欢 y 类型的食物，那么我们可以将最后一个重写为 ∀x(Y(x) → E(x, 泰国))。",
        "answer_symbols": [
            "∀",
            "→"
        ]
    },
    "1.4 27 e)": {
        "question": "班上的某个学生不玩曲棍球。",
        "answer": "如果我们设 H(x) 为 “x 打冰球”，那么当域仅限于你的同学时，我们有 ∃x ¬H(x)，或者当域为所有人时，我们有 ∃x(Y(x) ∧ ¬H(x))。如果我们设 P(x, y) 表示人 x 打游戏 y，那么我们可以将最后一个重写为 ∃x(Y(x) ∧ ¬P(x, 冰球))。",
        "answer_symbols": [
            "∃",
            "∧",
            "¬"
        ]
    },
    "1.4 28 a)": {
        "question": "某些东西不在正确的位置上。",
        "answer": "存在一个不在正确位置上的东西：∃x ¬R(x)。",
        "answer_symbols": [
            "∃",
            "¬"
        ]
    },
    "1.4 28 b)": {
        "question": "所有的工具都在正确的位置上并且状况良好。",
        "answer": "如果某物是工具，那么它在正确的位置上并且处于良好状态：∀x(T(x) → (R(x) ∧ E(x)))",
        "answer_symbols": [
            "∀",
            "→",
            "∧"
        ]
    },
    "1.4 28 c)": {
        "question": "每样东西都在正确的位置上并且状况良好。",
        "answer": "∀x(R(x) ∧ E(x))",
        "answer_symbols": [
            "∀",
            "∧"
        ]
    },
    "1.4 28 d)": {
        "question": "没有东西在正确的位置上并且状况良好。",
        "answer": "这是在说每样东西都不满足这个条件：∀x ¬(R(x) ∧ E(x))",
        "answer_symbols": [
            "∀",
            "¬",
            "∧"
        ]
    },
    "1.4 28 e)": {
        "question": "你的一个工具不在正确的位置上，但它状况良好。",
        "answer": "存在一个具有这种性质的工具：∃x(T(x) ∧ ¬R(x) ∧ E(x))",
        "answer_symbols": [
            "∃",
            "∧",
            "¬"
        ]
    },
    "1.4 29 a)": {
        "question": "某些命题是永真式。",
        "answer": "∃x T(x)",
        "answer_symbols": [
            "∃"
        ]
    },
    "1.4 29 b)": {
        "question": "矛盾式的否定是永真式。",
        "answer": "∀x(C(x) → T(¬x))",
        "answer_symbols": [
            "∀",
            "→",
            "¬"
        ]
    },
    "1.4 29 c)": {
        "question": "两个可能式的析取可以是一个永真式。",
        "answer": "∃x ∃y(¬T(x) ∧ ¬C(x) ∧ ¬T(y) ∧ ¬C(y) ∧ T(x ∨ y))",
        "answer_symbols": [
            "∃",
            "∧",
            "∨",
            "¬"
        ]
    },
    "1.4 29 d)": {
        "question": "两个永真式的合取是一个永真式。",
        "answer": "∀x ∀y((T(x) ∧ T(y)) → T(x ∧ y))",
        "answer_symbols": [
            "∀",
            "∧",
            "→"
        ]
    },
    "1.4 30 a)": {
        "question": "∃xP(x, 3)",
        "answer": "P(1, 3) ∨ P(2, 3) ∨ P(3, 3)",
        "answer_symbols": [
            "∨"
        ]
    },
    "1.4 30 b)": {
        "question": "∀yP(1, y)",
        "answer": "P(1, 1) ∧ P(1, 2) ∧ P(1, 3)",
        "answer_symbols": [
            "∧"
        ]
    },
    "1.4 30 c)": {
        "question": "∃y¬P(2, y)",
        "answer": "¬P(2, 1) ∨ ¬P(2, 2) ∨ ¬P(2, 3)",
        "answer_symbols": [
            "¬",
            "∨"
        ]
    },
    "1.4 30 d)": {
        "question": "∀x¬P(x, 2)",
        "answer": "¬P(1, 2) ∧ ¬P(2, 2) ∧ ¬P(3, 2)",
        "answer_symbols": [
            "¬",
            "∧"
        ]
    },
    "1.4 32 a)": {
        "question": "所有的狗都长跳蚤。",
        "answer": "让 F(x) 表示“x 有跳蚤”，论域为狗。原命题是 ∀x F(x)。其否定是 ∃x ¬F(x)，用英语表达为“有一只狗没有跳蚤”",
        "answer_symbols": [
            "∀"
        ]
    },
    "1.4 32 b)": {
        "question": "有一匹马会做加法。",
        "answer": "让 H(x) 表示“x 会加法”，论域为马。原命题是 ∃x H(x)。其否定是 ∀x ¬H(x)，用英语表达为“没有马会加法”。",
        "answer_symbols": [
            "∃",
            "¬"
        ]
    },
    "1.4 32 c)": {
        "question": "每只考拉都会爬树。",
        "answer": "让 C(x) 表示“x 会爬树”，论域为考拉。原命题是 ∀x C(x)。其否定是 ∃x ¬C(x)，用英语表达为“有一只考拉不会爬树”。",
        "answer_symbols": [
            "∃"
        ]
    },
    "1.4 32 d)": {
        "question": "没有猴子会说法语。",
        "answer": "让 F(x) 表示“x 会说法语”，论域为猴子。原命题是 ¬∃x F(x) 或 ∀x ¬F(x)。其否定是 ∃x F(x)，用英语表达为“有一只猴子会说法语”。",
        "answer_symbols": [
            "∀",
            "¬"
        ]
    },
    "1.4 32 e)": {
        "question": "有一只猪会游泳和捕鱼。",
        "answer": "让 S(x) 表示“x 会游泳”，C(x) 表示“x 会抓鱼”，论域为猪。原命题是 ∃x(S(x) ∧ C(x))。其否定是 ∀x ¬(S(x) ∧ C(x))，也可以写成 ∀x(¬S(x) ∨ ¬C(x))（德摩根定律）。用英语表达为“没有猪既会游泳又会抓鱼”，或“每只猪要么不会游泳，要么不会抓鱼”。\n",
        "answer_symbols": [
            "∀"
        ]
    },
    "1.4 34 a)": {
        "question": "用量词表达下列命题的否定，再用语句表达这些否定。（a）一些司机不遵守驾驶速度限制。",
        "answer": "让 S(x) 表示“x 遵守限速”，论域为司机。原命题是 ∃x ¬S(x)，其否定是 ∀x S(x)，即“所有司机都遵守限速”。",
        "answer_symbols": [
            "∃",
            "¬"
        ]
    },
    "1.4 34 b)": {
        "question": "用量词表达下列命题的否定，再用语句表达这些否定。（b）所有的瑞典电影都很严肃。",
        "answer": "让 S(x) 表示“x 是严肃的”，论域为瑞典电影。原命题是 ∀x S(x)，其否定是 ∃x ¬S(x)，即“有些瑞典电影不是严肃的”。",
        "answer_symbols": [
            "∀"
        ]
    },
    "1.4 34 c)": {
        "question": "用量词表达下列命题的否定，再用语句表达这些否定。（c）没人能保守秘密。",
        "answer": "让 S(x) 表示“x 能保守秘密”，论域为人。原命题是 ¬∃x S(x)，其否定是 ∃x S(x)，即“有些人能保守秘密”。",
        "answer_symbols": [
            "∀"
        ]
    },
    "1.4 34 d)": {
        "question": "用量词表达下列命题的否定，再用语句表达这些否定。（d）班上有人没有良好的心态。",
        "answer": "让 A(x) 表示“x 有好的态度”，论域为班上的学生。原命题是 ∃x ¬A(x)，其否定是 ∀x A(x)，即“班上的每个人都态度良好”。",
        "answer_symbols": [
            "∃",
            "¬"
        ]
    },
    "1.4 36 a)": {
        "question": "找出下列全称量化命题的反例（如果可能的话），其中所有变量的论域是实数集合。（a）∀x(x^²≠x)",
        "answer": "因为 1^2 = 1，所以这个命题是假的；x = 1 是一个反例。x = 0 也是反例（这两个是唯一的反例）。",
        "answer_symbols": [
            "^"
        ]
    },
    "1.4 36 b)": {
        "question": "找出下列全称量化命题的反例（如果可能的话），其中所有变量的论域是实数集合。（b）∀x(x^²≠2)",
        "answer": "有两个反例：x = √2 和 x = -√2。",
        "answer_symbols": [
            "√",
            "="
        ]
    },
    "1.4 36 c)": {
        "question": "找出下列全称量化命题的反例（如果可能的话），其中所有变量的论域是实数集合。（c）∀x(|x|≥0)",
        "answer": "有一个反例：x = 0。",
        "answer_symbols": [
            "="
        ]
    },
    "1.4 38 a)": {
        "question": "将下列系统规范说明翻译成语句，其中谓词S(x, y)是“x在状态y”，x和y的论域分别是所有系统和所有可能的状态。（a）∃xS(x, 开放)",
        "answer": "有些系统是开放的。",
        "answer_symbols": []
    },
    "1.4 38 b)": {
        "question": "将下列系统规范说明翻译成语句，其中谓词S(x, y)是“x在状态y”，x和y的论域分别是所有系统和所有可能的状态。（b）∀x(S(x, 故障) ∨ S(x, 诊断))",
        "answer": "每个系统要么发生故障，要么处于诊断状态。",
        "answer_symbols": []
    },
    "1.4 38 c)": {
        "question": "将下列系统规范说明翻译成语句，其中谓词S(x, y)是“x在状态y”，x和y的论域分别是所有系统和所有可能的状态。（c）∃xS(x, 开放) ∨ ∃xS(x, 诊断)",
        "answer": "有些系统是开放的，或者有些系统处于诊断状态。",
        "answer_symbols": []
    },
    "1.4 38 d)": {
        "question": "将下列系统规范说明翻译成语句，其中谓词S(x, y)是“x在状态y”，x和y的论域分别是所有系统和所有可能的状态。（d）∃x∀yS(x, 可用)",
        "answer": "有些系统不可用。",
        "answer_symbols": []
    },
    "1.4 38 e)": {
        "question": "将下列系统规范说明翻译成语句，其中谓词S(x, y)是“x在状态y”，x和y的论域分别是所有系统和所有可能的状态。（e）∀x∀yS(x, 工作)",
        "answer": "没有系统在工作。（我们也可以这么说：“每个系统都不在工作”，只要我们理解这与“不是每个系统都在工作”不同。）",
        "answer_symbols": []
    },
    "1.4 40 a)": {
        "question": "使用谓词、量词和逻辑联结词表达下列系统规范说明。（a）当硬盘中的空闲空间少于30MB时，就会向所有用户发送警告消息。",
        "answer": "设 F(x) 表示“硬盘上剩余空间少于 x 兆字节”，其中论域为正数，W(x) 表示“向用户 x 发送警告消息”。那么我们有 F(30) → 对所有 x，W(x)。",
        "answer_symbols": [
            "→",
            "(",
            ")",
            "F",
            "W",
            "x"
        ]
    },
    "1.4 40 b)": {
        "question": "使用谓词、量词和逻辑联结词表达下列系统规范说明。（b）当检测到系统错误时，文件系统中的目录均不能打开且文件不能关闭。",
        "answer": "设 O(x) 表示“目录 x 可以打开”，C(x) 表示“文件 x 可以关闭”，E 是命题“检测到系统错误”。那么我们有 E →（对所有 x，非 O(x)）且（对所有 x，非 C(x)）。",
        "answer_symbols": [
            "→",
            "(",
            ")",
            "E",
            "O",
            "C",
            "x",
            "非",
            "且"
        ]
    },
    "1.4 40 c)": {
        "question": "使用谓词、量词和逻辑联结词表达下列系统规范说明。（c）如果当前有登录用户，就不能备份文件系统。",
        "answer": "设 B 是命题“文件系统可以备份”，L(x) 表示“用户 x 当前已登录”。那么我们有（存在 x，L(x)）→ 非 B。",
        "answer_symbols": [
            "→",
            "(",
            ")",
            "B",
            "L",
            "x",
            "非",
            "存在"
        ]
    },
    "1.4 40 d)": {
        "question": "使用谓词、量词和逻辑联结词表达下列系统规范说明。（d）当有至少8MB内存可用且连接速度至少为56kbps时，就可以进行视频点播。",
        "answer": "设 D(x) 表示“产品 x 可以交付”，M(x) 表示“至少有 x 兆字节的内存可用”，S(x) 表示“连接速度至少为 x 千比特每秒”，其中最后两个命题函数的论域为正数。那么我们有（M(8) 且 S(56)）→ D(视频点播)。",
        "answer_symbols": [
            "→",
            "(",
            ")",
            "D",
            "M",
            "S",
            "x",
            "且"
        ]
    },
    "1.4 42 a)": {
        "question": "使用谓词、量词和逻辑联结词表达下列系统规范说明。（a）每个用户都可以访问电子邮件。",
        "answer": "设 A(x) 表示“用户 x 可以访问电子邮箱”。那么我们有 对所有 x，A(x)。",
        "answer_symbols": [
            "A",
            "x"
        ]
    },
    "1.4 42 b)": {
        "question": "使用谓词、量词和逻辑联结词表达下列系统规范说明。（b）如果文件系统被锁定，该组中的每个人都能访问系统邮箱。",
        "answer": "设 A(x, y) 表示“组成员 x 可以访问资源 y”，S(x, y) 表示“系统 x 处于状态 y”。那么我们有 S(文件系统, 锁定) → 对所有 x，A(x, 系统邮箱)。",
        "answer_symbols": [
            "→",
            "(",
            ")",
            "A",
            "S",
            "x",
            "y"
        ]
    },
    "1.4 42 c)": {
        "question": "使用谓词、量词和逻辑联结词表达下列系统规范说明。（c）防火墙处于诊断状态仅当代理服务器处于诊断状态。",
        "answer": "设 S(x, y) 表示“系统 x 处于状态 y”。回想一下，“只有当”表示必要条件，我们有 S(防火墙, 诊断) → S(代理服务器, 诊断)。",
        "answer_symbols": [
            "→",
            "(",
            ")",
            "S",
            "x",
            "y"
        ]
    },
    "1.4 42 d)": {
        "question": "使用谓词、量词和逻辑联结词表达下列系统规范说明。（d）如果吞吐量在100～500kbps且代理服务器不处于诊断模式，则至少有一个路由器工作正常。",
        "answer": "设 T(x) 表示“吞吐量至少为 x 千比特每秒”，其中论域为正数，M(x, y) 表示“资源 x 处于模式 y”，S(x, y) 表示“路由器 x 处于状态 y”。那么我们有 (T(100) 且 非 T(500) 且 非 M(代理服务器, 诊断)) → 存在 x，S(x, 正常)。",
        "answer_symbols": [
            "→",
            "(",
            ")",
            "T",
            "M",
            "S",
            "x",
            "y",
            "且",
            "非",
            "存在"
        ]
    },
    "1.4 44": {
        "question": "判断∀x(P(x)↔Q(x))和∀xP(x)↔∀xQ(x)是否是逻辑等价的，并证明。",
        "answer": "我们希望找到命题函数 P 和 Q，它们有时但并非总是为真（这样第二个双条件式为 F ↔ F，因此为真），但存在一个 x 使得其中一个为真而另一个为假。例如，我们可以取 P(x) 表示 x 是偶数（2 的倍数），Q(x) 表示 x 是 3 的倍数。那么像 x = 4 或 x = 9 这样的例子就表明 对所有 x (P(x) ↔ Q(x)) 为假。",
        "answer_symbols": [
            "→",
            "(",
            ")",
            "P",
            "Q",
            "x",
            "↔",
            "非"
        ]
    },
    "1.4 46 a)": {
        "question": "Prove the following logical equivalence, where x does not occur free in A. Assume the domain is non-empty. (∀x P(x)) ∨ A ≡ ∀x (P(x) ∨ A)",
        "answer": "有两种情况。如果 A 为真，那么 (∀x P(x)) ∨ A 为真，并且由于 P(x) ∨ A 对所有 x 为真，∀x (P(x) ∨ A) 也为真。因此逻辑等价式的两边都为真（因此等价）。现在假设 A 为假。如果 P(x) 对所有 x 为真，那么左边为真。此外，右边也为真（因为 P(x) ∨ A 对所有 x 为真）。另一方面，如果 P(x) 对某些 x 为假，那么两边都为假。因此再次，两边在逻辑上是等价的。",
        "answer_symbols": [
            "∨",
            "∧",
            "→",
            "(",
            ")",
            "∀",
            "P",
            "A",
            "x",
            "非"
        ]
    },
    "1.4 46 b)": {
        "question": "Prove the following logical equivalence, where x does not occur free in A. Assume the domain is non-empty. (∃x P(x)) ∨ A ≡ ∃x (P(x) ∨ A)",
        "answer": "有两种情况。如果 A 为真，那么 (∃x P(x)) ∨ A 为真，并且由于 P(x) ∨ A 对某些（实际上是所有）x 为真，∃x (P(x) ∨ A) 也为真。因此逻辑等价式的两边都为真（因此等价）。现在假设 A 为假。如果 P(x) 至少对一个 x 为真，那么左边为真。此外，右边也为真（因为 P(x) ∨ A 对那个 x 为真）。另一方面，如果 P(x) 对所有 x 为假，那么两边都为假。因此再次，两边在逻辑上是等价的。",
        "answer_symbols": [
            "∨",
            "∧",
            "→",
            "(",
            ")",
            "∃",
            "P",
            "A",
            "x",
            "非"
        ]
    },
    "1.4 48 a)": {
        "question": "Prove the following logical equivalence, where x does not occur free in A. Assume the domain is non-empty. ∀x (A → P(x)) ≡ A → ∀x P(x)",
        "answer": "有两种情况。如果 A 为假，那么等价式的两边都为真，因为具有假前提的条件语句为真。如果 A 为真，那么 A → P(x) 对每个 x 相当于 P(x)，所以左边相当于 ∀x P(x)，这相当于右边。",
        "answer_symbols": [
            "→",
            "∀"
        ]
    },
    "1.4 48 b)": {
        "question": "Prove the following logical equivalence, where x does not occur free in A. Assume the domain is non-empty. ∃x (A → P(x)) ≡ A → ∃x P(x)",
        "answer": "There are two cases. If A is false, then both sides of the equivalence are true, because a conditional statement with a false hypothesis is true (and we are assuming that the domain is nonempty). If A is true, then A → P(x) is equivalent to P(x) for each x, so the left-hand side is equivalent to ∃x P(x), which is equivalent to the right-hand side.",
        "answer_symbols": [
            "→",
            "∃"
        ]
    },
    "1.4 49 a)": {
        "question": "Prove the following logical equivalence, where x does not occur free in A. Assume the domain is non-empty. ∀x (P(x) → A) ≡ ∃x P(x) → A",
        "answer": "Suppose that A is true. Then for each x, P(x) → A is true; therefore the left-hand side is always true in this case. By similar reasoning the right-hand side is always true in this case. Therefore, the two propositions are logically equivalent when A is true. On the other hand, suppose that A is false. There are two subcases. If P(x) is false for every x, then P(x) → A is vacuously true, so the left-hand side is vacuously true. The same reasoning shows that the right-hand side is also true, because in this subcase ∃x P(x) is false. For the second subcase, suppose that P(x) is true for some x. Then for that x, P(x) → A is false, so the left-hand side is false. The right-hand side is also false, because in this subcase ∃x P(x) is true but A is false. Thus in all cases, the two propositions have the same truth value.",
        "answer_symbols": [
            "→",
            "∀",
            "∃",
            "¬"
        ]
    },
    "1.4 49 b)": {
        "question": "Prove the following logical equivalence, where x does not occur free in A. Assume the domain is non-empty. ∃x (P(x) → A) ≡ ∀x P(x) → A",
        "answer": "If A is true, then both sides are trivially true, because the conditional statements have true conclusions. If A is false, then there are two subcases. If P(x) is false for some x, then P(x) → A is vacuously true for that x, so the left-hand side is true. The same reasoning shows that the right-hand side is true, because in this subcase ∀x P(x) is false. For the second subcase, suppose that P(x) is true for every x. Then for every x, P(x) → A is false, so the left-hand side is false (there is no x making the conditional statement true). The right-hand side is also false, because it is a conditional statement with a true hypothesis and a false conclusion. Thus in all cases, the two propositions have the same truth value.",
        "answer_symbols": [
            "→",
            "∀",
            "∃",
            "¬"
        ]
    },
    "1.4 50": {
        "question": "Prove that ∀x P(x) ∨ ∀x Q(x) and ∀x (P(x) ∨ Q(x)) are not logically equivalent.",
        "answer": "It is enough to find a counterexample. It is intuitively clear that the first proposition is asserting much more than the second. It is saying that one of the two predicates, P or Q, is universally true; whereas the second proposition is simply saying that for every x either P(x) or Q(x) holds, but which it is may well depend on x. As a simple counterexample, let P(x) be the statement that x is odd, and let Q(x) be the statement that x is even. Let the domain of discourse be the positive integers. The second proposition is true, since every positive integer is either odd or even. But the first proposition is false, since it is neither the case that all positive integers are odd nor the case that all of them are even.",
        "answer_symbols": [
            "∀",
            "∃",
            "∨",
            "∧",
            "¬"
        ]
    },
    "1.4 52 a)": {
        "question": "As mentioned in the text, the symbol ∃! means 'there exists a unique x such that P(x) is true.' If the domain is the set of integers, what are the truth values of the following sentences? ∃! x (x > 1)",
        "answer": "This is false, since there are many values of x that make x > 1 true.",
        "answer_symbols": [
            ">"
        ]
    },
    "1.4 52 b)": {
        "question": "As mentioned in the text, the symbol ∃! means 'there exists a unique x such that P(x) is true.' If the domain is the set of integers, what are the truth values of the following sentences? ∃! x (x^² = 1)",
        "answer": "This is false, since there are two values of x that make x^² = 1 true.",
        "answer_symbols": [
            "=",
            "²"
        ]
    },
    "1.4 52 c)": {
        "question": "As mentioned in the text, the symbol ∃! means 'there exists a unique x such that P(x) is true.' If the domain is the set of integers, what are the truth values of the following sentences? ∃! x (x + 3 = 2x)",
        "answer": "This is true, since by algebra we see that the unique solution to the equation is x = 3.",
        "answer_symbols": [
            "="
        ]
    },
    "1.4 52 d)": {
        "question": "As mentioned in the text, the symbol ∃! means 'there exists a unique x such that P(x) is true.' If the domain is the set of integers, what are the truth values of the following sentences? ∃! x (x = x + 1)",
        "answer": "This is false, since there are no values of x that make x = x + 1 true.",
        "answer_symbols": [
            "="
        ]
    },
    "1.4 54": {
        "question": "Assume the domain consists of the integers 1, 2, and 3. Write the quantified statement ∃! x P(x) using negation, conjunction, and disjunction.",
        "answer": "There are only three cases in which ∃!x P(x) is true, so we form the disjunction of these three cases. The answer is thus (P(1) ∧ ¬P(2) ∧ ¬P(3)) ∨ (¬P(1) ∧ P(2) ∧ ¬P(3)) ∨ (¬P(1) ∧ ¬P(2) ∧ P(3)).",
        "answer_symbols": [
            "∃!",
            "∨",
            "∧",
            "¬"
        ]
    },
    "1.4 56 a)": {
        "question": "Given the Prolog facts, what does the following query return? enrolled(kevin, ee222)",
        "answer": "None of the facts was that Kevin was enrolled in EE 222. So the response is no.",
        "answer_symbols": []
    },
    "1.4 56 b)": {
        "question": "Given the Prolog facts, what does the following query return? enrolled(kiko, math273)",
        "answer": "One of the facts was that Kiko was enrolled in Math 273. So the response is yes.",
        "answer_symbols": []
    },
    "1.4 56 c)": {
        "question": "Given the Prolog facts, what does the following query return? instructor(grossman, X)",
        "answer": "Prolog returns the names of the courses for which Grossman is the instructor, namely just cs301.",
        "answer_symbols": []
    },
    "1.4 56 d)": {
        "question": "Given the Prolog facts, what does the following query return? instructor(X, cs301)",
        "answer": "Prolog returns the names of the instructor for CS 301, namely grossman.",
        "answer_symbols": []
    },
    "1.4 56 e)": {
        "question": "Given the Prolog facts, what does the following query return? teaches(X, kevin)",
        "answer": "Prolog returns the names of the instructors teaching any course that Kevin is enrolled in, namely chan, since Chan is the instructor in Math 273, the only course Kevin is enrolled in.",
        "answer_symbols": []
    },
    "1.4 58": {
        "question": "Assume the Prolog facts: the predicate mother(M, Y) and father(F, X), respectively, represent that M is Y's mother and F is X's father. Write a Prolog rule to define the predicate grandfather(X, Y), which represents that X is Y's grandfather. (Hint: You can write a disjunction in Prolog, using a semicolon to separate disjuncts or placing disjuncts on separate lines.)",
        "answer": "Following the idea and syntax of Example 28, we have the following rule: grandfather(X, Y) :- father(X, Z), father(Z, Y); father(X, Z), mother(Z, Y). Note that we used the comma to mean “and” and the semicolon to mean “or.” For X to be the grandfather of Y, X must be either Y’s father’s father or Y’s mother’s father.",
        "answer_symbols": [
            ":-",
            ",",
            ";"
        ]
    },
    "1.4 60 a)": {
        "question": "Let P(x), Q(x), and R(x) respectively represent the sentences 'x is a clear explanation,' 'x is satisfactory,' and 'x is an excuse.' Assume the domain is the set of all Chinese articles. Use quantifiers, logical connectives, and P(x), Q(x), R(x) to express the following sentences. All clear explanations are satisfactory.",
        "answer": "∀x (P(x) → Q(x))",
        "answer_symbols": [
            "∀",
            "→"
        ]
    },
    "1.4 60 b)": {
        "question": "Let P(x), Q(x), and R(x) respectively represent the sentences 'x is a clear explanation,' 'x is satisfactory,' and 'x is an excuse.' Assume the domain is the set of all Chinese articles. Use quantifiers, logical connectives, and P(x), Q(x), R(x) to express the following sentences. Some excuses are not satisfactory.",
        "answer": "∃x (R(x) ∧ ¬Q(x))",
        "answer_symbols": [
            "∃",
            "∧",
            "¬"
        ]
    },
    "1.4 60 c)": {
        "question": "Let P(x), Q(x), and R(x) respectively represent the sentences 'x is a clear explanation,' 'x is satisfactory,' and 'x is an excuse.' Assume the domain is the set of all Chinese articles. Use quantifiers, logical connectives, and P(x), Q(x), R(x) to express the following sentences. Some excuses are not clear explanations.",
        "answer": "∃x (R(x) ∧ ¬P(x))",
        "answer_symbols": [
            "∃",
            "∧",
            "¬"
        ]
    },
    "1.4 60 d)": {
        "question": "Let P(x), Q(x), and R(x) respectively represent the sentences 'x is a clear explanation,' 'x is satisfactory,' and 'x is an excuse.' Assume the domain is the set of all Chinese articles. Use quantifiers, logical connectives, and P(x), Q(x), R(x) to express the following sentences. Can you deduce c) from a) and b)?",
        "answer": "Yes. The unsatisfactory excuse guaranteed by part (b) cannot be a clear explanation by part (a).",
        "answer_symbols": []
    },
    "1.4 62 a)": {
        "question": "令 P(x)、Q(x)、R(x) 和 S(x) 分别为语句“x 是只鸭子”、“x 是我的一只家禽”、“x 是一名官员”和“x 愿意跳华尔兹”。用量词；逻辑联结词；P(x)、Q(x)、R(x) 和 S(x) 表达下列语句。没有鸭子愿意跳华尔兹。",
        "answer": "∀x (P(x) → ¬S(x))",
        "answer_symbols": [
            "∀",
            "→",
            "¬"
        ]
    },
    "1.4 62 b)": {
        "question": "令 P(x)、Q(x)、R(x) 和 S(x) 分别为语句“x 是只鸭子”、“x 是我的一只家禽”、“x 是一名官员”和“x 愿意跳华尔兹”。用量词；逻辑联结词；P(x)、Q(x)、R(x) 和 S(x) 表达下列语句。没有官员会拒绝跳华尔兹。",
        "answer": "∀x (R(x) → S(x))",
        "answer_symbols": [
            "∀",
            "→"
        ]
    },
    "1.4 62 c)": {
        "question": "令 P(x)、Q(x)、R(x) 和 S(x) 分别为语句“x 是只鸭子”、“x 是我的一只家禽”、“x 是一名官员”和“x 愿意跳华尔兹”。用量词；逻辑联结词；P(x)、Q(x)、R(x) 和 S(x) 表达下列语句。所有我的家禽都是鸭子。",
        "answer": "∀x (Q(x) → P(x))",
        "answer_symbols": [
            "∀",
            "→"
        ]
    },
    "1.4 62 d)": {
        "question": "令 P(x)、Q(x)、R(x) 和 S(x) 分别为语句“x 是只鸭子”、“x 是我的一只家禽”、“x 是一名官员”和“x 愿意跳华尔兹”。用量词；逻辑联结词；P(x)、Q(x)、R(x) 和 S(x) 表达下列语句。我的家禽都不是官员。",
        "answer": "∀x (Q(x) → ¬R(x))",
        "answer_symbols": [
            "∀",
            "→",
            "¬"
        ]
    },
    "1.4 62 e)": {
        "question": "令 P(x)、Q(x)、R(x) 和 S(x) 分别为语句“x 是只鸭子”、“x 是我的一只家禽”、“x 是一名官员”和“x 愿意跳华尔兹”。用量词；逻辑联结词；P(x)、Q(x)、R(x) 和 S(x) 表达下列语句。能从 a)、b) 和 c) 推出 d) 吗？如果不能，有没有一个正确的结论？",
        "answer": "Yes. If x is one of my poultry, then he is a duck (by part (c)), hence not willing to waltz (part (a)). Since officers are always willing to waltz (part (b)), x is not an officer.",
        "answer_symbols": []
    },
    "1.5 1 a)": {
        "question": "将下列语句翻译成汉语句子，其中每个变量的论域是全体实数。 (a) ∀ x ∃ y (x < y)",
        "answer": "For every real number x there exists a real number y such that x is less than y.",
        "answer_symbols": [
            "∀",
            "∃",
            "<"
        ]
    },
    "1.5 1 b)": {
        "question": "将下列语句翻译成汉语句子，其中每个变量的论域是全体实数。 (b) ∀ x ∀ y ((x ≥ 0) ∧ (y ≥ 0) → (xy ≥ 0))",
        "answer": "For every real number x and real number y, if x and y are both nonnegative, then their product is nonnegative.",
        "answer_symbols": [
            "∀",
            "∧",
            "→"
        ]
    },
    "1.5 1 c)": {
        "question": "将下列语句翻译成汉语句子，其中每个变量的论域是全体实数。 (c) ∀ x ∀ y ∃ z (x = y)",
        "answer": "For every real number x and real number y, there exists a real number z such that xy = z.",
        "answer_symbols": [
            "∀",
            "∧",
            "→"
        ]
    },
    "1.5 14 a)": {
        "question": "班上有个学生会说印地语。",
        "answer": "Let S(x, y) mean that person x can speak language y. Then our statement is ∃x S(x, Hindi).",
        "answer_symbols": [
            "∃",
            "S"
        ]
    },
    "1.5 14 b)": {
        "question": "班上每个学生都会玩一些运动项目。",
        "answer": "Let P(x, y) mean that person x plays sport y. Then our statement is ∀x∃y P(x, y).",
        "answer_symbols": [
            "∀",
            "∃",
            "P"
        ]
    },
    "1.5 14 c)": {
        "question": "班上某个学生去过阿拉斯加，但没去过夏威夷。",
        "answer": "Let V(x, y) mean that person x has visited state y. Then our statement is ∃x(V(x, Alaska) ∧ ¬V(x, Hawaii)).",
        "answer_symbols": [
            "∃",
            "V",
            "∧",
            "¬"
        ]
    },
    "1.5 14 d)": {
        "question": "班上所有学生都至少学过一种程序设计语言。",
        "answer": "Let L(x, y) mean that person x has learned programming language y. Then our statement is ∀x∃y L(x, y).",
        "answer_symbols": [
            "∀",
            "∃",
            "L"
        ]
    },
    "1.5 14 e)": {
        "question": "班上有一个学生已选修了这个学校的某个系开设的所有课程。",
        "answer": "Let T(x, y) mean that person x has taken course y, and let O(y, z) mean that course y is offered by department z. Then our statement is ∃x∃z∀y(O(y, z) → T(x, y)).",
        "answer_symbols": [
            "∃",
            "∀",
            "O",
            "T",
            "→"
        ]
    },
    "1.5 14 f)": {
        "question": "班上某个学生恰好与同班另一个学生在同一座城市长大。",
        "answer": "Let G(x, y) mean that persons x and y grew up in the same town. Then our statement is ∃x∃y(x ≠ y ∧ G(x, y) ∧ ∀z(G(x, z) → (x = y ∨ x = z))).",
        "answer_symbols": [
            "∃",
            "∀",
            "G",
            "≠",
            "∧",
            "∨",
            "→"
        ]
    },
    "1.5 14 g)": {
        "question": "班上每个学生都至少与另一位学生在至少一个聊天组里交谈过。",
        "answer": "Let C(x, y, z) mean that persons x and y have chatted with each other in chat group z. Then our statement is ∀x∃y∃z(x ≠ y ∧ C(x, y, z)).",
        "answer_symbols": [
            "∀",
            "∃",
            "C",
            "≠",
            "∧"
        ]
    },
    "1.5 16 a)": {
        "question": "班上有一个三年级学生。",
        "answer": "The proposition is ∃s∃mP(s, junior, m). It is true from the given information.",
        "answer_symbols": [
            "∃",
            "P"
        ]
    },
    "1.5 16 b)": {
        "question": "班上每个学生都是计算机科学专业的。",
        "answer": "The proposition is ∀s∃cP(s, c, computer science). This is false, since there are some mathematics majors.",
        "answer_symbols": [
            "∀",
            "∃",
            "P"
        ]
    },
    "1.5 16 c)": {
        "question": "班上有个学生既不是数学专业的，也不是三年级学生。",
        "answer": "The proposition is ∃s∃c∃m(P(s, c, m) ∧ (c ≠ junior) ∧ (m ≠ mathematics)). This is true, since there is a sophomore majoring in computer science.",
        "answer_symbols": [
            "∃",
            "P",
            "∧",
            "≠"
        ]
    },
    "1.5 16 d)": {
        "question": "班上每个学生要么是二年级学生，要么是计算机科学专业的。",
        "answer": "The proposition is ∀s(∃cP(s, c, computer science) ∨ ∃mP(s, sophomore, m)). This is false, since there is a freshman mathematics major.",
        "answer_symbols": [
            "∀",
            "∃",
            "P",
            "∨"
        ]
    },
    "1.5 16 e)": {
        "question": "存在这样一个专业使得该班级有这个专业每一个年级的学生。",
        "answer": "The proposition is ∃m∀c∃sP(s, c, m). This is false. It cannot be that m is mathematics, since there is no senior mathematics major, and it cannot be that m is computer science, since there is no freshman computer science major. Nor, of course, can m be any other major.",
        "answer_symbols": [
            "∃",
            "∀",
            "P"
        ]
    },
    "1.5 18 a)": {
        "question": "在各种故障情形下至少要有一个控制台必须可以访问。",
        "answer": "∀f(H(f) → ∃c A(c)), where A(x) means that console x is accessible, and H(x) means that fault condition x is happening.",
        "answer_symbols": [
            "∀",
            "∃",
            "H",
            "A",
            "→"
        ]
    },
    "1.5 18 b)": {
        "question": "只要档案文件包含该系统的每个用户发送的至少一条消息，那么每个用户的 E-mail 地址就可以被检索到。",
        "answer": "(∀u∃m(A(m) ∧ S(u, m))) → ∀u R(u), where A(x) means that the archive contains message x, S(x, y) means that user x sent message y, and R(x) means that the e-mail address of user x can be retrieved.",
        "answer_symbols": [
            "∀",
            "∃",
            "A",
            "S",
            "R",
            "∧",
            "→"
        ]
    },
    "1.5 18 c)": {
        "question": "对每个安全漏洞，至少有一个机制可以检测到这个漏洞当且仅当有一个进程还未被损害。",
        "answer": "(∀b∃m D(m, b)) ↔ ∃p ¬C(p), where D(x, y) means that mechanism x can detect breach y, and C(x) means that process x has been compromised.",
        "answer_symbols": [
            "∀",
            "∃",
            "D",
            "C",
            "↔",
            "¬"
        ]
    },
    "1.5 18 d)": {
        "question": "至少有两条路径可以连接网络上任意两个不同的端点。",
        "answer": "∀x∀y(x ≠ y → ∃p∃q(p ≠ q ∧ C(p, x, y) ∧ C(q, x, y))), where C(p, x, y) means that path p connects endpoint x to endpoint y.",
        "answer_symbols": [
            "∀",
            "∃",
            "C",
            "≠",
            "→",
            "∧"
        ]
    },
    "1.5 18 e)": {
        "question": "没有人知道系统上每个用户的口令，除了系统管理员以外，他知道所有口令。",
        "answer": "∀x((∀u K(x, u)) ↔ x = SysAdm), where K(x, y) means that person x knows the password of user y.",
        "answer_symbols": [
            "∀",
            "K",
            "↔",
            "="
        ]
    },
    "1.5 20 a)": {
        "question": "两个负整数的积是正数。",
        "answer": "∀x∀y((x < 0) ∧ (y < 0) → (xy > 0))",
        "answer_symbols": [
            "∀",
            "<",
            "∧",
            "→",
            ">"
        ]
    },
    "1.5 20 b)": {
        "question": "两个正整数的平均数是正数。",
        "answer": "∀x∀y((x > 0) ∧ (y > 0) → ((x + y) / 2 > 0))",
        "answer_symbols": [
            "∀",
            ">",
            "∧",
            "→",
            "+",
            "/",
            ">"
        ]
    },
    "1.5 20 c)": {
        "question": "两个负整数的差不一定是负数。",
        "answer": "What does 'necessarily' mean in this context? The best explanation is to assert that a certain universal conditional statement is not true. So we have ¬∀x∀y((x < 0) ∧ (y < 0) → (x - y < 0)). Note that we do not want to put the negation symbol inside (it is not true that the difference of two negative integers is never negative), nor do we want to negate just the conclusion (it is not true that the sum is always nonnegative). We could rewrite our solution by passing the negation inside, obtaining ∃x∃y((x < 0) ∧ (y < 0) ∧ (x - y ≥ 0)).",
        "answer_symbols": [
            "¬",
            "∀",
            "∃",
            "<",
            "∧",
            "→",
            "-",
            "≥"
        ]
    },
    "1.5 20 d)": {
        "question": "两个整数和的绝对值不大于它们绝对值的和。",
        "answer": "∀x∀y(|x + y| ≤ |x| + |y|)",
        "answer_symbols": [
            "∀",
            "|",
            "+",
            "≤"
        ]
    },
    "1.5 22": {
        "question": "有一个正整数不是三个整数的平方和。",
        "answer": "∃x∀a∀b∀c((x > 0) ∧ x ≠ a^² + b^² + c^²), where the domain of discourse consists of all integers.",
        "answer_symbols": [
            "∃",
            "∀",
            ">",
            "∧",
            "≠",
            "+",
            "²"
        ]
    },
    "1.5 24 a)": {
        "question": "存在一个 x，对于所有的 y，x+y=y。",
        "answer": "There exists an additive identity for the real numbers—a number that when added to every number does not change its value.",
        "answer_symbols": []
    },
    "1.5 34": {
        "question": "找出变量 x、y 和 z 的一个公共论域，使语句 ∀x∀y((x ≠ y) → ∃z((z = x) ∨ (z = y))) 为真，再找出另外一个论域使其为假。",
        "answer": "The logical expression is asserting that the domain consists of at most two members. (It is saying that whenever you have two unequal objects, any object has to be one of those two. Note that this is vacuously true for domains with one element.) Therefore any domain having one or two members will make it true (such as the female members of the United States Supreme Court in 2005), and any domain with more than two members will make it false (such as all members of the United States Supreme Court in 2005).",
        "answer_symbols": [
            "≠"
        ]
    },
    "1.5 36 a)": {
        "question": "用量词表达下列语句。然后取该语句的否定并使否定词不在量词的左边。再用简单语句表达该否定（不要简单地表达为“不是……”）。没有人因玩彩票输过 1000 多美元。",
        "answer": "Let L(x, y) mean that person x has lost y dollars playing the lottery. The original statement is then ¬∃x∃y(y > 1000 ∧ L(x, y)). Its negation of course is ∃x∃y(y > 1000 ∧ L(x, y)); someone has lost more than $1000 playing the lottery.",
        "answer_symbols": [
            "∃",
            "¬",
            ">",
            "∧"
        ]
    },
    "1.5 36 b)": {
        "question": "用量词表达下列语句。然后取该语句的否定并使否定词不在量词的左边。再用简单语句表达该否定（不要简单地表达为“不是……”）。班上有一个学生恰好与另一个学生交谈过。",
        "answer": "Let C(x, y) mean that person x has chatted with person y. The given statement is ∃x∃y(y ≠ x ∧ ∀z(z ≠ x → (z = y ↔ C(x, z)))). The negation is therefore ∀x∀y(y ≠ x → ∃z(z ≠ x ∧ ¬(z = y ↔ C(x, z)))). In English, everybody in this class has either chatted with no one else or has chatted with two or more others.",
        "answer_symbols": [
            "∃",
            "∀",
            "≠",
            "→",
            "=",
            "∧",
            "¬",
            "↔"
        ]
    },
    "1.5 36 c)": {
        "question": "用量词表达下列语句。然后取该语句的否定并使否定词不在量词的左边。再用简单语句表达该否定（不要简单地表达为“不是……”）。班上没人恰好给班里另外两个学生发过电子邮件。",
        "answer": "Let E(x, y) mean that person x has sent e-mail to person y. The given statement is ¬∃x∃y∃z(y ≠ z ∧ x ≠ y ∧ x ≠ z ∧ ∀w(w ≠ x → (E(x, w) ↔ (w = y ∨ w = z)))). The negation is obviously ∃x∃y∃z(y ≠ z ∧ x ≠ y ∧ x ≠ z ∧ ∀w(w ≠ x → (E(x, w) ↔ (w = y ∨ w = z)))). In English, some student in this class has sent e-mail to exactly two other students in this class.",
        "answer_symbols": [
            "∃",
            "∀",
            "≠",
            "→",
            "=",
            "∧",
            "¬",
            "∨",
            "↔"
        ]
    },
    "1.5 36 d)": {
        "question": "用量词表达下列语句。然后取该语句的否定并使否定词不在量词的左边。再用简单语句表达该否定（不要简单地表达为“不是……”）。某个学生已求解了本书的每道练习。",
        "answer": "Let S(x, y) mean that student x has solved exercise y. The statement is ∃x∀y S(x, y). The negation is ∀x∃y ¬S(x, y). In English, for every student in this class, there is some exercise that he or she has not solved. (One could also interpret the given statement as asserting that for every exercise, there exists a student—perhaps a different one for each exercise—who has solved it. In that case the order of the quantifiers would be reversed. Word order in English sometimes makes for a little ambiguity.)",
        "answer_symbols": [
            "∃",
            "∀",
            "¬"
        ]
    },
    "1.5 36 e)": {
        "question": "用量词表达下列语句。然后取该语句的否定并使否定词不在量词的左边。再用简单语句表达该否定（不要简单地表达为“不是……”）。没有学生求解过本书每节至少一道练习。",
        "answer": "Let S(x, y) mean that student x has solved exercise y, and let B(y, z) mean that exercise y is in section z of the book. The statement is ¬∃x∀z∃y(B(y, z) ∧ S(x, y)). The negation is of course ∃x∀z∃y(B(y, z) ∧ S(x, y)). In English, some student has solved at least one exercise in every section of this book.",
        "answer_symbols": [
            "∃",
            "∀",
            "¬",
            "∧"
        ]
    },
    "1.5 37 a)": {
        "question": "用量词表达下列语句。然后取该语句的否定并使否定词不在量词的左边。再用简单语句表达该否定（不要简单地表达为“不是……”）。班上每个学生都恰好选修过本校两门数学课。",
        "answer": "∀x((F(x, 25,000) ∨ S(x, 25)) → E(x))",
        "answer_symbols": [
            "∀",
            "∨",
            "→"
        ]
    },
    "1.5 37 b)": {
        "question": "用量词表达下列语句。然后取该语句的否定并使否定词不在量词的左边。再用简单语句表达该否定（不要简单地表达为“不是……”）。有人去过世界上除了利比亚以外的每个国家。",
        "answer": "∀x(((M(x) ∧ T(x, 3)) ∨ (¬M(x) ∧ T(x, 3.5))) → Q(x))",
        "answer_symbols": [
            "∀",
            "∧",
            "∨",
            "¬",
            "→"
        ]
    },
    "1.5 37 c)": {
        "question": "用量词表达下列语句。然后取该语句的否定并使否定词不在量词的左边。再用简单语句表达该否定（不要简单地表达为“不是……”）。没有人攀登过喜马拉雅山的每座山峰。",
        "answer": "M → ((H(60) ∨ (H(45) ∧ T)) ∧ ∀y G(B, y))",
        "answer_symbols": [
            "→",
            "∨",
            "∧",
            "∀"
        ]
    },
    "1.5 37 d)": {
        "question": "用量词表达下列语句。然后取该语句的否定并使否定词不在量词的左边。再用简单语句表达该否定（不要简单地表达为“不是……”）。每位电影演员或者与 Kevin Bacon 拍过一部电影，或者与 Kevin Bacon 拍过一部电影的人拍过一部电影。",
        "answer": "∃x((T(x, 21) ∧ G(x, 4.0))",
        "answer_symbols": [
            "∃",
            "∧"
        ]
    },
    "1.5 38 a)": {
        "question": "用量词和语句表达下列命题的否定。班上每个学生都喜欢数学。",
        "answer": "In English, the negation is “Some student in this class does not like mathematics.” With the obvious propositional function, this is ∃x¬L(x).",
        "answer_symbols": [
            "∃",
            "¬"
        ]
    },
    "1.5 38 b)": {
        "question": "用量词和语句表达下列命题的否定。班上有一个学生从来没见过计算机。",
        "answer": "In English, the negation is “Every student in this class has seen a computer.” With the obvious propositional function, this is ∀xS(x).",
        "answer_symbols": [
            "∀"
        ]
    },
    "1.5 38 c)": {
        "question": "用量词和语句表达下列命题的否定。班上有一个学生选修过本校开设的每门数学课。",
        "answer": "In English, the negation is “For every student in this class, there is a mathematics course that this student has not taken.” With the obvious propositional function, this is ∀x∃c¬T(x, c).",
        "answer_symbols": [
            "∀",
            "∃",
            "¬"
        ]
    },
    "1.5 38 d)": {
        "question": "用量词和语句表达下列命题的否定。班上有一个学生去过校园内每座楼的至少一个房间。",
        "answer": "As in Exercise 15f, let P(z, y) be “Room z is in building y,” and let Q(x, z) be “Student x has been in room z.” Then the original statement is ∃x∀y∃z(P(z, y) ∧ Q(x, z)). To form the negation, we change all the quantifiers and put the negation on the inside, then apply De Morgan’s law. The negation is therefore ∀x∃y∀z(¬P(z, y) ∨ ¬Q(x, z)), which is also equivalent to ∀x∃y∀z(P(z, y) → ¬Q(x, z)). In English, this could be read, “For every student there is a building such that for every room in that building, the student has not been in that room.”",
        "answer_symbols": [
            "∃",
            "∀",
            "¬",
            "∧",
            "∨",
            "→"
        ]
    },
    "1.5 39 a)": {
        "question": "找出下列全称量化命题的反例（如果可能的话），其中所有变量的论域是全体整数。∀x∀y(x^2 = y^2 → x = y)",
        "answer": "If there is a printer that is both out of service and busy, then some job has been lost.",
        "answer_symbols": [
            "→"
        ]
    },
    "1.5 39 b)": {
        "question": "找出下列全称量化命题的反例（如果可能的话），其中所有变量的论域是全体整数。∀x∃y(y^2 = x)",
        "answer": "If every printer is busy, then there is a job in the queue.",
        "answer_symbols": [
            "→"
        ]
    },
    "1.5 39 c)": {
        "question": "找出下列全称量化命题的反例（如果可能的话），其中所有变量的论域是全体整数。∀x∀y(xy ≥ x)",
        "answer": "If there is a job that is both queued and lost, then some printer is out of service.",
        "answer_symbols": [
            "→"
        ]
    },
    "1.5 40 a)": {
        "question": "找出下列全称量化命题的反例（如果可能的话），其中所有变量的论域是全体整数。∀x∃y(x = 1/y)",
        "answer": "There are many counterexamples. If x = 2, then there is no y among the integers such that 2 = 1/y, since the only solution of this equation is y = 1/2. Even if we were working in the domain of real numbers, x = 0 would provide a counterexample, since 0 = 1/y for no real number y.",
        "answer_symbols": [
            "=",
            "/"
        ]
    },
    "1.5 40 b)": {
        "question": "找出下列全称量化命题的反例（如果可能的话），其中所有变量的论域是全体整数。∀x∃y(y^2 - x < 100)",
        "answer": "We can rewrite y^² - x < 100 as y^² < 100 + x. Since squares can never be negative, no such y exists if x is, say, -200. This x provides a counterexample.",
        "answer_symbols": [
            "<",
            "+",
            "²"
        ]
    },
    "1.5 40 c)": {
        "question": "找出下列全称量化命题的反例（如果可能的话），其中所有变量的论域是全体整数。∀x∀y(x^2 ≠ y^2)",
        "answer": "This is not true, since sixth powers are both squares and cubes. Trivial counterexamples would include x = y = 0 and x = y = 1, but we can also take something like x = 27 and y = 9, since 27^² = 3^⁶ = 9^³.",
        "answer_symbols": [
            "=",
            "²",
            "³",
            "⁶"
        ]
    },
    "1.5 43": {
        "question": "用量词和逻辑联结词表示这样的事实：每个实系数线性多项式（即1次多项式），其中x的系数为非零，有恰好一个实根。",
        "answer": "They are not equivalent. Let P(x) be any propositional function that is sometimes true and sometimes false, and let Q(x) be any propositional function that is always false. Then ∀x(P(x) → Q(x)) is false but ∀x P(x) → ∀x Q(x) is true.",
        "answer_symbols": [
            "→",
            "∀",
            "¬"
        ]
    },
    "1.5 49 a)": {
        "question": "证明∀xP(x) ∧ ∃xQ(x)和∀x∃y(P(x) ∧ Q(y))是逻辑等价的，这里所有量词都有相同的非空论域。",
        "answer": "Suppose that ∀xP (x) ∧ ∃xQ(x) is true. Then P (x) is true for all x and there is an element y for which Q(y) is true. Because P (x)∧Q(y)is true for all x and there is a y for which Q(y) is true, ∀x∃y(P (x) ∧ Q(y)) is true. Conversely, suppose that the second proposition is true. Let x be an element in the domain. There is a y such that Q(y) is true, so ∃xQ(x) is true. Because ∀xP (x) is also true, it follows that the first proposition is true.",
        "answer_symbols": [
            "∀",
            "∃",
            "∨",
            "∧"
        ]
    },
    "1.5 49 b)": {
        "question": "证明∀xP(x) ∨ ∃xQ(x)和∀x∃y(P(x) ∨ Q(y))是逻辑等价的，这里所有量词都有相同的非空论域。",
        "answer": "假设 ∀x P(x) ∨ ∃x Q(x) 为真。那么要么对于所有 x，P(x) 为真，或者存在一个 y 使得 Q(y) 为真。在前一种情况下，P(x) ∨ Q(y) 对于所有 x 都为真，因此 ∀x ∃y(P(x) ∨ Q(y)) 为真。在后一种情况下，Q(y) 对于某个特定的 y 为真，所以 P(x) ∨ Q(y) 对于所有 x 都为真，从而 ∀x ∃y(P(x) ∨ Q(y)) 为真。反之，假设第二个命题为真。如果对于所有 x，P(x) 为真，那么第一个命题为真。如果不是这样，P(x) 对于某些 x 为假，对于这些 x 必须存在一个 y 使得 P(x)∨ Q(y) 为真。因此，Q(y) 必须为真，所以 ∃y Q(y) 为真。由此可知，第一个命题必须成立。",
        "answer_symbols": [
            "∀",
            "∃",
            "∨",
            "∧"
        ]
    },
    "1.5 51": {
        "question": "试阐述如何把任意语句转换为与之等价的前束范式。（注意：本练习的一个正式的解需要用到5.3节的结构归纳法。）",
        "answer": "To show these are not logically equivalent, let P(x) be the statement “x is positive,” and let Q(x) be the statement “x is negative” with domain the set of integers. Then ∃x P(x) ∧ ∃x Q(x) is true, but ∃x(P(x) ∧ Q(x)) is false.",
        "answer_symbols": [
            "→",
            "∃",
            "∧",
            "¬"
        ]
    },
    "1.6 1": {
        "question": "找出下列论证的论证形式，并判定是否有效。如果前提为真，能断定结论为真吗? 如果苏格拉底是人，那么苏格拉底是会死的。 苏格拉底是人 苏格拉底是会死的",
        "answer": "肯定前件；有效；结论为真，因为前提为真。",
        "answer_symbols": []
    },
    "1.6 2": {
        "question": "找出下列论证的论证形式，并判定是否有效。如果前提为真，能断定结论为真吗? 如果George没有8条腿，那么它就不是蜘蛛。 George是蜘蛛。 George有8条腿",
        "answer": "This is modus tollens. The first statement is p → q, where p is \"George does not have eight legs\" and q is \"George is not a spider.\" The second statement is ¬q. The third is ¬p. Modus tollens is valid. We can therefore conclude that the conclusion of the argument (third statement) is true, given that the hypotheses (the first two statements) are true.",
        "answer_symbols": [
            "→",
            "¬"
        ]
    },
    "1.6 3 a)": {
        "question": "在下列每个论证里使用了什么推理规则? Alice主修数学。因此，Alice主修数学或计算机科学。",
        "answer": "加法",
        "answer_symbols": []
    },
    "1.6 3 b)": {
        "question": "在下列每个论证里使用了什么推理规则? Jerry主修数学和计算机科学。因此，Jerry主修数学。",
        "answer": "化简",
        "answer_symbols": []
    },
    "1.6 3 c)": {
        "question": "在下列每个论证里使用了什么推理规则? 如果今天下雨，则游泳池将关闭。今天下雨。因此，游泳池关闭。",
        "answer": "肯定前件",
        "answer_symbols": []
    },
    "1.6 3 d)": {
        "question": "在下列每个论证里使用了什么推理规则? 如果今天下雪，则大学将关闭。今天大学没有关闭。因此，今天没有下雪。",
        "answer": "否定后件",
        "answer_symbols": []
    },
    "1.6 3 e)": {
        "question": "在下列每个论证里使用了什么推理规则? 如果我去游泳，则我会在太阳下停留过久。如果我在太阳下停留过久，则我会有晒斑。因此，如果我去游泳，则我会有晒斑。",
        "answer": "假言三段论",
        "answer_symbols": []
    },
    "1.6 4 a)": {
        "question": "在下列每个论证里使用了什么推理规则？（a）袋鼠生活在澳大利亚并且是有袋类动物。因此，袋鼠是有袋类动物。",
        "answer": "We have taken the conjunction of two propositions and asserted one of them. This is, according to Table 1, simplification.",
        "answer_symbols": [
            "∧"
        ]
    },
    "1.6 4 b)": {
        "question": "在下列每个论证里使用了什么推理规则？（b）今天气温高于 100 度或者污染是有害的。今天外面气温低于 100 度。因此，污染是有害的。",
        "answer": "We have taken the disjunction of two propositions and the negation of one of them, and asserted the other. This is, according to Table 1, disjunctive syllogism. See Table 1 for the other parts of this exercise as well.",
        "answer_symbols": [
            "∨",
            "¬"
        ]
    },
    "1.6 4 c)": {
        "question": "在下列每个论证里使用了什么推理规则？（c）Linda 是优秀的游泳者。如果 Linda 是优秀的游泳者，则她可以当救生员。因此，Linda 可以当救生员。",
        "answer": "modus ponens",
        "answer_symbols": [
            "→"
        ]
    },
    "1.6 4 d)": {
        "question": "在下列每个论证里使用了什么推理规则？（d）今年夏天 Steve 将在计算机公司工作。因此，今年夏天 Steve 将在计算机公司工作或者在海滩闲逛。",
        "answer": "addition",
        "answer_symbols": []
    },
    "1.6 4 e)": {
        "question": "在下列每个论证里使用了什么推理规则？（e）如果我整夜做这个作业，则我可以解答所有的习题。如果我解答所有的习题，则我会理解这些资料。因此，如果我整夜做这个作业，则我会理解这些资料。",
        "answer": "hypothetical syllogism",
        "answer_symbols": [
            "→"
        ]
    },
    "1.6 5": {
        "question": "使用推理规则证明前提“Randy 很用功”、“如果 Randy 很用功，则他是一个笨孩子”以及“如果 Randy 是一个笨孩子，则他不会得到工作”蕴含着结论“Randy 不会得到工作”。",
        "answer": "设 w 表示“兰迪努力工作”，d 表示“兰迪是个笨孩子”，j 表示“兰迪会得到这份工作”。前提是 w，w → d，和 d → ¬j。使用肯定前件和前两个前提，得出 d。使用肯定前件和最后一个前提，得出 ¬j，即所需结论“兰迪不会得到这份工作”。",
        "answer_symbols": [
            "→",
            "¬"
        ]
    },
    "1.6 6": {
        "question": "使用推理规则证明前提“如果天不下雨或天不起雾，则帆船比赛将举行并且救生表演将进行”、“如果帆船比赛举行，则将颁发奖杯”以及“没有颁发奖杯”蕴含着结论“天下雨了”。",
        "answer": "Let r be the proposition \"It rains,\" let f be the proposition \"It is foggy,\" let s be the proposition \"The sailing race will be held,\" let l be the proposition \"The life saving demonstration will go on,\" and let t be the proposition \"The trophy will be awarded.\" We are given premises (¬r ∨ ¬f) → (s ∧ l), s → t, and ¬t. We want to conclude r. We set up the proof in two columns, with reasons, as in Example 6. Note that it is valid to replace subexpressions by other expressions logically equivalent to them.",
        "answer_symbols": [
            "∨",
            "¬",
            "→",
            "∧"
        ]
    },
    "1.6 8": {
        "question": "在下面的论证里使用了什么推理规则？“没有人是岛屿。曼哈顿是岛屿。因此，曼哈顿不是人。”",
        "answer": "First we use universal instantiation to conclude from \"For all x, if x is a man, then x is not an island\" the special case of interest, \"If Manhattan is a man, then Manhattan is not an island.\" Then we form the contrapositive (using also double negative): \"If Manhattan is an island, then Manhattan is not a man.\" Finally we use modus ponens to conclude that Manhattan is not a man. Alternatively, we could apply modus tollens.",
        "answer_symbols": [
            "∀",
            "→",
            "¬"
        ]
    },
    "1.6 10 a)": {
        "question": "对下列的每组前提，可以得出什么样的相关结论？试解释从前提获得每个结论时所使用的推理规则。（a）“如果我打曲棍球，则我第二天会感到酸痛。”“如果我感到酸痛，则我会用水疗。”“我没有用水疗。”",
        "answer": "If we use modus tollens starting from the back, then we conclude that I am not sore. Another application of modus tollens then tells us that I did not play hockey.",
        "answer_symbols": [
            "¬",
            "→"
        ]
    },
    "1.6 10 b)": {
        "question": "对下列的每组前提，可以得出什么样的相关结论？试解释从前提获得每个结论时所使用的推理规则。（b）“如果我工作，则天晴或半晴。”“我上周一工作或上周五工作。”“周二不是半晴。”“周五也不是半晴。”",
        "answer": "We really can’t conclude anything specific here.",
        "answer_symbols": []
    },
    "1.6 10 c)": {
        "question": "对下列的每组前提，可以得出什么样的相关结论？试解释从前提获得每个结论时所使用的推理规则。（c）“所有的昆虫都有 6 条腿。”“蜻蜓是昆虫。”“蜘蛛不是 6 条腿。”“蜘蛛吃蜻蜓。”",
        "answer": "By universal instantiation, we conclude from the first conditional statement by modus ponens that dragonflies have six legs, and we conclude by modus tollens that spiders are not insects. We could say using existential generalization that, for example, there exists a non-six-legged creature that eats a six-legged creature, and that there exists a non-insect that eats an insect.",
        "answer_symbols": [
            "∀",
            "→",
            "¬",
            "∃"
        ]
    },
    "1.6 10 d)": {
        "question": "对下列的每组前提，可以得出什么样的相关结论？试解释从前提获得每个结论时所使用的推理规则。（d）“每个学生都有因特网账号。”“Homer 没有因特网账号。”“Maggie 有因特网账号。”",
        "answer": "We can apply universal instantiation to the conditional statement and conclude that if Homer (respectively, Maggie) is a student, then he (she) has an Internet account. Now modus tollens tells us that Homer is not a student. There are no conclusions to be drawn about Maggie.",
        "answer_symbols": [
            "∀",
            "→",
            "¬"
        ]
    },
    "1.6 10 e)": {
        "question": "对下列的每组前提，可以得出什么样的相关结论？试解释从前提获得每个结论时所使用的推理规则。（e）“所有对健康有益的食物都不好吃。”“豆腐对健康有益。”“你只吃好吃的东西。”“你不吃豆腐。”“汉堡包对健康无益。”",
        "answer": "The first conditional statement is that if x is healthy to eat, then x does not taste good. Universal instantiation and modus ponens therefore tell us that tofu does not taste good. The third sentence says that if you eat x, then x tastes good. Therefore the fourth hypothesis already follows (by modus tollens) from the first three. No conclusions can be drawn about cheeseburgers from these statements.",
        "answer_symbols": [
            "→",
            "¬"
        ]
    },
    "1.6 10 f)": {
        "question": "对下列的每组前提，可以得出什么样的相关结论？试解释从前提获得每个结论时所使用的推理规则。（f）“我在做梦或在幻觉中。”“我没有做梦。”“如果我在幻觉中，则我看见大象在路上跑。”",
        "answer": "通过析取三段论，前两个假设使我们得出结论：我在产生幻觉。因此，通过假言推理，我们知道我看到大象在路上奔跑。",
        "answer_symbols": [
            "∨",
            "→"
        ]
    },
    "1.6 12": {
        "question": "应用练习 11 和表 1 中的推理规则证明：由前提 (p ∧ t) → (r ∨ s), q → (u ∧ t), u → p 和 ¬s 及结论 q → r 构成的论证形式是有效的。",
        "answer": "应用练习11，我们要证明结论 r 可以从五个前提 (p ∧ t)→(r ∨ s)，q→(u ∧ t)，u→ p，¬s 和 q 推导出来。从 q 和 q→(u ∧ t) 我们通过假言推理得到 u ∧ t。从那里我们通过简化（和交换律）得到 u 和 t。从 u 和 u→ p 我们通过假言推理得到 p。从 p 和 t 我们通过合取得到 p ∧ t。从那个和 (p ∧ t)→(r ∨ s) 我们通过假言推理得到 r ∨ s。从那个和 ¬s 我们最终通过析取三段论得到 r。",
        "answer_symbols": [
            "∧",
            "∨",
            "→",
            "¬"
        ]
    },
    "1.6 14 a)": {
        "question": "本班学生Linda拥有红色敞篷汽车。拥有红色敞篷汽车的每个人都至少领到一张超速罚单。因此，本班的某人领到一张超速罚单。",
        "answer": "设 c(x) 表示“x 在这个班上”，设 r(x) 表示“x 拥有一辆红色敞篷车”，设 t(x) 表示“x 被开过超速罚单”。已知前提条件 c(Linda)，r(Linda)，∀x(r(x)→ t(x))，我们希望得出结论 ∃x(c(x)∧ t(x))。步骤 理由 1. ∀x(r(x)→ t(x)) 前提 2. r(Linda)→ t(Linda) 使用(1)的全称实例化 3. r(Linda) 前提 4. t(Linda) 使用(2)和(3)的假言推理 5. c(Linda) 前提 6. c(Linda)∧ t(Linda) 使用(4)和(5)的合取 7. ∃x(c(x)∧ t(x)) 使用(6)的存在推广",
        "answer_symbols": [
            "∀",
            "→",
            "∧",
            "∃"
        ]
    },
    "1.6 14 b)": {
        "question": "5位室友中的每一位（Melissa、Aaron、Ralph、Veneesha和Keeshawn）都选修过离散数学课程。每位选修过离散数学课程的学生都可以选修算法课程。因此，所有5位室友明年都可以选修算法课程。",
        "answer": "设 r(x) 表示“r 是列出的五个室友之一”，设 d(x) 表示“x 学过离散数学课程”，设 a(x) 表示“x 可以修读算法课程”。已知前提条件 ∀x(r(x)→ d(x)) 和 ∀x(d(x)→ a(x))，我们希望得出结论 ∀x(r(x)→ a(x))。在以下推导中，y 代表任意一个人。步骤 理由 1. ∀x(r(x)→ d(x)) 前提 2. r(y)→ d(y) 使用(1)的全称实例化 3. ∀x(d(x)→ a(x)) 前提 4. d(y)→ a(y) 使用(3)的全称实例化 5. r(y)→ a(y) 使用(2)和(4)的假设三段论 6. ∀x(r(x)→ a(x)) 使用(5)的全称推广",
        "answer_symbols": [
            "∀",
            "→"
        ]
    },
    "1.6 14 c)": {
        "question": "John Sayles制作的所有电影都很好看。John Sayles制作过关于煤矿工人的电影。因此，有一部很好看的关于煤矿工人的电影。",
        "answer": "设 s(x) 表示“x 是赛尔斯制作的电影”，设 c(x) 表示“x 是关于煤矿工人的电影”，设 w(x) 表示“电影 x 很棒”。已知前提条件 ∀x(s(x)→ w(x)) 和 ∃x(s(x)∧ c(x))，我们希望得出结论 ∃x(c(x)∧ w(x))。在我们的证明中，y 代表一个未指定的特定电影。步骤 理由 1. ∃x(s(x)∧ c(x)) 前提 2. s(y)∧ c(y) 使用(1)的存在实例化 3. s(y) 使用(2)的简化 4. ∀x(s(x)→ w(x)) 前提 5. s(y)→ w(y) 使用(4)的全称实例化 6. w(y) 使用(3)和(5)的假言推理 7. c(y) 使用(2)的简化 8. w(y)∧ c(y) 使用(6)和(7)的合取 9. ∃x(c(x)∧ w(x)) 使用(8)的存在推广",
        "answer_symbols": [
            "∀",
            "→",
            "∧",
            "∃"
        ]
    },
    "1.6 14 d)": {
        "question": "本班有人到过法国。到过法国的每个人都会参观卢浮宫。因此，本班有人参观过卢浮宫。",
        "answer": "设 c(x) 表示“x 在这个班上”，设 f(x) 表示“x 去过法国”，设 l(x) 表示“x 参观过卢浮宫”。已知前提条件 ∃x(c(x)∧ f(x))，∀x(f(x)→ l(x))，我们希望得出结论 ∃x(c(x)∧ l(x))。∃x(c(x) ∧ f(x)) Hypothesis \n c(y) ∧ f(y) Existential instantiation using (1) \f(y) Simplification using (2)\nc(y) Simplification using (2)\n ∀x(f(x) → l(x)) Hypothesis \n f(y) → l(y) Universal instantiation using (5) \n l(y) Modus ponens using (3) and (6) \nc(y) ∧ l(y) Conjunction using (4) and (7) \n∃x(c(x) ∧ l(x)) Existential generalization using (8)",
        "answer_symbols": [
            "∃",
            "∧",
            "→"
        ]
    },
    "1.6 15 a)": {
        "question": "班上的所有学生都懂逻辑。Xavier是这个班上的学生。因此，Xavier也懂逻辑。",
        "answer": "正确，使用全称实例化和肯定前件",
        "answer_symbols": [
            "∀",
            "→",
            "∧"
        ]
    },
    "1.6 15 b)": {
        "question": "每个计算机专业的学生都要学离散数学。Natasha在学离散数学，因此，Natasha是计算机专业的。",
        "answer": "无效；确认结论谬误",
        "answer_symbols": []
    },
    "1.6 15 c)": {
        "question": "所有鹦鹉都喜欢水果。我养的鸟不是鹦鹉，因此，我养的鸟不喜欢水果。",
        "answer": "无效；否定前提谬误",
        "answer_symbols": []
    },
    "1.6 15 d)": {
        "question": "每天吃麦片的人都很健康。Linda不健康，因此，Linda没有每天吃麦片。",
        "answer": "正确，使用全称实例化和否定后件",
        "answer_symbols": [
            "∀",
            "→",
            "¬"
        ]
    },
    "1.6 16 a)": {
        "question": "每一个上大学的人都住过宿舍。Mia从未住过宿舍，因此，Mia没有上过大学。",
        "answer": "This is correct, using universal instantiation and modus tollens.",
        "answer_symbols": []
    },
    "1.6 16 b)": {
        "question": "敞篷轿车开起来感觉很好。Isaac的车不是敞篷的，因此，Isaac的车开起来感觉不好。",
        "answer": "This is not correct. After applying universal instantiation, it contains the fallacy of denying the hypothesis.",
        "answer_symbols": []
    },
    "1.6 16 c)": {
        "question": "Quincy喜欢所有的动作电影。Quincy喜欢电影《Eight Men Out》，因此，《Eight Men Out》是一部动作电影。",
        "answer": "After applying universal instantiation, it contains the fallacy of affirming the conclusion.",
        "answer_symbols": []
    },
    "1.6 16 d)": {
        "question": "所有捕虾者都设置了至少12个陷阱。Hamilton是捕虾者，因此，Hamilton设置了至少12个陷阱。",
        "answer": "This is correct, using universal instantiation and modus ponens.",
        "answer_symbols": []
    },
    "1.6 18": {
        "question": "令S(x, y)为“x比y矮”。给定前提∃xS(x, Max)，可得出S(Max, Max)。由存在引入可得出∃xS(x, x)，因此某人比他自己矮。",
        "answer": "We know that some s exists that makes S(s, Max) true, but we cannot conclude that Max is one such s. Therefore this first step is invalid.",
        "answer_symbols": []
    },
    "1.6 19 a)": {
        "question": "如果n是满足n≥1的实数，则n^²>1。假定n^²>1。于是n≥1。",
        "answer": "肯定后件谬误",
        "answer_symbols": []
    },
    "1.6 19 b)": {
        "question": "如果n是满足n≥3的实数，则n^²>9。假定n^²≤9。于是n≤3。",
        "answer": "循环论证谬误",
        "answer_symbols": []
    },
    "1.6 19 c)": {
        "question": "如果n是满足n≥2的实数，则n^²>4。假定n≤2。于是n^²≤4。",
        "answer": "使用拒取式的有效论据",
        "answer_symbols": [
            "¬"
        ]
    },
    "1.6 20 a)": {
        "question": "如果x是正实数，那么x^²是正实数。因此，如果a^²是正的，这里a是实数，则a是正实数。",
        "answer": "This is invalid. It is the fallacy of affirming the conclusion. Letting a = -2 provides a counterexample.",
        "answer_symbols": []
    },
    "1.6 20 b)": {
        "question": "如果x^²≠0，这里x是实数，则x≠0。设a是实数，a^²≠0，则a≠0。",
        "answer": "This is valid; it is modus ponens.",
        "answer_symbols": []
    },
    "1.6 21": {
        "question": "哪些推理规则用来建立1.4节例26里所描述的卡洛尔(Lewis Carroll)论证的结论？",
        "answer": "根据第二个前提，存在不喝咖啡的狮子。设莱奥就是这样一种生物。通过简化我们知道莱奥是一只狮子。从第一个前提通过肯定前件知道莱奥是凶猛的。因此，莱奥是凶猛且不喝咖啡的。根据存在量词的定义，存在凶猛但不喝咖啡的生物，即有些凶猛的生物不喝咖啡。",
        "answer_symbols": [
            "∃",
            "¬",
            "∧"
        ]
    },
    "1.6 22": {
        "question": "哪些推理规则用来建立1.4节例27里所描述的卡洛尔(Lewis Carroll)论证的结论？",
        "answer": "We will give an argument establishing the conclusion. We want to show that all hummingbirds are small. Let Tweety be an arbitrary hummingbird. We must show that Tweety is small. The first premise implies that if Tweety is a hummingbird, then Tweety is richly colored. Therefore by (universal) modus ponens we can conclude that Tweety is richly colored. The third premise implies that if Tweety does not live on honey, then Tweety is not richly colored. Therefore by (universal) modus tollens we can now conclude that Tweety does live on honey. Finally, the second premise implies that if Tweety is a large bird, then Tweety does not live on honey. Therefore again by (universal) modus tollens we can now conclude that Tweety is not a large bird, i.e., that Tweety is small, as desired. Notice that we invoke universal generalization as the last step.",
        "answer_symbols": [
            "→",
            "¬"
        ]
    },
    "1.6 23": {
        "question": "指出如下试图证明“如果∃xP(x)∧∃xQ(x)为真，那么∃x(P(x)∧Q(x))为真”的论证中有哪些错误。1. ∃xP(x)∨∃xQ(x) 前提引入2. ∃xP(x) 化简律，用(1)3. P(c) 存在实例，用(2)4. ∃xQ(x) 化简律，用(1)5. Q(c) 存在实例，用(4)6. P(c)∧Q(c) 合取律，用(3)和(5)7. ∃x(P(x)∧Q(x)) 存在引入",
        "answer": "错误发生在步骤 (5)，因为我们不能假设使 P 为真的 c 与使 Q 为真的 c 是相同的。",
        "answer_symbols": [
            "¬",
            "→"
        ]
    },
    "1.6 24": {
        "question": "指出如下试图证明“如果∀x(P(x)∨Q(x))为真，那么∀xP(x)∨∀xQ(x)为真”的论证中有哪些错误。基础：逻辑和证明691. ∀x(P(x) ∨ Q(x))2. P(c) ∨ Q(c)3. P(c)4. ∀xP(x)5. Q(c)6. ∀xQ(x)7. ∀xP(x) ∨ ∀xQ(x)",
        "answer": "Steps 3 and 5 are incorrect; simplification applies to conjunctions, not disjunctions.",
        "answer_symbols": [
            "∧",
            "∨"
        ]
    },
    "1.6 25": {
        "question": "通过证明前提 ∀x(P(x) → Q(x)) 和 ¬Q(a)，推出 ¬P(a)（其中 a 是对论域中某个特定元素）来检验全称取拒式。",
        "answer": "我们有前提条件 ∀x(P(x) → Q(x)) 和 ¬Q(a)。我们想要证明 ¬P(a)。假设 ¬P(a) 不为真。那么 P(a) 为真。因此通过全称肯定前件，我们有 Q(a)。但这与给定的前提 ¬Q(a) 相矛盾。因此我们的假设必须是错误的，所以 ¬P(a) 为真，如所愿。",
        "answer_symbols": [
            "∀",
            "¬",
            "→"
        ]
    },
    "1.6 26": {
        "question": "试证明全称传递性，即，如果 ∀x(P(x) → Q(x)) 和 ∀x(Q(x) → R(x)) 为真，则 ∀x(P(x) → R(x)) 为真，这里所有量词的论域都是相同的。",
        "answer": "We want to show that the conditional statement P(a) → R(a) is true for all a in the domain; the desired conclusion then follows by universal generalization. Thus we want to show that if P(a) is true for a particular a, then R(a) is also true. For such an a, by universal modus ponens from the first premise we have Q(a), and then by universal modus ponens from the second premise we have R(a), as desired.",
        "answer_symbols": [
            "→"
        ]
    },
    "1.6 27": {
        "question": "用推理规则证明：如果 ∀x(P(x) → (Q(x) ∧ S(x))) 和 ∀x(P(x) ∧ R(x)) 为真，则 ∀x(R(x) ∧ S(x)) 为真。",
        "answer": "步骤 理由 1. ∀x(P(x) ∧ R(x)) 前提 2. P(a) ∧ R(a) 从 (1) 进行全称例示 3. P(a) 从 (2) 简化 4. ∀x(P(x) → (Q(x) ∧ S(x))) 前提 5. Q(a) ∧ S(a) 从 (3) 和 (4) 进行全称肯定前件 6. S(a) 从 (5) 简化 7. R(a) 从 (2) 简化 8. R(a) ∧ S(a) 从 (7) 和 (6) 结合 9. ∀x(R(x) ∧ S(x)) 从 (5) 进行全称泛化",
        "answer_symbols": [
            "∀",
            "¬",
            "∧",
            "→"
        ]
    },
    "1.6 28": {
        "question": "用推理规则证明：如果 ∀x(P(x) ∨ Q(x)) 和 ∀x((¬P(x) ∧ Q(x)) → R(x)) 为真，则 ∀x(¬R(x) → P(x)) 也为真，这里所有量词的论域都是相同的。",
        "answer": "We want to show that the conditional statement ¬R(a) → P(a) is true for all a in the domain; the desired conclusion then follows by universal generalization. Thus we want to show that if ¬R(a) is true for a particular a, then P(a) is also true. For such an a, universal modus tollens applied to the second premise gives us ¬(¬P(a) ∧ Q(a)). By rules from propositional logic, this gives us P(a) ∨ ¬Q(a). By universal generalization from the first premise, we have P(a) ∨ Q(a). Now by resolution we can conclude P(a) ∨ P(a), which is logically equivalent to P(a), as desired.",
        "answer_symbols": [
            "→",
            "¬",
            "∧",
            "∨"
        ]
    },
    "1.6 29": {
        "question": "用推理规则证明：如果 ∀x(P(x) ∨ Q(x)) 和 ∀x(¬Q(x) ∨ S(x))，∀x(R(x) → ¬S(x)) 和 ∃x¬P(x) 为真，则 ∃x¬R(x) 为真。",
        "answer": "步骤 理由 1. ∃x¬P(x) 前提 2. ¬P(c) 从 (1) 存在例示 3. ∀x(P(x) ∨ Q(x)) 前提 4. P(c) ∨ Q(c) 从 (3) 全称例示 5. Q(c) 从 (4) 和 (2) 析取三段论 6. ∀x(¬Q(x) ∨ S(x)) 前提 7. ¬Q(c) ∨ S(c) 从 (6) 全称例示 8. S(c) 从 (5) 和 (7) 析取三段论 9. ∀x(R(x) → ¬S(x)) 前提 10. R(c) → ¬S(c) 从 (9) 全称例示 11. ¬R(c) 从 (8) 和 (10) 拒取式 12. ∃x¬R(x) 从 (11) 存在泛化",
        "answer_symbols": [
            "∃",
            "¬",
            "∨",
            "→"
        ]
    },
    "1.6 30": {
        "question": "使用消解律证明前提“Allen 是一个坏男孩或 Hillary 是一个好女孩”和“Allen 是一个好男孩或 David 很开心”蕴含结论“Hillary 是一个好女孩或 David 很开心”。",
        "answer": "Let a be 'Allen is a good boy'; let h be 'Hillary is a good girl'; let d be 'David is happy.' Then our assumptions are ¬a ∨ h and a ∨ d. Using resolution gives us h ∨ d, as desired.",
        "answer_symbols": [
            "∨",
            "¬"
        ]
    },
    "1.6 31": {
        "question": "使用消解律证明前提“天下雨或 Yvette 带雨伞了”，“Yvette 没有带雨伞或她没有被淋湿”和“天下雨了或 Yvette 没有被淋湿”蕴含结论“Yvette 没有被淋湿”。",
        "answer": "设 p 为“下雨了”；设 q 为“伊维特有雨伞”；设 r 为“伊维特被淋湿”。假设是 ¬p ∨ q, ¬q ∨ ¬r, 和 p ∨ ¬r。对前两个进行归结得到 ¬p ∨ ¬r。再与第三个假设进行归结得到 ¬r，如所愿。",
        "answer_symbols": [
            "¬",
            "∨"
        ]
    },
    "1.6 33": {
        "question": "用消解律证明复合命题 (p ∨ q) ∧ (¬p ∨ q) ∧ (p ∨ ¬q) ∧ (¬p ∨ ¬q) 不是可满足的。",
        "answer": "假设这个命题是可以满足的。使用归结法对前两个子句进行归结，我们可以得出 q ∨ q；换句话说，我们知道 q 必须为真。使用归结法对最后两个子句进行归结，我们可以得出 ¬q ∨ ¬q；换句话说，我们知道 ¬q 必须为真。这是个矛盾。因此这个命题是不可满足的。",
        "answer_symbols": [
            "¬",
            "∨"
        ]
    },
    "1.6 35": {
        "question": "如果超人能够并愿意防止邪恶，则他将这样做。如果超人不能够防止邪恶，则他就是无能的；如果超人不愿意防止邪恶，则他就是恶意的。超人没有防止邪恶。如果超人存在，则他是无能的或者恶意的。因此，超人不存在。",
        "answer": "有效",
        "answer_symbols": []
    },
    "1.7 1": {
        "question": "用直接证明法证明两个奇数之和是偶数。",
        "answer": "设 n= 2k+ 1 和 m= 2l+ 1 是奇整数。那么 n+ m= 2(k+ l+ 1) 是偶数。",
        "answer_symbols": [
            "=",
            "+",
            "(",
            ")",
            "2"
        ]
    },
    "1.7 2": {
        "question": "用直接证明法证明两个偶数之和是偶数。",
        "answer": "We must prove that whenever there are two even integers, their sum is also even. Suppose a and b are two even integers. Then there exist integers s and t such that a = 2s and b = 2t. Adding them together, we get a + b = 2s + 2t = 2(s + t). Since this shows that a + b is 2 times the integer s + t, we conclude that a + b is even, as required.",
        "answer_symbols": [
            "=",
            "+",
            "(",
            ")",
            "×"
        ]
    },
    "1.7 3": {
        "question": "用直接证明法证明偶数的平方是偶数。",
        "answer": "假设 n 是偶数。那么 n= 2k 对于某个整数 k。因此，n^²= (2k)^²= 4k^²= 2(2k^²)。因为我们将 n^² 写成 2 乘以一个整数，我们得出 n^² 是偶数。",
        "answer_symbols": [
            "=",
            "+",
            "(",
            ")",
            "²",
            "4",
            "2"
        ]
    },
    "1.7 4": {
        "question": "用直接证明法证明一个偶数的相反数或负数也是偶数。",
        "answer": "We must prove that whenever there is an even integer, its negative is also even. Suppose a is an even integer. Then there exists an integer s such that a = 2s. Its additive inverse is -2s, which by arithmetic and algebra rules (see Appendix 1) equals 2(-s). Since this is 2 times the integer -s, it is even, as required.",
        "answer_symbols": [
            "=",
            "+",
            "(",
            ")",
            "×"
        ]
    },
    "1.7 5": {
        "question": "证明如果m+n和n+p都是偶数，其中m、n和p都是整数，那么m+p也是偶数。你用的是什么证明方法？",
        "answer": "直接证明：假设 m+n 和 n+p 是偶数。那么 m+n= 2s 对于某个整数 s，n+ p= 2t 对于某个整数 t。如果我们把这两个等式相加，我们得到 m+p+ 2n= 2s+ 2t。从两边减去 2n 并因式分解，我们有 m+ p= 2s+ 2t − 2n= 2(s+ t − n)。因为我们将 m+ p 写成 2 乘以一个整数，我们得出 m+ p 是偶数。",
        "answer_symbols": [
            "=",
            "+",
            "(",
            ")",
            "2",
            "−"
        ]
    },
    "1.7 6": {
        "question": "用直接证明法证明两个奇数之积是奇数。",
        "answer": "An odd number has the form 2n + 1, where n is an integer. Given two odd numbers, say 2a + 1 and 2b + 1. Their product is (2a + 1)(2b + 1) = 4ab + 2a + 2b + 1 = 2(2ab + a + b) + 1. This last expression shows that the product is odd, because it has the form 2n + 1, where n = 2ab + a + b.",
        "answer_symbols": [
            "+",
            "(",
            ")",
            "×"
        ]
    },
    "1.7 7": {
        "question": "用直接证明法证明每个奇数都是两个平方数的差。",
        "answer": "因为 n 是奇数，我们可以写 n= 2k+ 1 对于某个整数 k。那么 (k+1)^²−k^²= k^²+2k+1−k^²= 2k+1= n。",
        "answer_symbols": [
            "=",
            "+",
            "(",
            ")",
            "²",
            "−"
        ]
    },
    "1.7 8": {
        "question": "证明如果n是完全平方数，那么n+2不是完全平方数。",
        "answer": "Let n = m^². If m = 0, then n + 2 = 2, which is not a perfect square, so we can assume m ≥ 1. The smallest perfect square greater than n is (m + 1)^², we have (m + 1)^² = m^² + 2m + 1 = n + 2m + 1 > n + 2 * 1 + 1 > n + 2. Therefore, n + 2 cannot be a perfect square.",
        "answer_symbols": [
            "=",
            "+",
            ">",
            "×",
            "²"
        ]
    },
    "1.7 9": {
        "question": "使用归谬法证明一个无理数与一个有理数之和是无理数。",
        "answer": "假设 r 是有理数而 i 是无理数且 s= r+ i 是有理数。那么根据例 7，s+(−r)= i 是有理数，这是一个矛盾。",
        "answer_symbols": [
            "=",
            "+",
            "−"
        ]
    },
    "1.7 10": {
        "question": "用直接证明法证明两个有理数之积是有理数。",
        "answer": "A rational number is a number that can be written in the form x/y, where x and y are integers and y ≠ 0. Suppose we have two rational numbers, say a/b and c/d. Then their product is (ac)/(bd). Note that the numerator and denominator are both integers, and bd ≠ 0, since b and d are both non-zero. Therefore, by definition, the product is a rational number.",
        "answer_symbols": [
            "≠",
            "/"
        ]
    },
    "1.7 11": {
        "question": "证明或反驳两个无理数之积是无理数。",
        "answer": "因为 √2·√2= 2 是有理数而 √2 是无理数，两个无理数的乘积不一定是无理数。",
        "answer_symbols": [
            "√",
            "·",
            "="
        ]
    },
    "1.7 12": {
        "question": "证明或反驳一个非零有理数与一个无理数之积是无理数。",
        "answer": "This is true. Suppose that a/b is a nonzero rational number and that x is an irrational number. We must prove that the product xa/b is also irrational. We give a proof by contradiction. Suppose that xa/b were rational. Since a/b ≠ 0, we know that a ≠ 0, so b/a is also a rational number. Let us multiply this rational number b/a by the assumed rational number xa/b. By Exercise 26, the product is rational. But the product is (b/a)(xa/b) = x, which is irrational by hypothesis. This is a contradiction, so in fact xa/b must be irrational, as desired.",
        "answer_symbols": [
            "/",
            "≠"
        ]
    },
    "1.7 13": {
        "question": "证明如果x是无理数，则1/x是无理数。",
        "answer": "反证法：如果 1/x 是有理数，那么根据定义 1/x= p/q 对于某些整数 p 和 q 且 q ≠ 0。因为 1/x 不能为 0（如果它是，那么我们就会有 1= x·0 的矛盾，通过两边同时乘以 x），我们知道 p ≠ 0。现在 x= 1/(1/x)= 1/(p/q)= q/p 通过通常的代数和算术规则。因此，x 可以写成两个整数的商且分母不为零。因此根据定义，x 是有理数。",
        "answer_symbols": [
            "1",
            "/",
            "=",
            "≠",
            "·",
            "(",
            ")"
        ]
    },
    "1.7 14": {
        "question": "证明如果x是有理数且x≠0，则1/x是有理数。",
        "answer": "If x is rational and not zero, then by definition we can write x = p/q, where p and q are nonzero integers. Since 1/x is then q/p and p ≠ 0, we can conclude that 1/x is rational.",
        "answer_symbols": [
            "=",
            "/",
            "≠"
        ]
    },
    "1.7 15": {
        "question": "使用反证法证明如果x+y≥2，这里x和y是实数，那么x≥1或者y≥1。",
        "answer": "假设 x ≥ 1 或 y ≥ 1 不成立。那么 x< 1 且 y< 1。将这两个不等式相加，我们得到 x+ y< 2，这是 x+ y ≥ 2 的否定。",
        "answer_symbols": [
            "≥",
            "<",
            "+",
            "¬"
        ]
    },
    "1.7 16": {
        "question": "证明如果m和n是整数并且mn是偶数，那么m是偶数或者n是偶数。",
        "answer": "We give a proof by contraposition. If it is not true that m is even or n is even, then m and n are both odd. By Exercise 6, this tells us that mn is odd, and our proof is complete.",
        "answer_symbols": []
    },
    "1.7 19": {
        "question": "证明命题P(0)，其中P(n)是命题“如果n是个大于1的正整数，则n^2>n”。你使用什么类型的证明方法？",
        "answer": "该命题是空洞真，因为 0 不是正整数。空洞证明。",
        "answer_symbols": []
    },
    "1.7 20": {
        "question": "证明命题P(1)，其中P(n)是命题“如果n是个正整数，则n^2≥n”。你使用什么类型的证明方法？",
        "answer": "We need to prove the proposition “If 1 is a positive integer, then 1^2 ≥ 1.” The conclusion is the true statement 1 ≥ 1. Therefore the conditional statement is true. This is an example of a trivial proof, since we merely showed that the conclusion was true.",
        "answer_symbols": [
            "^",
            "≥"
        ]
    },
    "1.7 21": {
        "question": "设P(n)是命题“如果a和b是正实数，则(a+b)^n≥a^n+b^n”。证明P(1)为真。你使用什么类型的证明方法？",
        "answer": "P(1) 为真，因为 (a+ b)¹= a+ b ≥ a¹+ b¹= a+ b。直接证明。",
        "answer_symbols": [
            "=",
            "+",
            "(",
            ")",
            "≥"
        ]
    },
    "1.7 22": {
        "question": "证明如果你从装有蓝色和黑色袜子的抽屉中选择三只袜子，你一定能得到一双蓝袜子或者一双黑袜子。",
        "answer": "We give a proof by contradiction. Suppose that we don’t get a pair of blue socks or a pair of black socks. Then we drew at most one of each color. This accounts for only two socks. But we are drawing three socks. Therefore our supposition that we did not get a pair of blue socks or a pair of black socks is incorrect, and our proof is complete.",
        "answer_symbols": []
    },
    "1.7 23": {
        "question": "证明在任意64天中至少有10天在每星期的同一天里。",
        "answer": "如果我们在一周中的每一天选择 9 天或更少，这将总计最多 9 × 7= 63 天。但我们选择了 64 天。这一矛盾表明我们必须至少在一周中的同一天选择了 10 天。",
        "answer_symbols": [
            "×",
            "=",
            "≤",
            "≥"
        ]
    },
    "1.7 24": {
        "question": "证明在任意25天中至少有3天在同一个月份。",
        "answer": "We give a proof by contradiction. If there were at most two days falling in the same month, then we could have at most 2 * 12 = 24 days, since there are 12 months. Since we have chosen 25 days, at least three of them must fall in the same month.",
        "answer_symbols": [
            "*",
            "="
        ]
    },
    "1.7 25": {
        "question": "用归谬法证明没有有理数r使得r^3+r+1=0。",
        "answer": "假设 a/b 是一个有理根，其中 a 和 b 是整数且这个分数是最简形式（即 a 和 b 没有大于 1 的公因子）。将这个假设的根代入方程得到 a^³/b^³+ a/b+ 1= 0。两边同时乘以 b^³ 得到 a^³+ ab^²+ b^³= 0。如果 a 和 b 都是奇数，那么左边是三个奇数的和，因此必须是奇数。如果 a 是奇数而 b 是偶数，那么左边是奇数+偶数+偶数，这又是奇数。同样地，如果 a 是偶数而 b 是奇数，那么左边是偶数+偶数+奇数，这还是奇数。",
        "answer_symbols": [
            "=",
            "+",
            "(",
            ")",
            "³",
            "²",
            "1",
            "0"
        ]
    },
    "1.7 26": {
        "question": "证明如果n是正整数，则n是偶数当且仅当7n+4是偶数。",
        "answer": "We need to prove two things, since this is an “if and only if” statement. First let us prove directly that if n is even then 7n + 4 is even. Since n is even, it can be written as 2k for some integer k. Then 7n + 4 = 14k + 4 = 2(7k + 2). This is 2 times an integer, so it is even, as desired. Next we give a proof by contraposition that if 7n + 4 is even then n is even. So suppose that n is not even, i.e., that n is odd. Then n can be written as 2k + 1 for some integer k. Thus 7n + 4 = 14k + 11 = 2(7k + 5) + 1. This is 1 more than 2 times an integer, so it is odd. That completes the proof by contraposition.",
        "answer_symbols": [
            "=",
            "+",
            "*",
            "(",
            ")",
            "2"
        ]
    },
    "1.7 28": {
        "question": "证明m^2=n^2当且仅当m=n或m=−n。",
        "answer": "There are two things to prove. For the “if” part, there are two cases. If m = n, then of course m^2 = n^2; if m = -n, then m^2 = (-n)^2 = (-1)^2 n^2 = n^2. For the “only if” part, we suppose that m^2 = n^2. Putting everything on the left and factoring, we have (m + n)(m - n) = 0. Now the only way that a product of two numbers can be zero is if one of them is zero. Therefore we conclude that either m + n = 0 (in which case m = -n), or else m - n = 0 (in which case m = n), and our proof is complete.",
        "answer_symbols": [
            "=",
            "^",
            "+",
            "-",
            "(",
            ")",
            "0"
        ]
    },
    "1.7 30": {
        "question": "证明下面三条语句是等价的，其中a和b是实数：(i)a<b；(ii)a和b的平均值>b；(iii)a和b的平均值<b。",
        "answer": "We write these in symbols: a < b, (a + b)/2 > a, and (a + b)/2 < b. The latter two are equivalent to a + b > 2a and a + b < 2b, respectively, and these are in turn equivalent to b > a and a < b, respectively. It is now clear that all three statements are equivalent.",
        "answer_symbols": [
            "<",
            ">",
            "+",
            "(",
            ")",
            "/"
        ]
    },
    "1.7 17 a)": {
        "question": "证明如果n是整数而且n^3+5是奇数，则n是偶数。使用反证法证明。",
        "answer": "假设 n 是奇数，那么 n= 2k+1 对于某个整数 k。那么 n^³+5= 2(4k^³+6k^²+3k+3)。因为 n^³+ 5 是两倍的某个整数，它为偶数。",
        "answer_symbols": [
            "=",
            "+",
            "(",
            ")",
            "³",
            "²",
            "2"
        ]
    },
    "1.7 17 b)": {
        "question": "证明如果n是整数而且n^3+5是奇数，则n是偶数。使用归谬法证明。",
        "answer": "假设 n^³+ 5 是奇数且 n 是奇数。因为 n 是奇数且两个奇数的乘积是奇数，所以 n^² 是奇数，进而 n^³ 是奇数。但 5=(n^³+ 5) − n^³ 必须是偶数，因为它是一个奇数减去另一个奇数。因此，假设 n^³+ 5 和 n 都是奇数是错误的。",
        "answer_symbols": [
            "=",
            "+",
            "(",
            ")",
            "³",
            "²",
            "−"
        ]
    },
    "1.7 18 a)": {
        "question": "证明如果n是整数而且3n+2是偶数，则n是偶数。使用反证法证明。",
        "answer": "We must prove the contrapositive: If n is odd, then 3n + 2 is odd. Assume that n is odd. Then we can write n = 2k + 1 for some integer k. Then 3n + 2 = 3(2k + 1) + 2 = 6k + 5 = 2(3k + 2) + 1. Thus 3n + 2 is two times some integer plus 1, so it is odd.",
        "answer_symbols": [
            "=",
            "+",
            "*",
            "(",
            ")",
            "2"
        ]
    },
    "1.7 18 b)": {
        "question": "证明如果n是整数而且3n+2是偶数，则n是偶数。使用归谬法证明。",
        "answer": "Suppose that 3n + 2 is even and that n is odd. Since 3n + 2 is even, so is 3n. If we add subtract an odd number from an even number, we get an odd number, so 3n − n = 2n is odd. But this is obviously not true. Therefore our supposition was wrong, and the proof by contradiction is complete.",
        "answer_symbols": [
            "+",
            "-",
            "=",
            "2"
        ]
    },
    "1.7 32": {
        "question": "证明下面三条语句是等价的：(i)x是有理数；(ii)x/2是有理数；(iii)3x-1是有理数。",
        "answer": "We apply resolution to derive the tautology (p ∨ F) ∧ (¬p ∨ F) → (F ∨ F). The left side is equivalent to p ∧ ¬p, because p ∨ F is equivalent to p, and ¬p ∨ F is equivalent to ¬p. The right side is equivalent to F. Since the conditional statement is true and the conclusion is false, the assumption p ∧ ¬p is false, as expected.",
        "answer_symbols": [
            "∨",
            "∧",
            "¬",
            "→"
        ]
    },
    "1.7 34": {
        "question": "下列求解方程√(2x^2-1)=x的推理过程是否正确？(1)√(2x^2-1)=x，已知；(2)2x^2-1=x^2，(1)式两边取平方；(3)x^2-1=0，(2)式两边都减去x^2；(4)(x-1)(x+1)=0，对左边的x^2-1进行因式分解；(5)x=1或x=-1，因为ab=0蕴含a=0或b=0。",
        "answer": "Let d represent 'logic is hard', s represent 'many students like logic', and e represent 'math is easy'. The assumptions are d ∨ ¬s and e → ¬d. Note that the first assumption is equivalent to s → d, because both forms are false only when s is true and d is false. Also, note that the second assumption is equivalent to its contrapositive d → ¬e. Finally, by combining these two conditional statements, we see that s → ¬e also follows from our assumptions.",
        "answer_symbols": [
            "∨",
            "¬",
            "→"
        ]
    },
    "1.8 2": {
        "question": "证明不存在小于1000的正的完全立方数是两个正整数的立方和.",
        "answer": "我们必须证明这些数中没有两个数的和等于列表中的一个数。如果尝试45种组合（1+1, 1+8, ..., 1+729, 8+8, 8+27, ..., 8+729, ..., 729+729），我们会发现没有一种组合有效。在穷尽所有可能性后，我们得出结论：小于1000的立方数不能是两个立方数的和。",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "1.8 4": {
        "question": "使用分情形证明法来证明当a、b和c都是实数时就有min(a, min(b, c))=min(min(a, b), c).",
        "answer": "根据三个数中哪一个最小，可以分为三种主要情况。如果a是最小的（或并列最小），那么显然a ≤ min(b, c)，因此左边等于a。另一方面，对于右边，我们也有min(a, c) = a。在第二种情况下，b是最小的（或并列最小）。同样的推理显示右边等于b；而左边也是min(a, b) = b。在最后一种情况下，c是最小的（或并列最小），左边是min(a, c) = c，而右边显然也是c。由于三个数中必定有一个是最小的，我们已经处理了所有的情况。",
        "answer_symbols": [
            "≤",
            "min",
            "="
        ]
    },
    "1.8 6": {
        "question": "用不失一般性的概念证明当x和y是奇偶性相反的整数时有5x+5y是一个奇整数.",
        "answer": "因为x和y具有相反的奇偶性，我们可以不失一般性地假设x是偶数而y是奇数。这告诉我们x = 2m（某个整数m）且y = 2n + 1（某个整数n）。那么5x + 5y = 5(2m) + 5(2n + 1) = 10m + 10n + 1 = 10(m + n) + 1 = 2 * 5(m + n) + 1，这满足奇数的定义。",
        "answer_symbols": [
            "=",
            "+",
            "*",
            "(",
            ")"
        ]
    },
    "1.8 8": {
        "question": "证明存在一个正整数等于所有小于它的正整数的和。",
        "answer": "数字1具有这种性质，因为不超过1的唯一正整数就是1本身，因此总和是1。这是一个构造性证明。",
        "answer_symbols": []
    },
    "1.8 10": {
        "question": "证明2×10^100+15或2×10^500+16不是完全平方数。",
        "answer": "唯一相差1的完全平方数是0和1。因此这两个连续整数不可能都是完全平方数。这是一个非构造性证明——我们不知道哪一个满足条件。（事实上，计算机代数系统会告诉我们，它们都不是完全平方数。）",
        "answer_symbols": [
            "^"
        ]
    },
    "1.8 12": {
        "question": "证明65^1000−8^2001+3^177、79^1212−9^299+2^2001和24^4493−5^8192+7^1777这三个数中任意两个数之积是非负的。",
        "answer": "这三个数中至少有两个必须具有相同的符号（都是正数或都是负数），因为只有两种符号。（有些可能是零，但在本问题中我们将零视为正数。）相同符号的两个数的乘积是非负的。这是一个非构造性证明，因为我们没有确定哪个乘积是非负的。（事实上，计算机代数系统会告诉我们，这三个数都是正数，所以三个乘积都是正数。）",
        "answer_symbols": [
            "*",
            "≥"
        ]
    },
    "1.8 14": {
        "question": "证明或驳斥如果a和b是有理数，那么a^b也是有理数。",
        "answer": "像这样的断言是隐式全称量化的——它意味着对于所有的有理数a和b，ab是有理数。要反驳这样一个陈述，提供一个反例就足够了。取a = 2和b = 1/2。那么ab = 2^(1/2) = √2，从第1.7节的示例10我们知道√2不是有理数。",
        "answer_symbols": [
            "∀",
            "=",
            "^",
            "√"
        ]
    },
    "1.8 16": {
        "question": "证明：如果a、b和c是实数且a≠0，则方程ax+b=c存在唯一的解。",
        "answer": "我们从代数中知道以下方程是等价的：ax + b = c, ax = c - b, x = (c - b)/a。这构造性地展示了给定方程的唯一解。",
        "answer_symbols": [
            "=",
            "-",
            "/",
            "*"
        ]
    },
    "1.8 18": {
        "question": "证明如果r是无理数，则存在唯一的整数n使得r和n之间的距离小于1/2。",
        "answer": "给定r，令a是小于r的最接近r的整数，令b是大于r的最接近r的整数。在第2.3节将引入的符号中，a = ⌊r⌋，b = ⌈r⌉。实际上，b = a + 1。显然，r与任何其他整数（除了a和b）的距离大于1，因此不可能小于1/2。此外，由于r是无理数，它不能正好位于a和b之间的一半位置，因此r - a < 1/2和b - r < 1/2中恰好有一个成立。",
        "answer_symbols": [
            "<",
            ">",
            "=",
            "+",
            "-",
            "⌊",
            "⌋",
            "⌈",
            "⌉"
        ]
    },
    "1.8 20": {
        "question": "证明给定实数x，存在唯一的数n和ε使得x=n+ε，这里n是整数且0≤ε<1。",
        "answer": "给定x，令n是小于或等于x的最大整数，令ε = x - n。在第2.3节将引入的符号中，n = ⌊x⌋。显然0 ≤ ε < 1，且对于这个n，ε是唯一的。任何其他选择的n都会导致所需的ε小于0或大于等于1，因此n也是唯一的。",
        "answer_symbols": [
            "≤",
            "<",
            ">",
            "=",
            "-",
            "⌊",
            "⌋"
        ]
    },
    "1.8 22": {
        "question": "用正向推理证明：如果x是非零实数，则x^²+1/x^²≥2。",
        "answer": "每个实数的平方都是非负的，所以 (x - 1/x)^² ≥ 0。展开并简化后，我们得到 x^² - 2 + 1/x^² ≥ 0，因此 x^² + 1/x^² ≥ 2，正如所期望的。",
        "answer_symbols": [
            "-",
            "^",
            "≥",
            "+",
            "/"
        ]
    },
    "1.8 24": {
        "question": "两个实数x和y的平方均值(quadratic mean)是√((x^²+y^²)/2)。通过计算不同正实数对的算术均值和平方均值，构造一个关于这两种均值相对大小的猜想并证明之。",
        "answer": "设 x = 1 和 y = 10。那么它们的算术平均值是 5.5，二次平均值是 √50.5 ≈ 7.11。同样地，如果 x = 5 和 y = 8，那么算术平均值是 (5 + 8)/2 = 6.5，二次平均值是 √((5^² + 8^²)/2) ≈ 6.67。因此，我们推测二次平均值总是大于或等于算术平均值。因此，我们要证明对于所有正实数 x 和 y，√((x^² + y^²)/2) ≥ (x + y)/2。进行一些代数运算，我们发现这个不等式等价于 (x - y)^² ≥ 0：√((x^² + y^²)/2) ≥ (x + y)/2 2x^² + 2y^² ≥ x^² + 2xy + y^² x^² - 2xy + y^² ≥ 0 (x - y)^² ≥ 0 实际上，我们的论证还表明，等号成立当且仅当 x = y。",
        "answer_symbols": [
            "=",
            "-",
            "+",
            "√",
            "(",
            ")",
            "/",
            "²",
            "≥"
        ]
    },
    "1.8 26": {
        "question": "假设5个1和4个0绕圆周排列。在任何两个相同的位之间插入一个0，在任何两个不同的位之间插入一个1，以产生9个新的位。然后删除原来的9位。证明当反复进行这个过程时，永远不能得到9个0。",
        "answer": "如果最终得到九个 0，那么在前一步中我们必须有九个 0 或九个 1，因为每对相邻位必须相等，因此所有位都必须相同。因此，如果我们从不是九个 0 的其他数字开始，但最终得到九个 0，那么我们必须在某个时刻有九个 1。但在前一步中，每对相邻位必须不同；换句话说，它们必须交替出现 0, 1, 0, 1，等等。这在奇数位的情况下是不可能的。这一矛盾表明我们永远不可能得到九个 0。",
        "answer_symbols": []
    },
    "1.8 28": {
        "question": "构造一个关于一个整数平方的十进制末两位数字的猜想。用分情形证明法证明你的猜想。",
        "answer": "显然只有 n 的最后两位数字对 n^² 的最后两位数字有贡献。因此我们可以计算 0^², 1^², 2^², 3^², ..., 99^²，并记录最后两位数字，省略重复的部分。我们得到 00, 01, 04, 09, 16, 25, 36, 49, 64, 81, 21, 44, 69, 96, 56, 89, 24, 61, 41, 84, 29, 76。从那一点开始，列表以相反的顺序重复（当我们取 25^² 到 49^² 的平方时，然后再次重复当我们取 50^² 到 99^² 的平方时）。这些最后两个陈述的原因是 (50 - n)^² = 2500 - 100n + n^²，因此 (50 - n)^² 和 n^² 有相同的最后两位数字，以及 (50 + n)^² = 2500 + 100n + n^²，因此 (50 + n)^² 和 n^² 有相同的最后两位数字。因此我们的列表（包含 22 个数字）是完整的。",
        "answer_symbols": [
            "-",
            "+",
            "²",
            "="
        ]
    },
    "1.8 30": {
        "question": "证明方程2x^²+5y^²=14没有x和y的整数解。",
        "answer": "如果 |y| ≥ 2，那么 2x^² + 5y^² ≥ 2x^² + 20 ≥ 20，所以唯一可能的 y 值是 0 和 ±1。在前者情况下，我们需要找到 2x^² = 14 的解，在后者情况下，我们需要找到 2x^² = 9 的解。显然这些方程没有整数解，因此原始方程没有解。",
        "answer_symbols": [
            "|",
            "≥",
            "+",
            "²",
            "=",
            "±"
        ]
    },
    "1.8 32": {
        "question": "证明方程x^²+y^²=z^²有无穷多个正整数解x、y和z。",
        "answer": "跟随提示，我们设 x = m^² - n^², y = 2mn, 和 z = m^² + n^²。那么 x^² + y^² = (m^² - n^²)^² + (2mn)^² = m^⁴ - 2m^²n^² + n^⁴ + 4m^²n^² = m^⁴ + 2m^²n^² + n^⁴ = (m^² + n^²)^² = z^²。因此我们找到了无数多个解，因为 m 和 n 可以任意大。",
        "answer_symbols": [
            "=",
            "-",
            "+",
            "²",
            "⁴",
            "²",
            "²"
        ]
    },
    "1.8 34": {
        "question": "证明√2是无理数。",
        "answer": "证明 √32 是无理数的方法类似于第 1.7 节中的例子 10 中给出的证明 √2 是无理数的方法。这是一个反证法。假设 2^(1/3)（或 √32，这是同一回事）是有理数 p/q，其中 p 和 q 是没有公因数的正整数（分数是最简形式）。立方后，我们看到 2 = p^³/q^³，或者等价地，p^³ = 2q^³。因此 p^³ 是偶数。由于奇数的乘积是奇数，这意味着 p 是偶数，所以我们可以写 p = 2s。将 p = 2s 代入方程 p^³ = 2q^³，我们得到 8s^³ = 2q^³，简化后得到 4s^³ = q^³。",
        "answer_symbols": [
            "√",
            "(",
            ")",
            "/",
            "³",
            "=",
            "²",
            "³",
            "³"
        ]
    },
    "1.8 36": {
        "question": "证明任一个有理数和任一个无理数之间都有一个无理数。",
        "answer": "The average of two different numbers is certainly always between the two numbers. Furthermore, the average a of a rational number x and an irrational number y must be irrational, because the equation a = (x + y) / 2 leads to y = 2a - x, which would be rational if a were rational.",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "/",
            "√"
        ]
    },
    "1.8 38": {
        "question": "证明或驳斥：如果你有一个盛有8加仑水的瓶和两个容量分别为5加仑和3加仑的空瓶，那么你可以通过不断地把一瓶水全部或部分倒入另一个瓶中而测量出4加仑的水。",
        "answer": "The solution is not unique, but here is one way to measure out four gallons. Fill the 5-gallon jug from the 8-gallon jug, leaving the contents (3, 5, 0), where we are using the ordered triple to record the amount of water in the 8-gallon jug, the 5-gallon jug, and the 3-gallon jug, respectively. Next, fill the 3-gallon jug from the 5-gallon jug, leaving (3, 2, 3). Pour the contents of the 3-gallon jug back into the 8-gallon jug, leaving (6, 2, 0). Empty the 5-gallon jug’s contents into the 3-gallon jug, leaving (6, 0, 2), and then fill the 5-gallon jug from the 8-gallon jug, producing (1, 5, 2). Finally, top off the 3-gallon jug from the 5-gallon jug, and we’ll have (1, 4, 3), with four gallons in the 5-gallon jug.",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "1.8 40 a)": {
        "question": "对下列这些整数验证3x+1猜想：16",
        "answer": "16 → 8 → 4 → 2 → 1",
        "answer_symbols": [
            "→"
        ]
    },
    "1.8 40 b)": {
        "question": "对下列这些整数验证3x+1猜想：11",
        "answer": "11 → 34 → 17 → 52 → 26 → 13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1",
        "answer_symbols": [
            "→"
        ]
    },
    "1.8 40 c)": {
        "question": "对下列这些整数验证3x+1猜想：35",
        "answer": "35 → 106 → 53 → 160 → 80 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1",
        "answer_symbols": [
            "→"
        ]
    },
    "1.8 40 d)": {
        "question": "对下列这些整数验证3x+1猜想：113",
        "answer": "113 → 340 → 170 → 85 → 256 → 128 → 64 → 32 → 16 → 8 → 4 → 2 → 1",
        "answer_symbols": [
            "→"
        ]
    },
    "1.8 42": {
        "question": "证明或驳斥：你能用骨牌拼接去掉所有四个角的标准棋盘。",
        "answer": "This is easily done, by laying the dominoes horizontally, three in the first and last rows and four in each of the other six rows.",
        "answer_symbols": []
    },
    "1.8 44": {
        "question": "证明或驳斥：你能用骨牌拼接去掉三个角的 5×5 的棋盘。",
        "answer": "Without loss of generality, we number the squares from 1 to 25, starting in the top row and proceeding left to right in each row; and we assume that squares 5 (upper right corner), 21 (lower left corner), and 25 (lower right corner) are the missing ones. We argue that there is no way to cover the remaining squares with dominoes. By symmetry, we can assume that there is a domino placed in 1-2 (using the obvious notation). If square 3 is covered by 3-8, then the following dominoes are forced in turn: 4-9, 10-15, 19-20, 23-24, 17-22, and 13-18, and now no domino can cover square 14. Therefore, we must use 3-4 along with 1-2. If we use all of 17-22, 18-23, and 19-24, then we are again quickly forced into a sequence of placements that lead to a contradiction. Therefore, without loss of generality, we can assume that we use 22-23, which then forces 19-24, 15-20, 9-10, 13-14, 7-8, 6-11, and 12-17, and we are stuck once again. This completes the proof by contradiction that no placement is possible.",
        "answer_symbols": [
            "-",
            "→"
        ]
    },
    "1.8 46": {
        "question": "证明：当从一个 8×8(如同正文中的着色)的棋盘去掉一块白的和一块黑的方格后，你能用骨牌拼接棋盘上留下的方格。",
        "answer": "The barriers shown in the diagram split the board into one continuous closed path of 64 squares, each adjacent to the next (for example, start at the upper left corner, go all the way to the right, then all the way down, then all the way to the left, and then weave your way back up to the starting point). Because each square in the path is adjacent to its neighbors, the colors alternate. Therefore, if we remove one black square and one white square, this closed path decomposes into two paths, each of which starts in one color and ends in the other color (and therefore has even length). Clearly, each such path can be covered by dominoes by starting at one end. This completes the proof.",
        "answer_symbols": []
    },
    "1.8 48": {
        "question": "如果存在，找出所有这样的拼板：从一个 8×8 的棋盘上删除其中一个方格后能用直三联骨牌拼接的拼板。",
        "answer": "If we study Figure 7, we see that by rotating or reflecting the board, we can make any square we wish nonwhite, with the exception of the squares with coordinates (3, 3), (3, 6), (6, 3), and (6, 6). Therefore, the same argument as was used in Example 22 shows that we cannot tile the board using straight triominoes if these specific squares are removed.",
        "answer_symbols": [
            ")",
            ",",
            "("
        ]
    },
    "1.8 50": {
        "question": "证明或驳斥：可以用直四联骨牌拼接 10×10 的棋盘。",
        "answer": "我们将使用10×10棋盘的四种颜色着色作为证明矛盾的基础，以显示不存在这样的覆盖。假设25个直四联骨牌可以覆盖棋盘。一些是水平放置，一些是垂直放置。因为瓷砖的数量是奇数，所以水平放置和垂直放置的瓷砖数量不能都是奇数，因此不妨假设水平放置的瓷砖数量是偶数。按顺序使用红色、蓝色、绿色、黄色这四种颜色对正方形进行着色，从左上角开始，按行依次进行，每行从左到右。那么很明显，每个水平放置的瓷砖会覆盖每种颜色的一个方格，而每个垂直放置的瓷砖会覆盖零个或两个每种颜色的方格。由此得出，在这种覆盖中，每种颜色的方格都被覆盖了偶数次。但这与每种颜色有25个方格的事实相矛盾。因此，不存在这样的着色。",
        "answer_symbols": [
            "×",
            "≠"
        ]
    },
    "1 Supplementary Exercises 2": {
        "question": "求复合命题 (p∨q)→(p∧r) 的真值表。",
        "answer": "真值表如下所示。\np q r p ∨ q p ∧ ¬r (p ∨ q)→(p ∧ ¬r)\nT T T T F F\nT T F T T T\nT F T T F F\nT F F T T T\nF T T T F F\nF T F T F F\nF F T F F T\nF F F F F T",
        "answer_symbols": [
            "∨",
            "∧",
            "¬",
            "→"
        ]
    },
    "1 Supplementary Exercises 3 a)": {
        "question": "证明下列复合命题为永真式。（a）(¬q∧(p→q))→¬p",
        "answer": "这个命题除非¬p为假，否则不能为假，所以p为真。如果p为真且q为真，则¬q ∧ (p → q)为假，因此条件语句为真。如果p为真且q为假，则p → q为假，所以¬q ∧ (p → q)为假，条件语句为真。",
        "answer_symbols": [
            "¬",
            "∧",
            "→"
        ]
    },
    "1 Supplementary Exercises 3 b)": {
        "question": "证明下列复合命题为永真式。（b）((p∨q)∧¬p)→q",
        "answer": "这个命题除非q为假，否则不能为假。如果q为假且p为真，则(p ∨ q) ∧ ¬p为假，条件语句为真。如果q为假且p为假，则(p ∨ q) ∧ ¬p为假，条件语句为真。",
        "answer_symbols": [
            "∨",
            "∧",
            "¬"
        ]
    },
    "1 Supplementary Exercises 4 a)": {
        "question": "给出下列条件语句的逆命题、反命题和逆否命题。（a）如果今天下雨，我就开车上班。",
        "answer": "逆命题为“如果我今天开车上班，那么会下雨。”反命题为“如果我今天不开车上班，那么不会下雨。”反逆命题为“如果今天不下雨，那么我不开车上班。”",
        "answer_symbols": []
    },
    "1 Supplementary Exercises 4 b)": {
        "question": "给出下列条件语句的逆命题、反命题和逆否命题。（b）如果 |x| = x，那么 x≥0。",
        "answer": "逆命题为“如果 x ≥ 0 那么 |x| = x。”反命题为“如果 x < 0 那么 |x| ≠ x。”反逆命题为“如果 |x| ≠ x，那么 x < 0。”",
        "answer_symbols": [
            "≥",
            "|",
            "<",
            "≠"
        ]
    },
    "1 Supplementary Exercises 4 c)": {
        "question": "给出下列条件语句的逆命题、反命题和逆否命题。（c）如果 n 大于 3，那么 n^² 大于 9。",
        "answer": "逆命题为“如果 n^² 大于 9，那么 n 大于 3。”反命题为“如果 n^² 不大于 9，那么 n 不大于 3。”反逆命题为“如果 n 不大于 3，那么 n^² 不大于 9。”",
        "answer_symbols": [
            "²",
            ">",
            "≤"
        ]
    },
    "1 Supplementary Exercises 5": {
        "question": "给定条件语句 p→q，找出其反命题的逆命题、反命题的反命题、逆否命题的逆命题。",
        "answer": "¬q → ¬p; p → q; ¬p → ¬q",
        "answer_symbols": [
            "¬",
            "→"
        ]
    },
    "1 Supplementary Exercises 6": {
        "question": "给定条件语句 p→q，找出其反命题的反命题、逆命题的反命题、逆否命题的反命题。",
        "answer": "p → q 的反逆命题是 ¬p → ¬q。因此反逆命题的反逆命题是 ¬¬p → ¬¬q，这等价于 p → q（原命题）。p → q 的逆命题是 q → p。因此逆命题的反逆命题是 ¬q → ¬p，这是原命题的反命题。反命题的反逆命题是 q → p，这与原命题的逆命题相同。",
        "answer_symbols": [
            "→",
            "¬"
        ]
    },
    "1 Supplementary Exercises 7": {
        "question": "用命题变量 p、q、r 和 s 构造一个复合命题，使它在这些命题变量中恰有三个为真时取真值，其他情况下为假。",
        "answer": "(p ∧ q ∧ r ∧ ¬s) ∨ (p ∧ q ∧ ¬r ∧ s) ∨ (p ∧ ¬q ∧ r ∧ s) ∨ (¬p ∧ q ∧ r ∧ s)",
        "answer_symbols": [
            "∧",
            "∨",
            "¬"
        ]
    },
    "1 Supplementary Exercises 8": {
        "question": "证明下列语句是不相容的：“如果 Sergei 得到该工作机会，那他将获得一笔签约奖金。”“如果 Sergei 得到该工作机会，那他将获得一份高薪。”“如果 Sergei 获得一笔签约奖金，那他将不会获得一份高薪。”“Sergei 得到了该工作机会。”",
        "answer": "Let t be \"Sergei takes the job offer\"; let b be \"Sergei gets a signing bonus\"; and let h be \"Sergei will receive a higher salary.\" The given statements are t → b, t → h, b → ¬h, and t. By modus ponens we can conclude b and h from the first two conditional statements, and therefore we can conclude ¬h from the third conditional statement. We now have the contradiction h ∧ ¬h, so these statements are inconsistent.",
        "answer_symbols": [
            "→",
            "¬",
            "∧"
        ]
    },
    "1 Supplementary Exercises 9": {
        "question": "证明下列语句是不相容的：“如果 Miranda 没有修过离散数学课程，那她将不能毕业。”“如果 Miranda 不能毕业，那她将不没有资格获得那份工作。”“如果 Miranda 读了这本书，那她将有资格获得那份工作。”“Miranda 没有修过离散数学课程，但她读过这本书。”",
        "answer": "将这些陈述转化为符号，使用明显的字母，我们有¬t → ¬g, ¬g → ¬q, r → q, 和 ¬t ∧ r。假设这些陈述是一致的。第四条陈述告诉我们¬t必须为真。因此，通过第一陈述的演绎推理，我们知道¬g为真，从而（从第二陈述）¬q为真。另外，第四条陈述告诉我们r必须为真，因此再次通过演绎推理（第三陈述）使q为真。这是矛盾的：q ∧ ¬q。因此，这些陈述是不一致的。",
        "answer_symbols": [
            "¬",
            "→",
            "∧"
        ]
    },
    "1 Supplementary Exercises 10": {
        "question": "假定在一个有三轮的伴随游戏中，老师首先给学生命题 p→q，然后命题 ¬(p∨r)∨q，最后是命题 q。学生 3 次回答的 8 种可能的序列中的哪个能通过测试？",
        "answer": "We make a table of the eight possibilities for p, q, and r, showing the truth values of the three propositions. If we look at the first row of the table, we see that if the student accepts all three propositions, then the resulting commitments are consistent, because the propositions are all true in this case in which p, q, and r are all true. Similarly, looking at the sixth row of the table, where p and r are false but q is true, we see that a student who accepts the first two propositions and rejects the third also wins. Scanning the entire table, we see that the winning answers are accept-accept-accept, reject-reject-accept, accept-accept-reject, and accept-reject-reject.",
        "answer_symbols": [
            "∨",
            "¬",
            "→",
            "∧"
        ]
    },
    "1 Supplementary Exercises 12": {
        "question": "试阐述为什么每一个伴随游戏均有一个获胜策略。",
        "answer": "As we saw from the examples in the previous exercises, one winning strategy is just to assume that all the variables are true and answer \"accept\" or \"reject\" according to whether the given proposition is true or false.",
        "answer_symbols": []
    },
    "1 Supplementary Exercises 14": {
        "question": "假定你遇见三个人，Anita、Boris 和 Carmen。如果 Anita 说“我是无赖，Boris 是骑士”，而 Boris 说“我们三人中恰有一人是骑士”，Anita、Boris 和 Carmen 分别是哪种人？",
        "answer": "A knight would never claim that she is a knave, so we know that Anita is a knave. Because she is lying and the first part of her conjunction is true, it must be the second part that is false, and so Bohan must be a knave. If Carmen were a knight, then Bohan’s statement would be true; because Bohan is a knave, we know that that cannot be, so we conclude that Carmen is also a knave.",
        "answer_symbols": [
            "¬",
            "∧"
        ]
    },
    "1 Supplementary Exercises 15": {
        "question": "假定在一个岛上住着三类人：骑士、无赖和普通人（也称为间谍）。骑士总是说真话，无赖总是说谎话，普通人有时说谎话有时说真话。侦探为了调查一宗罪案而询问了岛上的三个人，Amy、Brenda 和 Claire。侦探知道三人中有一人犯罪了，但不知是哪个人。此外，侦探还记录了如下供述。Amy 说：“我是清白的。”Brenda 说：“Amy 说的是真的。”Claire 说：“Brenda 不是普通人。”经过分析这些信息，侦探非常肯定地确认了罪犯。他是谁？",
        "answer": "布伦达",
        "answer_symbols": []
    },
    "1 Supplementary Exercises 16": {
        "question": "证明：如果 S 是一个命题，这里 S 是条件命题“如果 S 是真的，则独角兽是存在的”，那么“独角兽是存在的”是真的。证明 S 不能是一个命题（这个悖论称为是 Lob 悖论）。",
        "answer": "If S is a proposition, then it is either true or false. If S is false, then the statement \"If S is true, then unicorns live\" is vacuously true; but this statement is S, so we would have a contradiction. Therefore S is true, so the statement \"If S is true, then unicorns live\" is true and has a true hypothesis. Hence it has a true conclusion (modus ponens), and so unicorns live. But we know that unicorns do not live. It follows that S cannot be a proposition.",
        "answer_symbols": [
            "→",
            "¬"
        ]
    },
    "1 Supplementary Exercises 11": {
        "question": "假定在一个有四轮的伴随游戏中，老师首先给学生命题 ¬(p → (q ∧ r))，然后命题 p ∨ ¬q，然后命题 ¬r，最后是命题 (p ∧ r) ∨ (q → p)。学生四次回答的 16 种可能的序列中的哪个能通过测试？",
        "answer": "拒绝-接受-拒绝-接受，接受-接受-接受-接受，接受-接受-拒绝-接受，拒绝-拒绝-拒绝-拒绝，拒绝-拒绝-接受-拒绝，以及拒绝-接受-接受-接受",
        "answer_symbols": []
    },
    "1 Supplementary Exercises 13": {
        "question": "假定你遇见三个人，Aaron、Bohan 和 Crystal。如果 Aaron 说“我们都是无赖”，而 Bohan 说“我们三人中恰有一人是无赖”，那么你能确定 Aaron、Bohan 和 Crystal 分别是哪种人吗？",
        "answer": "亚伦是一个骗子而克莉丝塔尔是一个骑士；不能确定波汉的身份。",
        "answer_symbols": []
    },
    "1 Supplementary Exercises 17": {
        "question": "证明：假设“牙齿仙女是真人”，“牙齿仙女就不是真人”，结论“你能在彩虹尽头找到金子”是一个有效论证。这样能证明结论是真的吗？",
        "answer": "前提不能同时为真，因为它们是矛盾的。因此，当所有前提都为真时，结论也为真是（空洞地）真的，按定义这是一个有效的论证。因为前提不是同时为真，我们不能得出结论是真的。",
        "answer_symbols": []
    },
    "1 Supplementary Exercises 18": {
        "question": "假定命题 p_i 的真值为 T 当 i 是一个正奇数时，而为 F 当 i 是一个正偶数时。试找出 ∨(i=1)^(100) (p_i ∧ p_{i+1}) 和 ∧(i=1)^(100) (p_i ∨ p_{i+1}) 的真值。",
        "answer": "From the given information we know that p1, p3, p5,... are true and p2, p4, p6,... are false. Therefore pi ∧ pi+1 is always false, and so the disjunction ∨(from i=1 to 100)(pi ∧ pi+1) is also false. On the other hand, pi ∨ pi+1 is always true, and so the conjunction ∧(from i=1 to 100)(pi ∨ pi+1) is also true.",
        "answer_symbols": [
            "∧",
            "∨",
            "¬"
        ]
    },
    "1 Supplementary Exercises 19": {
        "question": "试用可满足性问题对 16 × 16 的数独谜题（用 4 × 4 的单元）进行建模。",
        "answer": "使用与第1.3节相同的命题来解决一个9×9的数独谜题，变量索引从1到16，而不是从1到9，并且类似地改变4×4区块的命题：∧3 r=0∧3 s=0∧16 n=1∨4 i=1∨4 j=1 p(4r+ i, 4s+j, n)。",
        "answer_symbols": [
            "∧",
            "∨",
            "+"
        ]
    },
    "1 Supplementary Exercises 20 a)": {
        "question": "令 P(x) 为语句“学生 x 会微积分”，Q(y) 为“y 班上有个学生会微积分”。用 P(x) 和 Q(y) 的量化式表示下列各项。某个学生会微积分。",
        "answer": "The answer is ∃xP(x) if we do not read any significance into the use of the plural, and ∃x∃y(P(x) ∧ P(y) ∧ x ≠ y) if we do.",
        "answer_symbols": [
            "∃",
            "∧",
            "≠"
        ]
    },
    "1 Supplementary Exercises 20 b)": {
        "question": "令 P(x) 为语句“学生 x 会微积分”，Q(y) 为“y 班上有个学生会微积分”。用 P(x) 和 Q(y) 的量化式表示下列各项。不是每个学生都会微积分。",
        "answer": "¬∀xP(x), or, equivalently, ∃x¬P(x)",
        "answer_symbols": [
            "¬",
            "∀",
            "∃"
        ]
    },
    "1 Supplementary Exercises 20 c)": {
        "question": "令 P(x) 为语句“学生 x 会微积分”，Q(y) 为“y 班上有个学生会微积分”。用 P(x) 和 Q(y) 的量化式表示下列各项。每个班上都有一个学生会微积分。",
        "answer": "∀yQ(y)",
        "answer_symbols": [
            "∀"
        ]
    },
    "1 Supplementary Exercises 20 d)": {
        "question": "令 P(x) 为语句“学生 x 会微积分”，Q(y) 为“y 班上有个学生会微积分”。用 P(x) 和 Q(y) 的量化式表示下列各项。每个班上的每个学生都会微积分。",
        "answer": "∀xP(x) (the class has nothing to do with it)",
        "answer_symbols": [
            "∀"
        ]
    },
    "1 Supplementary Exercises 20 e)": {
        "question": "令 P(x) 为语句“学生 x 会微积分”，Q(y) 为“y 班上有个学生会微积分”。用 P(x) 和 Q(y) 的量化式表示下列各项。至少有一个班上没有学生会微积分。",
        "answer": "∃y¬Q(y)",
        "answer_symbols": [
            "∃",
            "¬"
        ]
    },
    "1 Supplementary Exercises 21 a)": {
        "question": "令 P(m, n) 为语句“m 整除 n”，其中变量 m 和 n 的论域均为正整数集合。（所谓“m 整除 n”，是指存在某个整数 k 使得 n = km。）确定下列每条语句的真值。P(4, 5)",
        "answer": "F",
        "answer_symbols": []
    },
    "1 Supplementary Exercises 21 b)": {
        "question": "令 P(m, n) 为语句“m 整除 n”，其中变量 m 和 n 的论域均为正整数集合。（所谓“m 整除 n”，是指存在某个整数 k 使得 n = km。）确定下列每条语句的真值。P(2, 4)",
        "answer": "T",
        "answer_symbols": []
    },
    "1 Supplementary Exercises 21 c)": {
        "question": "令 P(m, n) 为语句“m 整除 n”，其中变量 m 和 n 的论域均为正整数集合。（所谓“m 整除 n”，是指存在某个整数 k 使得 n = km。）确定下列每条语句的真值。∀ m ∀ n P(m, n)",
        "answer": "F",
        "answer_symbols": []
    },
    "1 Supplementary Exercises 21 d)": {
        "question": "令 P(m, n) 为语句“m 整除 n”，其中变量 m 和 n 的论域均为正整数集合。（所谓“m 整除 n”，是指存在某个整数 k 使得 n = km。）确定下列每条语句的真值。∃ m ∀ n P(m, n)",
        "answer": "T",
        "answer_symbols": []
    },
    "1 Supplementary Exercises 21 e)": {
        "question": "令 P(m, n) 为语句“m 整除 n”，其中变量 m 和 n 的论域均为正整数集合。（所谓“m 整除 n”，是指存在某个整数 k 使得 n = km。）确定下列每条语句的真值。∃ n ∀ m P(m, n)",
        "answer": "F",
        "answer_symbols": []
    },
    "1 Supplementary Exercises 21 f)": {
        "question": "令 P(m, n) 为语句“m 整除 n”，其中变量 m 和 n 的论域均为正整数集合。（所谓“m 整除 n”，是指存在某个整数 k 使得 n = km。）确定下列每条语句的真值。∀ n P(1, n)",
        "answer": "T",
        "answer_symbols": []
    },
    "1 Supplementary Exercises 22": {
        "question": "试为 ∃ x ∃ y (x ≠ y ∧ ∀ z ((z = x) ∨ (z = y))) 中的量词找一个论域使得该语句为真。",
        "answer": "The given statement tells us that there are exactly two elements in the domain. Therefore the statement will be true as long as we choose the domain to be anything with size 2, such as the United States presidents named Bush.",
        "answer_symbols": []
    },
    "1 Supplementary Exercises 23": {
        "question": "试为 ∃ x ∃ y (x ≠ y ∧ ∀ z ((z = x) ∧ (z = y))) 中的量词找一个论域使得该语句为假。",
        "answer": "可能有许多答案。一个例子是美国参议员。",
        "answer_symbols": []
    },
    "1 Supplementary Exercises 25": {
        "question": "用存在和全称量词表达语句“每个人恰有两个亲生父母”，使用命题函数 P(x, y)，它表示“x 是 y 的亲生父母。”量词 ∃ 表示“恰好存在 n 个”，因此 ∃_n x P(x) 意思是在论域中恰好存在 n 个值使得 P(x) 为真。",
        "answer": "∀x ∃y∃z(y = z ∧∀w(P(w, x) ↔ (w= y ∨ w= z)))",
        "answer_symbols": [
            "∀",
            "∃",
            "=",
            "∧",
            "↔",
            "∨"
        ]
    },
    "1 Supplementary Exercises 27 a)": {
        "question": "确定下列语句的真值，其中论域由所有实数组成。∃_0 x (x^² = -1)",
        "answer": "¬∃x P(x)",
        "answer_symbols": [
            "¬",
            "∃"
        ]
    },
    "1 Supplementary Exercises 27 b)": {
        "question": "确定下列语句的真值，其中论域由所有实数组成。∃_1 x (| x | = 0)",
        "answer": "∃x(P(x) ∧ ∀y(P(y) → y= x))",
        "answer_symbols": [
            "∃",
            "∧",
            "∀",
            "→",
            "="
        ]
    },
    "1 Supplementary Exercises 27 c)": {
        "question": "确定下列语句的真值，其中论域由所有实数组成。∃_2 x (x^² = 2)",
        "answer": "∃x1 ∃x2(P(x1) ∧ P(x2) ∧ x1 = x2 ∧ ∀y(P(y) → (y= x1∨y= x2)))",
        "answer_symbols": [
            "∃",
            "∧",
            "=",
            "∀",
            "→",
            "∨"
        ]
    },
    "1 Supplementary Exercises 27 d)": {
        "question": "确定下列语句的真值，其中论域由所有实数组成。∃_3 x (x = | x |)",
        "answer": "∃x1 ∃ x2 ∃ x3(P(x1)∧P(x2) ∧P(x3)∧x1 = x2 ∧ x1 = x3 ∧ x2 = x3 ∧ ∀y(P(y) → (y= x1 ∨ y= x2 ∨ y= x3)))",
        "answer_symbols": [
            "∃",
            "∧",
            "=",
            "∀",
            "→",
            "∨"
        ]
    },
    "1 Supplementary Exercises 29": {
        "question": "令 P(x) 和 Q(x) 为命题函数。求证 ∃x(P(x)→Q(x)) 和 ∀xP(x)→∃xQ(x) 总是具有同样的真值。",
        "answer": "假设∃x(P(x) → Q(x))为真。那么对于某个x0，Q(x0)为真，在这种情况下∀x P(x) → ∃x Q(x)为真；或者对于某个x0，P(x0)为假，在这种情况下∀x P(x) → ∃x Q(x)为真。反之，假设∃x(P(x) → Q(x))为假。这意味着∀x(P(x) ∧ ¬ Q(x))为真，这暗示∀x P(x)和∀x(¬ Q(x))。后者等价于¬∃x Q(x)。因此，∀x P(x) → ∃x Q(x)为假。",
        "answer_symbols": [
            "∃",
            "→",
            "∀",
            "∧",
            "¬"
        ]
    },
    "1 Supplementary Exercises 31": {
        "question": "如果 ∀x∃yP(x, y) 为真，是否必然有 ∃x∀yP(x, y) 为真？",
        "answer": "不",
        "answer_symbols": []
    },
    "1 Supplementary Exercises 33": {
        "question": "用量词表示“班上每个学生都选修过数学学院里每个系的一些课程”。",
        "answer": "∀x ∀z ∃y T(x, y, z)，其中T(x, y, z)表示学生x在部门z选修了课程y，域分别是班级中的学生集合、该大学的课程集合和数学科学学院的部门集合。",
        "answer_symbols": [
            ")",
            "(",
            ",",
            "T",
            "∀",
            "∃"
        ]
    },
    "1 Supplementary Exercises 35": {
        "question": "用唯一量词表示语句：“本班里恰好一个学生选修了学校里恰好一门数学课”，然后再用量词而不用唯一量词表示这个语句。",
        "answer": "∃!x ∃!y T(x, y) 和 ∃x∀z((∃y∀w(T(z, w) ↔ w= y)) ↔ z= x)，其中T(x, y)表示学生x选修了课程y，域是这个班的所有学生。",
        "answer_symbols": [
            "∀",
            ")",
            "↔",
            "∃!",
            "(",
            "=",
            ",",
            "T",
            "∃"
        ]
    },
    "1 Supplementary Exercises 37": {
        "question": "使用推理规则证明如果前提 ∀x(P(x)→Q(x))、∀x(Q(x)→R(x)) 和 ¬R(a) 为真，其中 a 在论域中，那么结论 ¬P(a) 为真。",
        "answer": "由全称实例化得到P(a) → Q(a) 和 Q(a) → R(a)；然后由否定后件法得到¬ Q(a) 和 ¬P(a)。",
        "answer_symbols": [
            "¬",
            "→"
        ]
    },
    "1 Supplementary Exercises 39": {
        "question": "证明如果 x 是无理数且 x≥0，则 √x 是无理数。",
        "answer": "我们通过反证法证明如果√x是有理数，那么x也是有理数，假设自始至终x ≥ 0。假设√x= p/q是有理数，q ≠ 0。那么x=(√x)^2= p^2/q^2也是有理数（q^2再次非零）。",
        "answer_symbols": [
            "√",
            "=",
            "≠",
            "^"
        ]
    },
    "1 Supplementary Exercises 41": {
        "question": "证明存在一个整数 m 使得 m^²>10^1000。你的证明是构造性的还是非构造性的？",
        "answer": "我们可以通过构造性证明给出m= 10^500+1。那么m^2=(10^500+1)^2>(10^500)^2= 10^1000。",
        "answer_symbols": [
            "=",
            "+",
            "^",
            ">"
        ]
    },
    "1 Supplementary Exercises 42": {
        "question": "证明存在这样一个正整数：它可以有两种不同的方式写成正整数的平方和。（使用计算机或计算器来加速完成计算。）",
        "answer": "A constructive proof seems indicated. We can look for examples by hand or with a computer program. The smallest ones to be found are 50 = 5^² + 5^² = 1^² + 7^² and 65 = 4^² + 7^² = 1^² + 8^².",
        "answer_symbols": [
            "=",
            "^"
        ]
    },
    "1 Supplementary Exercises 43": {
        "question": "反驳如下命题：每个正整数均可表示为 8 个非负整数的立方和。",
        "answer": "23不能写成八个立方数的和。",
        "answer_symbols": []
    },
    "1 Supplementary Exercises 44": {
        "question": "反驳如下命题：每个正整数均可表示为至多两个非负整数的平方与一个非负整数的立方的和。",
        "answer": "We claim that the number 7 is not the sum of at most two squares and a cube. The first two positive squares are 1 and 4, and the first positive cube is 1, and these are the only numbers that could be used in forming the sum. Clearly no sum of three or fewer of these is 7. This counterexample disproves the statement.",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "1 Supplementary Exercises 45": {
        "question": "反驳如下命题：每个正整数均可表示为 36 个非负整数的 5 次幂的和。",
        "answer": "223不能写成36个五次幂的和。",
        "answer_symbols": []
    },
    "1 Supplementary Exercises 46": {
        "question": "假设以下定理的真实性：当 n 是非完全平方数的正整数时，√n 是个无理数。由此证明 √2 + √3 是无理数。",
        "answer": "We give a proof by contradiction. If √2 + √3 were rational, then so would be its square, which is 5 + 2√6. Subtracting 5 and dividing by 2 then shows that √6 is rational, but this contradicts the theorem we are told to assume.",
        "answer_symbols": [
            "√",
            "+",
            "÷",
            "="
        ]
    },
    "2.1 1 a)": {
        "question": "列出下列集合的成员。（a）{x | x 是使得 x^²=1 的实数}",
        "answer": "{−1,1}",
        "answer_symbols": []
    },
    "2.1 1 b)": {
        "question": "列出下列集合的成员。（b）{x | x 是小于 12 的正整数}",
        "answer": "{1,2,3,4,5,6,7,8,9,10,11}",
        "answer_symbols": []
    },
    "2.1 1 c)": {
        "question": "列出下列集合的成员。（c）{x | x 是一个整数的平方且 x<100}",
        "answer": "{0,1,4, 9, 16, 25, 36, 49, 64, 81}",
        "answer_symbols": []
    },
    "2.1 1 d)": {
        "question": "列出下列集合的成员。（d）{x | x 是整数且 x^²=2}",
        "answer": "空集",
        "answer_symbols": []
    },
    "2.1 3 a)": {
        "question": "对下面每一对集合，判断第一个是否是第二个的子集，第二个是否是第一个的子集，或者哪个也不是另一个的子集。（a）从纽约至新德里的航空公司航班的集合，从纽约至新德里的不经停航空公司航班的集合",
        "answer": "第一个是第二个的子集，但第二个不是第一个的子集。",
        "answer_symbols": []
    },
    "2.1 3 b)": {
        "question": "对下面每一对集合，判断第一个是否是第二个的子集，第二个是否是第一个的子集，或者哪个也不是另一个的子集。（b）说英语的人的集合，说中文的人的集合",
        "answer": "两个都不是对方的子集。",
        "answer_symbols": []
    },
    "2.1 3 c)": {
        "question": "对下面每一对集合，判断第一个是否是第二个的子集，第二个是否是第一个的子集，或者哪个也不是另一个的子集。（c）飞鼠的集合，会飞行的生物的集合",
        "answer": "第一个是第二个的子集，但第二个不是第一个的子集。",
        "answer_symbols": []
    },
    "2.1 5 a)": {
        "question": "判断下面每对集合是否相等。（a）{1, 3, 3, 3, 5, 5, 5, 5, 5}, {5, 3, 1}",
        "answer": "是",
        "answer_symbols": []
    },
    "2.1 5 b)": {
        "question": "判断下面每对集合是否相等。（b）{{1}}, {1, {1}}",
        "answer": "否",
        "answer_symbols": []
    },
    "2.1 5 c)": {
        "question": "判断下面每对集合是否相等。（c）∅, {∅}",
        "answer": "否",
        "answer_symbols": []
    },
    "2.1 7 a)": {
        "question": "对下面的每个集合，判断 2 是否为该集合的元素。（a）{x∈R | x 是大于 1 的整数}",
        "answer": "是",
        "answer_symbols": []
    },
    "2.1 7 b)": {
        "question": "对下面的每个集合，判断 2 是否为该集合的元素。（b）{x∈R | x 是一个整数的平方}",
        "answer": "否",
        "answer_symbols": []
    },
    "2.1 7 c)": {
        "question": "对下面的每个集合，判断 2 是否为该集合的元素。（c）{2, {2}}",
        "answer": "是",
        "answer_symbols": []
    },
    "2.1 7 d)": {
        "question": "对下面的每个集合，判断 2 是否为该集合的元素。（d）{{2}, {{2}}}",
        "answer": "否",
        "answer_symbols": []
    },
    "2.1 7 e)": {
        "question": "对下面的每个集合，判断 2 是否为该集合的元素。（e）{{2}, {2, {2}}}",
        "answer": "否",
        "answer_symbols": []
    },
    "2.1 7 f)": {
        "question": "对下面的每个集合，判断 2 是否为该集合的元素。（f）{{{2}}}",
        "answer": "否",
        "answer_symbols": []
    },
    "2.1 9 a)": {
        "question": "判断下列语句是真还是假。（a）0 ∈ ∅",
        "answer": "假",
        "answer_symbols": []
    },
    "2.1 9 b)": {
        "question": "判断下列语句是真还是假。（b）∅ ∈ {0}",
        "answer": "假",
        "answer_symbols": []
    },
    "2.1 9 c)": {
        "question": "判断下列语句是真还是假。（c）{0} ⊆ ∅",
        "answer": "假",
        "answer_symbols": []
    },
    "2.1 9 d)": {
        "question": "判断下列语句是真还是假。（d）∅ ⊆ {0}",
        "answer": "真",
        "answer_symbols": []
    },
    "2.1 9 e)": {
        "question": "判断下列语句是真还是假。（e）{0} ∈ {0}",
        "answer": "假",
        "answer_symbols": []
    },
    "2.1 9 f)": {
        "question": "判断下列语句是真还是假。（f）{0} ⊆ {0}",
        "answer": "假",
        "answer_symbols": []
    },
    "2.1 9 g)": {
        "question": "判断下列语句是真还是假。（g）{∅} ⊆ {∅}",
        "answer": "真",
        "answer_symbols": []
    },
    "2.1 11 a)": {
        "question": "判断下列语句是真还是假。（a）x ∈ {x}",
        "answer": "真",
        "answer_symbols": []
    },
    "2.1 11 b)": {
        "question": "判断下列语句是真还是假。（b）{x} ⊆ {x}",
        "answer": "真",
        "answer_symbols": []
    },
    "2.1 11 c)": {
        "question": "判断下列语句是真还是假。（c）{x} ∈ {x}",
        "answer": "假",
        "answer_symbols": []
    },
    "2.1 11 d)": {
        "question": "判断下列语句是真还是假。（d）{x} ∈ {{x}}",
        "answer": "真",
        "answer_symbols": []
    },
    "2.1 11 e)": {
        "question": "判断下列语句是真还是假。（e）∅ ⊆ {x}",
        "answer": "真",
        "answer_symbols": []
    },
    "2.1 11 f)": {
        "question": "判断下列语句是真还是假。（f）∅ ∈ {x}",
        "answer": "假",
        "answer_symbols": []
    },
    "2.1 13": {
        "question": "用文氏图说明在一年所有的月份集合中月份名称中不包含字母 R 的所有月份的集合。",
        "answer": "January May June July August November December September October March February April",
        "answer_symbols": []
    },
    "2.1 14": {
        "question": "用文氏图说明集合关系 A ⊆ B 和 B ⊆ C。",
        "answer": "我们将子集放在超集中。因此，答案如所示。",
        "answer_symbols": []
    },
    "2.1 15": {
        "question": "用文氏图说明集合关系 A ⊆ B 和 B ⊆ C。",
        "answer": "图中的某些区域内的点表示这些区域不是空集。",
        "answer_symbols": []
    },
    "2.1 16": {
        "question": "用文氏图说明集合关系 A ⊆ B 和 A ⊆ C。",
        "answer": "我们允许B和C重叠，因为我们没有被告知它们之间的关系。集合A必须是每个集合的子集，并且这迫使它被定位为如所示。我们实际上无法在图中显示子集关系的正确性，因为不知道位于B和C中的但不在A中的元素的位置——可能只有一个（同时在B和C中），或者它们可能位于B和/或C的其他部分之外。因此，答案如所示，但附加条件是B中至少有一个元素不在A中，C中至少有一个元素不在A中。",
        "answer_symbols": [
            "⊆"
        ]
    },
    "2.1 17": {
        "question": "假定 A、B 和 C 为集合，且 A ⊆ B，B ⊆ C。证明 A ⊆ C。",
        "answer": "Suppose that x ∈ A. Because A ⊆ B, this implies that x ∈ B. Because B ⊆ C, we see that x ∈ C. Because x ∈ A implies that x ∈ C, it follows that A ⊆ C.",
        "answer_symbols": [
            "∈",
            "⊆"
        ]
    },
    "2.1 18": {
        "question": "找出两个集合 A 和 B，使得 A ∈ B 且 A ⊆ B。",
        "answer": "由于空集是每个集合的子集，我们需要取一个包含空集作为元素的集合B。因此，我们可以让A=空集，B={空集}作为最简单的例子。",
        "answer_symbols": [
            "∅",
            "⊆"
        ]
    },
    "2.1 19 a)": {
        "question": "下列各集合的基数是什么。（a）{a}",
        "answer": "1",
        "answer_symbols": []
    },
    "2.1 19 b)": {
        "question": "下列各集合的基数是什么。（b）{{a}}",
        "answer": "1",
        "answer_symbols": []
    },
    "2.1 19 c)": {
        "question": "下列各集合的基数是什么。（c）{a, {a}}",
        "answer": "2",
        "answer_symbols": []
    },
    "2.1 19 d)": {
        "question": "下列各集合的基数是什么。（d）{a, {a}, {a, {a}}}",
        "answer": "3",
        "answer_symbols": []
    },
    "2.1 20 a)": {
        "question": "下列各集合的基数是什么。（a）∅",
        "answer": "空集没有任何元素，所以其基数为0。",
        "answer_symbols": [
            "∅"
        ]
    },
    "2.1 20 b)": {
        "question": "下列各集合的基数是什么。（b）{{∅}}",
        "answer": "这个集合有一个元素（空集），所以其基数为1。",
        "answer_symbols": [
            "∅"
        ]
    },
    "2.1 20 c)": {
        "question": "下列各集合的基数是什么。（c）{∅, {∅}}",
        "answer": "这个集合有两个元素，所以其基数为2。",
        "answer_symbols": []
    },
    "2.1 20 d)": {
        "question": "下列各集合的基数是什么。（d）{∅, {∅}, {∅, {∅}}}",
        "answer": "这个集合有三个元素，所以其基数为3。",
        "answer_symbols": []
    },
    "2.1 21 a)": {
        "question": "找出下列各集合的幂集。（a）{a}",
        "answer": "{∅, {a}} ",
        "answer_symbols": [
            "}",
            "{",
            "∅",
            "∈"
        ]
    },
    "2.1 21 b)": {
        "question": "找出下列各集合的幂集。（b）{a, b}",
        "answer": "{∅, {a}, {b}, {a, b}} ",
        "answer_symbols": [
            "}",
            "{",
            "∅",
            "∈"
        ]
    },
    "2.1 21 c)": {
        "question": "找出下列各集合的幂集。（c）{∅, {∅}}",
        "answer": "{∅, {∅}, {{∅}}, {∅, {∅}}}",
        "answer_symbols": [
            "}",
            "{",
            "∅",
            "∈"
        ]
    },
    "2.1 22": {
        "question": "如果 A 和 B 是两个集合，且有相同的幂集，能否得出结论 A = B？",
        "answer": "所有集合X的幂集中的集合的并集必须恰好是X。换句话说，我们可以从X的幂集中唯一地恢复X。因此，答案是肯定的。",
        "answer_symbols": [
            "∪",
            "⊆"
        ]
    },
    "2.1 23 a)": {
        "question": "下列集合各有多少个元素。（a）P({a, b, {a, b}})",
        "answer": "8",
        "answer_symbols": []
    },
    "2.1 23 b)": {
        "question": "下列集合各有多少个元素。（b）P({∅, a, {a}, {{a}}})",
        "answer": "16",
        "answer_symbols": []
    },
    "2.1 23 c)": {
        "question": "下列集合各有多少个元素。（c）P(P(∅))",
        "answer": "2",
        "answer_symbols": []
    },
    "2.1 24 a)": {
        "question": "判断下列各集合是否为某集合的幂集。（a）∅",
        "answer": "每个集合的幂集至少包括空集，因此幂集不能是空集。因此，空集不是任何集合的幂集。",
        "answer_symbols": [
            "∅",
            "⊆"
        ]
    },
    "2.1 24 b)": {
        "question": "判断下列各集合是否为某集合的幂集。（b）{∅, {a}}",
        "answer": "这是{a}的幂集。",
        "answer_symbols": [
            "⊆"
        ]
    },
    "2.1 24 c)": {
        "question": "判断下列各集合是否为某集合的幂集。（c）{∅, {a}, {∅, a}}",
        "answer": "这个集合有三个元素。由于3不是2的幂，这个集合不能是任何集合的幂集。",
        "answer_symbols": [
            "⊆"
        ]
    },
    "2.1 24 d)": {
        "question": "判断下列各集合是否为某集合的幂集。（d）{∅, {a}, {b}, {a, b}}",
        "answer": "这是{a, b}的幂集。",
        "answer_symbols": [
            "⊆"
        ]
    },
    "2.1 25": {
        "question": "证明 P(A) ⊆ P(B) 当且仅当 A ⊆ B。",
        "answer": "For the “if” part, given A ⊆ B, we want to show that that P(A) ⊆ P(B), i.e., if C ⊆ A then C ⊆ B. But this follows directly from Exercise 17. For the “only if” part, given that P(A) ⊆ P(B), we want to show that A ⊆ B. Suppose a ∈ A. Then {a} ⊆ A, so {a} ∈ P(A). Since P(A) ⊆ P(B), it follows that {a} ∈ P(B), which means that {a} ⊆ B. But this implies a ∈ B, as desired.",
        "answer_symbols": [
            "⊆",
            "∈",
            "P"
        ]
    },
    "2.1 26": {
        "question": "证明如果 A ⊆ C 并且 B ⊆ D，则 A × B ⊆ C × D。",
        "answer": "我们需要证明A × B的每个元素也是C × D的元素。根据定义，A × B的一个典型元素是一个对(a, b)，其中a ∈ A且b ∈ B。因为A ⊆ C，我们知道a ∈ C；同样，b ∈ D。因此(a, b) ∈ C × D。",
        "answer_symbols": [
            "×",
            "∈",
            "⊆"
        ]
    },
    "2.1 28": {
        "question": "令 A 为一所大学的数学系所开设课程的集合，B 为该大学所有数学教授的集合，笛卡儿积 A × B 是什么？给出一个例子说明这个笛卡儿积如何使用。",
        "answer": "根据定义，它是所有有序对(c, p)的集合，其中c是一门课程，p是一位教授。这个集合的元素是数学系的可能教学安排。",
        "answer_symbols": [
            "×",
            "∈"
        ]
    },
    "2.1 29": {
        "question": "笛卡儿积 A × B × C 是什么，其中 A 是所有航线的集合，B 和 C 都是所有美国城市的集合？给出一个例子说明这个笛卡儿积如何使用。",
        "answer": "The set of triples (a, b, c), where a is an airline and b and c are cities. A useful subset of this set is the set of triples (a, b, c) for which a flies between b and c.",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "2.1 30": {
        "question": "假定 A × B = ∅，其中 A 和 B 为集合。你能得出什么结论？",
        "answer": "我们可以得出结论A=空集或B=空集。为了证明这一点，假设A和B都不是空集。那么会有元素a ∈ A和b ∈ B。这将给出至少一个元素，即(a, b)，在A × B中，所以A × B不会是空集。这一矛盾表明A或B（或两者）是空集。",
        "answer_symbols": [
            "∅",
            "∈",
            "×"
        ]
    },
    "2.1 31": {
        "question": "令 A 为集合。证明 ∅ × A = A × ∅ = ∅。",
        "answer": "∅ × A = {(x, y) | x 属于 ∅ 且 y 属于 A} = ∅ = {(x, y) | x 属于 A 且 y 属于 ∅} = A × ∅",
        "answer_symbols": [
            "=",
            "∅",
            "∈",
            "×"
        ]
    },
    "2.1 32 a)": {
        "question": "令 A = {a, b, c}，B = {x, y}，C = {0, 1}。求（a）A × B × C",
        "answer": "{(a, x, 0), (a, x, 1), (a, y, 0), (a, y, 1), (b, x, 0), (b, x, 1), (b, y, 0), (b, y, 1), (c, x, 0), (c, x, 1), (c, y, 0), (c, y, 1)}",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "2.1 32 b)": {
        "question": "令 A = {a, b, c}，B = {x, y}，C = {0, 1}。求（b）C × B × A",
        "answer": "{(0, x, a), (0, x, b), (0, x, c), (0, y, a), (0, y, b), (0, y, c), (1, x, a), (1, x, b), (1, x, c), (1, y, a), (1, y, b), (1, y, c)}",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "2.1 32 c)": {
        "question": "令 A = {a, b, c}，B = {x, y}，C = {0, 1}。求（c）C × A × B",
        "answer": "{(0, a, x), (0, a, y), (0, b, x), (0, b, y), (0, c, x), (0, c, y), (1, a, x), (1, a, y), (1, b, x), (1, b, y), (1, c, x), (1, c, y)}",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "2.1 32 d)": {
        "question": "令 A = {a, b, c}，B = {x, y}，C = {0, 1}。求（d）B × B × B",
        "answer": "{(x, x, x), (x, x, y), (x, y, x), (x, y, y), (y, x, x), (y, x, y), (y, y, x), (y, y, y)}",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "2.1 34 a)": {
        "question": "求 A^² 如果（a）A = {a}",
        "answer": "{(a, a, a)}",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "2.1 34 b)": {
        "question": "求 A^² 如果（b）A = {0, a}",
        "answer": "{(0, 0, 0), (0, 0, a), (0, a, 0), (0, a, a), (a, 0, 0), (a, 0, a), (a, a, 0), (a, a, a)}",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "2.1 35": {
        "question": "如果 A 有 m 个元素，B 有 n 个元素，则 A × B 有多少个不同的元素？",
        "answer": "mn",
        "answer_symbols": [
            "n",
            "m",
            "×"
        ]
    },
    "2.1 36": {
        "question": "如果 A 有 m 个元素，B 有 n 个元素，C 有 p 个元素，则 A × B × C 有多少个不同的元素？",
        "answer": "The set A × B × C consists of ordered triples (a, b, c) with a ∈ A, b ∈ B, and c ∈ C. There are m choices for the first coordinate. For each of these, there are n choices for the second coordinate, giving us mn choices for the first two coordinates. For each of these, there are p choices for the third coordinate, giving us mnp choices in all. Therefore A × B × C has mnp elements. This is an application of the product rule (see Chapter 6).",
        "answer_symbols": [
            "×",
            "∈",
            "(",
            ")",
            ","
        ]
    },
    "2.1 37": {
        "question": "如果 A 有 m 个元素且 n 是一个正整数，则 A^n 有多少个不同的元素？",
        "answer": "mn",
        "answer_symbols": [
            "n",
            "m",
            "×"
        ]
    },
    "2.1 38": {
        "question": "证明 A × B ≠ B × A 除非 A = B，其中 A 和 B 均为非空集合。",
        "answer": "Suppose A' = B and neither A nor B is empty. We must prove that A × B' = B × A. Since A' = B, either we can find an element x that is in A but not B, or vice versa. The two cases are similar, so without loss of generality, let us assume that x is in A but not B. Also, since B is not empty, there is some element y ∈ B. Then (x, y) is in A × B by definition, but it is not in B × A since x ∉ B. Therefore A × B' ≠ B × A.",
        "answer_symbols": [
            "'",
            "=",
            "×",
            "∈",
            "(",
            ")",
            "≠"
        ]
    },
    "2.1 39": {
        "question": "试解释为什么 A × B × C 和 (A × B) × C 不同。",
        "answer": "The elements of A × B × C consist of 3-tuples (a, b, c), where a ∈ A, b ∈ B, and c ∈ C, whereas the elements of (A × B) × C look like ((a, b), c)—ordered pairs, the first coordinate of which is again an ordered pair.",
        "answer_symbols": [
            "×",
            "∈",
            "(",
            ")",
            ","
        ]
    },
    "2.1 40": {
        "question": "试解释为什么 (A × B) × (C × D) 和 A × (B × C) × D 不同。",
        "answer": "The only difference between (A × B) × (C × D) and A × (B × C) × D is parentheses, so for all practical purposes one can think of them as essentially the same thing. By Definition 8, the elements of (A × B) × (C × D) consist of ordered pairs (x, y), where x ∈ A × B and y ∈ C × D, so the typical element of (A × B) × (C × D) looks like ((a, b), (c, d)). By Definition 9, the elements of A × (B × C) × D consist of 3-tuples (a, x, d), where a ∈ A, d ∈ D, and x ∈ B × C, so the typical element of A × (B × C) × D looks like (a, (b, c), d). The structures ((a, b), (c, d)) and (a, (b, c), d) are different, even if they convey exactly the same information (the first is a pair, and the second is a 3-tuple). To be more precise, there is a natural one-to-one correspondence between (A × B) × (C × D) and A × (B × C) × D given by ((a, b), (c, d)) ↔ (a, (b, c), d).",
        "answer_symbols": [
            "×",
            "∈",
            "(",
            ")",
            ",",
            "↔"
        ]
    },
    "2.1 42 a)": {
        "question": "将下列量化表达式翻译成汉语句子并确定其真值。（a）∃ x ∈ R (x^² = -1)",
        "answer": "There is a real number whose cube is -1. This is true, since x = -1 is a solution.",
        "answer_symbols": [
            "=",
            "^"
        ]
    },
    "2.1 42 b)": {
        "question": "将下列量化表达式翻译成汉语句子并确定其真值。（b）∃ x ∈ Z (x + 1 > x)",
        "answer": "There is an integer such that the number obtained by adding 1 to it is greater than the integer. This is true—in fact, every integer satisfies this statement.",
        "answer_symbols": [
            "+",
            ">"
        ]
    },
    "2.1 42 c)": {
        "question": "将下列量化表达式翻译成汉语句子并确定其真值。（c）∀ x ∈ Z (x - 1 ∈ Z)",
        "answer": "For every integer, the number obtained by subtracting 1 is again an integer. This is true.",
        "answer_symbols": [
            "-"
        ]
    },
    "2.1 42 d)": {
        "question": "将下列量化表达式翻译成汉语句子并确定其真值。（d）∀ x ∈ Z (x^² ∈ Z)",
        "answer": "The square of every integer is an integer. This is true.",
        "answer_symbols": [
            "^"
        ]
    },
    "2.1 44 a)": {
        "question": "给出以下各个谓词的真值集合，这里域是整数集合。（a）P(x): x^² ≥ 1",
        "answer": "It is exactly the positive integers that satisfy this inequality. Therefore the truth set is {x ∈ Z | x^³ ≥ 1} = {x ∈ Z | x ≥ 1} = {1, 2, 3, ...}.",
        "answer_symbols": [
            "∈",
            "|",
            "≥",
            "(",
            ")",
            "^"
        ]
    },
    "2.1 44 b)": {
        "question": "给出以下各个谓词的真值集合，这里域是整数集合。（b）Q(x): x^² = 2",
        "answer": "The square roots of 2 are not integers, so the truth set is the empty set, ∅.",
        "answer_symbols": [
            "√",
            "∅"
        ]
    },
    "2.1 44 c)": {
        "question": "给出以下各个谓词的真值集合，这里域是整数集合。（c）R(x): x < x^²",
        "answer": "Negative integers certainly satisfy this inequality, as do all positive integers greater than 1. However, 0 < 0^² and 1 < 1^². Thus the truth set is {x ∈ Z | x < x^²} = {x ∈ Z | x ≠ 0 ∧ x ≠ 1} = {..., -3, -2, -1, 2, 3, ...}.",
        "answer_symbols": [
            "∈",
            "|",
            "<",
            "≠",
            "∧",
            "^"
        ]
    },
    "2.1 45": {
        "question": "序偶所定义的性质是两个序偶相等当且仅当其第一个元素相等且第二个元素相等。令人惊奇的是，我们可以用集合论的基本概念来构造序偶，从而取代用序偶作为最基本的概念。证明如果将序偶 (a, b) 定义为 {{a}, {a, b}}，那么 (a, b) = (c, d) 当且仅当 a = c 且 b = d。[提示：首先证明 {{a}, {a, b}} = {{c}, {c, d}} 当且仅当 a = c 且 b = d。]",
        "answer": "We must show that {{a}, {a, b}} = {{c}, {c, d}} if and only if a = c and b = d. The “if” part is immediate. So assume these two sets are equal. First, consider the case when a = b. Then {{a}, {a, b}} contains exactly two elements, one of which contains one element. Thus, {{c}, {c, d}} must have the same property, so c = d and {c} is the element containing exactly one element. Hence, {a} = {c}, which implies that a = c. Also, the two-element sets {a, b} and {c, d} must be equal. Because a = c and a = b, it follows that b = d. Second, suppose that a ≠ b. Then {{a}, {a, b}} = {{a}}, a set with one element. Hence, {{c}, {c, d}} has only one element, which can happen only when c = d, and the set is {{c}}. It then follows that a = c and b = d.",
        "answer_symbols": [
            "{",
            "}",
            "=",
            "≠"
        ]
    },
    "2.1 46 a)": {
        "question": "这里介绍罗素悖论 (Russel’s paradox)。令 S 为这样的集合，它包含集合 x 如果集合 x 不属于它自己，即 S = {x | x ∉ x}。（a）证明从 S 是它自己的一个元素的假设能推出矛盾。",
        "answer": "If S ∈ S, then by the defining condition for S we conclude that S ∉ S, a contradiction.",
        "answer_symbols": [
            "∈",
            "∉"
        ]
    },
    "2.1 46 b)": {
        "question": "这里介绍罗素悖论 (Russel’s paradox)。令 S 为这样的集合，它包含集合 x 如果集合 x 不属于它自己，即 S = {x | x ∉ x}。（b）证明从 S 不是它自己的一个元素的假设能推出矛盾。从 a) 和 b) 可知，S 不可能是由其定义所描述的集合。这一悖论是可以避免的，只要对集合可以拥有的元素类型加以限制即可。",
        "answer": "If S ∉ S, then by the defining condition for S we conclude that it is not the case that S ∉ S (otherwise S would be an element of S), again a contradiction.",
        "answer_symbols": [
            "∉"
        ]
    },
    "2.1 47": {
        "question": "给出一个能列出一个有限集合所有子集的步骤。",
        "answer": "Let S = {a1, a2, ..., an}. Represent each subset of S with a bit string of length n, where the i-th bit is 1 if and only if ai ∈ S. To generate all subsets of S, list all 2^n bit strings of length n (for instance, in increasing order), and write down the corresponding subsets.",
        "answer_symbols": [
            "{",
            "}",
            "∈",
            "^"
        ]
    },
    "2.2 1 a)": {
        "question": "令 A 为住在离学校一英里以内的所有学生的集合，B 是走路上学的所有学生的集合。描述下列各集合中的学生：A ∩ B",
        "answer": "生活在学校一英里范围内并且步行上课的学生的集合",
        "answer_symbols": []
    },
    "2.2 1 b)": {
        "question": "令 A 为住在离学校一英里以内的所有学生的集合，B 是走路上学的所有学生的集合。描述下列各集合中的学生：A ∪ B",
        "answer": "生活在学校一英里范围内或步行上课（或两者都做）的学生的集合",
        "answer_symbols": []
    },
    "2.2 1 c)": {
        "question": "令 A 为住在离学校一英里以内的所有学生的集合，B 是走路上学的所有学生的集合。描述下列各集合中的学生：A - B",
        "answer": "生活在学校一英里范围内但不步行上课的学生的集合",
        "answer_symbols": []
    },
    "2.2 1 d)": {
        "question": "令 A 为住在离学校一英里以内的所有学生的集合，B 是走路上学的所有学生的集合。描述下列各集合中的学生：B - A",
        "answer": "步行上课但住在学校一英里以外的学生的集合",
        "answer_symbols": []
    },
    "2.2 2 a)": {
        "question": "假定 A 是学校二年级学生的集合，B 是学校选修离散数学课的学生集合。用 A 和 B 来表示下列各个集合。学校选修离散数学课的二年级学生集合。",
        "answer": "A ∩ B",
        "answer_symbols": [
            "∩"
        ]
    },
    "2.2 2 b)": {
        "question": "假定 A 是学校二年级学生的集合，B 是学校选修离散数学课的学生集合。用 A 和 B 来表示下列各个集合。学校不选修离散数学课的二年级学生集合。",
        "answer": "A ∩ B, which is the same as A - B",
        "answer_symbols": [
            "∩",
            "-"
        ]
    },
    "2.2 2 c)": {
        "question": "假定 A 是学校二年级学生的集合，B 是学校选修离散数学课的学生集合。用 A 和 B 来表示下列各个集合。学校二年级学生或选修离散数学课的学生的集合。",
        "answer": "A ∪ B",
        "answer_symbols": [
            "∪"
        ]
    },
    "2.2 2 d)": {
        "question": "假定 A 是学校二年级学生的集合，B 是学校选修离散数学课的学生集合。用 A 和 B 来表示下列各个集合。学校里既不在二年级学生也不选修离散数学课的学生的集合。",
        "answer": "A ∪ B",
        "answer_symbols": [
            "∪"
        ]
    },
    "2.2 3 a)": {
        "question": "令 A = {1, 2, 3, 4, 5}, B = {0, 3, 6}。求 A ∪ B",
        "answer": "{0, 1, 2, 3, 4, 5, 6}",
        "answer_symbols": []
    },
    "2.2 3 b)": {
        "question": "令 A = {1, 2, 3, 4, 5}, B = {0, 3, 6}。求 A ∩ B",
        "answer": "{3}",
        "answer_symbols": []
    },
    "2.2 3 c)": {
        "question": "令 A = {1, 2, 3, 4, 5}, B = {0, 3, 6}。求 A - B",
        "answer": "{1, 2, 4, 5}",
        "answer_symbols": []
    },
    "2.2 3 d)": {
        "question": "令 A = {1, 2, 3, 4, 5}, B = {0, 3, 6}。求 B - A",
        "answer": "{0, 6}",
        "answer_symbols": []
    },
    "2.2 4 a)": {
        "question": "令 A = {a, b, c, d, e}, B = {a, b, c, d, e, f, g, h}。求 A ∪ B",
        "answer": "{a, b, c, d, e, f, g, h} = B",
        "answer_symbols": [
            "="
        ]
    },
    "2.2 4 b)": {
        "question": "令 A = {a, b, c, d, e}, B = {a, b, c, d, e, f, g, h}。求 A ∩ B",
        "answer": "{a, b, c, d, e} = A",
        "answer_symbols": [
            "="
        ]
    },
    "2.2 4 c)": {
        "question": "令 A = {a, b, c, d, e}, B = {a, b, c, d, e, f, g, h}。求 A - B",
        "answer": "There are no elements in A that are not in B, so the answer is Ø",
        "answer_symbols": [
            "Ø"
        ]
    },
    "2.2 4 d)": {
        "question": "令 A = {a, b, c, d, e}, B = {a, b, c, d, e, f, g, h}。求 B - A",
        "answer": "{f, g, h}",
        "answer_symbols": []
    },
    "2.2 5": {
        "question": "证明表 1 中的补集律：A̅ = A",
        "answer": "A = {x | ¬(x 属于 A)} = {x | ¬(¬x 属于 A)} = {x | x 属于 A} = A",
        "answer_symbols": [
            "{",
            "¬",
            "|",
            "=",
            "}",
            "∈"
        ]
    },
    "2.2 6 a)": {
        "question": "证明表 1 中的恒等律：A ∪ ∅ = A",
        "answer": "A ∪ Ø = { x | x ∈ A ∨ x ∈ Ø} = { x | x ∈ A ∨ F} = { x | x ∈ A} = A",
        "answer_symbols": [
            "∪",
            "∈",
            "∨",
            "F",
            "="
        ]
    },
    "2.2 6 b)": {
        "question": "证明表 1 中的恒等律：A ∩ U = A",
        "answer": "A ∩ U = { x | x ∈ A ∧ x ∈ U} = { x | x ∈ A ∧ T} = { x | x ∈ A} = A",
        "answer_symbols": [
            "∩",
            "∈",
            "∧",
            "T",
            "="
        ]
    },
    "2.2 7 a)": {
        "question": "证明表 1 中的支配律：A ∪ U = U",
        "answer": "A ∪ U = {x | x 属于 A 或 x 属于 U} = {x | x 属于 A 或 T} = {x | T} = U",
        "answer_symbols": [
            "∪",
            "{",
            "}",
            "|",
            "∈",
            "∨",
            "T"
        ]
    },
    "2.2 8 a)": {
        "question": "证明表 1 中的幂等律：A ∪ A = A",
        "answer": "A ∪ A = { x | x ∈ A ∨ x ∈ A} = { x | x ∈ A} = A",
        "answer_symbols": [
            "∪",
            "∈",
            "∨",
            "="
        ]
    },
    "2.2 8 b)": {
        "question": "证明表 1 中的幂等律：A ∩ A = A",
        "answer": "A ∩ A = { x | x ∈ A ∧ x ∈ A} = { x | x ∈ A} = A",
        "answer_symbols": [
            "∩",
            "∈",
            "∧",
            "="
        ]
    },
    "2.2 9 a)": {
        "question": "证明表 1 中的交换律：A ∪ B = B ∪ A",
        "answer": "A ∪ A = {x | x 属于 A 或 x 属于 A} = U",
        "answer_symbols": [
            "∪",
            "{",
            "}",
            "|",
            "∈",
            "∨"
        ]
    },
    "2.2 9 b)": {
        "question": "证明表 1 中的交换律：A ∩ B = B ∩ A",
        "answer": "A ∩ A = {x | x 属于 A 且 x 属于 A} = ∅",
        "answer_symbols": [
            "∩",
            "{",
            "}",
            "|",
            "∈",
            "∧",
            "∅"
        ]
    },
    "2.2 10 a)": {
        "question": "证明：A - ∅ = A",
        "answer": "A - Ø = { x | x ∈ A ∧ x ∉ Ø} = { x | x ∈ A ∧ T} = { x | x ∈ A} = A",
        "answer_symbols": [
            "-",
            "∈",
            "∉",
            "∧",
            "T",
            "="
        ]
    },
    "2.2 10 b)": {
        "question": "证明：∅ - A = ∅",
        "answer": "Ø - A = { x | x ∈ Ø ∧ x ∉ A} = { x | F ∧ x ∉ A} = { x | F} = Ø",
        "answer_symbols": [
            "-",
            "∈",
            "∉",
            "∧",
            "F",
            "="
        ]
    },
    "2.2 11 a)": {
        "question": "令 A 和 B 为两个集合。试证明表 1 中的交换律：A ∪ B = B ∪ A",
        "answer": "A ∪ B = {x | x 属于 A 或 x 属于 B} = {x | x 属于 B 或 x 属于 A} = B ∪ A",
        "answer_symbols": [
            "∪",
            "{",
            "}",
            "|",
            "∈",
            "∨"
        ]
    },
    "2.2 11 b)": {
        "question": "令 A 和 B 为两个集合。试证明表 1 中的交换律：A ∩ B = B ∩ A",
        "answer": "A ∩ B = {x | x 属于 A 且 x 属于 B} = {x | x 属于 B 且 x 属于 A} = B ∩ A",
        "answer_symbols": [
            "∩",
            "{",
            "}",
            "|",
            "∈",
            "∧"
        ]
    },
    "2.2 12": {
        "question": "证明表 1 中的第一个吸收律：如果 A 和 B 为两个集合，那么 A ∪ (A ∩ B) = A",
        "answer": "We will show that these two sets are equal by showing that each is a subset of the other. Suppose x ∈ A ∪ (A ∩ B). Then x ∈ A or x ∈ A ∩ B by the definition of union. In the former case, we have x ∈ A, and in the latter case we have x ∈ A and x ∈ B by the definition of intersection; thus in any event, x ∈ A, so we have proved that the left-hand side is a subset of the right-hand side. Conversely, let x ∈ A. Then by the definition of union, x ∈ A ∪ (A ∩ B) as well. Thus we have shown that the right-hand side is a subset of the left-hand side.",
        "answer_symbols": [
            "∪",
            "∈",
            "∩",
            "∨",
            "∧"
        ]
    },
    "2.2 13": {
        "question": "证明表 1 中的第二个吸收律：如果 A 和 B 为两个集合，那么 A ∩ (A ∪ B) = A",
        "answer": "Suppose x ∈ A ∩ (A ∪ B). Then x ∈ A and x ∈ A ∪ B by the definition of intersection. Because x ∈ A, we have proved that the left-hand side is a subset of the right-hand side. Conversely, let x ∈ A. Then by the definition of union, x ∈ A ∪ B as well. Therefore x ∈ A ∩ (A ∪ B) by the definition of intersection, so the right-hand side is a subset of the left-hand side.",
        "answer_symbols": [
            "∈",
            "∩",
            "∪"
        ]
    },
    "2.2 14": {
        "question": "如果 A - B = {1, 5, 7, 8}, B - A = {2, 10}, 且 A ∩ B = {3, 6, 9}, 试找出集合 A 和 B",
        "answer": "Since A = (A - B) ∪ (A ∩ B), we conclude that A = {1, 5, 7, 8} ∪ {3, 6, 9} = {1, 3, 5, 6, 7, 8, 9}. Similarly B = (B - A) ∪ (A ∩ B) = {2, 10} ∪ {3, 6, 9} = {2, 3, 6, 9, 10}.",
        "answer_symbols": [
            "=",
            "-",
            "∪",
            "∩"
        ]
    },
    "2.2 15 a)": {
        "question": "通过以下两种方式证明表 1 中的第一个德·摩根律：如果 A 和 B 为两个集合，那么 A̅ ∪ B̅ = A ∩ B̅ 通过证明两边互为子集。",
        "answer": "x 属于 A ∪ B ≡ x 属于 A ∪ B ≡ ¬(x 属于 A 或 x 属于 B) ≡ ¬(x 属于 A) 且 ¬(x 属于 B) ≡ x 属于 A 且 x 属于 B ≡ x 属于 A 且 x 属于 B ≡ x 属于 A ∩ B",
        "answer_symbols": [
            "∪",
            "∈",
            "¬",
            "∨",
            "∧",
            "≡",
            "∩"
        ]
    },
    "2.2 16 a)": {
        "question": "令 A 和 B 为集合。证明：(A ∩ B) ⊆ A",
        "answer": "If x is in A ∩ B, then perforce it is in A (by definition of intersection).",
        "answer_symbols": [
            "∈",
            "∩"
        ]
    },
    "2.2 16 b)": {
        "question": "令 A 和 B 为集合。证明：A ⊆ (A ∪ B)",
        "answer": "If x is in A, then perforce it is in A ∪ B (by definition of union).",
        "answer_symbols": [
            "∈",
            "∪"
        ]
    },
    "2.2 16 c)": {
        "question": "令 A 和 B 为集合。证明：A - B ⊆ A",
        "answer": "If x is in A - B, then perforce it is in A (by definition of difference).",
        "answer_symbols": [
            "∈",
            "-"
        ]
    },
    "2.2 16 d)": {
        "question": "令 A 和 B 为集合。证明：A ∩ (B - A) = ∅",
        "answer": "If x ∈ A then x ∉ B - A. Therefore there can be no elements in A ∩ (B - A), so A ∩ (B - A) = Ø.",
        "answer_symbols": [
            "∈",
            "∉",
            "∩",
            "-",
            "Ø"
        ]
    },
    "2.2 16 e)": {
        "question": "令 A 和 B 为集合。证明：A ∪ (B - A) = A ∪ B",
        "answer": "The left-hand side consists precisely of those things that are either elements of A or else elements of B but not A, in other words, things that are elements of either A or B (or, of course, both). This is precisely the definition of the right-hand side.",
        "answer_symbols": [
            "∈",
            "∪",
            "∩",
            "-"
        ]
    },
    "2.2 17 a)": {
        "question": "如果 A, B, C 为集合，试用下面的方法证明 A ∩ B ∩ C = A ∪ B ∪ C（a）通过证明两边互为子集。",
        "answer": "x 属于 A ∩ B ∩ C ≡ x 属于 A ∩ B ∩ C ≡ x 属于 A 或 x 属于 B 或 x 属于 C ≡ x 属于 A 或 x 属于 B 或 x 属于 C ≡ x 属于 A ∪ B ∪ C",
        "answer_symbols": [
            "∩",
            "∈",
            "∨",
            "≡",
            "∪"
        ]
    },
    "2.2 18 a)": {
        "question": "令 A, B, C 为集合。证明：（a）(A ∪ B) ⊆ (A ∪ B ∪ C)",
        "answer": "Suppose that x ∈ A ∪ B. Then either x ∈ A or x ∈ B. In either case, certainly x ∈ A ∪ B ∪ C. This establishes the desired inclusion.",
        "answer_symbols": [
            "∈",
            "∪",
            "∨"
        ]
    },
    "2.2 18 b)": {
        "question": "令 A, B, C 为集合。证明：（b）(A ∩ B ∩ C) ⊆ (A ∩ B)",
        "answer": "Suppose that x ∈ A ∩ B ∩ C. Then x is in all three of these sets. In particular, it is in both A and B and therefore in A ∩ B, as desired.",
        "answer_symbols": [
            "∈",
            "∩"
        ]
    },
    "2.2 18 c)": {
        "question": "令 A, B, C 为集合。证明：（c）(A - B) - C = A - C",
        "answer": "Suppose that x ∈ (A - B) - C. Then x is in A - B but not in C. Since x ∈ A - B, we know that x ∈ A (we also know that x ∉ B, but that won’t be used here). Since we have established that x ∈ A but x ∉ C, we have proved that x ∈ A - C.",
        "answer_symbols": [
            "∈",
            "-",
            "∩"
        ]
    },
    "2.2 18 d)": {
        "question": "令 A, B, C 为集合。证明：（d）(A - C) ∩ (C - B) = ∅",
        "answer": "To show that the set given on the left-hand side is empty, it suffices to assume that x is some element in that set and derive a contradiction, thereby showing that no such x exists. So suppose that x ∈ (A - C) ∩ (C - B). Then x ∈ A - C and x ∈ C - B. The first of these statements implies by definition that x ∉ C, while the second implies that x ∈ C. This is impossible, so our proof by contradiction is complete.",
        "answer_symbols": [
            "∈",
            "∩",
            "-",
            "∅"
        ]
    },
    "2.2 18 e)": {
        "question": "令 A, B, C 为集合。证明：（e）(B - A) ∪ (C - A) = (B ∪ C) - A",
        "answer": "To establish the equality, we need to prove inclusion in both directions. To prove that (B - A) ∪ (C - A) ⊆ (B ∪ C) - A, suppose that x ∈ (B - A) ∪ (C - A). Then either x ∈ (B - A) or x ∈ (C - A). Without loss of generality, assume x ∈ (B - A). Then x ∈ B and x ∉ A. Since x ∈ B, it follows that x ∈ B ∪ C. Since x ∉ A, it follows that x ∈ (B ∪ C) - A. Therefore, (B - A) ∪ (C - A) ⊆ (B ∪ C) - A.",
        "answer_symbols": [
            "∈",
            "∪",
            "∩",
            "-",
            "⊆"
        ]
    },
    "2.2 19 a)": {
        "question": "证明如果 A 和 B 为集合，则（a）A - B = A ∩ B̄",
        "answer": "两边等于 {x | x ∈ A ∧ x ∈ B}",
        "answer_symbols": [
            "∈",
            "∧"
        ]
    },
    "2.2 19 b)": {
        "question": "证明如果 A 和 B 为集合，则（b）(A ∩ B) ∪ (A ∩ B̄) = A",
        "answer": "A = A ∩ U = A ∩ (B ∪ B) = (A ∩ B) ∪ (A ∩ B)",
        "answer_symbols": [
            "=",
            "∩",
            "∪"
        ]
    },
    "2.2 20 a)": {
        "question": "证明如果 A 和 B 为集合且 A ⊆ B，则（a）A ∪ B = B",
        "answer": "To show that A U B = B if A ⊆ B: - It is always the case that B ⊆ A U B. - We need to show that A U B ⊆ B. - If x ∈ A U B, then x ∈ A or x ∈ B. - If x ∈ A, then x ∈ B (because A ⊆ B). - If x ∈ B, then x ∈ B. - In either case, x ∈ B.",
        "answer_symbols": [
            "⊆",
            "∪",
            "∈",
            "∉"
        ]
    },
    "2.2 20 b)": {
        "question": "证明如果 A 和 B 为集合且 A ⊆ B，则（b）A ∩ B = A",
        "answer": "To show that A ∩ B = A if A ⊆ B: - It is always the case that A ∩ B ⊆ A. - We need to show that A ⊆ A ∩ B. - If x ∈ A, then x ∈ B (because A ⊆ B). - Therefore, x ∈ A ∩ B.",
        "answer_symbols": [
            "⊆",
            "∩",
            "∈"
        ]
    },
    "2.2 21": {
        "question": "证明表 1 中的第一结合律：如果 A, B, C 为集合，那么 A ∪ (B ∪ C) = (A ∪ B) ∪ C。",
        "answer": "x ∈ A ∪ (B ∪ C) ≡ (x ∈ A) ∨ (x ∈ (B ∪ C)) ≡ (x ∈ A) ∨ (x ∈ B ∨ x ∈ C) ≡ (x ∈ A ∨ x ∈ B) ∨ (x ∈ C) ≡ x ∈ (A ∪ B) ∪ C",
        "answer_symbols": [
            "∈",
            "∪",
            "∨",
            "≡"
        ]
    },
    "2.2 22": {
        "question": "证明表 1 中的第二结合律：如果 A, B, C 为集合，那么 A ∩ (B ∩ C) = (A ∩ B) ∩ C。",
        "answer": "To show that A ∩ (B ∩ C) = (A ∩ B) ∩ C: 1. First Direction: A ∩ (B ∩ C) ⊆ (A ∩ B) ∩ C - If x ∈ A ∩ (B ∩ C), then x ∈ A and x ∈ B ∩ C. - Therefore, x ∈ A, x ∈ B, and x ∈ C. - Since x ∈ A and x ∈ B, x ∈ A ∩ B. - Since x ∈ A ∩ B and x ∈ C, x ∈ (A ∩ B) ∩ C. 2. Second Direction: (A ∩ B) ∩ C ⊆ A ∩ (B ∩ C) - If x ∈ (A ∩ B) ∩ C, then x ∈ A ∩ B and x ∈ C. - Therefore, x ∈ A, x ∈ B, and x ∈ C. - Since x ∈ A and x ∈ B ∩ C, x ∈ A ∩ (B ∩ C). The argument in the other direction is nearly identical.",
        "answer_symbols": [
            "⊆",
            "∩",
            "∈"
        ]
    },
    "2.2 23": {
        "question": "证明表 1 中的第一分配律：如果 A, B, C 为集合，那么 A ∪ (B ∩ C) = (A ∪ B) ∩ (A ∪ C)。",
        "answer": "x ∈ A ∪ (B ∩ C) ≡ (x ∈ A) ∨ (x ∈ (B ∩ C)) ≡ (x ∈ A) ∨ (x ∈ B ∧ x ∈ C) ≡ (x ∈ A ∨ x ∈ B) ∧ (x ∈ A ∨ x ∈ C) ≡ x ∈ (A ∪ B) ∩ (A ∪ C)",
        "answer_symbols": [
            "∈",
            "∪",
            "∩",
            "∨",
            "∧",
            "≡"
        ]
    },
    "2.2 24": {
        "question": "令 A, B, C 为集合。证明 (A - B) - C = (A - C) - (B - C)。",
        "answer": "To show that A - (B U C) = (A - B) - C: 1. First Direction: A - (B U C) ⊆ (A - B) - C - Suppose x ∈ A - (B U C). - Then x ∈ A and x ∉ B U C. - Therefore, x ∉ B and x ∉ C. - Since x ∈ A and x ∉ C, x ∈ A - C. - Since x ∉ B, x ∉ B - C. - Therefore, x ∈ (A - C) - (B - C). 2. Second Direction: (A - B) - C ⊆ A - (B U C) - Suppose x ∈ (A - B) - C. - Then x ∈ A - B and x ∉ C. - Therefore, x ∈ A and x ∉ B. - Since x ∉ B and x ∉ C, x ∉ B U C. - Therefore, x ∈ A - (B U C).",
        "answer_symbols": [
            "∪",
            "U",
            "-",
            "∈",
            "∩",
            "⊆",
            "∉"
        ]
    },
    "2.2 25 a)": {
        "question": "令 A = {0, 2, 4, 6, 8, 10}, B = {0, 1, 2, 3, 4, 5, 6}, C = {4, 5, 6, 7, 8, 9, 10}。求：（a）A ∩ B ∩ C",
        "answer": "{4, 6}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "2.2 25 b)": {
        "question": "令 A = {0, 2, 4, 6, 8, 10}, B = {0, 1, 2, 3, 4, 5, 6}, C = {4, 5, 6, 7, 8, 9, 10}。求：（b）A ∪ B ∪ C",
        "answer": "{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "2.2 25 c)": {
        "question": "令 A = {0, 2, 4, 6, 8, 10}, B = {0, 1, 2, 3, 4, 5, 6}, C = {4, 5, 6, 7, 8, 9, 10}。求：（c）(A ∪ B) ∩ C",
        "answer": "{4, 5, 6, 8, 10}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "2.2 25 d)": {
        "question": "令 A = {0, 2, 4, 6, 8, 10}, B = {0, 1, 2, 3, 4, 5, 6}, C = {4, 5, 6, 7, 8, 9, 10}。求：（d）(A ∩ B) ∪ C",
        "answer": "{0, 2, 4, 5, 6, 7, 8, 9, 10}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "2.2 27 a)": {
        "question": "画出以下集合 A, B, C, D 的每个组合的文氏图：（a）A ∩ (B - C)",
        "answer": "双重阴影部分是所需的集合| A | B |  \n   | --- | --- |  \n   | C | C |",
        "answer_symbols": []
    },
    "2.2 27 b)": {
        "question": "画出以下集合 A, B, C, D 的每个组合的文氏图：（b）(A ∩ B) ∪ (A ∩ C)",
        "answer": "所需的集合是整个阴影部分 B A C",
        "answer_symbols": []
    },
    "2.2 27 c)": {
        "question": "画出以下集合 A, B, C, D 的每个组合的文氏图：（c）(A ∩ B̄) ∪ (A ∩ C̄)",
        "answer": "所需的集合是整个阴影部分| A | |  \n   | B | |  \n   | --- | --- |  \n   | | | |  \n   | | | |  \n   | C | |",
        "answer_symbols": []
    },
    "2.2 29 a)": {
        "question": "如果集合 A 与 B 具有下列性质，你能就 A 和 B 说什么？（a）A ∪ B = A",
        "answer": "B ⊆ A",
        "answer_symbols": [
            "⊆"
        ]
    },
    "2.2 29 b)": {
        "question": "如果集合 A 与 B 具有下列性质，你能就 A 和 B 说什么？（b）A ∩ B = A",
        "answer": "A ⊆ B",
        "answer_symbols": [
            "⊆"
        ]
    },
    "2.2 29 c)": {
        "question": "如果集合 A 与 B 具有下列性质，你能就 A 和 B 说什么？（c）A - B = A",
        "answer": "A ∩ B = ∅",
        "answer_symbols": [
            "∩",
            "=",
            "∅"
        ]
    },
    "2.2 29 d)": {
        "question": "如果集合 A 与 B 具有下列性质，你能就 A 和 B 说什么？（d）A ∩ B = B ∩ A",
        "answer": "没有，因为这总是成立的",
        "answer_symbols": []
    },
    "2.2 29 e)": {
        "question": "如果集合 A 与 B 具有下列性质，你能就 A 和 B 说什么？（e）A - B = B - A",
        "answer": "A = B",
        "answer_symbols": [
            "="
        ]
    },
    "2.2 30 a)": {
        "question": "如果集合 A, B, C 满足下述条件，你能断定 A = B 吗？（a）A ∪ C = B ∪ C",
        "answer": "We cannot conclude that A = B. For instance, if A and B are both subsets of C, then this equation will always hold, and A need not equal B.",
        "answer_symbols": [
            "=",
            "⊆"
        ]
    },
    "2.2 30 b)": {
        "question": "如果集合 A, B, C 满足下述条件，你能断定 A = B 吗？（b）A ∩ C = B ∩ C",
        "answer": "We cannot conclude that A = B; let C = ∅, for example.",
        "answer_symbols": [
            "=",
            "∅"
        ]
    },
    "2.2 30 c)": {
        "question": "如果集合 A, B, C 满足下述条件，你能断定 A = B 吗？（c）A ∪ C = B ∪ C 并且 A ∩ C = B ∩ C",
        "answer": "By putting the two conditions together, we can now conclude that A = B. By symmetry, it suffices to prove that A ⊆ B. Suppose that x ∈ A. There are two cases. If x ∈ C, then x ∈ A ∩ C = B ∩ C, which forces x ∈ B. On the other hand, if x ∉ C, then because x ∈ A ∪ C = B ∪ C, we must have x ∈ B.",
        "answer_symbols": [
            "=",
            "⊆",
            "∩",
            "∪",
            "∈",
            "∉"
        ]
    },
    "2.2 31": {
        "question": "令 A 和 B 为全集 U 的子集。证明 A ⊆ B 当且仅当 B̄ ⊆ Ā。集合 A 和 B 的对称差，用 A ⊕ B 表示，是属于 A 或属于 B 但不同时属于 A 与 B 的元素组成的集合。",
        "answer": "A ⊆ B ≡ ∀x (x ∈ A → x ∈ B) ≡ ∀x (x ∈ B → x ∈ A) ≡ ∀x (x ∈ B → x ∈ A) ≡ B ⊆ A",
        "answer_symbols": [
            "⊆",
            "∀",
            "∈",
            "→",
            "≡"
        ]
    },
    "2.2 32": {
        "question": "求 {1, 3, 5} 和 {1, 2, 3} 的对称差。",
        "answer": "This is the set of elements in exactly one of these sets, namely {2, 5}.",
        "answer_symbols": [
            "{",
            "}"
        ]
    },
    "2.2 33": {
        "question": "求某校主修计算机科学的学生集合与主修数学的学生集合的对称差。",
        "answer": "计算机科学专业的学生但不是数学专业的学生，或者是数学专业的学生但不是计算机科学专业的学生",
        "answer_symbols": []
    },
    "2.2 34": {
        "question": "画出集合 A 与 B 的对称差的文氏图。",
        "answer": "The figure is as shown; we shade that portion of A that is not in B and that portion of B that is not in A.",
        "answer_symbols": []
    },
    "2.2 35": {
        "question": "证明 A ⊕ B = (A ∪ B) - (A ∩ B)。",
        "answer": "元素在 (A ∪ B) - (A ∩ B) 中，如果它在 A 和 B 的并集中但不在 A 和 B 的交集中，这意味着它在 A 或 B 中但不在 A 和 B 都在其中。这正是元素属于 A ⊕ B 的意思",
        "answer_symbols": [
            "∪",
            "∩",
            "-",
            "⊕"
        ]
    },
    "2.2 36": {
        "question": "证明 A ⊕ B = (A - B) ∪ (B - A)。",
        "answer": "There are precisely two ways that an item can be in either A or B but not both. It can be in A but not B (which is equivalent to saying that it is in A - B), or it can be in B but not A (which is equivalent to saying that it is in B - A). Thus an element is in A ⊕ B if and only if it is in (A - B) ∪ (B - A).",
        "answer_symbols": [
            "-",
            "∪",
            "⊕"
        ]
    },
    "2.2 37 a)": {
        "question": "证明如果 A 是全集 U 的子集，则（a）A ⊕ A = ∅",
        "answer": "A ⊕ A = (A - A) ∪ (A - A) = ∅ ∪ ∅ = ∅",
        "answer_symbols": [
            "⊕",
            "-",
            "∪",
            "∅"
        ]
    },
    "2.2 37 b)": {
        "question": "证明如果 A 是全集 U 的子集，则（b）A ⊕ ∅ = A",
        "answer": "A ⊕ ∅ = (A - ∅) ∪ (∅ - A) = A ∪ ∅ = A",
        "answer_symbols": [
            "⊕",
            "-",
            "∪",
            "∅"
        ]
    },
    "2.2 37 c)": {
        "question": "证明如果 A 是全集 U 的子集，则（c）A ⊕ U = Ā",
        "answer": "A ⊕ U = (A - U) ∪ (U - A) = ∅ ∪ A = A",
        "answer_symbols": [
            "⊕",
            "-",
            "∪",
            "∅"
        ]
    },
    "2.2 37 d)": {
        "question": "证明如果 A 是全集 U 的子集，则（d）A ⊕ Ā = U",
        "answer": "A ⊕ A = (A - A) ∪ (A - A) = A ∪ A = U",
        "answer_symbols": [
            "⊕",
            "-",
            "∪"
        ]
    },
    "2.2 38 a)": {
        "question": "如果 A 和 B 为集合，证明：（a）A ⊕ B = B ⊕ A",
        "answer": "This is clear from the symmetry (between A and B) in the definition of symmetric difference.",
        "answer_symbols": [
            "⊕"
        ]
    },
    "2.2 38 b)": {
        "question": "如果 A 和 B 为集合，证明：（b）(A ⊕ B) ⊕ B = A",
        "answer": "We prove two things. To show that A ⊆ (A ⊕ B) ⊕ B, suppose x ∈ A. If x ∈ B, then x ∉ A ⊕ B, so x is an element of the right-hand side. On the other hand, if x ∉ B, then x ∈ A ⊕ B, so again x is in the right-hand side. Conversely, suppose x is an element of the right-hand side. There are two cases. If x ∉ B, then necessarily x ∈ A ⊕ B, whence x ∈ A. If x ∈ B, then necessarily x ∉ A ⊕ B, and the only way for that to happen (since x ∈ B) is for x to be in A.",
        "answer_symbols": [
            "⊆",
            "∈",
            "∉",
            "⊕"
        ]
    },
    "2.2 39": {
        "question": "如果 A ⊕ B = A，你能就集合 A 和 B 说什么？",
        "answer": "B = ∅",
        "answer_symbols": [
            "=",
            "∅"
        ]
    },
    "2.2 40": {
        "question": "判断对称差是否满足结合律，即如果 A, B, C 为集合，是否有 A ⊕ (B ⊕ C) = (A ⊕ B) ⊕ C 成立？",
        "answer": "这是一个恒等式；每一边都由在集合 A、B 和 C 中出现奇数次的事物组成。",
        "answer_symbols": [
            "A",
            "B",
            "C"
        ]
    },
    "2.2 41": {
        "question": "假定 A, B, C 为集合，使得 A ⊕ C = B ⊕ C。是否必定有 A = B？",
        "answer": "是",
        "answer_symbols": []
    },
    "2.2 42": {
        "question": "如果 A、B、C、D 为集合，(A⊕B)⊕(C⊕D)=(A⊕C)⊕(B⊕D)是否成立?",
        "answer": "这是一个恒等式；每一边都由在集合 A、B、C 和 D 中出现奇数次的事物组成。",
        "answer_symbols": [
            "A",
            "B",
            "C",
            "D"
        ]
    },
    "2.2 43": {
        "question": "如果 A、B、C、D 为集合，(A⊕B)⊕(C⊕D)=(A⊕D)⊕(B⊕C)是否成立?",
        "answer": "是",
        "answer_symbols": []
    },
    "2.2 44": {
        "question": "证明如果 A 和 B 是有限集，则 A∪B 是有限集。",
        "answer": "有限集是具有 k 个元素的集合，其中 k 是某个自然数。假设 A 有 n 个元素，B 有 m 个元素。那么 A ∪ B 中的元素数量最多为 n + m（可能更少，因为 A ∩ B 可能非空）。因此，根据定义，A ∪ B 是有限的。",
        "answer_symbols": [
            "∪",
            "∩"
        ]
    },
    "2.2 45": {
        "question": "证明如果 A 是无限集，则只要 B 是一个集合，A∪B 也是一个无限集。",
        "answer": "如果 A ∪ B 是有限的，那么它将有 n 个元素，对于某个自然数 n。但是 A 已经有超过 n 个元素，因为它无限，并且 A ∪ B 包含 A 的所有元素，所以 A ∪ B 有超过 n 个元素。这个矛盾表明 A ∪ B 必须是无限的",
        "answer_symbols": [
            "∪"
        ]
    },
    "2.2 46": {
        "question": "证明：如果 A、B、C 为集合，则|A∪B∪C|=|A|+|B|+|C|-|A∩B|-|A∩C|-|B∩C|+|A∩B∩C|（这是第 8 章将要学习的包含排除原理的一个特例。）",
        "answer": "要计算 A ∪ B ∪ C 中的元素，我们按以下步骤进行。首先，我们计算每个集合中的元素并相加。这当然给出了并集中所有的元素，但我们会多算一些。每个在 A ∩ B、A ∩ C 和 B ∩ C 中的元素都被计数了两次。因此，我们减去这些交集的基数以弥补多算的部分。最后，我们补偿得有点过头了，因为 A ∩ B ∩ C 中的元素现在被计数了三次并减去了三次。我们通过加上 A ∩ B ∩ C 的基数来调整。",
        "answer_symbols": [
            "∪",
            "∩"
        ]
    },
    "2.2 47 a)": {
        "question": "令 A_i={1, 2, 3, …, i}, i=1, 2, 3, …。求 a) ∪A_i",
        "answer": "{1, 2, 3, ..., n}",
        "answer_symbols": [
            "{",
            "}",
            ",",
            "..."
        ]
    },
    "2.2 47 b)": {
        "question": "令 A_i={1, 2, 3, …, i}, i=1, 2, 3, …。求 b) ∩A_i",
        "answer": "{1}",
        "answer_symbols": [
            "{",
            "}"
        ]
    },
    "2.2 49 a)": {
        "question": "令 A_i 为所有长度不超过 i 的非空位串 (即长度至少为 1) 的集合。求 a) ∪A_i",
        "answer": "A_n",
        "answer_symbols": []
    },
    "2.2 49 b)": {
        "question": "令 A_i 为所有长度不超过 i 的非空位串 (即长度至少为 1) 的集合。求 b) ∩A_i",
        "answer": "{0, 1}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "2.2 50 a)": {
        "question": "试求 ∪∞i=1 A_i 和 ∩∞i=1 A_i，如果对于任意正整数 i，a) A_i={i, i+1, i+2, …}。",
        "answer": "随着 i 的增加，集合变小：... ⊂ A₃ ⊂ A₂ ⊂ A₁。所有集合都是 A₁ 的子集，A₁ 是正整数集 Z^⁺。因此，∪∞i=1 Aᵢ = Z^⁺。每个正整数至少被排除在一个集合之外（实际上是无限多个），所以 ∩∞i=1 Aᵢ = Ø。",
        "answer_symbols": [
            "⊂",
            "∪",
            "∩",
            "Ø"
        ]
    },
    "2.2 50 b)": {
        "question": "试求 ∪∞i=1 A_i 和 ∩∞i=1 A_i，如果对于任意正整数 i，b) A_i={0, i}。",
        "answer": "所有集合都是自然数集 N（非负整数）的子集。数字 0 在每个集合中，每个正整数都在恰好一个集合中，因此 ∪∞i=1 Aᵢ = N 且 ∩∞i=1 Aᵢ = {0}。",
        "answer_symbols": [
            "∪",
            "∩"
        ]
    },
    "2.2 50 c)": {
        "question": "试求 ∪∞i=1 A_i 和 ∩∞i=1 A_i，如果对于任意正整数 i，c) A_i=(0, i)，即满足 0<x<i 的实数 x 的集合。",
        "answer": "随着 i 的增加，集合变大：A₁ ⊂ A₂ ⊂ A₃ ... 所有集合都是正实数集 R^⁺ 的子集，每个正实数最终都会被包括在内，因此 ∪∞i=1 Aᵢ = R^⁺。因为 A₁ 是每个其他集合的子集，所以 ∩∞i=1 Aᵢ = A₁ = (0, 1)（0 到 1 之间的所有实数，不包括 0 和 1）。",
        "answer_symbols": [
            "⊂",
            "∪",
            "∩"
        ]
    },
    "2.2 50 d)": {
        "question": "试求 ∪∞i=1 A_i 和 ∩∞i=1 A_i，如果对于任意正整数 i，d) A_i=(i, ∞)，即满足 x>i 的实数 x 的集合。",
        "answer": "这次，像部分 (a) 一样，随着 i 的增加，集合变小：... ⊂ A₃ ⊂ A₂ ⊂ A₁。因为 A₁ 包括所有其他集合，所以 ∪∞i=1 A₁ = (1, ∞)（所有大于 1 的实数）。每个数字最终都会被排除在外，所以 ∩∞i=1 Aᵢ = Ø。注意 ∞ 不是实数，所以我们不能写成 ∩∞i=1 Aᵢ = {∞}。",
        "answer_symbols": [
            "⊂",
            "∪",
            "∩",
            "Ø"
        ]
    },
    "2.2 51 a)": {
        "question": "试求 ∪∞i=1 A_i 和 ∩∞i=1 A_i，如果对于任意正整数 i，a) A_i={-i, -i+1, …, -1, 0, 1, …, i-1, i}。",
        "answer": "Z, {-1, 0, 1}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "2.2 51 b)": {
        "question": "试求 ∪∞i=1 A_i 和 ∩∞i=1 A_i，如果对于任意正整数 i，b) A_i={-i, i}。",
        "answer": "Z - {0}, ∅",
        "answer_symbols": [
            "-",
            "{",
            "}",
            "∅"
        ]
    },
    "2.2 51 c)": {
        "question": "试求 ∪∞i=1 A_i 和 ∩∞i=1 A_i，如果对于任意正整数 i，c) A_i=[-i, i]，即满足 -i≤x≤i 的实数 x 的集合。",
        "answer": "R, [-1, 1]",
        "answer_symbols": [
            "[",
            "]",
            ","
        ]
    },
    "2.2 51 d)": {
        "question": "试求 ∪∞i=1 A_i 和 ∩∞i=1 A_i，如果对于任意正整数 i，d) A_i=[i, ∞)，即满足 x≥i 的实数 x 的集合。",
        "answer": "[1, ∞), ∅",
        "answer_symbols": [
            "[",
            ")",
            "∅"
        ]
    },
    "2.2 52 a)": {
        "question": "假定全集 U={1, 2, 3, 4, 5, 6, 7, 8, 9, 10}。用位串表示下列各集合，假定如果 i 属于该集合，则其位串的第 i 位为 1，否则第 i 位为 0。a) {3, 4, 5}",
        "answer": "00 1110 0000",
        "answer_symbols": []
    },
    "2.2 52 b)": {
        "question": "假定全集 U={1, 2, 3, 4, 5, 6, 7, 8, 9, 10}。用位串表示下列各集合，假定如果 i 属于该集合，则其位串的第 i 位为 1，否则第 i 位为 0。b) {1, 3, 6, 10}",
        "answer": "10 1001 0001",
        "answer_symbols": []
    },
    "2.2 52 c)": {
        "question": "假定全集 U={1, 2, 3, 4, 5, 6, 7, 8, 9, 10}。用位串表示下列各集合，假定如果 i 属于该集合，则其位串的第 i 位为 1，否则第 i 位为 0。c) {2, 3, 4, 7, 8, 9}",
        "answer": "01 1100 1110",
        "answer_symbols": []
    },
    "2.2 53 a)": {
        "question": "使用上题中的同一个全集，求下列位串各自代表的集合。a) 11 1100 1111",
        "answer": "{1, 2, 3, 4, 7, 8, 9, 10}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "2.2 53 b)": {
        "question": "使用上题中的同一个全集，求下列位串各自代表的集合。b) 01 0111 1000",
        "answer": "{2, 4, 5, 6, 7}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "2.2 53 c)": {
        "question": "使用上题中的同一个全集，求下列位串各自代表的集合。c) 10 0000 0001",
        "answer": "{1, 10}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "2.2 54 a)": {
        "question": "下列位串各代表有限全集的什么子集？a) 所有位全为 0 的串。",
        "answer": "没有元素被包括，所以这是空集。",
        "answer_symbols": [
            "Ø"
        ]
    },
    "2.2 54 b)": {
        "question": "下列位串各代表有限全集的什么子集？b) 所有位全为 1 的串。",
        "answer": "所有元素都被包括，所以这是全集。",
        "answer_symbols": []
    },
    "2.2 55": {
        "question": "对应于两个集合之差的位串是什么？",
        "answer": "两个集合差集的位字符串的第 i 位是 1，如果第一个字符串的第 i 位是 1 而第二个字符串的第 i 位是 0，否则为 0",
        "answer_symbols": [
            "-",
            "1",
            "0"
        ]
    },
    "2.2 56": {
        "question": "对应于两个集合的对称差的位串是什么？",
        "answer": "对称差的位字符串是通过取两个集合的位字符串的按位异或得到的，因为我们希望包括那些在一个集合中或另一个集合中但不在两者中的元素。",
        "answer_symbols": [
            "⊕"
        ]
    },
    "2.2 57 a)": {
        "question": "令 A={a, b, c, d, e}, B={b, c, d, g, p, t, v}, C={c, e, i, o, u, x, y, z}, D={d, e, h, i, n, o, t, u, x, y}。说明怎样用位串的按位运算求下列集合的组合：a) A∪B",
        "answer": "11 1110 0000 0000 0000 0000 0000 ∨ 01 1100 1000 0000 0100 0101 0000 = 11 1110 1000 0000 0100 0101 0000，表示 {a, b, c, d, e, g, p, t, v}",
        "answer_symbols": [
            "∨",
            "{",
            "}",
            ","
        ]
    },
    "2.2 57 b)": {
        "question": "令 A={a, b, c, d, e}, B={b, c, d, g, p, t, v}, C={c, e, i, o, u, x, y, z}, D={d, e, h, i, n, o, t, u, x, y}。说明怎样用位串的按位运算求下列集合的组合：b) A∩B",
        "answer": "11 1110 0000 0000 0000 0000 0000 ∧ 01 1100 1000 0000 0100 0101 0000 = 01 1100 0000 0000 0000 0000 0000，表示 {b, c, d}",
        "answer_symbols": [
            "∧",
            "{",
            "}",
            ","
        ]
    },
    "2.2 57 c)": {
        "question": "令 A={a, b, c, d, e}, B={b, c, d, g, p, t, v}, C={c, e, i, o, u, x, y, z}, D={d, e, h, i, n, o, t, u, x, y}。说明怎样用位串的按位运算求下列集合的组合：c) (A∪D)∩(B∪C)",
        "answer": "(11 1110 0000 0000 0000 0000 0000 ∨ 00 0110 0110 0001 1000 0110 0110) ∧ (01 1100 1000 0000 0100 0101 0000 ∨ 00 1010 0010 0000 1000 0010 0111) = 11 1110 0110 0001 1000 0110 0110 ∧ 01 1110 1010 0000 1100 0111 0111 = 01 1110 0010 0000 1000 0110 0110，表示 {b, c, d, e, i, o, t, u, x, y}",
        "answer_symbols": [
            "∨",
            "∧",
            "{",
            "}",
            ","
        ]
    },
    "2.2 57 d)": {
        "question": "令 A={a, b, c, d, e}, B={b, c, d, g, p, t, v}, C={c, e, i, o, u, x, y, z}, D={d, e, h, i, n, o, t, u, x, y}。说明怎样用位串的按位运算求下列集合的组合：d) A∪B∪C∪D",
        "answer": "11 1110 0000 0000 0000 0000 0000 ∨ 01 1100 1000 0000 0100 0101 0000 ∨ 00 1010 0010 0000 1000 0010 0111 ∨ 00 0110 0110 0001 1000 0110 0110 = 11 1110 1110 0001 1100 0111 0111，表示 {a, b, c, d, e, g, h, i, n, o, p, t, u, v, x, y, z}",
        "answer_symbols": [
            "∨",
            "{",
            "}",
            ","
        ]
    },
    "2.2 58": {
        "question": "怎样用位串求出同一全集 U 的 n 个子集的并集和交集？",
        "answer": "我们可以对这些集合的所有位字符串进行按位或运算（用于并集）或按位与运算（用于交集）。",
        "answer_symbols": [
            "∨",
            "∧"
        ]
    },
    "2.2 59 a)": {
        "question": "求下列集合的后继。a) {1, 2, 3}",
        "answer": "{1, 2, 3, {1, 2, 3}}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "2.2 59 b)": {
        "question": "求下列集合的后继。b) ∅",
        "answer": "{}",
        "answer_symbols": [
            "{",
            "}"
        ]
    },
    "2.2 59 c)": {
        "question": "求下列集合的后继。c) {∅}",
        "answer": "{{∅}}",
        "answer_symbols": [
            "{",
            "∅",
            "}"
        ]
    },
    "2.2 59 d)": {
        "question": "求下列集合的后继。d) {∅, {∅}}",
        "answer": "{{∅}, {{∅}}, {{∅, {∅}}}}",
        "answer_symbols": [
            "{",
            "∅",
            "}"
        ]
    },
    "2.2 60": {
        "question": "一个含 n 个元素的集合的后继有几个元素？",
        "answer": "后继集比原集多一个元素，即原集本身。因此答案是 n + 1。",
        "answer_symbols": [
            "+",
            "1"
        ]
    },
    "2.2 61 a)": {
        "question": "令A和B分别为多重集{3·a, 2·b, 1·c}和{2·a, 3·b, 4·d}。求 a) A∪B",
        "answer": "{3 · a, 3 · b, 1 · c, 4 · d}",
        "answer_symbols": [
            "{",
            "}",
            "·",
            ","
        ]
    },
    "2.2 61 b)": {
        "question": "令A和B分别为多重集{3·a, 2·b, 1·c}和{2·a, 3·b, 4·d}。求 b) A∩B",
        "answer": "{2 · a, 2 · b}",
        "answer_symbols": [
            "{",
            "}",
            "·",
            ","
        ]
    },
    "2.2 61 c)": {
        "question": "令A和B分别为多重集{3·a, 2·b, 1·c}和{2·a, 3·b, 4·d}。求 c) A−B",
        "answer": "{1 · a, 1 · c}",
        "answer_symbols": [
            "{",
            "}",
            "·",
            ","
        ]
    },
    "2.2 61 d)": {
        "question": "令A和B分别为多重集{3·a, 2·b, 1·c}和{2·a, 3·b, 4·d}。求 d) B−A",
        "answer": "{1 · b, 4 · d}",
        "answer_symbols": [
            "{",
            "}",
            "·",
            ","
        ]
    },
    "2.2 61 e)": {
        "question": "令A和B分别为多重集{3·a, 2·b, 1·c}和{2·a, 3·b, 4·d}。求 e) A+B",
        "answer": "{5 · a, 5 · b, 1 · c, 4 · d}",
        "answer_symbols": [
            "{",
            "}",
            "·",
            ","
        ]
    },
    "2.2 62 a)": {
        "question": "假定A是多重集，其元素是某大学一个系需要的计算机设备的类型，而元素的重数则是每一类所需设备的件数；B是同一所大学另一个系需要的多重集。例如A可以是多重集{107·PC, 44·路由器，6·服务器}，而B可以是{14·PC, 6·路由器，2·大型计算机}。a) 假定两个系使用同样的设备，A和B的什么组合代表该大学应该买的设备？",
        "answer": "如果各部门共享设备，则每种设备的最大数量是所需的，因此我们希望取多重集的并集，A ∪ B。",
        "answer_symbols": [
            "∪"
        ]
    },
    "2.2 62 b)": {
        "question": "假定A是多重集，其元素是某大学一个系需要的计算机设备的类型，而元素的重数则是每一类所需设备的件数；B是同一所大学另一个系需要的多重集。例如A可以是多重集{107·PC, 44·路由器，6·服务器}，而B可以是{14·PC, 6·路由器，2·大型计算机}。b) 假定两个系使用同样的设备，A和B的什么组合代表两个系都使用的设备？",
        "answer": "各部门将使用每种类型的最小数量，因此我们希望取多重集的交集，A ∩ B。",
        "answer_symbols": [
            "∩"
        ]
    },
    "2.2 62 c)": {
        "question": "假定A是多重集，其元素是某大学一个系需要的计算机设备的类型，而元素的重数则是每一类所需设备的件数；B是同一所大学另一个系需要的多重集。例如A可以是多重集{107·PC, 44·路由器，6·服务器}，而B可以是{14·PC, 6·路由器，2·大型计算机}。c) 假定两个系使用同样的设备，A和B的什么组合代表第二个系使用，但第一个系不使用的设备？",
        "answer": "这将是多重集的差集，B - A。",
        "answer_symbols": [
            "-"
        ]
    },
    "2.2 62 d)": {
        "question": "假定A是多重集，其元素是某大学一个系需要的计算机设备的类型，而元素的重数则是每一类所需设备的件数；B是同一所大学另一个系需要的多重集。例如A可以是多重集{107·PC, 44·路由器，6·服务器}，而B可以是{14·PC, 6·路由器，2·大型计算机}。d) 假定两个系不共享设备，A和B的什么组合代表该大学应该购买的设备？",
        "answer": "如果不允许共享，则大学需要购买的数量是各部门使用的数量之和；这是多重集的和，A + B。",
        "answer_symbols": [
            "+"
        ]
    },
    "2.2 63": {
        "question": "模糊集合S的补集是集合S，元素在S中的隶属度等于1减去该元素在S中的隶属度。求F（不出名者的模糊集合）和R（不富裕者的模糊集合）。",
        "answer": "F = {0.4 Alice, 0.1 Brian, 0.6 Fred, 0.9 Oscar, 0.5 Rita}, R = {0.6 Alice, 0.2 Brian, 0.8 Fred, 0.1 Oscar, 0.3 Rita}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "2.2 64": {
        "question": "模糊集合S和T的并集是模糊集合S∪T，其中每个元素的隶属度是该元素在S和T中成员度的最大值。求名人或富人的模糊集合F∪R。",
        "answer": "取每个人的最大值，我们有 S ∪ T = {0.6 Alice, 0.9 Brian, 0.4 Fred, 0.9 Oscar, 0.7 Rita}。",
        "answer_symbols": [
            "∪"
        ]
    },
    "2.2 65": {
        "question": "模糊集合S和T的交集是模糊集合S∩T，其中每个元素的隶属度是该元素在S和T中的成员度的最小值。求既出名又富裕者的模糊集合F∩R。",
        "answer": "{0.4 Alice, 0.8 Brian, 0.2 Fred, 0.1 Oscar, 0.5 Rita}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "2.3 1 a)": {
        "question": "为什么下列问题中的f不是从R到R的函数？（a）f(x)=1/x",
        "answer": "f(0) 未定义",
        "answer_symbols": []
    },
    "2.3 1 b)": {
        "question": "为什么下列问题中的f不是从R到R的函数？（b）f(x)=√x",
        "answer": "当 x < 0 时，f(x) 未定义",
        "answer_symbols": [
            "<"
        ]
    },
    "2.3 1 c)": {
        "question": "为什么下列问题中的f不是从R到R的函数？（c）f(x)=±√(2x+1)",
        "answer": "f(x) 定义不明确，因为每个 x 被分配了两个不同的值",
        "answer_symbols": []
    },
    "2.3 2 a)": {
        "question": "判断下面定义的几个f是不是从Z到R的函数。（a）f(n)=±n",
        "answer": "这不是一个函数，因为规则没有明确定义。我们不知道 f(3) 是 3 还是 -3。对于一个函数，它不能同时是两个值。",
        "answer_symbols": []
    },
    "2.3 2 b)": {
        "question": "判断下面定义的几个f是不是从Z到R的函数。（b）f(n)=√(n^²+1)",
        "answer": "这是一个函数。对于所有整数 n，根号下 n^² + 1 是一个定义良好的实数。",
        "answer_symbols": [
            "√",
            "+",
            "^"
        ]
    },
    "2.3 2 c)": {
        "question": "判断下面定义的几个f是不是从Z到R的函数。（c）f(n)=1/(n^²-4)",
        "answer": "这不是定义域为 Z 的函数，因为对于 n = 2（以及 n = -2），f(n) 的值未由给定规则定义。换句话说，f(2) 和 f(-2) 没有指定，因为除以 0 没有意义。",
        "answer_symbols": [
            "/"
        ]
    },
    "2.3 3 a)": {
        "question": "判断f是否为从所有位串的集合到整数集合的函数。（a）f(S)是S中某个0位的位置。",
        "answer": "不是函数",
        "answer_symbols": []
    },
    "2.3 3 b)": {
        "question": "判断f是否为从所有位串的集合到整数集合的函数。（b）f(S)是S中1位的个数。",
        "answer": "函数",
        "answer_symbols": []
    },
    "2.3 3 c)": {
        "question": "判断f是否为从所有位串的集合到整数集合的函数。（c）f(S)是最小整数i使S中的第i位为1，当S是不含位的空串时f(S)=0。",
        "answer": "不是函数",
        "answer_symbols": []
    },
    "2.3 4 a)": {
        "question": "求下列函数的定义域和值域。（a）函数为每个非负整数指派该整数的最后一位数字。",
        "answer": "定义域是非负整数集，值域是数字集（0 到 9）。",
        "answer_symbols": []
    },
    "2.3 4 b)": {
        "question": "求下列函数的定义域和值域。（b）函数为每个正整数指派比它小的最大整数。",
        "answer": "定义域是正整数集，值域是大于 1 的整数集。",
        "answer_symbols": []
    },
    "2.3 4 c)": {
        "question": "求下列函数的定义域和值域。（c）函数为每个位串指派串中1的位数。",
        "answer": "定义域是所有位串集，值域是非负整数集。",
        "answer_symbols": []
    },
    "2.3 4 d)": {
        "question": "求下列函数的定义域和值域。（d）函数为每个位串指派串的位数。",
        "answer": "定义域是所有位串集，值域是非负整数集（位串可以长度为 0）。",
        "answer_symbols": []
    },
    "2.3 5 a)": {
        "question": "求下列函数的定义域和值域。（a）函数为每个位串指派串中1的位数与0的位数之差。",
        "answer": "定义域为位字符串集；值域为整数集",
        "answer_symbols": []
    },
    "2.3 5 b)": {
        "question": "求下列函数的定义域和值域。（b）函数为每个位串指派串中0的位数的2倍。",
        "answer": "定义域为位字符串集；值域为非负偶数集",
        "answer_symbols": []
    },
    "2.3 5 c)": {
        "question": "求下列函数的定义域和值域。（c）函数为每个位串指派当把串分成字节(8位为1个字节)时不够一个字节的位数。",
        "answer": "定义域为位字符串集；值域为不超过 7 的非负整数集",
        "answer_symbols": []
    },
    "2.3 5 d)": {
        "question": "求下列函数的定义域和值域。（d）函数为每个正整数指派不超过该整数的最大完全平方数。",
        "answer": "定义域为正整数集；值域为正整数的平方集 = {1, 4, 9, 16, ...}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "2.3 6 a)": {
        "question": "求下列函数的定义域和值域。（a）函数为每正整数序偶指派序偶中的第一个整数。",
        "answer": "定义域是 Z+ × Z+，值域是 Z+。",
        "answer_symbols": [
            "×"
        ]
    },
    "2.3 6 b)": {
        "question": "求下列函数的定义域和值域。（b）函数为每个正整数指派该整数中最大的十进数字。",
        "answer": "由于严格正整数的最大十进制数位不能是 0，我们有定义域 Z+ 和值域 {1, 2, 3, 4, 5, 6, 7, 8, 9}。",
        "answer_symbols": []
    },
    "2.3 6 c)": {
        "question": "求下列函数的定义域和值域。（c）函数为位串指派串中1的位数与0的位数之差。",
        "answer": "定义域是所有位串集。1 的数量减去 0 的数量可以是任何正或负整数或 0，所以值域是 Z。",
        "answer_symbols": [
            "-",
            "+"
        ]
    },
    "2.3 6 d)": {
        "question": "求下列函数的定义域和值域。（d）函数为每个正整数指派不超过该整数的平方根的最大整数。",
        "answer": "定义域是 Z+。显然值域也是 Z+。",
        "answer_symbols": []
    },
    "2.3 6 e)": {
        "question": "求下列函数的定义域和值域。（e）函数为位串指派串中最长的1的子串。",
        "answer": "定义域是位串集。值域是 1 的字符串集，即 {λ, 1, 11, 111, ...}，其中 λ 是空字符串（不包含任何符号）。",
        "answer_symbols": []
    },
    "2.3 7 a)": {
        "question": "求下列函数的定义域和值域。（a）函数为每对正整数序偶指派这两个整数中的最大数。",
        "answer": "定义域 Z+ × Z+；值域 Z+",
        "answer_symbols": [
            "×"
        ]
    },
    "2.3 7 b)": {
        "question": "求下列函数的定义域和值域。（b）函数为每个正整数指派在该整数中未出现的0，1，2，3，4，5，6，7，8，9数字的个数。",
        "answer": "定义域 Z+；值域 {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "2.3 7 c)": {
        "question": "求下列函数的定义域和值域。（c）函数为位串指派串中块11出现的次数。",
        "answer": "定义域为位字符串集；值域 N",
        "answer_symbols": []
    },
    "2.3 7 d)": {
        "question": "求下列函数的定义域和值域。（d）函数为位串指派串中第一个1的位置值，如果位串为全0就指派0。",
        "answer": "定义域为位字符串集；值域 N",
        "answer_symbols": []
    },
    "2.3 8 a)": {
        "question": "求下列各值。（a）[1, 1]",
        "answer": "1",
        "answer_symbols": []
    },
    "2.3 8 b)": {
        "question": "求下列各值。（b）[1, 1]",
        "answer": "2",
        "answer_symbols": []
    },
    "2.3 8 c)": {
        "question": "求下列各值。（c）[-0, 1]",
        "answer": "-1",
        "answer_symbols": []
    },
    "2.3 8 d)": {
        "question": "求下列各值。（d）[-0, 1]",
        "answer": "0",
        "answer_symbols": []
    },
    "2.3 8 e)": {
        "question": "求下列各值。（e）[2, 99]",
        "answer": "3",
        "answer_symbols": []
    },
    "2.3 8 f)": {
        "question": "求下列各值。（f）[-2, 99]",
        "answer": "-2",
        "answer_symbols": []
    },
    "2.3 8 g)": {
        "question": "求下列各值。（g）[1/2, 1/2]",
        "answer": "1 1/2 + 1/2 = 1 3/2^² = 1",
        "answer_symbols": [
            "+",
            "/",
            "^"
        ]
    },
    "2.3 8 h)": {
        "question": "求下列各值。（h）[1/2, 1/2]",
        "answer": "30 + 1 + 1/2^⁴ = 3 3/2^⁴ = 2",
        "answer_symbols": [
            "+",
            "/",
            "^"
        ]
    },
    "2.3 9 a)": {
        "question": "求下列各值。（a）[3/4]",
        "answer": "1",
        "answer_symbols": []
    },
    "2.3 9 b)": {
        "question": "求下列各值。（b）[7/8]",
        "answer": "0",
        "answer_symbols": []
    },
    "2.3 9 c)": {
        "question": "求下列各值。（c）[-3/4]",
        "answer": "0",
        "answer_symbols": []
    },
    "2.3 9 d)": {
        "question": "求下列各值。（d）[-7/8]",
        "answer": "-1",
        "answer_symbols": [
            "-"
        ]
    },
    "2.3 9 e)": {
        "question": "求下列各值。（e）[3]",
        "answer": "3",
        "answer_symbols": []
    },
    "2.3 9 f)": {
        "question": "求下列各值。（f）[-1]",
        "answer": "-1",
        "answer_symbols": [
            "-"
        ]
    },
    "2.3 9 g)": {
        "question": "求下列各值。（g）[1/2, 3/2]",
        "answer": "2",
        "answer_symbols": []
    },
    "2.3 10 a)": {
        "question": "判断下列从(a, b, c, d)到它自身的函数是否是一对一的。（a）f(a) = b, f(b) = a, f(c) = c, f(d) = d",
        "answer": "这是一对一的。",
        "answer_symbols": []
    },
    "2.3 10 b)": {
        "question": "判断下列从(a, b, c, d)到它自身的函数是否是一对一的。（b）f(a) = b, f(b) = b, f(c) = d, f(d) = c",
        "answer": "这不是一对一的，因为 b 是 a 和 b 的像。",
        "answer_symbols": []
    },
    "2.3 10 c)": {
        "question": "判断下列从(a, b, c, d)到它自身的函数是否是一对一的。（c）f(a) = d, f(b) = b, f(c) = c, f(d) = d",
        "answer": "这不是一对一的，因为 d 是 a 和 d 的像。",
        "answer_symbols": []
    },
    "2.3 11": {
        "question": "练习10中哪些函数是映上的?",
        "answer": "仅 (a) 部分的函数",
        "answer_symbols": []
    },
    "2.3 12 a)": {
        "question": "判断下列Z到Z的函数是否是一对一的。（a）f(n) = n - 1",
        "answer": "这是一对一的，因为如果 n1 - 1 = n2 - 1，则 n1 = n2。",
        "answer_symbols": [
            "-",
            "="
        ]
    },
    "2.3 12 b)": {
        "question": "判断下列Z到Z的函数是否是一对一的。（b）f(n) = n^² + 1",
        "answer": "这不是一对一的，例如，f(3) = f(-3) = 10。",
        "answer_symbols": [
            "="
        ]
    },
    "2.3 12 c)": {
        "question": "判断下列Z到Z的函数是否是一对一的。（c）f(n) = n^³",
        "answer": "这是一对一的，因为如果 n1^³ = n2^³，则 n1 = n2（取立方根）。",
        "answer_symbols": [
            "=",
            "^",
            "∛"
        ]
    },
    "2.3 13": {
        "question": "练习10中哪些函数是映上的?",
        "answer": "仅 (a) 和 (d) 部分的函数",
        "answer_symbols": []
    },
    "2.3 14 a)": {
        "question": "判断在下列情况下f: Z×Z→Z是否是映上的。（a）f(m, n) = 2m - n",
        "answer": "这显然是满射的，因为对于每个整数 n，f(0, -n) = n。",
        "answer_symbols": [
            "="
        ]
    },
    "2.3 14 b)": {
        "question": "判断在下列情况下f: Z×Z→Z是否是映上的。（b）f(m, n) = m^² - n^²",
        "answer": "这不是满射的，因为例如 2 不在范围内。要看到这一点，如果 m^² - n^² = (m - n)(m + n) = 2，则 m 和 n 必须具有相同的奇偶性（都是偶数或都是奇数）。在这两种情况下，m - n 和 m + n 都是偶数，所以这个表达式可以被 4 整除，因此不能等于 2。",
        "answer_symbols": [
            "²",
            "=",
            "-",
            "+",
            "(",
            ")"
        ]
    },
    "2.3 14 c)": {
        "question": "判断在下列情况下f: Z×Z→Z是否是映上的。（c）f(m, n) = m + n + 1",
        "answer": "这显然是满射的，因为对于每个整数 n，f(0, n - 1) = n。",
        "answer_symbols": [
            "=",
            "-"
        ]
    },
    "2.3 14 d)": {
        "question": "判断在下列情况下f: Z×Z→Z是否是映上的。（d）f(m, n) = |m| - |n|",
        "answer": "这是满射的。为了实现负值，我们设 m = 0；为了实现非负值，我们设 n = 0。",
        "answer_symbols": [
            "="
        ]
    },
    "2.3 14 e)": {
        "question": "判断在下列情况下f: Z×Z→Z是否是映上的。（e）f(m, n) = m^² - 4",
        "answer": "这不是满射的，原因同 (b)。事实上，这里的范围显然是那部分范围的一个子集。",
        "answer_symbols": []
    },
    "2.3 15 a)": {
        "question": "判断在下列情况下函数f: Z×Z→Z是否是映上的。（a）f(m, n) = m + n",
        "answer": "满射",
        "answer_symbols": []
    },
    "2.3 15 b)": {
        "question": "判断在下列情况下函数f: Z×Z→Z是否是映上的。（b）f(m, n) = m^² + n^²",
        "answer": "不满射",
        "answer_symbols": []
    },
    "2.3 15 c)": {
        "question": "判断在下列情况下函数f: Z×Z→Z是否是映上的。（c）f(m, n) = m",
        "answer": "满射",
        "answer_symbols": []
    },
    "2.3 15 d)": {
        "question": "判断在下列情况下函数f: Z×Z→Z是否是映上的。（d）f(m, n) = |n|",
        "answer": "不满射",
        "answer_symbols": []
    },
    "2.3 15 e)": {
        "question": "判断在下列情况下函数f: Z×Z→Z是否是映上的。（e）f(m, n) = m - n",
        "answer": "满射",
        "answer_symbols": []
    },
    "2.3 16 a)": {
        "question": "考虑离散数学班上学生集合上的函数。在什么条件下函数是一对一的，如果给学生指派他的（a）移动电话号码",
        "answer": "这通常是单射的，除非班上有两个学生使用了一种奇怪的手机服务，他们共享同一个电话号码。",
        "answer_symbols": []
    },
    "2.3 16 b)": {
        "question": "考虑离散数学班上学生集合上的函数。在什么条件下函数是一对一的，如果给学生指派他的（b）学生学号",
        "answer": "这肯定是单射的；否则，学号将无法很好地“识别”学生！",
        "answer_symbols": []
    },
    "2.3 16 c)": {
        "question": "考虑离散数学班上学生集合上的函数。在什么条件下函数是一对一的，如果给学生指派他的（c）在班上的最后得分",
        "answer": "这几乎肯定不是单射的；除非班级非常小，否则很可能有两个学生会得到相同的分数。",
        "answer_symbols": []
    },
    "2.3 17 a)": {
        "question": "考虑一所学校中老师集合上的函数。在什么条件下函数是一对一的，如果给老师指派他的（a）办公室",
        "answer": "取决于教师是否共享办公室",
        "answer_symbols": []
    },
    "2.3 17 b)": {
        "question": "考虑一所学校中老师集合上的函数。在什么条件下函数是一对一的，如果给老师指派他的（b）陪伴学生进行野外实习时一组巴士中制定的巴士",
        "answer": "假设每辆公共汽车只有一名教师，则是一对一的",
        "answer_symbols": []
    },
    "2.3 17 c)": {
        "question": "考虑一所学校中老师集合上的函数。在什么条件下函数是一对一的，如果给老师指派他的（c）薪水",
        "answer": "特别是在工资由集体谈判协议确定的情况下，很可能不是一对一的",
        "answer_symbols": []
    },
    "2.3 17 d)": {
        "question": "考虑一所学校中老师集合上的函数。在什么条件下函数是一对一的，如果给老师指派他的（d）社会保险号",
        "answer": "一对一",
        "answer_symbols": []
    },
    "2.3 18 a)": {
        "question": "为练习16的每个函数指定陪域。在什么情况下这些你指定了陪域的函数是映上的？（a）移动电话号码",
        "answer": "一个陪域可以是所有十位数的正整数；该函数不是满射的，因为有许多可能的电话号码分配给了不在班上的人员。",
        "answer_symbols": []
    },
    "2.3 18 b)": {
        "question": "为练习16的每个函数指定陪域。在什么情况下这些你指定了陪域的函数是映上的？（b）学生学号",
        "answer": "在某些学生记录系统中，学号由八位数字组成，因此陪域可以是小于 100,000,000 的所有自然数。这个班没有 100,000,000 名学生，所以这个函数不是满射的。",
        "answer_symbols": []
    },
    "2.3 18 c)": {
        "question": "为练习16的每个函数指定陪域。在什么情况下这些你指定了陪域的函数是映上的？（c）在班上的最后得分",
        "answer": "一个陪域可能是 {A, B, C, D, F}（这取决于该学校使用的评分系统）。如果这个班有所有五个成绩等级的学生，那么这个函数就是满射的。如果没有（例如，没有人不及格），则它不是满射的。",
        "answer_symbols": []
    },
    "2.3 19 a)": {
        "question": "为练习17的每个函数指定陪域。在什么情况下这些你指定了陪域的函数是映上的？（a）办公室",
        "answer": "学校的办公室集合；可能不满射",
        "answer_symbols": []
    },
    "2.3 19 b)": {
        "question": "为练习17的每个函数指定陪域。在什么情况下这些你指定了陪域的函数是映上的？（b）陪伴学生进行野外实习时一组巴士中制定的巴士",
        "answer": "去旅行的公共汽车集合；满射，假设每辆公共汽车都有教师陪同",
        "answer_symbols": []
    },
    "2.3 19 c)": {
        "question": "为练习17的每个函数指定陪域。在什么情况下这些你指定了陪域的函数是映上的？（c）薪水",
        "answer": "实数集合；不满射",
        "answer_symbols": []
    },
    "2.3 19 d)": {
        "question": "为练习17的每个函数指定陪域。在什么情况下这些你指定了陪域的函数是映上的？（d）社会保险号",
        "answer": "九位数字带第三位和第五位后跟连字符的字符串集合；不满射",
        "answer_symbols": []
    },
    "2.3 20 a)": {
        "question": "给出从N到N的函数的例子，满足：（a）一对一但非映上。",
        "answer": "f(n) = n + 17",
        "answer_symbols": [
            "=",
            "+"
        ]
    },
    "2.3 20 b)": {
        "question": "给出从N到N的函数的例子，满足：（b）映上但非一对一。",
        "answer": "f(n) = 3n / 24",
        "answer_symbols": [
            "=",
            "/",
            "*"
        ]
    },
    "2.3 20 c)": {
        "question": "给出从N到N的函数的例子，满足：（c）既映上又一对一(但不同于恒等函数)。",
        "answer": "我们让 f(n) = n - 1 对于 n 的偶数值，f(n) = n + 1 对于 n 的奇数值。因此我们有 f(1) = 2, f(2) = 1, f(3) = 4, f(4) = 3，等等。请注意，这是一个函数，即使它的定义使用了两个公式，取决于 n 的奇偶性。",
        "answer_symbols": [
            "=",
            "-",
            "+"
        ]
    },
    "2.3 21 a)": {
        "question": "给出从整数集合到正整数集合的函数的显式公式，满足：（a）一对一但非映上。",
        "answer": "函数 f(x)，当 x ≥ 0 时 f(x) = 3x + 1，当 x < 0 时 f(x) = -3x + 2",
        "answer_symbols": [
            "≥",
            "<",
            "=",
            "+",
            "-"
        ]
    },
    "2.3 21 b)": {
        "question": "给出从整数集合到正整数集合的函数的显式公式，满足：（b）映上但非一对一。",
        "answer": "f(x) = |x| + 1",
        "answer_symbols": [
            "|",
            "=",
            "+"
        ]
    },
    "2.3 21 c)": {
        "question": "给出从整数集合到正整数集合的函数的显式公式，满足：（c）既映上又一对一。",
        "answer": "函数 f(x)，当 x ≥ 0 时 f(x) = 2x + 1，当 x < 0 时 f(x) = -2x",
        "answer_symbols": [
            "≥",
            "<",
            "=",
            "+",
            "-"
        ]
    },
    "2.3 22 a)": {
        "question": "判断下列各函数是否是从R到R的双射函数。（a）f(x) = -3x + 4",
        "answer": "这是一个双射，因为其逆函数是 f^⁻¹(x) = (4 - x) / 3。",
        "answer_symbols": [
            "=",
            "-",
            "/"
        ]
    },
    "2.3 22 b)": {
        "question": "判断下列各函数是否是从R到R的双射函数。（b）f(x) = -3x^² + 7",
        "answer": "这不是单射的，因为例如 f(17) = f(-17)。它也不是满射的，因为其范围是区间 (-∞, 7]。例如，42548 不在其范围内。",
        "answer_symbols": [
            "=",
            "-",
            "∞",
            "["
        ]
    },
    "2.3 22 c)": {
        "question": "判断下列各函数是否是从R到R的双射函数。（c）f(x) = (x + 1)/(x + 2)",
        "answer": "这个函数是一个双射，但不是从 R 到 R 的双射。要看到其定义域和值域不是 R，注意 x = -2 不在定义域内，x = 1 不在值域内。另一方面，f 是从 R - {-2} 到 R - {1} 的双射，因为其逆函数是 f^⁻¹(x) = (1 - 2x) / (x - 1)。",
        "answer_symbols": [
            "=",
            "-",
            "/",
            "(",
            ")",
            "∈"
        ]
    },
    "2.3 22 d)": {
        "question": "判断下列各函数是否是从R到R的双射函数。（d）f(x) = x^² + 1",
        "answer": "很明显，这个连续函数在整个定义域 (R) 内是递增的，并且它可以取任意大的值和任意小（大的负数）的值。所以它是一个双射。其逆函数显然是 f^⁻¹(x) = √(5x - 1)。",
        "answer_symbols": [
            "=",
            "-",
            "√",
            "(",
            ")"
        ]
    },
    "2.3 23 a)": {
        "question": "判断下列各函数是否是从R到R的双射函数。（a）f(x) = 2x + 1",
        "answer": "是",
        "answer_symbols": []
    },
    "2.3 23 b)": {
        "question": "判断下列各函数是否是从R到R的双射函数。（b）f(x) = x^² + 1",
        "answer": "否",
        "answer_symbols": []
    },
    "2.3 23 c)": {
        "question": "判断下列各函数是否是从R到R的双射函数。（c）f(x) = x^³",
        "answer": "是",
        "answer_symbols": []
    },
    "2.3 23 d)": {
        "question": "判断下列各函数是否是从R到R的双射函数。（d）f(x) = (x^² + 1)/(x^² + 2)",
        "answer": "否",
        "answer_symbols": []
    },
    "2.3 25": {
        "question": "令 f: ℝ → ℝ 且对所有 x ∈ ℝ 有 f(x) > 0。证明 f(x) 是严格递减的当且仅当函数 g(x) = 1/f(x) 是严格递增的。",
        "answer": "假设 f 严格递减。这意味着每当 x < y 时，f(x) > f(y)。为了证明 g 严格递增，假设 x < y。则 g(x) = 1/f(x) < 1/f(y) = g(y)。反之，假设 g 严格递增。这意味着每当 x < y 时，g(x) < g(y)。为了证明 f 严格递减，假设 x < y。则 f(x) = 1/g(x) > 1/g(y) = f(y)",
        "answer_symbols": [
            "<",
            ">",
            "="
        ]
    },
    "2.3 29": {
        "question": "证明从实数集到非负实数集的函数 f(x) = |x| 不是可逆的，但如果将其定义域限制到非负实数集，则函数是可逆的。",
        "answer": "The function is not one-to-one, so it is not invertible. On the restricted domain, the function is the identity function on the nonnegative real numbers, f(x) = x, so it is its own inverse",
        "answer_symbols": [
            "="
        ]
    },
    "2.3 35": {
        "question": "如果 f 和 f ∘ g 都是映上的，能否得出结论 g 也是映上的？说明理由。",
        "answer": "No. For example, suppose that A = {a}, B = {b, c}, and C = {d}. Let g(a) = b, f(b) = d, and f(c) = d. Then f and f ◦ g are onto, but g is not",
        "answer_symbols": [
            "=",
            "◦"
        ]
    },
    "2.3 37": {
        "question": "试求 f + g 和 f · g，其中函数 f 和 g 同练习 36 一样。",
        "answer": "(f + g)(x) = x^² + x + 3, (f * g)(x) = x^³ + 2x^² + x + 2",
        "answer_symbols": [
            "+",
            "*",
            "=",
            "²",
            "³"
        ]
    },
    "2.3 39": {
        "question": "证明从 ℝ 到 ℝ 的函数 f(x) = ax + b 是可逆的，其中 a 和 b 为常数且 a ≠ 0，并找出 f 的反函数。",
        "answer": "f is one-to-one because f(x₁) = f(x₂) → ax₁ + b = ax₂ + b → ax₁ = ax₂ → x₁ = x₂. f is onto because f((y - b)/a) = y. f^⁻¹(y) = (y - b)/a",
        "answer_symbols": [
            "=",
            "→",
            "-",
            "/"
        ]
    },
    "2.3 45": {
        "question": "令 f 为从 A 到 B 的函数。S 为 B 的子集。证明 f^(-1)(\\overline{S}) = \\overline{f^(-1)(S)}。",
        "answer": "f^⁻¹(S) = {x ∈ A | f(x) ∈ S} = {x ∈ A | f(x) ∈ S} = f^⁻¹(S)",
        "answer_symbols": [
            "=",
            "∈",
            "|"
        ]
    },
    "2.3 27 a)": {
        "question": "证明从 ℝ 到自身的严格递减函数是一对一的。",
        "answer": "if a < b, then f(a) > f(b); if a > b, then f(a) < f(b). Thus if a = b, then f(a) = f(b)",
        "answer_symbols": [
            "<",
            ">",
            "="
        ]
    },
    "2.3 27 b)": {
        "question": "试给出一个从 ℝ 到自身的不是一对一的递减函数实例。",
        "answer": "Answers will vary; for example, f (x) = 0 for x < 0 and f (x) = −x for x ≥ 0.",
        "answer_symbols": [
            "<",
            ">",
            "=",
            "≥"
        ]
    },
    "2.3 31 a)": {
        "question": "令 f(x) = ⌊x^2/3⌋。求 f(S)，如果 S = {-2, -1, 0, 1, 2, 3}。",
        "answer": "f(S) = {0, 1, 3}",
        "answer_symbols": [
            "="
        ]
    },
    "2.3 31 b)": {
        "question": "令 f(x) = ⌊x^2/3⌋。求 f(S)，如果 S = {0, 1, 2, 3, 4, 5}。",
        "answer": "f(S) = {0, 1, 3, 5, 8}",
        "answer_symbols": [
            "="
        ]
    },
    "2.3 31 c)": {
        "question": "令 f(x) = ⌊x^2/3⌋。求 f(S)，如果 S = {1, 5, 7, 11}。",
        "answer": "f(S) = {0, 8, 16, 40}",
        "answer_symbols": [
            "="
        ]
    },
    "2.3 33 a)": {
        "question": "假定 g 是从 A 到 B 的函数，f 是从 B 到 C 的函数。证明如果 f 和 g 均为一对一函数，那么 f ∘ g 也是一对一函数。",
        "answer": "Let x and y be distinct elements of A. Because g is one-to-one, g(x) and g(y) are distinct elements of B. Because f is one-to-one, f(g(x)) = (f ◦ g)(x) and f(g(y)) = (f ◦ g)(y) are distinct elements of C. Hence, f ◦ g is one-to-one",
        "answer_symbols": [
            "=",
            "◦"
        ]
    },
    "2.3 33 b)": {
        "question": "假定 g 是从 A 到 B 的函数，f 是从 B 到 C 的函数。证明如果 f 和 g 均为到映上函数，那么 f ∘ g 也是映上函数。",
        "answer": "Let y ∈ C. Because f is onto, y = f(b) for some b ∈ B. Now because g is onto, b = g(x) for some x ∈ A. Hence, y = f(b) = f(g(x)) = (f ◦ g)(x). It follows that f ◦ g is onto",
        "answer_symbols": [
            "∈",
            "=",
            "◦"
        ]
    },
    "2.3 41 a)": {
        "question": "给出一个例子说明练习 40b 中的包含可能是真包含。",
        "answer": "A = B = ℝ, S = {x | x > 0}, T = {x | x < 0}, f(x) = x^²",
        "answer_symbols": [
            "=",
            "|",
            ">"
        ]
    },
    "2.3 41 b)": {
        "question": "证明如果 f 是一对一的，则练习 40b 中的包含就是相等。",
        "answer": "It suffices to show that f(S) ∩ f(T) ⊆ f(S ∩ T). Let y ∈ B be an element of f(S) ∩ f(T). Then y ∈ f(S), so y = f(x₁) for some x₁ ∈ S. Similarly, y = f(x₂) for some x₂ ∈ T. Because f is one-to-one, it follows that x₁ = x₂. Therefore x₁ ∈ S ∩ T, so y ∈ f(S ∩ T)",
        "answer_symbols": [
            "∩",
            "⊆",
            "∈",
            "="
        ]
    },
    "2.3 43 a)": {
        "question": "令 g(x) = ⌊x⌋。求 g^(-1)({0})。",
        "answer": "{x | 0 ≤ x < 1}",
        "answer_symbols": [
            "|",
            "≤",
            "<"
        ]
    },
    "2.3 43 b)": {
        "question": "令 g(x) = ⌊x⌋。求 g^(-1)({-1, 0, 1})。",
        "answer": "{x | -1 ≤ x < 2}",
        "answer_symbols": [
            "|",
            "≤",
            "<"
        ]
    },
    "2.3 47": {
        "question": "证明 ⌊x-1/2⌋ 是最接近 x 的整数，除非 x 恰为两个相邻整数的中间数，此时它为这两个整数中较小的一个。",
        "answer": "Let x = x + ε, where ε is a real number with 0 ≤ ε < 1. If ε < 0.5, then x - 1 < x - 0.5 < x, so x - 0.5 = x and this is the integer closest to x. If ε > 0.5, then x < x - 0.5 < x + 1, so x - 0.5 = x + 1 and this is the integer closest to x. If ε = 0.5, then x - 0.5 = x, which is the smaller of the two integers that surround x and are the same distance from x",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "<",
            "≤"
        ]
    },
    "2.3 49": {
        "question": "证明如果 x 是一个实数，则有 x-1<⌊x⌋<x<⌊x⌋+1。",
        "answer": "Write the real number x as x + ε, where ε is a real number with 0 ≤ ε < 1. Because ε = x - x, it follows that 0 ≤ -x < 1. The first two inequalities, x - 1 < x and x ≤ x, follow directly. For the other two inequalities, write x = x - ε', where 0 ≤ ε' < 1. Then 0 ≤ x - x < 1, and the desired inequality follows",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "<",
            "≤"
        ]
    },
    "2.3 51 a)": {
        "question": "证明如果 x 为实数，n 为整数，则 x<n 当且仅当 ⌊x⌋<n。",
        "answer": "If x < n, because x ≤ x, it follows that x < n. Suppose that x ≥ n. By the definition of the floor function, it follows that x ≥ n. This means that if x < n, then x < n",
        "answer_symbols": [
            "<",
            "≥",
            "≤"
        ]
    },
    "2.3 51 b)": {
        "question": "证明如果 x 为实数，n 为整数，则 n<x 当且仅当 ⌊x⌋。",
        "answer": "If n < x, then because x ≤ x, it follows that n ≤ x. Suppose that n ≥ x. By the definition of the ceiling function, it follows that x ≤ n. This means that if n < x, then n < x",
        "answer_symbols": [
            "<",
            "≥",
            "≤"
        ]
    },
    "2.3 53": {
        "question": "证明如果 n 为整数，则当 n 为偶数时 ⌊n/2⌋=n/2；当 n 为奇数时 ⌊n/2⌋=(n-1)/2。",
        "answer": "If n is even, then n = 2k for some integer k. Thus, n/2 = k = k = n/2. If n is odd, then n = 2k + 1 for some integer k. Thus, n/2 = k + 0.5 = k = (n - 1)/2",
        "answer_symbols": [
            "=",
            "+",
            "/",
            "-"
        ]
    },
    "2.3 55": {
        "question": "有些计算器上有 INT 函数，当 x 为非负实数时 INT(x)=⌊x⌋；当 x 为负实数时 INT(x)=⌊x⌋。 证明这一函数 INT 满足等式 INT(-x)=-INT(x)。",
        "answer": "Assume that x ≥ 0. The left-hand side is -x and the right-hand side is -x. If x is an integer, then both sides equal -x. Otherwise, let x = n + ε, where n is a natural number and ε is a real number with 0 ≤ ε < 1. Then -x = -n - ε = -n and -x = -n + ε = -n also. When x < 0, the equation also holds because it can be obtained by substituting -x for x",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "<",
            "≤"
        ]
    },
    "2.3 57": {
        "question": "令 a 和 b 的实数，且 a<b， 用下取整函数和上取整函数表示满足 a<n<b 的整数 n 的数目。",
        "answer": "b - a - 1",
        "answer_symbols": [
            "-",
            "1"
        ]
    },
    "2.3 59 a)": {
        "question": "需要多少字节来编码 7 位的数据？",
        "answer": "1",
        "answer_symbols": []
    },
    "2.3 59 b)": {
        "question": "需要多少字节来编码 17 位的数据？",
        "answer": "3",
        "answer_symbols": []
    },
    "2.3 59 c)": {
        "question": "需要多少字节来编码 1001 位的数据？",
        "answer": "126",
        "answer_symbols": []
    },
    "2.3 59 d)": {
        "question": "需要多少字节来编码 28800 位的数据？",
        "answer": "3600",
        "answer_symbols": []
    },
    "2.3 61 a)": {
        "question": "数据在某以太网上以 1500 个 8 位 (octet) 为信息块传输。下面的数据量在这个以太网上传输时需要多少个信息块？150 千字节的数据。",
        "answer": "100",
        "answer_symbols": []
    },
    "2.3 61 b)": {
        "question": "数据在某以太网上以 1500 个 8 位 (octet) 为信息块传输。下面的数据量在这个以太网上传输时需要多少个信息块？384 千字节的数据。",
        "answer": "256",
        "answer_symbols": []
    },
    "2.3 61 c)": {
        "question": "数据在某以太网上以 1500 个 8 位 (octet) 为信息块传输。下面的数据量在这个以太网上传输时需要多少个信息块？1.544 兆字节的数据。",
        "answer": "1030",
        "answer_symbols": []
    },
    "2.3 61 d)": {
        "question": "数据在某以太网上以 1500 个 8 位 (octet) 为信息块传输。下面的数据量在这个以太网上传输时需要多少个信息块？45.3 兆字节的数据。",
        "answer": "30,200",
        "answer_symbols": []
    },
    "2.3 62": {
        "question": "画出从 Z 到 Z 的函数 f(n)=1-n^² 的图。",
        "answer": "The graph consists of the points (n, 1 - n^²) for all n ∈ Z. The picture shows part of the graph on the usual coordinate axes.",
        "answer_symbols": [
            "(",
            ")",
            "-",
            "^",
            "∈"
        ]
    },
    "2.3 63": {
        "question": "画出从 R 到 R 的函数 f(x)=| 2x | 的图。",
        "answer": "-2 -1 0 -1 -2 2 4 3 11324665",
        "answer_symbols": [
            "-"
        ]
    },
    "2.3 64": {
        "question": "画出从 R 到 R 的函数 f(x)=| x/2 | 的图。",
        "answer": "The graph is similar to the graph of f(x) = 1/x^²; the only difference is a change in the scale of the x-axis.",
        "answer_symbols": [
            "=",
            "/",
            "^"
        ]
    },
    "2.3 65": {
        "question": "画出从 R 到 R 的函数 f(x)=| x |+| x/2 | 的图。",
        "answer": "-2 -1 0 -1 -2 12 3 132 -3",
        "answer_symbols": [
            "-"
        ]
    },
    "2.3 66": {
        "question": "画出从 R 到 R 的函数 f(x)=| x |+| x/2 | 的图。",
        "answer": "The function values for this step function change only at integer values of x, and different things happen for odd x and for even x because of the x/2 term. Whatever jump pattern is established on the closed interval [0, 2] must repeat indefinitely in both directions. A thoughtful analysis then yields the following graph.",
        "answer_symbols": [
            "[",
            "]",
            "/",
            "∈"
        ]
    },
    "2.3 67 a)": {
        "question": "画出下列各函数的图。f(x)=⌊x+1/2⌋。",
        "answer": "3 2 1 -2 -4 2 4 -2 -3 -1",
        "answer_symbols": [
            "-"
        ]
    },
    "2.3 67 b)": {
        "question": "画出下列各函数的图。f(x)=⌊2x+1⌋。",
        "answer": "3 2 1 -2 -3 -1 -2 1 2 -1",
        "answer_symbols": [
            "-"
        ]
    },
    "2.3 67 c)": {
        "question": "画出下列各函数的图。f(x)=⌊x/3⌋。",
        "answer": "3 2 1 -2 -3 -1 -6 -12 -3 -9 6 12 3 9",
        "answer_symbols": [
            "-"
        ]
    },
    "2.3 67 d)": {
        "question": "画出下列各函数的图。f(x)=⌊1/x⌋。",
        "answer": "3 2 1 4 -2 -3 -1 -1 1",
        "answer_symbols": [
            "-",
            "1"
        ]
    },
    "2.3 67 e)": {
        "question": "画出下列各函数的图。f(x)=⌊x-2⌋+⌊x+2⌋。",
        "answer": "3 2 1 4 -2 -3 -4 -1 -2 -1 2 1",
        "answer_symbols": [
            "-",
            "1",
            "2",
            "4"
        ]
    },
    "2.3 67 f)": {
        "question": "画出下列各函数的图。f(x)=⌊2x⌋⌊x/2⌋。",
        "answer": "3 2 1 4 5 -2 -1 1 2 -2 -3 -1 -4",
        "answer_symbols": [
            "-",
            "1",
            "2",
            "4",
            "5"
        ]
    },
    "2.3 67 g)": {
        "question": "画出下列各函数的图。f(x)=⌊x-1/2⌋+⌊1/2⌋。",
        "answer": "See part (a)",
        "answer_symbols": []
    },
    "2.3 68 a)": {
        "question": "画出下列各函数的图。f(x)=⌊3x-2⌋。",
        "answer": "We can rewrite this as f(x) = 33(x - 2/3)^⁴. The graph will therefore look exactly like the graph of the function f(x) = 33x^⁴, except that the picture will be shifted to the right by 2/3 units, since x has been replaced by x - 2/3. The graph of f(x) = 33x^⁴ is just like the graph shown in Figure 10b, except that the x-axis needs to be rescaled by a factor of 3 (the first jump on the positive x-axis occurs at x = 1/3 here). Putting this all together yields the following picture. (Alternatively, we can think of this as the graph of f(x) = 33x^⁴ shifted down 2 units, since 33x - 2^⁴ = 33x^⁴ - 2.)",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "-",
            "^",
            "/"
        ]
    },
    "2.3 68 b)": {
        "question": "画出下列各函数的图。f(x)=⌊0.2x⌋。",
        "answer": "The graph will look exactly like the graph shown in Figure 10b, except that the x-axis needs to be rescaled by a factor of 5 (the first jump on the positive x-axis occurs at x = 5 here).",
        "answer_symbols": [
            "x"
        ]
    },
    "2.3 68 c)": {
        "question": "画出下列各函数的图。f(x)=⌊-1/x⌋。",
        "answer": "Since 1 - 1/x^² = -31/x^⁴ (see Exercise 54), the picture is just the picture for Exercise 67d flipped upside down.",
        "answer_symbols": [
            "-",
            "^",
            "=",
            "x"
        ]
    },
    "2.3 68 d)": {
        "question": "画出下列各函数的图。f(x)=⌊x^²⌋。",
        "answer": "The basic shape is the parabola, y = x^². However, because of the greatest integer function, the curve is broken into steps, with jumps at x = ±1, ±√2, ±√3,.... Note the symmetry around the y-axis.",
        "answer_symbols": [
            "=",
            "^",
            "±",
            "√",
            "y",
            "x"
        ]
    },
    "2.3 68 e)": {
        "question": "画出下列各函数的图。f(x)=⌊x/2⌋⌊x/2⌋。",
        "answer": "The basic shape is the parabola, y = x^²/4. However, because of the step functions, the curve is broken into steps. For x an even integer, f(x) = x^⁴/4, since the terms inside the floor and ceiling function symbols are integers. Note how these are isolated points, as in Exercise 67f.",
        "answer_symbols": [
            "=",
            "^",
            "/",
            "y",
            "x"
        ]
    },
    "2.3 69": {
        "question": "求 f(x)=x^³+1 的反函数。",
        "answer": "f^⁻¹(y) = (y - 1)^(1/3)",
        "answer_symbols": [
            "=",
            "-",
            "1",
            "^",
            "(",
            ")"
        ]
    },
    "2.3 71 a)": {
        "question": "令 S 为全集 U 的子集。S 的特征函数 f_S 是从 U 到集合 {0, 1} 的函数，使得如果 x 属于 S 则 f_S(x) = 1，如果 x 不属于 S 则 f_S(x) = 0。令 A、B 为集合。证明对于所有 x ∈ U 有 f_{A ∩ B}(x) = f_A(x) · f_B(x)。",
        "answer": "f_A ∩ B(x) = 1 ↔ x ∈ A ∩ B ↔ x ∈ A and x ∈ B ↔ f_A(x) = 1 and f_B(x) = 1 ↔ f_A(x) * f_B(x) = 1",
        "answer_symbols": [
            "∩",
            "∈",
            "=",
            "↔",
            "*"
        ]
    },
    "2.3 71 b)": {
        "question": "令 S 为全集 U 的子集。S 的特征函数 f_S 是从 U 到集合 {0, 1} 的函数，使得如果 x 属于 S 则 f_S(x) = 1，如果 x 不属于 S 则 f_S(x) = 0。令 A、B 为集合。证明对于所有 x ∈ U 有 f_{A ∪ B}(x) = f_A(x) + f_B(x) - f_A(x) · f_B(x)。",
        "answer": "f_A ∪ B(x) = 1 ↔ x ∈ A ∪ B ↔ x ∈ A or x ∈ B ↔ f_A(x) = 1 or f_B(x) = 1 ↔ f_A(x) + f_B(x) - f_A(x) * f_B(x) = 1",
        "answer_symbols": [
            "∪",
            "∈",
            "=",
            "↔",
            "+",
            "-"
        ]
    },
    "2.3 71 c)": {
        "question": "令 S 为全集 U 的子集。S 的特征函数 f_S 是从 U 到集合 {0, 1} 的函数，使得如果 x 属于 S 则 f_S(x) = 1，如果 x 不属于 S 则 f_S(x) = 0。令 A、B 为集合。证明对于所有 x ∈ U 有 f_{A^c}(x) = 1 - f_A(x)。",
        "answer": "f_A(x) = 1 ↔ x ∈ A ↔ x ∈ A ↔ f_A(x) = 0 ↔ 1 - f_A(x) = 1",
        "answer_symbols": [
            "∈",
            "=",
            "↔",
            "-"
        ]
    },
    "2.3 71 d)": {
        "question": "令 S 为全集 U 的子集。S 的特征函数 f_S 是从 U 到集合 {0, 1} 的函数，使得如果 x 属于 S 则 f_S(x) = 1，如果 x 不属于 S 则 f_S(x) = 0。令 A、B 为集合。证明对于所有 x ∈ U 有 f_{A ⊕ B}(x) = f_A(x) + f_B(x) - 2f_A(x) · f_B(x)。",
        "answer": "f_A ⊕ B(x) = 1 ↔ x ∈ A ⊕ B ↔ (x ∈ A and x ∈ B) or (x ∈ A and x ∈ B) ↔ f_A(x) + f_B(x) - 2 * f_A(x) * f_B(x) = 1",
        "answer_symbols": [
            "⊕",
            "∈",
            "=",
            "↔",
            "+",
            "-",
            "*"
        ]
    },
    "2.3 73 a)": {
        "question": "证明或推翻下列关于上取整函数和下取整函数的语句。对任意实数 x，⌊x⌋ = ⌊x⌋。",
        "answer": "True; because x is already an integer, x = x",
        "answer_symbols": [
            "=",
            "True"
        ]
    },
    "2.3 73 b)": {
        "question": "证明或推翻下列关于上取整函数和下取整函数的语句。只要 x 是实数，⌊2x⌋ = 2⌊x⌋。",
        "answer": "False; x = 0.5 is a counterexample",
        "answer_symbols": [
            "=",
            "False"
        ]
    },
    "2.3 73 c)": {
        "question": "证明或推翻下列关于上取整函数和下取整函数的语句。只要 x 和 y 是实数，⌊x⌋ + ⌊y⌋ = ⌊x + y⌋ 或 1。",
        "answer": "True; if x or y is an integer, then by property 4b in Table 1, the difference is 0",
        "answer_symbols": [
            "=",
            "True"
        ]
    },
    "2.3 74 a)": {
        "question": "证明或推翻下列关于下取整函数和上取整函数的语句。对任意实数 x，⌊x⌋ = ⌊x⌋。",
        "answer": "This is true. Since 3x4 is already an integer, 13x42 = 3x4.",
        "answer_symbols": [
            "="
        ]
    },
    "2.3 74 b)": {
        "question": "证明或推翻下列关于下取整函数和上取整函数的语句。对任意实数 x 和 y，⌊x + y⌋ = ⌊x⌋ + ⌊y⌋。",
        "answer": "A little experimentation shows that this is not always true. To disprove it we need only produce a counterexample, such as x = y = 34. In this case the left-hand side is 13/22 = 1, while the right-hand side is 0 + 0 = 0.",
        "answer_symbols": [
            "=",
            "+"
        ]
    },
    "2.3 74 c)": {
        "question": "证明或推翻下列关于下取整函数和上取整函数的语句。对任意实数 x，⌊x/2⌋ = ⌊x/4⌋。",
        "answer": "A little trial and error fails to produce a counterexample, so maybe this is true. We look for a proof. Since we are dividing by 4, let us write x = 4n + k, where 0 ≤ k < 4. In other words, write x in terms of how much it exceeds the largest multiple of 4 not exceeding it. There are three cases. If k = 0, then x is already a multiple of 4, so both sides equal n. If 0 < k ≤ 2, then 3x/24 = 2n + 1, so the left-hand side is 3n + 124 = n + 1. Of course the right-hand side is n + 1 as well, so again the two sides agree. Finally, suppose that 2 < k < 4. Then 3x/24 = 2n + 2, and the left-hand side is 3n + 14 = n + 1; of course the right-hand side is still n + 1, as well. Since we proved that the two sides are equal in all cases, the proof is complete.",
        "answer_symbols": [
            "=",
            "<",
            "≤",
            "+",
            "/"
        ]
    },
    "2.3 74 d)": {
        "question": "证明或推翻下列关于下取整函数和上取整函数的语句。对任意实数 x，⌊√⌊x⌋⌋ = ⌊√x⌋。",
        "answer": "For x = 8.5, the left-hand side is 3, whereas the right-hand side is 2.",
        "answer_symbols": [
            "="
        ]
    },
    "2.3 74 e)": {
        "question": "证明或推翻下列关于下取整函数和上取整函数的语句。对任意实数 x 和 y，⌊x⌋ + ⌊y⌋ + ⌊x + y⌋ ≤ 2⌊x⌋ + ⌊2y⌋。",
        "answer": "This is true. Write x = n + ε and y = m + δ, where n and m are integers and ε and δ are nonnegative real numbers less than 1. The left-hand side is n + m + (n + m) or n + m + (n + m + 1), the latter occurring if and only if ε + δ ≥ 1. The right-hand side is the sum of two quantities. The first is either 2n (if ε < 12) or 2n + 1 (if ε ≥ 12). The second is either 2m (if δ < 12) or 2m + 1 (if δ ≥ 12). The only way, then, for the left-hand side to exceed the right-hand side is to have the left-hand side be 2n + 2m + 1 and the right-hand side be 2n + 2m. This can occur only if ε + δ ≥ 1 while ε < 12 and δ < 12. But that is an impossibility, since the sum of two numbers less than 12 cannot be as large as 1. Therefore the right-hand side is always at least as large as the left-hand side.",
        "answer_symbols": [
            "=",
            "<",
            "≥",
            "+"
        ]
    },
    "2.3 76": {
        "question": "令 x 为实数。证明 ⌊3x⌋ = ⌊x⌋ + ⌊x + 1/3⌋ + ⌊x + 2/3⌋。",
        "answer": "A straightforward way to do this problem is to consider the three cases determined by where in the interval between two consecutive integers the real number x lies. Certainly every real number x lies in an interval [n, n + 1) for some integer n; indeed, n = 1x2. (Recall that [s, t) is the notation for the set of real numbers greater than or equal to s and less than t.) If x ∈ [n, n + 13), then 3x lies in the interval [3n, 3n + 1), so 13x2 = 3n. Moreover in this case x + 13 is still less than n + 1, and x + 23 is still less than n + 1, so 1x2 + 1x + 132 + 1x + 232 = n + n + n = 3n as well. For the second case, we assume that x ∈ [n + 13, n + 23). This time 3x ∈ [3n + 1, 3n + 2), so 13x2 = 3n + 1. Moreover in this case x + 13 is in [n + 23, n + 1), and x + 23 is in [n + 1, n + 43), so 1x2 + 1x + 132 + 1x + 232 = n + n + (n + 1) = 3n + 1 as well. The third case, x ∈ [n + 23, n + 1), is similar, with both sides equaling 3n + 2.",
        "answer_symbols": [
            "∈",
            "[",
            ")",
            "=",
            "+",
            "<"
        ]
    },
    "2.3 78 a)": {
        "question": "证明从 A 到 B 的一个部分函数 f 可以看成从 A 到 B ∪ {u} 的函数 f*，其中 u 不是 B 的元素，且 f*(a) = { f(a) 如果 a 属于 f 的定义域 { u 如果 f 在 a 点无定义。",
        "answer": "We merely have to remark that f* is well-defined by the rule given here. For each a ∈ A, either a is in the domain of definition of f or it is not. If it is, then f*(a) is the well-defined element f(a) ∈ B, and otherwise f*(a) = u. In either case f*(a) is a well-defined element of B ∪ {u}.",
        "answer_symbols": [
            "∈",
            "∪"
        ]
    },
    "2.3 78 b)": {
        "question": "使用 a) 中的构造法，找出练习 77 中各部分函数对应的 f*。",
        "answer": "We simply need to set f*(a) = u for each a not in the domain of definition of f. In part (a), then, f*(n) = 1/n for n ≠ 0, and f*(0) = u. In part (b) we have a total function already, so f*(n) = 3n/24 for all n ∈ Z. In part (c) f*(m, n) = m/n if n ≠ 0, and f*(m, 0) = u for all m ∈ Z. In part (d) we have a total function already, so f*(m, n) = mn for all values of m and n. In part (e) the rule only applies if m > n, so f*(m, n) = m − n if m > n, and f*(m, n) = u if m ≤ n.",
        "answer_symbols": [
            "∈",
            "≠",
            "/",
            "*",
            "-",
            "≤"
        ]
    },
    "2.3 80": {
        "question": "证明 S 为无穷集合当且仅当存在 S 的一个真子集 A 使得 A 到 S 有一个一一对应函数。",
        "answer": "For the “if” direction, we simply need to note that if S is a finite set, with cardinality m, then every proper subset of S has cardinality strictly smaller than m, so there is no possible one-to-one correspondence between the elements of S and the elements of the proper subset. (This is essentially the pigeonhole principle, to be discussed in Section 6.2.) The “only if” direction is much deeper. Let S be the given infinite set. Clearly S is not empty, because by definition, the empty set has cardinality 0, a nonnegative integer. Let a₀ be one element of S, and let A = S − {a₀}. Clearly A is also infinite (because if it were finite, then we would have |S| = |A| + 1, making |S| finite, which contradicts the assumption that S is infinite).",
        "answer_symbols": [
            "=",
            "∈",
            "-",
            "|",
            "+"
        ]
    },
    "2.4 2 a)": {
        "question": "如果序列 {aₙ} 的 aₙ 等于下列各值，则 a₈ 项是多少？ a) 2^ⁿ^⁻¹",
        "answer": "2^8 - 1 = 128",
        "answer_symbols": [
            "^",
            "-"
        ]
    },
    "2.4 2 b)": {
        "question": "如果序列 {aₙ} 的 aₙ 等于下列各值，则 a₈ 项是多少？ b) 7",
        "answer": "7",
        "answer_symbols": []
    },
    "2.4 2 c)": {
        "question": "如果序列 {aₙ} 的 aₙ 等于下列各值，则 a₈ 项是多少？ c) 1 + (-1)^ⁿ",
        "answer": "1 + (-1)^8 = 0",
        "answer_symbols": [
            "+",
            "^"
        ]
    },
    "2.4 2 d)": {
        "question": "如果序列 {aₙ} 的 aₙ 等于下列各值，则 a₈ 项是多少？ d) (-2)^ⁿ",
        "answer": "-(-2)^8 = -256",
        "answer_symbols": [
            "-",
            "^"
        ]
    },
    "2.4 4 a)": {
        "question": "序列 {aₙ} 的项 a₀、a₁、a₂ 和 a₃ 是什么？其中 aₙ 等于 a) (-2)^ⁿ",
        "answer": "a₀ = (-2)^0 = 1, a₁ = (-2)^1 = -2, a₂ = (-2)^2 = 4, a₃ = (-2)^3 = -8",
        "answer_symbols": [
            "=",
            "^",
            "-"
        ]
    },
    "2.4 4 b)": {
        "question": "序列 {aₙ} 的项 a₀、a₁、a₂ 和 a₃ 是什么？其中 aₙ 等于 b) 3",
        "answer": "a₀ = a₁ = a₂ = a₃ = 3",
        "answer_symbols": [
            "="
        ]
    },
    "2.4 4 c)": {
        "question": "序列 {aₙ} 的项 a₀、a₁、a₂ 和 a₃ 是什么？其中 aₙ 等于 c) 7 + 4^ⁿ",
        "answer": "a₀ = 7 + 4^0 = 8, a₁ = 7 + 4^1 = 11, a₂ = 7 + 4^2 = 23, a₃ = 7 + 4^3 = 71",
        "answer_symbols": [
            "+",
            "^",
            "="
        ]
    },
    "2.4 4 d)": {
        "question": "序列 {aₙ} 的项 a₀、a₁、a₂ 和 a₃ 是什么？其中 aₙ 等于 d) 2^ⁿ + (-2)^ⁿ",
        "answer": "a₀ = 2^0 + (-2)^0 = 2, a₁ = 2^1 + (-2)^1 = 0, a₂ = 2^2 + (-2)^2 = 8, a₃ = 2^3 + (-2)^3 = 0",
        "answer_symbols": [
            "+",
            "^",
            "=",
            "-"
        ]
    },
    "2.4 6 a)": {
        "question": "列出下列各序列的前 10 项。 a) 序列从 10 开始，后面每项都是从前项减去 3 所得。",
        "answer": "10, 7, 4, 1, -2, -5, -8, -11, -14, -17",
        "answer_symbols": [
            ","
        ]
    },
    "2.4 6 b)": {
        "question": "列出下列各序列的前 10 项。 b) 序列的第 n 项是前 n 个正整数之和。",
        "answer": "1, 3, 6, 10, 15, 21, 28, 36, 45, 55. These are called the triangular numbers.",
        "answer_symbols": [
            ","
        ]
    },
    "2.4 6 c)": {
        "question": "列出下列各序列的前 10 项。 c) 序列的第 n 项是 3^ⁿ - 2^ⁿ。",
        "answer": "1, 5, 19, 65, 211, 665, 2059, 6305, 19171, 58025",
        "answer_symbols": [
            ","
        ]
    },
    "2.4 6 d)": {
        "question": "列出下列各序列的前 10 项。 d) 序列的第 n 项是 ⌊√n⌋。",
        "answer": "1, 1, 1, 2, 2, 2, 2, 2, 3, 3 (there will be 2k + 1 copies of k)",
        "answer_symbols": [
            ","
        ]
    },
    "2.4 6 e)": {
        "question": "列出下列各序列的前 10 项。 e) 序列的前两项是 1 和 5，后面每项都是前两项之和。",
        "answer": "1, 5, 6, 11, 17, 28, 45, 73, 118, 191",
        "answer_symbols": [
            ","
        ]
    },
    "2.4 6 f)": {
        "question": "列出下列各序列的前 10 项。 f) 序列的第 n 项是具有 n 位的二进制展开式（在 4.2 节有定义）的最大整数（用十进制数写出答案）。",
        "answer": "The largest number whose binary expansion has n bits is (11...1)_2, which is 2^n - 1. So the sequence is 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023.",
        "answer_symbols": [
            "(",
            ")",
            "_",
            "^",
            "-"
        ]
    },
    "2.4 6 g)": {
        "question": "列出下列各序列的前 10 项。 g) 序列的各项以下列方式按序构造：从 1 开始，然后加 1，然后乘 1，然后加 2，然后乘 2，等等。",
        "answer": "1, 2, 2, 4, 8, 11, 33, 37, 148, 153",
        "answer_symbols": [
            ","
        ]
    },
    "2.4 6 h)": {
        "question": "列出下列各序列的前 10 项。 h) 序列的第 n 项是满足 k! ≤ n 的最大整数 k。",
        "answer": "1, 2, 2, 2, 2, 3, 3, 3, 3, 3",
        "answer_symbols": [
            ","
        ]
    },
    "2.4 8": {
        "question": "至少找出 3 个不同的序列，其初始项都是 3、5、7，并可用简单的公式或规则产生各项。",
        "answer": "One rule could be that each term is 2 greater than the previous term; the sequence would be 3, 5, 7, 9, 11, 13, .... Another rule could be that the n-th term is the n-th odd prime; the sequence would be 3, 5, 7, 11, 13, 17, .... Actually, we could choose any number we want for the fourth term (say 12) and find a third-degree polynomial whose value at n would be the n-th term; in this case, we need to solve for A, B, C, and D in the equations y = Ax^3 + Bx^2 + Cx + D where (1, 3), (2, 5), (3, 7), (4, 12) have been plugged in for x and y. Doing so yields (x^3 - 6x^2 + 15x - 4)/2. With this formula, the sequence is 3, 5, 7, 12, 23, 43, 75, 122, 187, 273. Obviously, many other answers are possible.",
        "answer_symbols": [
            ",",
            "+",
            "-",
            "^",
            "/",
            "="
        ]
    },
    "2.4 10 a)": {
        "question": "找出有下列递推关系和初始条件所定义的序列的前六项。 a) aₙ = -2aₙ₋₁, a₀ = -1",
        "answer": "a₀ = -1, a₁ = -2a₀ = 2, a₂ = -2a₁ = -4, a₃ = -2a₂ = 8, a₄ = -2a₃ = -16, a₅ = -2a₄ = 32",
        "answer_symbols": [
            "=",
            "-",
            "*"
        ]
    },
    "2.4 10 b)": {
        "question": "找出有下列递推关系和初始条件所定义的序列的前六项。 b) aₙ = aₙ₋₁ - aₙ₋₂, a₀ = 2, a₁ = -1",
        "answer": "a₀ = 2, a₁ = -1, a₂ = a₁ - a₀ = -3, a₃ = a₂ - a₁ = -2, a₄ = a₃ - a₂ = 1, a₅ = a₄ - a₃ = 3",
        "answer_symbols": [
            "=",
            "-",
            "+"
        ]
    },
    "2.4 10 c)": {
        "question": "找出有下列递推关系和初始条件所定义的序列的前六项。 c) aₙ = 3aₙ₋₁, a₀ = 1",
        "answer": "a₀ = 1, a₁ = 3a₂0 = 3, a₂ = 3a₂1 = 27 = 3^3, a₃ = 3a₂2 = 2187 = 3^7, a₄ = 3a₂3 = 14348907 = 3^15, a₅ = 3a₂4 = 617673396283947 = 3^31",
        "answer_symbols": [
            "=",
            "*",
            "^"
        ]
    },
    "2.4 10 d)": {
        "question": "找出有下列递推关系和初始条件所定义的序列的前六项。 d) aₙ = naₙ₋₁ + aₙ₋₂^², a₀ = -1, a₁ = 0",
        "answer": "a₀ = -1, a₁ = 0, a₂ = 2a₁ + a₂0 = 1, a₃ = 3a₂ + a₂1 = 3, a₄ = 4a₃ + a₂2 = 13, a₅ = 5a₄ + a₂3 = 74",
        "answer_symbols": [
            "=",
            "+",
            "*"
        ]
    },
    "2.4 10 e)": {
        "question": "找出有下列递推关系和初始条件所定义的序列的前六项。 e) aₙ = aₙ₋₁ - aₙ₋₂ + aₙ₋₃, a₀ = 1, a₁ = 1, a₂ = 2",
        "answer": "a₀ = 1, a₁ = 1, a₂ = 2, a₃ = a₂ - a₁ + a₀ = 2, a₄ = a₃ - a₂ + a₁ = 1, a₅ = a₄ - a₃ + a₂ = 1",
        "answer_symbols": [
            "=",
            "+",
            "-"
        ]
    },
    "2.5 2 a)": {
        "question": "确定下列各集合是否是有限的、可数无限的或不可数的。对那些可数无限集合，给出在自然数集合和该集合之间的一一对应。（a）大于 10 的整数。",
        "answer": "这个集合是可数无限的。集合中的整数是 11, 12, 13, 14，等等。我们可以按这个顺序列出这些数字，从而建立所需的对应关系。换句话说，对应关系为 1 ↔ 11, 2 ↔ 12, 3 ↔ 13，等等；一般而言 n ↔ (n + 10)。",
        "answer_symbols": [
            "↔",
            "+"
        ]
    },
    "2.5 2 b)": {
        "question": "确定下列各集合是否是有限的、可数无限的或不可数的。对那些可数无限集合，给出在自然数集合和该集合之间的一一对应。（b）奇负整数。",
        "answer": "这个集合是可数无限的。集合中的整数是 -1, -3, -5, -7，等等。我们可以按这个顺序列出这些数字，从而建立所需的对应关系。换句话说，对应关系为 1 ↔ -1, 2 ↔ -3, 3 ↔ -5，等等；一般而言 n ↔ -(2n - 1)。",
        "answer_symbols": [
            "↔",
            "-",
            "*"
        ]
    },
    "2.5 2 c)": {
        "question": "确定下列各集合是否是有限的、可数无限的或不可数的。对那些可数无限集合，给出在自然数集合和该集合之间的一一对应。（c）绝对值小于 1 000 000 的整数。",
        "answer": "这个集合是 { -999,999, -999,998, ..., -1, 0, 1, ..., 999,999 }。它是有限的，基数为 1,999,999。",
        "answer_symbols": [
            "{",
            "}",
            ",",
            "-"
        ]
    },
    "2.5 2 d)": {
        "question": "确定下列各集合是否是有限的、可数无限的或不可数的。对那些可数无限集合，给出在自然数集合和该集合之间的一一对应。（d）0 和 2 之间的实数。",
        "answer": "这个集合是不可数的。我们可以通过与示例 5 中用于证明所有实数集不可数相同的对角线论证来证明这一点。",
        "answer_symbols": []
    },
    "2.5 2 e)": {
        "question": "确定下列各集合是否是有限的、可数无限的或不可数的。对那些可数无限集合，给出在自然数集合和该集合之间的一一对应。（e）集合 A × Z^⁺ 这里 A = {2, 3}。",
        "answer": "这个集合是可数的。我们可以按 (2, 1), (3, 1), (2, 2), (3, 2), (2, 3), (3, 3), ... 的顺序列出其元素，给我们提供了一对一的对应关系 1 ↔ (2, 1), 2 ↔ (3, 1), 3 ↔ (2, 2), 4 ↔ (3, 2), 5 ↔ (2, 3), 6 ↔ (3, 3), ...。",
        "answer_symbols": [
            "↔",
            ","
        ]
    },
    "2.5 2 f)": {
        "question": "确定下列各集合是否是有限的、可数无限的或不可数的。对那些可数无限集合，给出在自然数集合和该集合之间的一一对应。（f）10 的整倍数。",
        "answer": "这个集合是可数的。集合中的整数是 0, ±10, ±20, ±30，等等。我们可以按 0, 10, -10, 20, -20, 30, ... 的顺序列出这些数字，从而建立所需的对应关系。换句话说，对应关系为 1 ↔ 0, 2 ↔ 10, 3 ↔ -10, 4 ↔ 20, 5 ↔ -20, 6 ↔ 30，等等。",
        "answer_symbols": [
            "±",
            "↔",
            "-"
        ]
    },
    "2.5 4 a)": {
        "question": "确定下列各集合是否是可数的或不可数的。对那些可数无限集合，给出在自然数集合和该集合之间的——对应。（a）不能被 3 整除的整数",
        "answer": "这个集合是可数的。集合中的整数是 ±1, ±2, ±4, ±5, ±7，等等。我们可以按 1, -1, 2, -2, 4, -4, 5, -5, 7, -7, ... 的顺序列出这些数字，从而建立所需的对应关系。换句话说，对应关系为 1 ↔ 1, 2 ↔ -1, 3 ↔ 2, 4 ↔ -2, 5 ↔ 4，等等。",
        "answer_symbols": [
            "±",
            "↔",
            "-"
        ]
    },
    "2.5 4 b)": {
        "question": "确定下列各集合是否是可数的或不可数的。对那些可数无限集合，给出在自然数集合和该集合之间的——对应。（b）能被 5 整除但不能被 7 整除的整数",
        "answer": "这类似于部分 (a)；我们可以简单地按绝对值递增的顺序列出集合的元素，每个正项在其对应的负项之前：5, -5, 10, -10, 15, -15, 20, -20, 25, -25, 30, -30, 40, -40, 45, -45, 50, -50, ...。",
        "answer_symbols": [
            "-",
            "↔"
        ]
    },
    "2.5 4 c)": {
        "question": "确定下列各集合是否是可数的或不可数的。对那些可数无限集合，给出在自然数集合和该集合之间的——对应。（c）十进制表示是全 1 的实数",
        "answer": "这个集合是可数的但有点棘手。我们可以将数字排列成二维表格如下： .1 .1 .11 .111 .1111 .11111 .111111 ... 1.1 1 1.1 1.11 1.111 1.1111 1.11111 ... 11.1 11 11.1 11.11 11.111 11.1111 11.11111 ... 111.1 111 111.1 111.11 111.111 111.1111 111.11111 ... ... ... ... ... 因此我们已经证明了我们的集合是可数个可数集的并集（每个可数集是该表格的一行）。因此，根据练习 27，整个集合是可数的。对于显式的对应关系，可以将表格中的每一行按顺序列出。",
        "answer_symbols": [
            "."
        ]
    },
    "2.5 4 d)": {
        "question": "确定下列各集合是否是可数的或不可数的。对那些可数无限集合，给出在自然数集合和该集合之间的——对应。（d）十进制表示是全 1 或全 9 的实数",
        "answer": "This set is not countable. We can prove it using the same diagonalization argument as in Example 5, which shows that the set of all real numbers is uncountable. Specifically, we choose d_i = 1 when d_ii = 9, and d_i = 9 when d_ii = 1 or d_ii is blank (if the decimal expansion is finite).",
        "answer_symbols": [
            "=",
            "<->"
        ]
    },
    "2.5 6": {
        "question": "假设希尔伯特大饭店已客满，但是饭店要关闭所有偶数编号的房间进行维修。证明所有客人依然可以住在饭店里",
        "answer": "We need a one-to-one function from the set of positive integers to the set of odd positive integers. The simplest function to use is f(n) = 2n - 1. This function maps the guest currently in Room n to Room (2n - 1). For example, the guest in Room 1 stays in Room 1, the guest in Room 2 moves to Room 3, the guest in Room 3 moves to Room 5, and so on.",
        "answer_symbols": [
            "-",
            "->",
            "="
        ]
    },
    "2.5 8": {
        "question": "证明可数无限个客人到达客满的希尔伯特大饭店时依然可以在不赶走客人的情况下得到房间",
        "answer": "First, we can make the move explained in Exercise 6, which frees up all the even-numbered rooms. The new guests can then be placed in these rooms (the first new guest goes to Room 2, the second new guest goes to Room 4, and so on).",
        "answer_symbols": []
    },
    "2.5 9": {
        "question": "假设有可数无限辆巴士，每辆载有可数无限多位客人到达客满的希尔伯特大饭店。证明在不赶走客人的情况下所有达到的客人都可以住进希尔伯特大饭店",
        "answer": "将目前在房间 i 的客人移动到房间 2i + 1，对于 i = 1, 2, 3, ...。将第 k 辆车上的第 j 位客人放入房间 2k(2j + 1)。",
        "answer_symbols": [
            "+",
            "*",
            "(",
            ")"
        ]
    },
    "2.5 10 a)": {
        "question": "给出两个不可数集合 A 和 B 的例子使得 A−B 是（a）有限的",
        "answer": "We can let B be the set of real numbers as well; then A - B = Ø, which is finite.",
        "answer_symbols": [
            "-",
            "Ø"
        ]
    },
    "2.5 10 b)": {
        "question": "给出两个不可数集合 A 和 B 的例子使得 A−B 是（b）可数无限的",
        "answer": "We can let B be the set of real numbers that are not positive integers; in symbols, B = A - Z+. Then A - B = Z+, which is countably infinite.",
        "answer_symbols": [
            "-",
            "Z+"
        ]
    },
    "2.5 10 c)": {
        "question": "给出两个不可数集合 A 和 B 的例子使得 A−B 是（c）不可数的",
        "answer": "We can let B be the set of positive real numbers. Then A - B is the set of negative real numbers and 0, which is uncountable.",
        "answer_symbols": [
            "-",
            "0"
        ]
    },
    "2.5 12": {
        "question": "证明如果 A 和 B 是集合且 A⊆B，则 |A| ≤ |B|",
        "answer": "The definition of |A| ≤ |B| is that there is a one-to-one function from A to B. In this case, the desired function is just f(x) = x for each x ∈ A.",
        "answer_symbols": [
            "|",
            "<=",
            "->",
            "∈",
            "="
        ]
    },
    "2.5 13": {
        "question": "试解释为什么集合 A 是可数的当且仅当 |A| ≤ |Z^⁺|",
        "answer": "假设 A 是可数的。那么 A 的基数为某个非负整数 n，在这种情况下，存在一个从 A 到 Z^⁺ 的子集的一对一函数（范围是前 n 个正整数），或者存在一个从 A 到 Z^⁺ 的一对一对应关系 f；在这两种情况下，我们满足了定义 2。相反，假设 |A| ≤ |Z^⁺|。根据定义，这意味着存在一个从 A 到 Z^⁺ 的一对一函数，因此 A 与 Z^⁺ 的子集（即该函数的范围）具有相同的基数。根据练习 16，我们得出 A 是可数的。",
        "answer_symbols": [
            "|",
            "|",
            "≤",
            "→",
            "∈",
            "⊆"
        ]
    },
    "2.5 14": {
        "question": "证明如果 A 和 B 是集合并具有相同的基数，则 |A| ≤ |B| 并且 |B| ≤ |A|",
        "answer": "If A and B have the same cardinality, then we have a one-to-one correspondence f: A → B. The function f meets the requirement of the definition that |A| ≤ |B|, and f^-1 meets the requirement of the definition that |B| ≤ |A|.",
        "answer_symbols": [
            "|",
            "<=",
            "->",
            "^-1"
        ]
    },
    "2.5 15": {
        "question": "证明如果 A 和 B 是集合，A 是不可数的，并且 A⊆B，则 B 是不可数的",
        "answer": "假设 B 是可数的。那么 B 的元素可以被列出来为 b₁, b₂, b₃, ...。因为 A 是 B 的子集，取 {bₙ} 中包含 A 中项的子序列给出 A 的元素列表。因为 A 是不可数的，这是不可能的。",
        "answer_symbols": [
            "⊆"
        ]
    },
    "2.5 16": {
        "question": "证明可数集的子集是可数的",
        "answer": "If a set A is countable, then we can list its elements, a1, a2, a3, ..., an, ... (possibly ending after a finite number of terms). Every subset of A consists of some (or none or all) of the items in this sequence, and we can list them in the same order in which they appear in the sequence. This gives us a sequence (again, infinite or finite) listing all the elements of the subset. Thus, the subset is also countable.",
        "answer_symbols": []
    },
    "2.5 17": {
        "question": "如果 A 是不可数集合而 B 是可数集合，那么 A−B 一定是不可数的吗",
        "answer": "假设 A - B 是可数的。然后，因为 A = (A - B) ∪ (A ∩ B)，A 的元素可以通过交替 A - B 和 A ∩ B 的元素来列出。这与 A 的不可数性相矛盾。",
        "answer_symbols": [
            "-",
            "∪",
            "∩"
        ]
    },
    "2.5 18": {
        "question": "证明如果 A 和 B 是集合且 |A| = |B|，则 |P(A)| = |P(B)|",
        "answer": "The hypothesis gives us a one-to-one and onto function f from A to B. By Exercise 16e in the supplementary exercises for this chapter, the function S_f from P(A) to P(B) defined by S_f(X) = f(X) for all X ⊆ A is one-to-one and onto. Therefore, P(A) and P(B) have the same cardinality.",
        "answer_symbols": [
            "->",
            "⊆",
            "=",
            "P"
        ]
    },
    "2.5 19": {
        "question": "证明如果 A、B、C 和 D 是集合且 |A| = |B| 和 |C| = |D|，则 |A×C| = |B×D|",
        "answer": "我们得到了从 A 到 B 的双射 f 和从 C 到 D 的双射 g。然后，从 A × C 到 B × D 发送 (a, c) 到 (f(a), g(c)) 的函数是一个双射。",
        "answer_symbols": [
            "→",
            "×",
            "(",
            ")"
        ]
    },
    "2.5 20": {
        "question": "证明如果 |A| = |B| 且 |B| = |C|，则 |A| = |C|",
        "answer": "By definition, we have one-to-one onto functions f: A → B and g: B → C. Then g ◦ f is a one-to-one onto function from A to C, so |A| = |C|.",
        "answer_symbols": [
            "->",
            "◦",
            "|",
            "="
        ]
    },
    "2.5 21": {
        "question": "证明如果 A、B 和 C 是集合使得 |A| ≤ |B| 和 |B| ≤ |C|，则 |A| ≤ |C|",
        "answer": "根据 |A| ≤ |B| 的定义，存在一个从 A 到 B 的一对一函数 f。类似地，存在一个从 B 到 C 的一对一函数 g。根据第 2.3 节中的练习 33，复合函数 g ◦ f：A → C 是一对一的。因此根据定义 |A| ≤ |C|。",
        "answer_symbols": [
            "|",
            "|",
            "≤",
            "→",
            "◦"
        ]
    },
    "2.5 22": {
        "question": "假设 A 是可数集合。证明如果存在一个从 A 到 B 的映上函数 f，则 B 也是可数的",
        "answer": "If A = Ø, then the only way for the conditions to be met is that B = Ø as well, and we are done. So assume that A is nonempty. Let f be the given onto function from A to B, and let g: Z+ → A be an onto function that establishes the countability of A. (If A is finite rather than countably infinite, say of cardinality k, then the function g will be defined so that g(1), g(2), ..., g(k) will list the elements of A, and g(n) = g(1) for n > k.) We need to find an onto function from Z+ to B. The function f ◦ g does the trick, because the composition of two onto functions is onto (Exercise 33b in Section 2.3).",
        "answer_symbols": [
            "=",
            "Ø",
            "->",
            "◦",
            "Z+",
            "k"
        ]
    },
    "2.5 23": {
        "question": "证明如果 A 是一个无限集合，则它包含可数无限子集",
        "answer": "使用集合论中的选择公理，一次选择 A 中的不同元素 a₁, a₂, a₃, ...（这是可能的，因为 A 是无限的）。得到的集合 {a₁, a₂, a₃, ...} 是所需的 A 的无限子集。",
        "answer_symbols": [
            "{",
            "}",
            "∈"
        ]
    },
    "2.5 24": {
        "question": "证明不存在无限集合 A 使得 |A| < |Z^⁺| = ℵ₀",
        "answer": "Because |A| < |Z+|, there is a one-to-one function f: A → Z+. We are also given that A is infinite, so the range of f has to be infinite. We will construct a bijection g from Z+ to A. For each n ∈ Z+, let m be the nth smallest element in the range of f. Then g(n) = f^⁻¹(m). The existence of g contradicts the definition of |A| < |Z+|, and our proof is complete.",
        "answer_symbols": [
            "<",
            "->",
            "|",
            "∈",
            "Z+",
            "⁻¹",
            "^-1",
            "→"
        ]
    },
    "2.5 25": {
        "question": "证明如果有可能用 (具有有限个字符的) 键盘字符的有限串来标记一个无限集 S 的每个元素，且 S 中没有两个元素具有相同的标记，则 S 是可数无限集",
        "answer": "有限字母表上的字符有限字符串集是可数无限的，因为我们可以通过长度按字母顺序列出这些字符串。因此，无限集 S 可以与这个可数集的一个无限子集标识，根据练习 16，这也是可数无限的。",
        "answer_symbols": [
            "⊆"
        ]
    },
    "2.5 26": {
        "question": "利用练习 25 给出一个不同于书上的方法来证明有理数集是可数的。[提示：证明你能将一个有理数表示为一串带有斜杠的数字外加可能的减号]",
        "answer": "我们可以使用来自集合 {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, /, -} 的字符串来标记有理数，方法是写下表示该有理数最简形式的字符串（没有前导零，分母不为零，分子和分母之间没有大于1的公因数，如果数字是负数，则在前面加上减号）。这些标签是唯一的。从练习25可以直接得出有理数集是可数的。",
        "answer_symbols": [
            "{",
            "}",
            "/"
        ]
    },
    "2.5 27": {
        "question": "证明可数多个可数集的并集是可数的",
        "answer": "假设 A₁, A₂, A₃, ... 是可数集。因为 Aᵢ 是可数的，我们可以将其元素按序列列出为 aᵢ₁, aᵢ₂, aᵢ₃, ...。集合 ∪^ⁿᵢ₌₁ Aᵢ 的元素可以通过列出所有项 aᵢⱼ 使得 i + j = 2，然后所有项 aᵢⱼ 使得 i + j = 3，然后所有项 aᵢⱼ 使得 i + j = 4，等等来列出。",
        "answer_symbols": [
            "∪",
            "=",
            "+"
        ]
    },
    "2.5 28": {
        "question": "证明集合 Z^⁺×Z^⁺ 是可数的",
        "answer": "我们可以将 Z+ × Z+ 视为可数集合的可数并集，其中集合中的第i个集合（对于 i 属于 Z+）是 {(i, n) | n 属于 Z+}。现在从练习27可以得出结论。",
        "answer_symbols": [
            "×",
            "∈",
            "{",
            "}",
            "|"
        ]
    },
    "2.5 29": {
        "question": "证明所有有限位串的集合是可数的",
        "answer": "长度为 m 的位串的数量是有限的，即 2ᵐ。所有位串的集合是长度为 m 的位串集合的并集，其中 m = 0, 1, 2, ...。因为可数数量的可数集的并集是可数的（见练习 27），所以有可数数量的位串。",
        "answer_symbols": [
            "^",
            "∪"
        ]
    },
    "2.5 30": {
        "question": "证明二次方程 ax^2 + bx + c = 0 的实数解的集合是可数的，其中 a、b 和 c 都是整数",
        "answer": "每个二次方程最多有两个实数解，因此只要三元组 (a, b, c) 的数量是可数的，解的数量就是可数的。其中 a, b 和 c 是整数。但这可以从练习27中得出。因为对于每个 b（b 的数量是可数的），只有可数对 (b, c)，其 b 作为第一个坐标。现在对于每个 a（a 的数量是可数的），只有可数个三元组以该 a 作为第一个坐标（因为我们刚刚证明了只有可数对 (b, c)）。因此，再次根据练习27，只有可数个三元组。",
        "answer_symbols": [
            "(",
            ")",
            ",",
            "{",
            "}",
            "|"
        ]
    },
    "2.5 31": {
        "question": "通过证明多项式函数 f : Z^+ × Z^+ → Z^+，f(m, n) = (m + n - 2)(m + n - 1)/2 + m 是一对一和映射的来证明 Z^+ × Z^+ 是可数集",
        "answer": "从公式可以看出，对于固定的 m + n 值，比如 m + n = x，函数取值范围是从 (x - 2)(x - 1)/2 + 1 到 (x - 2)(x - 1)/2 + (x - 1)，因为 m 在这些条件下可以取 1, 2, 3, ..., (x - 1)，并且当 m + n 固定时，公式中的第一项是一个固定的正整数。为了证明这个函数是一对一且满射的，我们只需要证明 x + 1 的值域恰好从 x 的值域结束的地方开始，即 f(x - 1, 1) + 1 = f(1, x)。我们有 f(x - 1, 1) + 1 = (x - 2)(x - 1) / 2 + (x - 1) + 1 = x^² - x + 2 / 2 = (x - 1)x / 2 + 1 = f(1, x)。",
        "answer_symbols": [
            "+",
            "-",
            "(",
            ")",
            "/",
            "^",
            "=",
            "→"
        ]
    },
    "2.5 32": {
        "question": "证明当用 (3n + 1)^2 来替换练习 31 的函数 f(m, n) 右边表达式的每个 n 的出现时，用 (3m + 1)^2 来替换每个 m 的出现时，你会得到一个一对一的多项式函数 Z × Z → Z。是否存在一个一对一的多项式函数 Q × Q → Q 是一个开放问题",
        "answer": "在练习31中我们看到 f(m, n) = (m + n - 2)(m + n - 1)/2 + m 是一个从 Z+ × Z+ 到 Z+ 的一一函数。我们希望扩展定义域到 Z × Z，所以如果我们要保持它是一一函数，需要稍微分散一下。如果我们能找到一个从 Z × Z 到 Z+ × Z+ 的一一函数 g，那么组合这两个函数将是我们的目标一一函数，从 Z × Z 到 Z（根据第2.3节练习33a，一一函数的组合是一一函数）。这里建议的函数是 g(m, n) = ((3m + 1)^², (3n + 1)^²)，因此组合函数为 (f ◦ g)(m, n) = ((3m + 1)^² + (3n + 1)^² - 2)((3m + 1)^² + (3n + 1)^² - 1)/2 + (3m + 1)^²。要看到 g 是一一函数，首先注意到每个坐标的函数行为都是一一的；即，将整数 k 映射到正整数 (3k + 1)^² 的函数是一一的。要看到这一点，首先注意如果 k1 ≠ k2 并且 k1 和 k2 都是正数或都是负数，那么 (3k1 + 1)^² ≠ (3k2 + 1)^²。如果一个是非负数而另一个是负数，那么它们在这函数下的像不能相同，因为非负整数被映射到除以3余1的数的平方（0 → 1^², 1 → 4^², 2 → 7^², ...），而负整数被映射到除以3余2的数的平方（-1 → 2^², -2 → 5^², -3 → 8^², ...）。",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "-",
            "*",
            "/",
            "²",
            "≠",
            "→",
            "×",
            "∈",
            "◦"
        ]
    },
    "2.5 33": {
        "question": "利用 Schröder-Bernstein 定理证明 (0, 1) 和 [0, 1] 具有相同的基数",
        "answer": "根据 Schröder-Bernstein 定理，找到从 (0, 1) 到 [0, 1] 的一对一函数 f 和从 [0, 1] 到 (0, 1) 的一对一函数 g 即可。令 f(x) = x 和 g(x) = (x + 1) / 3。",
        "answer_symbols": [
            "→",
            "[",
            "]",
            "(",
            ")",
            "+",
            "/"
        ]
    },
    "2.5 34": {
        "question": "证明 (0, 1) 和 R 具有相同的基数。[提示：利用 Schröder-Bernstein 定理]",
        "answer": "只需找到从 (0, 1) 到 R 和从 R 到 (0, 1) 的一一函数 f 和 g。在第一种情况下，我们可以显然使用函数 f(x) = x。对于第二种情况，我们可以通过使用反正切函数将 R 压缩到 (0, 1)，该函数已知是单射的；令 g(x) = 2 arctan(x)/π。然后根据 Schröder-Bernstein 定理，|(0, 1)| = |R|。",
        "answer_symbols": [
            "(",
            ")",
            "→",
            "×",
            "∈",
            "arctan",
            "π",
            "|",
            "="
        ]
    },
    "2.5 35": {
        "question": "证明不存在从正整数集合到正整数集合的幂集的一一对应。[提示：假设存在这样的——对应。将正整数集的一个子集表示为一个无限位串，其中第 i 位为 1 如果 i 属于该子集，否则为 0。假设你能将这些无限位串排成正整数下标的序列。构造一个新的位串，其第 i 位等于序列中第 i 个位串的第 i 位的补。证明这个新位串不可能出现在该序列中]",
        "answer": "正整数集的幂集的每个元素 A（即 A ⊆ Z^⁺）都可以唯一地由位串 a₁a₂a₃... 表示，其中 aᵢ = 1 如果 i ∈ A，aᵢ = 0 如果 i ∉ A。假设存在从 Z^⁺ 到 P(Z^⁺) 的一对一对应关系 f。通过设置 sᵢ 为 1 减去 f(i) 的第 i 位形成一个新的位串 s = s₁s₂s₃...。因为 s 在第 i 位与 f(i) 不同，s 不在 f 的范围内，这是一个矛盾。",
        "answer_symbols": [
            "⊆",
            "∈",
            "∉",
            "→"
        ]
    },
    "2.5 36": {
        "question": "证明从正整数集的集合到 0 和 1 之间实数的集合存在一个一一对应。利用这个结果以及练习 34 和 35 推出结论 |N| < |P(Z^+)| = |R|。[提示：看看练习 35 提示的第一部分]",
        "answer": "我们可以将正整数集的子集编码为由 5 和 6 组成的字符串，其中第 i 个符号如果是 5 表示 i 在子集中，否则为 6。如果我们通过在前面加上 0 和小数点将此字符串解释为实数，那么我们已经构建了一个从 P(Z+) 到 (0, 1) 的一一函数。另外，我们可以通过将二进制展开为 0.d1d2d3... 的数映射到集合 {i | di = 1} 来构造从 (0, 1) 到 P(Z+) 的一一函数。因此，根据 Schröder-Bernstein 定理，|P(Z+)| = |(0, 1)|。根据练习34，|(0, 1)| = |R|，所以我们已经证明了 |P(Z+)| = |R|。（我们已经知道从康托尔对角线论证得出 ℵ0 < |R|。）这里有一个技术细节。为了使从 (0, 1) 到 P(Z+) 的函数明确定义，我们必须选择如何表示具有终止二进制展开的数（例如，0.100101 或 0.100110）；我们可以决定始终使用终止形式，即以全 0 结尾的形式。",
        "answer_symbols": [
            "ℵ",
            "=",
            ".",
            "<",
            "×",
            "∈",
            "|",
            "}",
            "→",
            "{"
        ]
    },
    "2.5 37": {
        "question": "证明用特定编程语言编写的所有计算机程序的集合是可数的。[提示：可以认为用编程语言编写的一个计算机程序是有限字母表上的一个符号串]",
        "answer": "对于任何有限字母表，长度为 n 的字符串数量是有限的，无论 n 是正整数。根据练习 27 的结果，从任何给定的有限字母表中只有可数数量的字符串。因为特定语言中的所有计算机程序集是有限字母表的所有字符串集的子集，根据练习 16 的结果，这是一个可数集，因此它本身是一个可数集。",
        "answer_symbols": [
            "⊆"
        ]
    },
    "2.5 39": {
        "question": "一个函数是可计算的(computable)如果存在一个计算机程序能够计算函数的值。用练习 27 和 38 证明存在不可计算的函数",
        "answer": "练习 37 显示只有可数数量的计算机程序。因此，只有可数数量的可计算函数。因为，正如练习 38 所显示的那样，有不可数数量的函数，不是所有的函数都是可计算的。",
        "answer_symbols": [
            "⊆"
        ]
    },
    "2.6 1 a)": {
        "question": "令 A = ⎡⎢⎣0 0 1\\1 0 0\\1 1 0⎤⎥⎦。A 的大小是什么？",
        "answer": "3 × 4",
        "answer_symbols": [
            "×"
        ]
    },
    "2.6 1 b)": {
        "question": "令 A = ⎡⎢⎣0 0 1\\1 0 0\\1 1 0⎤⎥⎦。A 的第 3 列是什么？",
        "answer": "[1 4 3]",
        "answer_symbols": [
            "[",
            "]"
        ]
    },
    "2.6 1 c)": {
        "question": "令 A = ⎡⎢⎣0 0 1\\1 0 0\\1 1 0⎤⎥⎦。A 的第 2 行是什么？",
        "answer": "[2 0 4 6]",
        "answer_symbols": [
            "[",
            "]"
        ]
    },
    "2.6 1 d)": {
        "question": "令 A = ⎡⎢⎣0 0 1\\1 0 0\\1 1 0⎤⎥⎦。A 在 (3, 2) 位置上的元素是什么？",
        "answer": "1",
        "answer_symbols": []
    },
    "2.6 1 e)": {
        "question": "令 A = ⎡⎢⎣0 0 1\\1 0 0\\1 1 0⎤⎥⎦。A^T 是什么？",
        "answer": "[1 2 1 0 1 1 4 3 3 6 7]",
        "answer_symbols": [
            "[",
            "]"
        ]
    },
    "2.6 2 a)": {
        "question": "求 A + B，其中 A = ⎡⎢⎣1 0 4\\-1 2 2\\0 -2 -3⎤⎥⎦，B = ⎡⎢⎣-1 3 5\\2 2 -3\\2 -3 0⎤⎥⎦。",
        "answer": "[ 0 3 9 ]\n[ 1 4 -1 ]\n[ 2 -5 -3 ]",
        "answer_symbols": [
            "[",
            "]",
            "+",
            "-"
        ]
    },
    "2.6 2 b)": {
        "question": "求 A + B，其中 A = ⎡⎢⎣-1 0 5 6\\-4 -3 5 -2⎤⎥⎦，B = ⎡⎢⎣-3 9 -3 4\\0 -2 -1 2⎤⎥⎦。",
        "answer": "[-4 9 2 ]\n[10 -4 -5 ]\n[ 4 0 0 ]",
        "answer_symbols": [
            "[",
            "]",
            "+",
            "-"
        ]
    },
    "2.6 3 a)": {
        "question": "求 AB，如果 A = ⎡⎢⎣2 1\\3 2⎤⎥⎦，B = ⎡⎢⎣0 4\\1 3⎤⎥⎦。",
        "answer": "[1 11 2 18]",
        "answer_symbols": [
            "[",
            "]"
        ]
    },
    "2.6 3 b)": {
        "question": "求 AB，如果 A = ⎡⎢⎣1 -1\\0 1\\2 3⎤⎥⎦，B = ⎡⎢⎣3 -2 -1\\1 0 2⎤⎥⎦。",
        "answer": "[2 -2 -3 1 0 2 9 -4 4]",
        "answer_symbols": [
            "[",
            "]",
            "-"
        ]
    },
    "2.6 3 c)": {
        "question": "求 AB，如果 A = ⎡⎢⎣4 -3\\3 -1\\0 -2\\-1 5⎤⎥⎦，B = ⎡⎢⎣-1 3 2 -2\\0 -1 4 -3⎤⎥⎦。",
        "answer": "[-4 15 -4 1 -3 10 2 -3 0 2 -8 6 1 -8 18 -13]",
        "answer_symbols": [
            "[",
            "]",
            "-"
        ]
    },
    "2.6 4 a)": {
        "question": "求乘积 AB，其中 A = ⎡⎢⎣1 0 1\\0 -1 -1\\-1 1 0⎤⎥⎦，B = ⎡⎢⎣0 1 -1\\1 -1 0\\-1 0 1⎤⎥⎦。",
        "answer": "[-1 1 0 ]\n[ 0 1 -1 ]\n[ 1 -2 1 ]",
        "answer_symbols": [
            "[",
            "]",
            "+",
            "-"
        ]
    },
    "2.6 4 b)": {
        "question": "求乘积 AB，其中 A = ⎡⎢⎣1 -3 0\\1 2 2\\2 1 -1⎤⎥⎦，B = ⎡⎢⎣1 -1 2 3\\-1 0 3 -1\\-3 -2 0 2⎤⎥⎦。",
        "answer": "[ 4 -1 -7 ]\n[ 6 -7 -5 ]\n[ 8 5 4 ]\n[ 0 7 3 ]",
        "answer_symbols": [
            "[",
            "]",
            "+",
            "-"
        ]
    },
    "2.6 4 c)": {
        "question": "求乘积 AB，其中 A = ⎡⎢⎣0 -1\\7 2\\-4 3⎤⎥⎦，B = ⎡⎢⎣4 -1 2 3 0\\-2 0 3 4 1⎤⎥⎦。",
        "answer": "[ 2 0 -3 ]\n[ -4 -1 24 ]\n[ -7 20 29 ]\n[ 2 -10 4 ]\n[-17 -24 -3 ]",
        "answer_symbols": [
            "[",
            "]",
            "+",
            "-"
        ]
    },
    "2.6 5": {
        "question": "求矩阵 A 使得 [[2, 3], [1, 4]] A = [[3, 0], [1, 2]]. [提示：求解 A 需要解线性方程组。]",
        "answer": "[9/5 -6/5 -1/5 4/5]",
        "answer_symbols": [
            "[",
            "]",
            "/",
            "-"
        ]
    },
    "2.6 6": {
        "question": "求矩阵 A 使得 [[2, 1, 1], [4, 0, 3]] A = [[7, 1, 3], [1, 0, 3], [-1, -3, 7]].",
        "answer": "First note that A must be a 3×3 matrix in order for the sizes to work out as shown. If we name the elements of A in the usual way as [aij], then the given equation is really nine equations in the nine unknowns aij.通过写出左边矩阵乘法的含义，可以得到以下方程：\n1 * a11 + 3 * a21 + 2 * a31 = 7 \n1 * a12 + 3 * a22 + 2 * a32 = 1 \n1 * a13 + 3 * a23 + 2 * a33 = 3 \n2 * a11 + 1 * a21 + 1 * a31 = 1 \n2 * a12 + 1 * a22 + 1 * a32 = 0 \n2 * a13 + 1 * a23 + 1 * a33 = 3 \n4 * a11 + 0 * a21 + 3 * a31 = -1 \n4 * a12 + 0 * a22 + 3 * a32 = -3 \n4 * a13 + 0 * a23 + 3 * a33 = 7 \n这实际上并没有看起来那么复杂，因为每个变量只出现在三个方程中。例如，第一个、第四个和第七个方程是关于变量 a11、a21 和 a31 的三个方程系统。\n我们可以使用标准代数技术解这些方程，得到 a11 = -1, a21 = 2 和 a31 = 1。类似地，我们还可以得到 a12 = 0, a22 = 1 和 a32 = -1；以及 a13 = 1, a23 = 0 和 a33 = 1。因此，我们的答案是：\nA =\n| -1 0 1 |\n| 2 1 0 |\n| 1 -1 1 |\n为了验证，我们可以进行矩阵乘法运算，确认结果与给定的右侧一致。",
        "answer_symbols": [
            "*",
            "=",
            "+",
            "-",
            "|"
        ]
    },
    "2.6 7": {
        "question": "令 A 为 m × n 矩阵，0 为元素全为 0 的 m × n 矩阵。证明 A+0=A=0+A。",
        "answer": "0 + A = [0 + aij] = [aij + 0] = 0 + A",
        "answer_symbols": [
            "+",
            "=",
            "[",
            "]"
        ]
    },
    "2.6 8": {
        "question": "证明矩阵加法是可交换的，即证明如果 A 和 B 均为 m × n 矩阵，则 A+B=B+A。",
        "answer": "由于矩阵 A + B 的元素是 aij + bij，而矩阵 B + A 的元素是 bij + aij，因此 A + B = B + A 由实数加法的交换性得出。",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "2.6 9": {
        "question": "证明矩阵加法是可结合的，即证明如果 A、B 和 C 均为 m × n 矩阵，则 A+(B+C)=(A+B)+C。",
        "answer": "A + (B + C) = [aij + (bij + cij)] = [(aij + bij) + cij] = (A + B) + C",
        "answer_symbols": [
            "+",
            "=",
            "[",
            "]",
            "(",
            ")"
        ]
    },
    "2.6 11": {
        "question": "如果乘积 AB 和 BA 均有定义，对矩阵 A 和 B 的大小能知道些什么？",
        "answer": "A 的行数等于 B 的列数，A 的列数等于 B 的行数。",
        "answer_symbols": [
            "=",
            "∈"
        ]
    },
    "2.6 13": {
        "question": "本题要证明矩阵乘法的结合律。假定 A 是 m × p 矩阵，B 是 p × k 矩阵，C 是 k × n 矩阵。证明 A(BC)=(AB)C。",
        "answer": "A(BC) = [∑q aiq(∑r bqr crl)] = [∑q∑r aiq bqr crl] = [∑r∑q aiq bqr crl] = [∑r(∑q aiq bqr) crl] = (AB)C",
        "answer_symbols": [
            "=",
            "[",
            "]",
            "(",
            ")",
            "∑",
            "→"
        ]
    },
    "2.6 14": {
        "question": "n × n 矩阵 A=[a_ij] 称为对角矩阵，如果对所有 i ≠ j 有 a_ij=0。证明两个 n × n 对角矩阵的乘积仍是对角矩阵。给出计算这一乘积的一个简单规则。",
        "answer": "设 A 和 B 是两个对角线 n × n 矩阵。设 C = [cij] 是乘积 AB。根据矩阵乘法的定义，cij = ∑ aiqbqj。现在这个表达式中的所有项 aiq 除了 q = i 都为 0，所以 cij = aiibij。但 bij 只有在 i = j 时才不为 0，所以 C 的唯一非零元素是对角线元素 cii = aiibii。",
        "answer_symbols": [
            "=",
            "∑",
            "*",
            "≠",
            "0"
        ]
    },
    "2.6 15": {
        "question": "令 A= [[1, 1], [0, 1]]。找出计算 A^n 的公式，其中 n 为正整数。",
        "answer": "A^ⁿ = [1 n 0 1]",
        "answer_symbols": [
            "=",
            "[",
            "]",
            "^"
        ]
    },
    "2.6 16": {
        "question": "证明 (A^T)^T=A。",
        "answer": "矩阵 (At)t 的 (i, j) 元素是矩阵 At 的 (j, i) 元素，即矩阵 A 的 (i, j) 元素。",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "2.6 17 a)": {
        "question": "令 A 和 B 为两个 n × n 矩阵。证明 a) (A+B)^T=A^T+B^T",
        "answer": "设 A = [aij] 和 B = [bij]。则 A + B = [aij + bij]。我们有 (A + B)ᵗ = [aji + bji] = [aji] + [bji] = Aᵗ + Bᵗ。",
        "answer_symbols": [
            "=",
            "[",
            "]",
            "+",
            "→"
        ]
    },
    "2.6 17 b)": {
        "question": "令 A 和 B 为两个 n × n 矩阵。证明 b) (AB)^T=B^T A^T",
        "answer": "使用与部分 (a) 相同的符号，我们有 B^T A^T = [∑q bqi ajq] = [∑q ajq bqi] = (AB)^T，因为 (i, j) 项是 AB 的 (j, i) 项",
        "answer_symbols": [
            "→",
            ",",
            "(",
            "[",
            "^",
            "T",
            ")",
            "∑",
            "=",
            "]"
        ]
    },
    "2.6 18": {
        "question": "证明 [[2, 3, -1], [1, 2, 1], [-1, -1, 3]] 是 [[7, -8, 5], [-4, 5, -3], [1, -1, 1]] 的逆。",
        "answer": "我们需要在这两个方向上乘以这两个矩阵，并检查两个乘积是否都是 I3。\n确实如此。",
        "answer_symbols": []
    },
    "2.6 19": {
        "question": "令 A 为 2×2 矩阵，A= [[a, b], [c, d]]。证明如果 ad-bc ≠ 0，则 A^-1=[[d/(ad-bc), -b/(ad-bc)], [-c/(ad-bc), a/(ad-bc)]]。",
        "answer": "结果是因为 [a b; -c a] [d -b; -c a] = [ad - bc 0; 0 ad - bc] = (ad - bc)I_2",
        "answer_symbols": [
            "[",
            "]",
            ";",
            "=",
            "(",
            ")",
            "I",
            "_",
            "-"
        ]
    },
    "2.6 20 a)": {
        "question": "令 A= [[-1, 2], [1, 3]]。a) 求 A^-1 [提示：利用练习 19 的结果]。",
        "answer": "使用练习 19，注意到 ad - bc = -5，我们可以立即写出逆矩阵：[-3/5 2/5 1/5 1/5]",
        "answer_symbols": [
            "-",
            "=",
            "[",
            "]"
        ]
    },
    "2.6 20 b)": {
        "question": "令 A= [[-1, 2], [1, 3]]。b) 求 A^3。",
        "answer": "We multiply to obtain A^² = [32 141] and then A^³ = [1 18 9 37]",
        "answer_symbols": [
            "=",
            "[",
            "]"
        ]
    },
    "2.6 20 c)": {
        "question": "令 A= [[-1, 2], [1, 3]]。c) 求 (A^(-1))^3。",
        "answer": "We multiply to obtain (A^⁻¹)^² = [11/25 -4/25 -2/25 3/25] and then (A^⁻¹)^³ = [-37/125 18/125 9/125 -1/125]",
        "answer_symbols": [
            "=",
            "[",
            "]"
        ]
    },
    "2.6 20 d)": {
        "question": "令 A= [[-1, 2], [1, 3]]。d) 用 b) 和 c) 的答案证明 (A^(-1))^3 是 A^3 的逆。",
        "answer": "Applying the method of Exercise 19 for obtaining inverses to the answer in part (b), we obtain the answer in part (c). Therefore (A^³)^⁻¹ = (A^⁻¹)^³.",
        "answer_symbols": [
            "="
        ]
    },
    "2.6 21": {
        "question": "令 A 为可逆矩阵。证明当 n 是正整数时就有 (A^n)^-1 = (A^-1)^n。",
        "answer": "A^n (A^{-1})^n = A(A ... (A(AA^{-1})A^{-1}) ... A^{-1})A^{-1} 由结合律。因为 AA^{-1} = I，从内向外工作显示 A^n (A^{-1})^n = I。同样 (A^{-1})^n A^n = I。因此 (A^n)^{-1} = (A^{-1})^n",
        "answer_symbols": [
            "^",
            "(",
            ")",
            "A",
            "I",
            "=",
            "-",
            "n",
            "…"
        ]
    },
    "2.6 23": {
        "question": "假设 A 是 n×n 矩阵，其中 n 是正整数。证明 A + A^T 是对称的。",
        "answer": "A + A^T 的 (i, j) 项是 aij + aji，等于 aji + aij，即 A + A^T 的 (j, i) 项，所以按定义 A + A^T 是对称的",
        "answer_symbols": [
            "+",
            "^",
            "T",
            "(",
            ")",
            "=",
            ","
        ]
    },
    "2.6 25": {
        "question": "用练习 18 和 24 解方程组 7x1 - 8x2 + 5x3 = 5 -4x1 + 5x2 - 3x3 = -3 x1 - x2 + x3 = 0",
        "answer": "x1 = 1, x2 = -1, x3 = -2",
        "answer_symbols": [
            "=",
            ","
        ]
    },
    "2.6 26 a)": {
        "question": "令 A = [1 1; 0 1] 和 B = [0 1; 1 0]。求 A ∨ B",
        "answer": "[11 11]",
        "answer_symbols": [
            "["
        ]
    },
    "2.6 26 b)": {
        "question": "令 A = [1 1; 0 1] 和 B = [0 1; 1 0]。求 A ∧ B",
        "answer": "[00 10]",
        "answer_symbols": [
            "["
        ]
    },
    "2.6 26 c)": {
        "question": "令 A = [1 1; 0 1] 和 B = [0 1; 1 0]。求 A ⊙ B",
        "answer": "[11 10]",
        "answer_symbols": [
            "["
        ]
    },
    "2.6 27 a)": {
        "question": "令 A = [1 1 0; 1 1 0; 0 0 1] 和 B = [0 1 1; 1 0 1; 1 0 1]。求 A ∨ B",
        "answer": "[1 1 1; 1 1 0; 1 1 1]",
        "answer_symbols": [
            "[",
            "]",
            ";",
            "1",
            "0"
        ]
    },
    "2.6 27 b)": {
        "question": "令 A = [1 1 0; 1 1 0; 0 0 1] 和 B = [0 1 1; 1 0 1; 1 0 1]。求 A ∧ B",
        "answer": "[0 0 1; 1 0 0; 0 0 1]",
        "answer_symbols": [
            "[",
            "]",
            ";",
            "0",
            "1"
        ]
    },
    "2.6 27 c)": {
        "question": "令 A = [1 1 0; 1 1 0; 0 0 1] 和 B = [0 1 1; 1 0 1; 1 0 1]。求 A ⊙ B",
        "answer": "[1 1 1; 1 1 0; 1 1 1] [0 0 1; 0 1 0; 1 0 0] [0 0 1; 1 1 1; 1 0 0] [0 0 1; 1 1 1; 1 1 1]",
        "answer_symbols": [
            "[",
            "]",
            ";",
            "1",
            "0"
        ]
    },
    "2.6 28": {
        "question": "求 A 和 B 的布尔积，其中 A = [1 0 0 1; 0 1 0 1; 1 1 1 1] B = [1 0; 0 1; 1 1; 1 0]",
        "answer": "[1 0 11 11]",
        "answer_symbols": [
            "["
        ]
    },
    "2.6 30 a)": {
        "question": "令 A 为 0-1 矩阵。证明 A ∨ A = A",
        "answer": "A ∨ A = [a_ij ∨ a_ij] = [a_ij] = A",
        "answer_symbols": [
            "∨",
            "=",
            "["
        ]
    },
    "2.6 30 b)": {
        "question": "令 A 为 0-1 矩阵。证明 A ∧ A = A",
        "answer": "A ∧ A = [a_ij ∧ a_ij] = [a_ij] = A",
        "answer_symbols": [
            "∧",
            "=",
            "["
        ]
    },
    "2.6 31 a)": {
        "question": "本题证明交和并运算是可交换的。令 A 和 B 为 m×n 阶 0-1 矩阵。证明 A ∨ B = B ∨ A",
        "answer": "A ∨ B = [aij ∨ bij] = [bij ∨ aij] = B ∨ A",
        "answer_symbols": [
            "∨",
            "[",
            "]",
            "="
        ]
    },
    "2.6 31 b)": {
        "question": "本题证明交和并运算是可交换的。令 A 和 B 为 m×n 阶 0-1 矩阵。证明 A ∧ B = B ∧ A",
        "answer": "A ∧ B = [aij ∧ bij] = [bij ∧ aij] = B ∧ A",
        "answer_symbols": [
            "∧",
            "[",
            "]",
            "="
        ]
    },
    "2.6 32 a)": {
        "question": "本题证明交和并运算是可结合的。令 A、B 和 C 为 m×n 阶 0-1 矩阵。证明 (A ∨ B) ∨ C = A ∨ (B ∨ C)",
        "answer": "(A ∨ B) ∨ C = [(a_ij ∨ b_ij) ∨ c_ij] = [a_ij ∨ (b_ij ∨ c_ij)] = A ∨ (B ∨ C)",
        "answer_symbols": [
            "∨",
            "=",
            "["
        ]
    },
    "2.6 32 b)": {
        "question": "本题证明交和并运算是可结合的。令 A、B 和 C 为 m×n 阶 0-1 矩阵。证明 (A ∧ B) ∧ C = A ∧ (B ∧ C)",
        "answer": "This is identical to part (a), with ∧ replacing ∨.",
        "answer_symbols": [
            "∨",
            "∧"
        ]
    },
    "2.6 33 a)": {
        "question": "本题建立交对并运算的分配律。令 A、B 和 C 为 m×n 阶 0-1 矩阵。证明 A ∨ (B ∧ C) = (A ∨ B) ∧ (A ∨ C)",
        "answer": "A ∨ (B ∧ C) = [aij] ∨ [bij ∧ cij] = [aij ∨ (bij ∧ cij)] = [(aij ∨ bij) ∧ (aij ∨ cij)] = [aij ∨ bij] ∧ [aij ∨ cij] = (A ∨ B) ∧ (A ∨ C)",
        "answer_symbols": [
            "∨",
            "∧",
            "[",
            "]",
            "(",
            ")",
            "="
        ]
    },
    "2.6 33 b)": {
        "question": "本题建立交对并运算的分配律。令 A、B 和 C 为 m×n 阶 0-1 矩阵。证明 A ∧ (B ∨ C) = (A ∧ B) ∨ (A ∧ C)",
        "answer": "A ∧ (B ∨ C) = [aij] ∧ [bij ∨ cij] = [aij ∧ (bij ∨ cij)] = [(aij ∧ bij) ∨ (aij ∧ cij)] = [aij ∧ bij] ∨ [aij ∧ cij] = (A ∧ B) ∨ (A ∧ C)",
        "answer_symbols": [
            "∧",
            "∨",
            "[",
            "]",
            "(",
            ")",
            "="
        ]
    },
    "2.6 34": {
        "question": "令 A 为 n×n 阶 0-1 矩阵，令 I 为 n×n 单位矩阵。证明 A ⊙ I = I ⊙ A = A。",
        "answer": "Since the i-th row of I consists of all 0’s except for a 1 in the (i, i)-th position, we have I 9 A = [(0 ∧ a_1j) ∨ ... ∨ (1 ∧ a_ij) ∨ ... ∨ (0 ∧ a_nj)] = [a_ij] = A. Similarly, since the j-th column of I consists of all 0’s except for a 1 in the (j, j)-th position, we have A 9 I = [(a_i1 ∧ 0) ∨ ... ∨ (a_ij ∧ 1) ∨ ... ∨ (a_in ∧ 0)] = [a_ij] = A.",
        "answer_symbols": [
            "∧",
            "∨",
            "=",
            "["
        ]
    },
    "2.6 35": {
        "question": "本题证明 0-1 矩阵的布尔积是可结合的。假定 A 是 m×p 阶 0-1 矩阵，B 是 p×k 阶 0-1 矩阵，C 是 k×n 阶 0-1 矩阵。证明 A ⊙ (B ⊙ C) = (A ⊙ B) ⊙ C。",
        "answer": "A(BC) = [∨q aiq ∧ (∨r (bqr ∧ crl))] = [∨q ∨r (aiq ∧ bqr ∧ crl)] = [∨r ∨q (aiq ∧ bqr ∧ crl)] = [∨r (∨q (aiq ∧ bqr)) ∧ crl] = (AB)C",
        "answer_symbols": [
            "∨",
            "∧",
            "[",
            "]",
            "(",
            ")",
            "="
        ]
    },
    "2 Supplementary Exercises 2": {
        "question": "证明如果 A 是 B 的子集，则 A 的幂集是 B 的幂集的子集。",
        "answer": "We are given that A ⊆ B. We want to prove that the power set of A is a subset of the power set of B, which means that if C ⊆ A then C ⊆ B. But this follows directly from Exercise 17 in Section 2.1.",
        "answer_symbols": [
            "⊆"
        ]
    },
    "2 Supplementary Exercises 4 a)": {
        "question": "令 E 表示偶整数集合，O 表示奇整数集合。令 Z 表示整数集合。确定下列每个集合。（a）E ∪ O",
        "answer": "Z",
        "answer_symbols": []
    },
    "2 Supplementary Exercises 4 b)": {
        "question": "令 E 表示偶整数集合，O 表示奇整数集合。令 Z 表示整数集合。确定下列每个集合。（b）E ∩ O",
        "answer": "Ø",
        "answer_symbols": [
            "Ø"
        ]
    },
    "2 Supplementary Exercises 4 c)": {
        "question": "令 E 表示偶整数集合，O 表示奇整数集合。令 Z 表示整数集合。确定下列每个集合。（c）Z - E",
        "answer": "O",
        "answer_symbols": []
    },
    "2 Supplementary Exercises 7": {
        "question": "令 A、B、和 C 为集合。证明 (A - B) - C 不一定等于 A - (B - C)",
        "answer": "(A - B) - C = ∅，但 A - (B - C) = {1}",
        "answer_symbols": [
            "-",
            "∅",
            "="
        ]
    },
    "2 Supplementary Exercises 11 a)": {
        "question": "令 A 和 B 为有限全集 U 的两个子集。按照递增顺序列出下列各项。（a）|A|, |A ∪ B|, |A ∩ B|, |U|, |∅|",
        "answer": "|∅| ≤ |A ∩ B| ≤ |A| ≤ |A ∪ B| ≤ |U|",
        "answer_symbols": [
            "|",
            "∅",
            "≤",
            "∩",
            "∪"
        ]
    },
    "2 Supplementary Exercises 11 b)": {
        "question": "令 A 和 B 为有限全集 U 的两个子集。按照递增顺序列出下列各项。（b）|A - B|, |A ⊕ B|, |A| + |B|, |A ∪ B|, |∅|",
        "answer": "|∅| ≤ |A - B| ≤ |A ⊕ B| ≤ |A ∪ B| ≤ |A| + |B|",
        "answer_symbols": [
            "|",
            "∅",
            "≤",
            "-",
            "⊕",
            "∪",
            "+"
        ]
    },
    "2 Supplementary Exercises 12": {
        "question": "令 A 和 B 为有限全集 U 的两个子集。证明 |A ∩ B| = |U| - |A| - |B| + |A ∪ B|",
        "answer": "因为 A ∩ B = (A ∪ B)，所以我们要证明的是 |A ∪ B| = |U| - (|A| + |B| - |A ∩ B|)。这直接从以下事实得出：|X| = |U| - |X|（这从定义上是显而易见的）以及（参见第2.2节示例5后的讨论）|A ∪ B| = |A| + |B| - |A ∩ B|。",
        "answer_symbols": [
            "∩",
            "∪",
            "=",
            "|",
            "-",
            "+"
        ]
    },
    "2 Supplementary Exercises 14": {
        "question": "假设 f 是一个从 A 到 B 的函数，其中 A 和 B 为有限集。试解释为什么对于 A 的所有子集均有 |f(S)| ≤ |S|",
        "answer": "定义一个函数 g: f(S) → S，对于f(S)中的每个元素x，选择一个元素g(x) ∈ S，使得f(g(x)) = x。显然，g是一对一的，因此 |f(S)| ≤ |S|。注意我们不需要假设A和B是有限的。",
        "answer_symbols": [
            "→",
            "∈",
            "=",
            "|",
            "≤"
        ]
    },
    "2 Supplementary Exercises 15": {
        "question": "假设 f 是一个从 A 到 B 的函数，其中 A 和 B 为有限集。试解释为什么对于 A 的所有子集 |f(S)| = |S| 成立当且仅当 f 是一对一的",
        "answer": "如果 f 是一对一的，则 f 提供了 S 和 f(S) 之间的双射，因此它们具有相同的基数。如果 f 不是一对一的，则存在 S 中的元素 x 和 y 使得 f(x) = f(y)。设 S = {x, y}。那么 |S| = 2 但 |f(S)| = 1",
        "answer_symbols": [
            "=",
            "{",
            "}",
            "|",
            "→"
        ]
    },
    "2 Supplementary Exercises 17": {
        "question": "证明如果 f 和 g 均为从 A 到 B 的函数并且 S_f = S_g（使用练习 16 前言中的定义），则对于所有 x ∈ A 必有 f(x) = g(x)",
        "answer": "令 x ∈ A。则 S_f({x}) = {f(y) | y ∈ {x}} = {f(x)}。同样的推理，S_g({x}) = {g(x)}。因为 S_f = S_g，可以得出结论 {f(x)} = {g(x)}，因此必然有 f(x) = g(x)",
        "answer_symbols": [
            "∈",
            "=",
            "{",
            "}",
            "|",
            "→"
        ]
    },
    "2 Supplementary Exercises 18": {
        "question": "证明如果 n 是一个整数，则 n = ⌊n/2⌋ + ⌊n/2⌋",
        "answer": "如果n是偶数，那么n/2是一个整数，所以3n/24 + 1n/22 = (n/2) + (n/2) = n。如果n是奇数，那么3n/24 = (n+1)/2 和 1n/22 = (n - 1)/2，所以总和仍然是n。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "/"
        ]
    },
    "2 Supplementary Exercises 1 a)": {
        "question": "令 A 为包含字母 x 的英文单词集合，B 为包含字母 q 的英文单词集合。试用 A、B 的组合来表示下列集合：",
        "answer": "A",
        "answer_symbols": []
    },
    "2 Supplementary Exercises 1 b)": {
        "question": "令 A 为包含字母 x 的英文单词集合，B 为包含字母 q 的英文单词集合。试用 A、B 的组合来表示下列集合： b) 包含字母 x 和 q 的英文单词集合。",
        "answer": "A ∩ B",
        "answer_symbols": [
            "∩"
        ]
    },
    "2 Supplementary Exercises 1 c)": {
        "question": "令 A 为包含字母 x 的英文单词集合，B 为包含字母 q 的英文单词集合。试用 A、B 的组合来表示下列集合： c) 包含字母 x 而不包含字母 q 的英文单词集合。",
        "answer": "A - B",
        "answer_symbols": [
            "-"
        ]
    },
    "2 Supplementary Exercises 1 d)": {
        "question": "令 A 为包含字母 x 的英文单词集合，B 为包含字母 q 的英文单词集合。试用 A、B 的组合来表示下列集合： d) 不包含字母 x 或 q 的英文单词集合。",
        "answer": "A ∩ B",
        "answer_symbols": [
            "∩"
        ]
    },
    "2 Supplementary Exercises 1 e)": {
        "question": "令 A 为包含字母 x 的英文单词集合，B 为包含字母 q 的英文单词集合。试用 A、B 的组合来表示下列集合： e) 包含 x 或 q 但不同时包含二者的英文单词集合。",
        "answer": "A ⊕ B",
        "answer_symbols": [
            "⊕"
        ]
    },
    "2 Supplementary Exercises 3": {
        "question": "假定 A 和 B 为集合使得 A 的幂集是 B 的幂集的子集。是否一定有 A 是 B 的子集？",
        "answer": "是",
        "answer_symbols": []
    },
    "2 Supplementary Exercises 5": {
        "question": "证明如果 A 和 B 为集合，则 A - (A - B) = A ∩ B",
        "answer": "A - (A - B) = A - (A ∩ B) = A ∩ (A ∩ B) = A ∩ (A ∪ B) = (A ∩ A) ∪ (A ∩ B) = ∅ ∪ (A ∩ B) = A ∩ B",
        "answer_symbols": [
            "-",
            "∩",
            "∪",
            "∅",
            "="
        ]
    },
    "2 Supplementary Exercises 6": {
        "question": "令 A 和 B 为集合。证明 A ⊆ B 当且仅当 A ∩ B = A",
        "answer": "If A ⊆ B, then every element in A is also in B, so clearly A ∩ B = A. Conversely, if A ∩ B = A, then every element of A must also be in A ∩ B, and hence in B. Therefore A ⊆ B.",
        "answer_symbols": [
            "⊆",
            "∩",
            "="
        ]
    },
    "2 Supplementary Exercises 8": {
        "question": "假定 A、B、和 C 为集合。证明或推翻 (A - B) - C = (A - C) - B",
        "answer": "This identity is true, so we must show that every element in the left-hand side is also an element in the right-hand side and conversely. Let x ∈ (A - B) - C. Then x ∈ A - B but x ∉ C. This means that x ∈ A, but x ∉ B and x ∉ C. Therefore x ∈ A - C, and therefore x ∈ (A - C) - B. The converse is proved in exactly the same way.",
        "answer_symbols": [
            "∈",
            "-",
            "∉"
        ]
    },
    "2 Supplementary Exercises 9": {
        "question": "假定 A、B、C 和 D 为集合。证明或推翻 (A - B) - (C - D) = (A - C) - (B - D)",
        "answer": "不。例如，(A - B) - (C - D) = ∅ - ∅ = ∅，但 (A - C) - (B - D) = {a, b} - {b} = {a}",
        "answer_symbols": [
            "-",
            "∅",
            "="
        ]
    },
    "2 Supplementary Exercises 10": {
        "question": "证明如果 A 和 B 为有限集合，则 |A ∩ B| ≤ |A ∪ B|。判断什么时候等号成立",
        "answer": "不等式源于明显的事实 A ∩ B ⊆ A ∪ B。只有当A或B中没有不是同时属于A和B的元素时，等式才能成立，而这只有在A=B时才可能发生。",
        "answer_symbols": [
            "⊆",
            "∪",
            "∩"
        ]
    },
    "2 Supplementary Exercises 13 a)": {
        "question": "令 f 和 g 分别为从 {1, 2, 3, 4} 到 {a, b, c, d} 和从 {a, b, c, d} 到 {1, 2, 3, 4} 的两个函数，且 f(1) = d, f(2) = c, f(3) = a, f(4) = b, 以及 g(a) = 2, g(b) = 1, g(c) = 3, g(d) = 2。（a）f 是否是一对一的？g 是否是一对一的？",
        "answer": "是，否",
        "answer_symbols": []
    },
    "2 Supplementary Exercises 16 a)": {
        "question": "假设 f 是一个从 A 到 B 的函数。证明：（a）如果 f 是一对一函数，则 S_f 是从 P(A) 到 P(B) 的一对一函数",
        "answer": "已知f是一对一的，我们必须证明Sf是一对一的。假设X1 ≠ X2，其中这些是A的子集。我们需要证明Sf(X1) ≠ Sf(X2)。不失一般性，设有一个元素a ∈ X1 - X2。这意味着f(a) ∈ Sf(X1)。如果f(a)也是Sf(X2)的元素，则需要一个元素a' ∈ X2，使得f(a') = f(a)。但由于f是一对一的，这迫使a' = a，这是不可能的，因为a ∉ X2。因此f(a) ∈ Sf(X1) - Sf(X2)，所以Sf(X1) ≠ Sf(X2)。",
        "answer_symbols": [
            "≠",
            "∈",
            "⊆",
            "→",
            "∩",
            "-"
        ]
    },
    "2 Supplementary Exercises 19": {
        "question": "对于哪些实数 x, y 有 ⌊x + y⌋ = ⌊x⌋ + ⌊y⌋ 为真",
        "answer": "方程成立当且仅当 x 和 y 的小数部分之和小于 1",
        "answer_symbols": [
            "<",
            "∑",
            "→"
        ]
    },
    "2 Supplementary Exercises 20": {
        "question": "对于哪些实数 x, y 有 ⌊x + y⌋ = ⌊x⌋ + ⌊y⌋ 为真",
        "answer": "如果x或y中的任何一个都是整数，那么这个方程显然是正确的，因为它相当于第2.3节表1中的恒等式(4b)。否则，用它们的整数部分和小数部分表示x和y：x = n + ε 和 y = m + δ，其中n = ⌊x⌋，0 < ε < 1，m = ⌊y⌋，0 < δ < 1。如果δ + ε > 1，那么方程是正确的，因为两边都等于m + n + 2；如果δ + ε ≤ 1，那么方程是错误的，因为左边等于m + n + 1，而右边等于m + n + 2。总结一下：当且仅当x和y中至少有一个是整数或者x和y的小数部分之和大于1时，方程是正确的。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "<",
            ">",
            "⌊",
            "⌋"
        ]
    },
    "2 Supplementary Exercises 21": {
        "question": "对于哪些实数 x, y 有 ⌊x + y⌋ = ⌊x⌋ + ⌊y⌋ 为真",
        "answer": "方程成立当且仅当 x 和 y 都是整数，或者 x 不是整数但 x 和 y 的小数部分之和小于或等于 1",
        "answer_symbols": [
            "<",
            "=",
            "∑",
            "→"
        ]
    },
    "2 Supplementary Exercises 22": {
        "question": "证明对于所有整数 n 有 ⌊n/2⌋ ⌊n/2⌋ = ⌊n^²/4⌋",
        "answer": "取整函数和天花板函数的值取决于它们的参数是否为整数。因此这里似乎有两种情况。首先假设n是偶数。那么n/2是一个整数，n^²/4也是一个整数，所以方程是一个简单的代数事实。第二种情况更复杂。假设n是奇数，设 n= 2k+ 1。那么 n/2= k+ 1/2。因此左侧给出我们 k(k+ 1)= k^²+ k，因为第一个因子需要向下取整而第二个因子需要向上取整。右侧呢？\nn^²=(2k+ 1)^²= 4k^²+ 4k+ 1，所以 n^²/4= k^²+ k+ 1/4。因此取底函数给我们 k^²+ k，证明完成。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "/",
            "²"
        ]
    },
    "2 Supplementary Exercises 23": {
        "question": "证明如果 m 是整数，则有 ⌊x⌋ + ⌊m - x⌋ = m - 1 除非 x 是整数；当 x 为整数时表达式等于 m",
        "answer": "如果 x 是整数，那么 x + ⌊m - x⌋ = x + ⌊m - x⌋ = m。否则，将 x 表示为其整数部分和小数部分：x = n + ε，其中 n = ⌊x⌋ 且 0 < ε < 1。在这种情况下 x + ⌊m - x⌋ = n + ε + ⌊m - n - ε⌋ = n + ε + m - n - 1 = m - 1",
        "answer_symbols": [
            "⌊",
            "⌋",
            "+",
            "<",
            "=",
            "→"
        ]
    },
    "2 Supplementary Exercises 24": {
        "question": "证明如果 x 是实数，则有 ⌊x/2⌋ ⌊2⌋ = ⌊x/4⌋",
        "answer": "由于我们要除以 4，让我们写 x= 4n − k，其中 0 ≤ k< 4。换句话说，用 x 小于但最接近它的 4 的倍数少多少来表示 x。有三种情况。如果 k= 0，那么 x 已经是 4 的倍数，所以两边都等于 n。如果 0< k ≤ 2，那么 [x/2]= 2n − 1，所以左侧是 [n− 1/2]= n−1。当然右侧也是 n−1，所以两边一致。最后，假设 2< k< 4。那么 [x/2]= 2n − 2，左侧是 [n − 1/2]= n − 1；当然右侧仍然是 n − 1。因为我们证明了在所有情况下两边相等，证明完成。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "/",
            "²"
        ]
    },
    "2 Supplementary Exercises 25": {
        "question": "证明如果 n 是奇数，则有 ⌊n^²/4⌋ = (n^² + 3)/4",
        "answer": "写 n = 2k + 1 对于某些整数 k。那么 n^2 = 4k^2 + 4k + 1，所以 ⌊n^2 / 4⌋ = k^2 + k + 1。但是 ⌊(n^2 + 3) / 4⌋ = (4k^2 + 4k + 1 + 3) / 4 = k^2 + k + 1",
        "answer_symbols": [
            "=",
            "+",
            "⌊",
            "⌋",
            "/",
            "→"
        ]
    },
    "2 Supplementary Exercises 26": {
        "question": "证明如果 m, n 均为正整数，而 x 为实数，则有 ⌊(x + n)/m⌋ = ⌊(x + n)/m⌋",
        "answer": "如果 x 是整数，那么当然两边相同。所以假设 x= k+ ε，其中 k 是整数且 ε 是一个实数，0< ε< 1。那么左侧的值，即 [(k+ n)/m]，和右侧的值，即 [(k+ n+ ε)/m]，是相同的，因为向分数的分子（分子和分母都是整数）加上一个严格介于 0 和 1 之间的数不会使分数达到下一个更高的整数值（分子不会达到 m 的下一个倍数）。\n",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "/"
        ]
    },
    "2 Supplementary Exercises 27": {
        "question": "证明如果 m 是正整数，而 x 是实数，则有 ⌊mx⌋ = ⌊x⌋ + ⌊x + 1/m⌋ + ⌊x + 2/m⌋ + ⋯ + ⌊x + (m - 1)/m⌋",
        "answer": "令 x = n + (r/m) + ε，其中 n 是整数，r 是小于 m 的非负整数，ε 是实数且 0 ≤ ε < 1/m。左侧是 nm + r + mε = nm + r。右侧，从 x 到 x + (m + r - 1)/m 的项都是 n，从 x + (m - r)/m 开始的项都是 n + 1。因此，右侧是 (m - r)n + r(n + 1) = nm + r，与左侧相同",
        "answer_symbols": [
            "=",
            "+",
            "≤",
            "→"
        ]
    },
    "2 Supplementary Exercises 4 d)": {
        "question": "令 E 表示偶整数集合，O 表示奇整数集合。令 Z 表示整数集合。确定下列每个集合。（d）Z - O",
        "answer": "E",
        "answer_symbols": []
    },
    "2 Supplementary Exercises 13 b)": {
        "question": "令 f 和 g 分别为从 {1, 2, 3, 4} 到 {a, b, c, d} 和从 {a, b, c, d} 到 {1, 2, 3, 4} 的两个函数，且 f(1) = d, f(2) = c, f(3) = a, f(4) = b, 以及 g(a) = 2, g(b) = 1, g(c) = 3, g(d) = 2。（b）f 是否是映上的？g 是否是映上的？",
        "answer": "是，否",
        "answer_symbols": []
    },
    "2 Supplementary Exercises 13 c)": {
        "question": "令 f 和 g 分别为从 {1, 2, 3, 4} 到 {a, b, c, d} 和从 {a, b, c, d} 到 {1, 2, 3, 4} 的两个函数，且 f(1) = d, f(2) = c, f(3) = a, f(4) = b, 以及 g(a) = 2, g(b) = 1, g(c) = 3, g(d) = 2。（c）f 或 g 是否有逆？如果有，求出其逆函数",
        "answer": "f 有逆，且 f^(-1)(a) = 3, f^(-1)(b) = 4, f^(-1)(c) = 2, f^(-1)(d) = 1；g 没有逆",
        "answer_symbols": [
            "^",
            "(",
            ")",
            "=",
            ",",
            ";"
        ]
    },
    "2 Supplementary Exercises 16 b)": {
        "question": "假设 f 是一个从 A 到 B 的函数。证明：（b）如果 f 是映上函数，则 S_f 是从 P(A) 到 P(B) 的映上函数",
        "answer": "已知f是满射的，我们必须证明Sf是满射的。假设Y ⊆ B。我们需要找到X ⊆ A，使得Sf(X) = Y。令X = {x ∈ A | f(x) ∈ Y}。我们声称Sf(X) = Y。显然Sf(X) ⊆ Y。为了证明Y ⊆ Sf(X)，假设b ∈ Y。由于f是满射的，存在某个a ∈ A，使得f(a) = b。根据X的定义，a ∈ X。因此按定义b ∈ Sf(X)。",
        "answer_symbols": [
            "⊆",
            "∈",
            "=",
            "→",
            "∩"
        ]
    },
    "2 Supplementary Exercises 16 c)": {
        "question": "假设 f 是一个从 A 到 B 的函数。证明：（c）如果 f 是映上函数，则 S_f 是从 P(B) 到 P(A) 的一对一函数",
        "answer": "已知f是满射的，我们必须证明Sf^-1是一对一的。假设Y1 ≠ Y2，其中这些是B的子集。我们需要证明Sf^-1(Y1) ≠ Sf^-1(Y2)。不失一般性，设有一个元素b ∈ Y1 - Y2。因为f是满射的，存在一个a ∈ A，使得f(a) = b。因此a ∈ Sf^-1(Y1)。但我们也知道a ∉ Sf^-1(Y2)，因为如果a是Sf^-1(Y2)的元素，那么我们会有b = f(a) ∈ Y2，这与我们选择的b矛盾。这个a的存在表明Sf^-1(Y1) ≠ Sf^-1(Y2)。",
        "answer_symbols": [
            "≠",
            "∈",
            "⊆",
            "→",
            "∩",
            "-"
        ]
    },
    "2 Supplementary Exercises 16 d)": {
        "question": "假设 f 是一个从 A 到 B 的函数。证明：（d）如果 f 是一对一函数，则 S_f 是从 P(B) 到 P(A) 的映上函数",
        "answer": "已知f是一对一的，我们必须证明Sf^-1是满射的。假设X ⊆ A。我们需要找到Y ⊆ B，使得Sf^-1(Y) = X。令Y = Sf(X)。换句话说，Y = {f(x) | x ∈ X}。我们必须证明Sf^-1(Y) = X，这意味着我们必须证明{u ∈ A | f(u) ∈ {f(x) | x ∈ X}} = X（为了清晰起见，我们将哑变量改为u）。右边是左边的子集是直接的，因为如果u ∈ X，那么f(u)是某个x ∈ X的f(x)。相反，假设u在左边。因此f(u) = f(x0)，对于某个x0 ∈ X。但由于f是一对一的，我们知道u = x0；即u ∈ X。",
        "answer_symbols": [
            "⊆",
            "∈",
            "=",
            "→",
            "∩"
        ]
    },
    "2 Supplementary Exercises 16 e)": {
        "question": "假设 f 是一个从 A 到 B 的函数。证明：（e）如果 f 是一个一一对应，则 S_f 是从 P(A) 到 P(B) 的一一对应并且 S_f 是从 P(B) 到 P(A) 的一一对应。[提示：利用 a) - d)。]",
        "answer": "这直接从前几部分得出，因为一对一对应意味着一对一且满射。",
        "answer_symbols": []
    },
    "2 Supplementary Exercises 28 a)": {
        "question": "我们定义乌拉姆数(Ulam number): 设 u_1 = 1 和 u_2 = 2。再者，在判断小于 n 的整数是否是乌拉姆数之后，如果 n 可以被唯一地写成两个不同的乌拉姆数之和，则设 n 为下一个乌拉姆数。注意 u_3 = 3，u_4 = 4，u_5 = 6，u_6 = 8。（a）求前 20 个乌拉姆数",
        "answer": "1, 2, 3, 4, 6, 8, 11, 13, 16, 18, 26, 28, 36, 38, 47, 48, 53, 57, 62, 69",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "/"
        ]
    },
    "2 Supplementary Exercises 28 b)": {
        "question": "我们定义乌拉姆数(Ulam number): 设 u_1 = 1 和 u_2 = 2。再者，在判断小于 n 的整数是否是乌拉姆数之后，如果 n 可以被唯一地写成两个不同的乌拉姆数之和，则设 n 为下一个乌拉姆数。注意 u_3 = 3，u_4 = 4，u_5 = 6，u_6 = 8。（b）证明存在无穷多个乌拉姆数",
        "answer": "假设只有有限个乌拉姆数，记为 u1< u2< · · ·< un。那么显然 un−1+ un 可以唯一地表示为两个不同的乌拉姆数之和，所以这是一个大于 un 的乌拉姆数，矛盾。因此存在无限多个乌拉姆数。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "/"
        ]
    },
    "2 Supplementary Exercises 29": {
        "question": "求 ∏_(k=1)^(100) (k+1)/k 的值(此处所使用的乘积符号在 2.4 节练习 43 前言有定义)",
        "answer": "1013",
        "answer_symbols": []
    },
    "2 Supplementary Exercises 30": {
        "question": "试给出一个规则以产生以 1, 3, 4, 8, 15, 27, 50, 92, … 开头的序列项，并求出该序列的后续四项",
        "answer": "如果我们足够长时间地研究这个问题，可能会注意到每个项在前三个项之后是前三个项的和。按照这个规则，接下来的四个项将是 169, 311, 572, 1052。这里利用技术的力量的一种方法是将给定的序列提交到《在线整数序列百科全书》(oeis.org)。\n",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "/"
        ]
    },
    "2 Supplementary Exercises 31": {
        "question": "试给出一个规则以产生以 2, 3, 5, 10, 13, 39, 43, 172, 177, 885, 891, … 开头的序列项，并求出该序列的后续四项",
        "answer": "a1 = 1；a2n+1 = n · a2n 对所有 n > 0；a2n = n + a2n-1 对所有 n > 0。接下来的四个项是 5346、5353、37471 和 37479",
        "answer_symbols": [
            "=",
            ">",
            "·",
            "+",
            "→"
        ]
    },
    "2 Supplementary Exercises 32": {
        "question": "证明无理数集是不可数集",
        "answer": "我们知道有理数集是可数的。如果无理数集也是可数的，那么这两个集合的并集也是可数的（根据第 2.5 节中的定理 1）。但是它们的并集，即实数集，已知是不可数的。这一矛盾告诉我们无理数集不是可数的。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "/"
        ]
    },
    "2 Supplementary Exercises 33": {
        "question": "证明集合 S 是可数集，如果存在一个从 S 到正整数集的函数使得只要当 j 是一个正整数时 f^-1(j) 是可数的",
        "answer": "如果每个 f^(-1)(j) 都是可数的，那么 S = f^(-1)(1) ∪ f^(-1)(2) ∪ ... 是可数个可数集的并集，因此是可数的（由第 2.5 节中的练习 27）",
        "answer_symbols": [
            "^",
            "(",
            ")",
            "=",
            "∪",
            "→"
        ]
    },
    "2 Supplementary Exercises 34": {
        "question": "证明正整数集合的所有有限子集的集合是一个可数集",
        "answer": "正整数集 Z+ 的有限子集有一个最大元素，因此是某个正整数 n 的 {1, 2, 3,..., n} 的子集。令 Sn 为 {1, 2, 3,..., n} 的子集集。它是有限的，因此是可数的；实际上 |Sn| = 2^n。正整数集 Z+ 的所有有限子集是 ∪∞ n=1 Sn 的并集。作为可数个可数集的并集，它是可数的（根据第 2.5 节中的习题 27）。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "/"
        ]
    },
    "2 Supplementary Exercises 35": {
        "question": "证明 |R × R| = |R|。[提示：利用 Schröder-Bernstein 定理证明 |(0, 1) × (0, 1)| = |(0, 1)|。构造一个从 (0, 1) × (0, 1) 到 (0, 1) 的单射函数，假设 (x, y) ∈ (0, 1) × (0, 1)。将 (x, y) 映射到这样一个数，其十进制展开式交替取自 x 和 y 的十进制展开式中的数字，这里的数均不以 9 的无限循环结尾]",
        "answer": "因为 R 和开区间 (0, 1) 之间存在一一对应关系（给定 f(x) = 2 arctan(x) / π），只需证明 |(0, 1) × (0, 1)| = |(0, 1)|。根据 Schröder-Bernstein 定理，只需找到从 (0, 1) 到 (0, 1) × (0, 1) 和从 (0, 1) × (0, 1) 到 (0, 1) 的单射函数 f 和 g。设 f(x) = (x, 1/2)。对于 g，我们遵循提示。假设 (x, y) ∈ (0, 1) × (0, 1)，用它们的小数展开表示 x 和 y：x = 0.x1x2x3... 和 y = 0.y1y2y3...，不选择以无限多个 9 结尾的展开。令 g(x, y) 是通过交织这两个字符串得到的小数展开，即 0.x1y1x2y2x3y3...",
        "answer_symbols": [
            "|",
            "×",
            "→",
            "(",
            ")",
            "=",
            "∈",
            "∞",
            "9",
            "→"
        ]
    },
    "2 Supplementary Exercises 36": {
        "question": "证明复数集合 C 具有和实数集合 R 同样的基数",
        "answer": "这直接从习题 35 得出，因为复数集 C 可以通过将复数 a+ bi（a 和 b 是实数）映射到有序对 (a, b) 来与 R × R 标识。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "/"
        ]
    },
    "2 Supplementary Exercises 37": {
        "question": "计算 A^²，如果 A 是 (0 1; -1 0)",
        "answer": "A^(4n) = [1 0; 0 1], A^(4n+2) = [-1 0; 0 -1]，对于 n ≥ 0",
        "answer_symbols": [
            "^",
            "[",
            "]",
            ";",
            "1",
            "0",
            "≥",
            "="
        ]
    },
    "2 Supplementary Exercises 38": {
        "question": "证明如果 A = cI，这里 c 是一个实数而 I 是 n × n 单位矩阵，则当 B 是一个 n × n 矩阵时有 AB = BA",
        "answer": "由于矩阵 A 定义为 aii= c 且 aij= 0 对于 i ≠ j，从乘法的定义很容易看出 AB 和 BA 都与 B 相同，只是每个元素都被乘以 c。因此这两个矩阵相等。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "/"
        ]
    },
    "2 Supplementary Exercises 39": {
        "question": "证明如果 A 一个 2 × 2 矩阵使得当 B 是一个 2 × 2 矩阵时有 AB = BA，则有 A = cI，这里 c 是一个实数而 I 是 2 × 2 单位矩阵",
        "answer": "假设 A = [a b; c d]。令 B = [0 1; 0 0]。因为 AB = BA，所以 c = 0 且 a = d。令 B = [0 0; 1 0]。因为 AB = BA，所以 b = 0。因此，A = [a 0; 0 a] = aI",
        "answer_symbols": [
            "[",
            "]",
            ";",
            "=",
            "0",
            "1",
            "→"
        ]
    },
    "2 Supplementary Exercises 40": {
        "question": "证明如果 A 和 B 是可逆的矩阵且 AB 存在，则 (AB)^-1 = B^-1A^-1",
        "answer": "我们只需要证明 AB 的所谓逆具有正确的定义性质——它与 AB（无论哪一侧）的乘积是单位矩阵。因此我们计算\n(AB)(B^⁻¹A^⁻¹)= A(BB^⁻¹)A^⁻¹= AIA^⁻¹= AA^⁻¹= I，\n同样地 (B^⁻¹A^⁻¹)(AB)= I。因此 (AB)^⁻¹= B^⁻¹A^⁻¹。（注意所指示的矩阵乘法都是定义好的，因为假设意味着 A 和 B 都是某个（且相同的）n 的 n × n 矩阵。）",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "/"
        ]
    },
    "2 Supplementary Exercises 41 a)": {
        "question": "令 A 是一个 n × n 矩阵，令 0 是一个所有元素都是 0 的 n × n 矩阵。证明下列式子为真。（a）A ∪ 0 = 0 ∪ A = 0",
        "answer": "令 A_0 = [bij]。那么 bij = (ai1 ∧ 0) ∨ ... ∨ (aip ∧ 0) = 0。因此，A_0 = 0。类似地 0A = 0",
        "answer_symbols": [
            "=",
            "∧",
            "∨",
            "[",
            "]",
            "0",
            "→"
        ]
    },
    "2 Supplementary Exercises 41 b)": {
        "question": "令 A 是一个 n × n 矩阵，令 0 是一个所有元素都是 0 的 n × n 矩阵。证明下列式子为真。（b）A ∩ 0 = 0 ∩ A = A",
        "answer": "A ∨ 0 = [aij ∨ 0] = [aij] = A。因此 A ∨ 0 = A。类似地 0 ∨ A = A",
        "answer_symbols": [
            "∨",
            "[",
            "]",
            "=",
            "→"
        ]
    },
    "2 Supplementary Exercises 41 c)": {
        "question": "令 A 是一个 n × n 矩阵，令 0 是一个所有元素都是 0 的 n × n 矩阵。证明下列式子为真。（c）A ⊕ 0 = 0 ⊕ A = 0",
        "answer": "A ∧ 0 = [a_ij ∧ 0] = [0] = 0。因此 A ∧ 0 = 0。类似地 0 ∧ A = 0",
        "answer_symbols": [
            "→",
            "[",
            "0",
            "∧",
            "=",
            "]"
        ]
    },
    "3.1 1": {
        "question": "列出算法 1 在表 1，8，12，9，11，2，14，5，10，4 中找最大值的所有步骤。",
        "answer": "max:= 1, i:= 2, max:= 8, i:= 3, max:= 12, i:= 4, i:= 5, i:= 6, i:= 7, max:= 14, i:= 8, i:= 9, i:= 10, i:= 11",
        "answer_symbols": [
            ":=",
            ","
        ]
    },
    "3.1 2 a)": {
        "question": "判断下列过程具有和缺乏在正文中（算法 1 之后）所描述的哪些算法特征。 procedure double(n: 正整数) while n>0 n := 2n",
        "answer": "该过程不是有限的，因为 while 循环的执行会无限期地继续下去。",
        "answer_symbols": []
    },
    "3.1 2 b)": {
        "question": "判断下列过程具有和缺乏在正文中（算法 1 之后）所描述的哪些算法特征。 procedure divide(n: 正整数) while n>0 m := 1/n n := n-1",
        "answer": "该过程是无效的，因为当 n = 0 时，步骤 m := 1/n 无法执行，而这种情况最终会发生。",
        "answer_symbols": [
            ":=",
            "/"
        ]
    },
    "3.1 2 c)": {
        "question": "判断下列过程具有和缺乏在正文中（算法 1 之后）所描述的哪些算法特征。 procedure sum(n: 正整数) sum := 0 while i<10 sum := sum+i",
        "answer": "该过程缺乏明确性，因为 i 的值从未被设置。",
        "answer_symbols": []
    },
    "3.1 2 d)": {
        "question": "判断下列过程具有和缺乏在正文中（算法 1 之后）所描述的哪些算法特征。 procedure choose(a, b: 整数) x := a 或 b",
        "answer": "该过程缺乏明确性，因为语句没有说明 x 是要设置为 a 还是 b。",
        "answer_symbols": []
    },
    "3.1 3": {
        "question": "设计一个求表中所有整数之和的算法。",
        "answer": "procedure AddUp(a1,..., an: integers) sum:= a1 for i:= 2 to n sum:= sum + a_i return sum",
        "answer_symbols": [
            "...",
            ":=",
            "+",
            "return"
        ]
    },
    "3.1 4": {
        "question": "描述一个算法，以 n 个整数的表作为输入，求出表中相邻整数后一个数减去前一个数的最大差值作为输出。",
        "answer": "将答案设为 -∞。对于从 1 到 n - 1 的 i，计算列表中第 (i + 1) 个元素减去第 i 个元素的值。如果这个值大于答案，则将答案重置为这个值。",
        "answer_symbols": [
            "-",
            ">"
        ]
    },
    "3.1 5": {
        "question": "描述一个算法，以 n 个按非递减序排列的整数的表作为输入，求出所有出现两次以上的值的表。（一列整数是非递减序的，如果表中的每个整数至少和列表中前一项一样大）",
        "answer": "procedure duplicates(a1, a2,..., an: integers in nondecreasing order) k:= 0 {this counts the duplicates} j:= 2 while j ≤ n if a_j = a_{j−1} then k:= k + 1 c_k:= a_j while j ≤ n and a_j = c_k j:= j + 1 j:= j + 1 {c1, c2,..., c_k is the desired list}",
        "answer_symbols": [
            "...",
            ":=",
            "<=",
            "=",
            "+",
            "{",
            "}",
            "while",
            "if",
            "then",
            "and"
        ]
    },
    "3.1 6": {
        "question": "描述一个算法，以 n 个整数的表作为输入，求出表中负整数的个数。",
        "answer": "我们需要遍历列表并计数负数条目。",
        "answer_symbols": []
    },
    "3.1 7": {
        "question": "描述一个算法，以 n 个整数的表作为输入，求出表中最后一个偶数的位置，或者如果表中没有偶数就返回 0。",
        "answer": "procedure last_even_location(a1, a2,..., an: integers) k:= 0 for i:= 1 to n if a_i is even then k:= i return k {k= 0 if there are no evens}",
        "answer_symbols": [
            "...",
            ":=",
            "for",
            "if",
            "is",
            "then",
            "return",
            "{",
            "}"
        ]
    },
    "3.1 8": {
        "question": "描述一个算法，以 n 个不同整数的表作为输入，求出表中最大偶数的位置，或者如果表中没有偶数就返回 0。",
        "answer": "这类似于练习 7，修改为跟踪我们遇到的最大偶数。",
        "answer_symbols": []
    },
    "3.1 9": {
        "question": "回文 (palindrome) 是从前向后读和从后向前读都一样的串。描述一个判定 n 个字符的串是否为回文的算法。",
        "answer": "procedure palindrome_check(a1a2... an: string) answer:= true for i:= 1 to n/2 if a_i ≠ a_{n+1−i} then answer:= false return answer",
        "answer_symbols": [
            "...",
            ":=",
            "for",
            "if",
            "≠",
            "then",
            "return"
        ]
    },
    "3.1 10": {
        "question": "设计计算 x^n 的算法，其中 x 是实数，n 是整数。[提示：首先给出一个 n 为非负整数时从 1 开始不断乘以 x 来计算 x^n 的过程。然后扩展这一过程利用 x^-n = 1/x^n 的事实来计算当 n 为负数时的 x^n。]",
        "answer": "我们假设如果输入 x = 0，则 n > 0，因为否则 x^n 未定义。在我们的过程中，我们让 m = |n| 并以显而易见的方式计算 x^m。然后如果 n 是负数，我们将答案替换为其倒数。",
        "answer_symbols": [
            "=",
            ">",
            "|",
            "^",
            "/"
        ]
    },
    "3.1 11": {
        "question": "描述一个交换变量 x 和 y 值的算法，只许使用赋值。至少需要多少个赋值语句才能完成交换？",
        "answer": "procedure interchange(x, y: real numbers) z:= x x:= y y:= z The minimum number of assignments needed is three.",
        "answer_symbols": [
            ":=",
            "real",
            "numbers",
            "The",
            "minimum",
            "number",
            "of",
            "assignments",
            "needed",
            "is",
            "three"
        ]
    },
    "3.1 12": {
        "question": "描述一个只使用赋值语句实现用三元组 (y, z, x) 来代替 (x, y, z) 的算法。最少需要多少个赋值语句？",
        "answer": "需要四个赋值语句，每个变量一个，以及一个临时赋值以开始，这样我们就不会丢失其中一个原始值。",
        "answer_symbols": []
    },
    "3.1 14 a)": {
        "question": "给定练习 13 给出的序列，列出采用线性搜索时搜索 7 使用的所有步骤。",
        "answer": "With linear search, we start at the beginning of the list and compare 7 successively with 1, 3, 4, 5, 6, 8, 9, and 11. When we come to the end of the list and still have not found 7, we conclude that it is not in the list.",
        "answer_symbols": []
    },
    "3.1 14 b)": {
        "question": "给定练习 13 给出的序列，列出采用二分搜索时搜索 7 使用的所有步骤。",
        "answer": "We begin the search on the entire list, with i = 1 and j = n = 8. We set m := 4 and compare 7 to the fourth element of the list. Since 7 > 5, we next restrict the search to the second half of the list, with i = 5 and j = 8. This time we set m := 6 and compare 7 to the sixth element of the list. Since 7 < 8, we next restrict ourselves to the first half of the second half of the list, with i = 5 and j = 6. This time we set m := 5, and compare 7 to the fifth element. Since 7 > 6, we now restrict ourselves to the portion of the list between i = 6 and j = 6. Since at this point i = j, we exit the loop. Since the sixth element of the list is not equal to 7, we conclude that 7 is not in the list.",
        "answer_symbols": [
            ">",
            "<",
            ":="
        ]
    },
    "3.1 15": {
        "question": "描述一个算法，把整数 x 插入到按递增序排列的整数表 a1, a2, …, an 中合适的位置。",
        "answer": "procedure insert(x, a1, a2,..., an: integers) {the list is in order: a1 ≤ a2 ≤··· ≤ an} a_{n+1}:= x + 1 i:= 1 while x > a_i i:= i + 1 for j:= 0 to n − i a_{n−j+1}:= a_{n−j} a_i:= x {x has been inserted into correct position}",
        "answer_symbols": [
            "...",
            ":=",
            "+",
            "{",
            "}",
            "while",
            ">",
            "for",
            "to",
            "−",
            "="
        ]
    },
    "3.1 16": {
        "question": "描述一个求自然数的有限序列中最小整数的算法。",
        "answer": "We let min be the smallest element found so far. At the end, it is the smallest element, since we update it as necessary as we scan through the list.",
        "answer_symbols": []
    },
    "3.1 17": {
        "question": "描述一个算法，求整数的有限列表中最大元素首次出现的位置，其中列表中的整数不一定互不相同。",
        "answer": "procedure first_largest(a1,..., an: integers) max:= a1 location:= 1 for i:= 2 to n if max < a_i then max:= a_i location:= i return location",
        "answer_symbols": [
            "...",
            ":=",
            "<",
            "for",
            "if",
            "then",
            "return"
        ]
    },
    "3.1 18": {
        "question": "描述一个算法，求整数的有限列表中最小元素最后出现的位置，其中列表中的整数不一定互不相同。",
        "answer": "This is similar to Exercise 17.",
        "answer_symbols": []
    },
    "3.1 19": {
        "question": "描述一个算法，计算由三个整数构成的集合的最大值、中间值、平均值和最小值。（整数集合的中间值是把这些整数按增序排列时中间元素的值。整数集合的平均值是这些整数之和除以整数个数。）",
        "answer": "procedure mean_median_max_min(a, b, c: integers) mean:= (a + b + c) / 3 {the six different orderings of a, b, c with respect to ≥ will be handled separately} if a ≥ b then if b ≥ c then median:= b; max:= a; min:= c ... (The rest of the algorithm is similar.)",
        "answer_symbols": [
            ":=",
            "+",
            "/",
            "{",
            "}",
            "if",
            "≥",
            "then",
            ";",
            "..."
        ]
    },
    "3.1 20": {
        "question": "描述一个求整数的有限序列中最大和最小整数的算法。",
        "answer": "We just combine procedures for finding the largest and smallest elements.",
        "answer_symbols": []
    },
    "3.1 21": {
        "question": "描述一个算法，把任意长度整数序列的头三项排成递增序。",
        "answer": "procedure first_three(a1, a2,..., an: integers) if a1 > a2 then interchange a1 and a2 if a2 > a3 then interchange a2 and a3 if a1 > a2 then interchange a1 and a2",
        "answer_symbols": [
            "...",
            "if",
            ">",
            "then",
            "interchange",
            "and"
        ]
    },
    "3.1 22": {
        "question": "描述一个算法，求英文句子中最长的单词（这里句子是指符号的序列，符号可以是一个字母或者一个空格，句子可以被分隔成交替的单词和空格）",
        "answer": "We assume that the input is a sequence of symbols, a1, a2,..., an, each of which is either a letter or a blank. We build up the longest word in word; its length is length. We denote the empty word by λ.",
        "answer_symbols": [
            "λ"
        ]
    },
    "3.1 23": {
        "question": "描述一个算法，判断从一个整数的有限集合到另一个整数的有限集合的一个函数是否是映上的",
        "answer": "procedure onto(f: function from A to B where A={a1,..., an}, B={b1,..., bm}, a1,..., an, b1,..., bm are integers) for i:= 1 to m hit(b_i):= 0 count:= 0 for j:= 1 to n if hit(f(a_j))= 0 then hit(f(a_j)):= 1 count:= count + 1 if count= m then return true else return false",
        "answer_symbols": [
            "...",
            ":=",
            "for",
            "if",
            "=",
            "then",
            "return",
            "else"
        ]
    },
    "3.1 24": {
        "question": "描述一个算法，判断从一个有限集合到另一个有限集合的一个函数是否是一对一的",
        "answer": "This is similar to Exercise 23. We let the array hit track which elements of the codomain B have already been found to be images of elements in the domain A. When we find an element that has already been hit again, we conclude that the function is not one-to-one.",
        "answer_symbols": []
    },
    "3.1 25": {
        "question": "描述一个算法，逐一检查位串中每位是否为 1，数一数其中为 1 的位的个数",
        "answer": "procedure ones(a: bit string, a= a1a2... an) count:= 0 for i:= 1 to n if a_i = 1 then count:= count + 1 return count",
        "answer_symbols": [
            "...",
            ":=",
            "for",
            "if",
            "=",
            "+",
            "return"
        ]
    },
    "3.1 26": {
        "question": "改动算法 3 使得二分搜索过程在算法的每一阶段都比较 x 和 a[m]，并且如果 x = a[m] 则算法终止。算法的这个版本有何优越之处？",
        "answer": "There are two changes. First, we need to test x = am (immediately after computing m) and take appropriate action when they are equal (we set both i and j to m). Second, if x != am, then j can be set to m - 1 instead of m. The advantage is that this allows the size of the 'half part' of the list being viewed to shrink slightly faster, and it can stop almost immediately after finding the element being searched for.",
        "answer_symbols": [
            "="
        ]
    },
    "3.1 27": {
        "question": "三分搜索算法是在递增序整数表中通过连续地把表分成大小相等（或尽可能接近相等）的三个子表，并将搜索限制在一个合适的子表中的方法来定位一个元素。描述这一算法的步骤",
        "answer": "procedure ternary_search(s: integer, a1, a2,..., an: increasing integers) i:= 1 j:= n while i < j − 1 l:= (i + j) / 3 u:= 2 * (i + j) / 3 if x > a_u then i:= u + 1 else if x > a_l then i:= l + 1 j:= u else j:= l if x = a_i then location:= i else if x = a_j then location:= j else location := 0 return location {0 if not found}",
        "answer_symbols": [
            "*",
            "then",
            ":=",
            "+",
            "/",
            "...",
            "if",
            "else",
            "=",
            "−",
            "while",
            "<",
            ">",
            "location"
        ]
    },
    "3.1 28": {
        "question": "描述在递增序整数表中通过连续地把表分成大小相等（或尽可能接近相等）的四个子表，并将搜索限制在一个合适的子表中的方法来定位一个元素的算法步骤。在一个元素列表中，同一个元素可能出现多次。这样一个列表的众数（mode）是一个其出现次数不少于其他元素的元素。当有多个元素都出现最大次数时，一个列表就有多个众数",
        "answer": "This can be considered as performing two binary searches simultaneously. We compare the element being searched for with the middle element of the active part of the list, and then with the middle element of the top or bottom half. This restricts the subsequent search to one of four sublists, each approximately one-quarter the size of the previous list. When the list length is three or less, we need to stop and perform explicit checks. Here is the pseudocode.procedure tetrary search(x: integer, a1, a2,..., an: increasing integers) i := 1 j := n while i < j − 2 l := ⌊(i + j) / 4⌋ m := ⌊(i + j) / 2⌋ u := ⌊3(i + j) / 4⌋ if x > am then if x ≤ au then i := m + 1 j := u else i := u + 1 else if x > al then i := l + 1 j := m else j := l if x = ai then location := i else if x = aj then location := j else if x = a⌊(i + j) / 2⌋ then location := ⌊(i + j) / 2⌋ else location := 0 return location {the subscript of the term equal to x (0 if not found)}",
        "answer_symbols": [
            "/",
            "⌊",
            "=",
            ">",
            "<",
            "+",
            "⌋"
        ]
    },
    "3.1 29": {
        "question": "设计一个算法，求非递减序整数表的一个众数。（一列整数是非递减序的，如果列表中的每个整数至少和列表中前一项一样大）",
        "answer": "procedure find a mode(a1, a2,..., an: nondecreasing integers) modecount := 0 i := 1 while i ≤ n value := ai count := 1 while i ≤ n and ai = value count := count + 1 i := i + 1 if count > modecount then modecount := count mode := value return mode",
        "answer_symbols": [
            "=",
            "+",
            "<",
            ">"
        ]
    },
    "3.1 30": {
        "question": "设计一个算法，求非递减序整数表的所有众数（一列整数是非递减序的，如果列表中的每个整数至少和列表中前一项一样大）",
        "answer": "procedure find all modes(a1, a2,..., an: nondecreasing integers) modecount := 0 i := 1 while i ≤ n value := ai count := 1 while i ≤ n and ai = value count := count + 1 i := i + 1 if count > modecount then modecount := count set L to consist just of value else if count = modecount then add value to L return L {the list of all the values occurring most often, namely modecount times}",
        "answer_symbols": [
            "<",
            ">",
            "=",
            "+",
            "≤",
            "and"
        ]
    },
    "3.1 31": {
        "question": "设计一个算法，求整数序列中第一个与序列中排在它前面的某项相等的项",
        "answer": "procedure find duplicate(a1, a2,..., an: integers) location := 0 i := 2 while i ≤ n and location = 0 j := 1 while j < i and location = 0 if ai = aj then location := i else j := j + 1 i := i + 1 return location {location is the subscript of the first value that repeats a previous value in the sequence}",
        "answer_symbols": [
            "=",
            "<"
        ]
    },
    "3.1 32": {
        "question": "设计一个算法，找出整数有限序列中所有那些大于它前面各项之和的项",
        "answer": "procedure find all biggies(a1, a2,..., an: integers) set L to be the empty list sum := 0 i := 1 while i ≤ n if ai > sum then append ai to L sum := sum + ai i := i + 1 return L {the list of all the values that exceed the sum of all the previous terms in the sequence}",
        "answer_symbols": [
            "<",
            ">",
            "=",
            "+",
            "≤"
        ]
    },
    "3.1 33": {
        "question": "设计一个算法，求正整数序列中第一个小于其紧挨着前项的项",
        "answer": "procedure find decrease(a1, a2,..., an: positive integers) location := 0 i := 2 while i ≤ n and location = 0 if ai < ai−1 then location := i else i := i + 1 return location {location is the subscript of the first value less than the immediately preceding one}",
        "answer_symbols": [
            "=",
            "<"
        ]
    },
    "3.1 34": {
        "question": "用冒泡排序来排序 6，2，3，1，5，4，说明在每一步所获得的表",
        "answer": "列表中有五次遍历。经过一次遍历后，列表读作 2, 3, 1, 5, 4, 6，因为6在每个阶段都被比较并移动。在下一次遍历中，2和3没有互换，但3和1互换了，5和4也互换了，得到 2, 1, 3, 4, 5, 6。在第三次遍历中，2和1互换，得到 1, 2, 3, 4, 5, 6。还有两次遍历，但由于列表现在已排序，没有进一步的互换。",
        "answer_symbols": []
    },
    "3.1 35": {
        "question": "用冒泡排序来排序 3，1，5，7，4，说明在每一步所获得的表",
        "answer": "At the end of the first pass: 1, 3, 5, 4, 7; at the end of the second pass: 1, 3, 4, 5, 7; at the end of the third pass: 1, 3, 4, 5, 7; at the end of the fourth pass: 1, 3, 4, 5, 7",
        "answer_symbols": []
    },
    "3.1 36": {
        "question": "用冒泡排序来排序 d，f，k，m，a，b，说明在每一步所获得的表",
        "answer": "过程与练习35的解决方案相同。我们将展示每次步骤后的列表，同一遍历期间获得的所有列表在同一行显示。\ndfkmab, dfkmab, dfkmab, dfkamb, dfkabm\ndfkabm, dfkabm, dfakbm, dfabkm\ndfabkm, dafbkm, dabfkm\nadbfkm, abdfkm\nabdfkm",
        "answer_symbols": []
    },
    "3.1 37": {
        "question": "改编冒泡排序算法使得当不再需要交换时算法停止。用伪代码描述这个更有效的算法版本",
        "answer": "procedure better bubblesort(a1,..., an: integers) i := 1; done := false while i < n and done = false done := true for j := 1 to n − i if aj > aj+1 then interchange aj and aj+1 done := false i := i + 1 {a1,..., an is in increasing order}",
        "answer_symbols": [
            "=",
            "+",
            ">",
            "<"
        ]
    },
    "3.1 38": {
        "question": "用插入排序来排序练习 34 中的表，说明在每一步所获得的表",
        "answer": "我们从 6, 2, 3, 1, 5, 4 开始。第一步将2正确插入到已排序的列表6中，生成 2, 6, 3, 1, 5, 4。\n接下来将3插入到 2, 6 中，列表变为 2, 3, 6, 1, 5, 4。接着将1插入到 2, 3, 6 中，列表变为 1, 2, 3, 6, 5, 4。然后将5插入到 1, 2, 3, 6 中，列表变为 1, 2, 3, 5, 6, 4。最后将4插入到 1, 2, 3, 5, 6 中，列表变为 1, 2, 3, 4, 5, 6。每次插入时，要插入的元素都会与已排序的元素进行比较，从开始处进行，直到找到其正确位置，然后将该位置之后的已排序元素各自向后移动一个位置。",
        "answer_symbols": []
    },
    "3.1 39": {
        "question": "用插入排序来排序练习 35 中的表，说明在每一步所获得的表",
        "answer": "At the end of the first, second, and third passes: 1, 3, 5, 7, 4; at the end of the fourth pass: 1, 3, 4, 5, 7",
        "answer_symbols": []
    },
    "3.1 40": {
        "question": "用插入排序来排序练习 36 中的表，说明在每一步所获得的表",
        "answer": "我们从 d, f, k, m, a, b 开始。第一步将f正确插入到已排序的列表d中，没有变化。\n同样地，当k和m分别插入到已排序的列表 d, f 和 d, f, k 中时，也没有变化。接下来将a插入到 d, f, k, m 中，列表变为 a, d, f, k, m, b。最后将b插入到 a, d, f, k, m 中，列表变为 a, b, d, f, k, m。每次插入时，要插入的元素都会与已排序的元素进行比较，从开始处进行，直到找到其正确位置，然后将该位置之后的已排序元素各自向后移动一个位置。",
        "answer_symbols": []
    },
    "3.1 41 a)": {
        "question": "用选择排序来排序下列的表。3，5，4，1，2",
        "answer": "1, 5, 4, 3, 2; 1, 2, 4, 3, 5; 1, 2, 3, 4, 5; 1, 2, 3, 4, 5",
        "answer_symbols": []
    },
    "3.1 41 b)": {
        "question": "用选择排序来排序下列的表。5，4，3，2，1",
        "answer": "1, 4, 3, 2, 5; 1, 2, 3, 4, 5; 1, 2, 3, 4, 5; 1, 2, 3, 4, 5",
        "answer_symbols": []
    },
    "3.1 41 c)": {
        "question": "用选择排序来排序下列的表。1，2，3，4，5",
        "answer": "1, 2, 3, 4, 5; 1, 2, 3, 4, 5; 1, 2, 3, 4, 5; 1, 2, 3, 4, 5",
        "answer_symbols": []
    },
    "3.1 42": {
        "question": "用伪代码写出选择排序算法",
        "answer": "我们让 minspot 是剩余最小元素的位置。在第i次遍历后，我们只需交换 minspot 位置和 i 位置的元素。\n过程选择 (a1, a2,..., an)\n对于 i := 1 到 n − 1\nminspot := i 对于 j := i + 1 到 n 如果 aj < aminspot 那么 minspot := j\n交换 aminspot 和 ai\n{列表现在已排序}",
        "answer_symbols": [
            "<"
        ]
    },
    "3.1 43": {
        "question": "描述一个基于线性搜索的算法，确定在已经排序的表中插入一个新元素的正确位置",
        "answer": "We carry out the linear search algorithm given as Algorithm 2 in this section, except that we replace x = ai by x < ai, and we replace the else clause with else location := n + 1.",
        "answer_symbols": [
            "=",
            "<"
        ]
    },
    "3.1 44": {
        "question": "描述一个基于二分搜索的算法，确定在已经排序的表中插入一个新元素的正确位置",
        "answer": "我们执行本节给出的算法3中的二分查找算法，只是用 if x < ai 那么 location := i 否则 location := i + 1 替换最终检查。",
        "answer_symbols": [
            "<"
        ]
    },
    "3.1 45": {
        "question": "用插入排序对表 1，2，…，n 排序需要多少次比较？",
        "answer": "2 + 3 + 4 + ··· + n = (n^² + n − 2) / 2",
        "answer_symbols": [
            "+",
            "-",
            "*",
            "/",
            "^"
        ]
    },
    "3.1 46": {
        "question": "用插入排序对表 n，n-1，…，2，1 排序需要多少次比较？",
        "answer": "我们只计算列表中数字的比较次数，不包括任何用于for循环的簿记所需的比较。列表中的第二个元素仅需与第一个元素比较（换句话说，在算法5中，当 j = 2 时，i 在我们跳出while循环之前取值 1）。类似地，第三个元素仅需与第一个元素比较。继续这样操作，直到最后第n个元素仅需与第一个元素比较。因此，总比较次数为 n - 1。这是插入排序在比较次数方面的最佳情况，但为了进行插入而移动元素需要更多的努力。",
        "answer_symbols": [
            "-",
            "<"
        ]
    },
    "3.1 47": {
        "question": "列出二分插入排序对表 3，2，4，5，1，6 进行排序时使用的所有步骤",
        "answer": "Find the location for the 2 in the list 3 (one comparison), and insert it in front of the 3, so the list now reads 2, 3, 4, 5, 1, 6. Find the location for the 4 (compare it to the 2 and then the 3), and insert it, leaving 2, 3, 4, 5, 1, 6. Find the location for the 5 (compare it to the 3 and then the 4), and insert it, leaving 2, 3, 4, 5, 1, 6. Find the location for the 1 (compare it to the 3 and then the 2 and then the 2 again), and insert it, leaving 1, 2, 3, 4, 5, 6. Find the location for the 6 (compare it to the 3 and then the 4 and then the 5), and insert it, giving the final answer 1, 2, 3, 4, 5, 6.",
        "answer_symbols": [
            ">",
            "<"
        ]
    },
    "3.1 48": {
        "question": "比较插入排序和二分插入排序对表 7，4，3，8，1，5，4，2 进行排序时所用的比较次数",
        "answer": "对于插入排序，找到4的正确位置需要一次比较，3需要一次，8需要四次，1需要一次，5需要四次，2需要两次。总共是13次比较。对于二分插入排序，找到4的正确位置需要一次比较，3需要两次，8需要两次，1需要三次，5需要三次，2需要四次。总共是15次比较。如果列表很长（并且不是几乎按降序排列的），使用二分插入排序会减少很多比较次数。这里答案“错误”的原因是列表太短，以至于二分查找效率不高。",
        "answer_symbols": [
            "<"
        ]
    },
    "3.1 49": {
        "question": "用伪代码写出二分插入排序算法",
        "answer": "procedure binary insertion sort(a1, a2,..., an: real numbers with n ≥ 2) for j := 2 to n {binary search for insertion location i} left := 1 right := j − 1 while left < right middle := (left + right) / 2 if aj > amiddle then left := middle + 1 else right := middle if aj < aleft then i := left else i := left + 1 {insert aj in location i by moving ai through aj−1 toward back of list} m := aj for k := 0 to j − i − 1 aj−k := aj−k−1 ai := m {a1, a2,..., an are sorted}",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "*",
            "/",
            ">",
            "<"
        ]
    },
    "3.1 50 a)": {
        "question": "设计插入排序的一个变体，用线性搜索技术把第 j 个元素插入正确位置，即首先将它与第 j-1 个元素比较，然后如有必要再与第 j-2 个元素比较，依次进行下去",
        "answer": "这基本上与算法5相同，但从另一端开始。然而，我们可以在搜索正确插入位置的同时进行移动，因此伪代码只有一个部分。\nprocedure backward insertion sort(a1, a2, ..., an: real numbers with n ≥ 2)\n for j := 2 to n\n m := aj\n i := j − 1\n while (m < ai and i > 0)\n ai+1 := ai\n i := i − 1\n ai+1 := m\n { a1, a2, ..., an are sorted }",
        "answer_symbols": [
            ":=",
            "<",
            ">",
            "-"
        ]
    },
    "3.1 50 b)": {
        "question": "用你的算法来排序 3，2，4，5，1，6",
        "answer": "在第一次传递中，2与3进行比较并发现较小，所以3向右移动。我们已经到达列表的开头，所以循环终止（i = 0），2被插入，结果是2, 3, 4, 5, 1, 6。\n在第二次传递中，4与3进行比较，由于4 > 3，while循环终止，没有任何变化。同样，5插入时也没有变化。在第四次传递中，1一直比较到列表的开头，每个元素在比较过程中向后移动，最后1被插入到正确的位置，结果是1, 2, 3, 4, 5, 6。最后一次传递没有变化。",
        "answer_symbols": [
            "<",
            ">"
        ]
    },
    "3.1 50 c)": {
        "question": "用这个算法求解练习 45",
        "answer": "每次传递只使用一次比较，因为条件 m < ai 立即为假。因此，总共使用了 n - 1 次比较。",
        "answer_symbols": [
            "<",
            "-"
        ]
    },
    "3.1 50 d)": {
        "question": "用这个算法求解练习 46",
        "answer": "第j次传递需要 j - 1 次元素比较，所以总比较次数是 1 + 2 + ... + (n - 1) = n(n - 1)/2。",
        "answer_symbols": [
            "+",
            "-",
            "=",
            "/"
        ]
    },
    "3.1 51": {
        "question": "当一个元素列表接近于正确顺序时，采用插入排序或练习 50 描述的变体，哪一种更好？",
        "answer": "The variation from Exercise 50",
        "answer_symbols": []
    },
    "3.1 52 a)": {
        "question": "采用贪心算法，用 25 美分、10 美分、5 美分和 1 美分硬币找出下列零钱：87 美分",
        "answer": "算法使用最多的25美分硬币，三个，剩下12美分。然后使用最多的10美分硬币（一个）和5美分硬币（没有），最后使用两个1美分硬币。",
        "answer_symbols": []
    },
    "3.1 52 b)": {
        "question": "采用贪心算法，用 25 美分、10 美分、5 美分和 1 美分硬币找出下列零钱：49 美分",
        "answer": "一个25美分硬币，剩下24美分，然后两个10美分硬币，剩下4美分，最后四个1美分硬币。",
        "answer_symbols": []
    },
    "3.1 52 c)": {
        "question": "采用贪心算法，用 25 美分、10 美分、5 美分和 1 美分硬币找出下列零钱：99 美分",
        "answer": "三个25美分硬币，剩下24美分，然后两个10美分硬币，剩下4美分，最后四个1美分硬币。",
        "answer_symbols": []
    },
    "3.1 52 d)": {
        "question": "采用贪心算法，用 25 美分、10 美分、5 美分和 1 美分硬币找出下列零钱：33 美分",
        "answer": "一个25美分硬币，剩下8美分，然后一个5美分硬币和三个1美分硬币。",
        "answer_symbols": []
    },
    "3.1 53 a)": {
        "question": "采用贪心算法，用 25 美分、10 美分、5 美分和 1 美分硬币找出下列零钱：51 美分",
        "answer": "Two quarters, one penny",
        "answer_symbols": []
    },
    "3.1 53 b)": {
        "question": "采用贪心算法，用 25 美分、10 美分、5 美分和 1 美分硬币找出下列零钱：69 美分",
        "answer": "Two quarters, one dime, one nickel, four pennies",
        "answer_symbols": []
    },
    "3.1 53 c)": {
        "question": "采用贪心算法，用 25 美分、10 美分、5 美分和 1 美分硬币找出下列零钱：76 美分",
        "answer": "A three quarters, one penny",
        "answer_symbols": []
    },
    "3.1 53 d)": {
        "question": "采用贪心算法，用 25 美分、10 美分、5 美分和 1 美分硬币找出下列零钱：60 美分",
        "answer": "Two quarters, one dime",
        "answer_symbols": []
    },
    "3.1 55": {
        "question": "采用贪心算法，用 25 美分、10 美分和 1 美分（但是无 5 美分）硬币找出练习 53 中的各种零钱。对于哪些零钱数，贪心算法使用尽可能少的这些面值的硬币？",
        "answer": "Greedy algorithm uses fewest coins in parts (a), (c), and (d). a) Two quarters, one penny b) Two quarters, one dime, nine pennies c) Three quarters, one penny d) Two quarters, one dime",
        "answer_symbols": []
    },
    "3.1 56": {
        "question": "证明如果有面值 12 美分的硬币，则用 25 美分、12 美分、10 美分、5 美分和 1 美分硬币的贪心算法，不一定总是用最少的硬币数找零钱",
        "answer": "One approach is to come up with an example in which using the 12-cent coin before using dimes or nickels would be inefficient. A dime and a nickel together are worth 15 cents, but the greedy algorithm would have us use four coins (a 12-cent coin and three pennies) rather than two. An alternative example would be 29 cents, in which case the greedy algorithm would use a quarter and four pennies, but we could have done better using two 12-cent coins and a nickel.",
        "answer_symbols": [
            "-",
            "+",
            "=",
            "<"
        ]
    },
    "3.1 57": {
        "question": "用算法 7 从一组候选演讲中选择以便在报告厅安排尽可能多的演讲。假设这些演讲的开始和结束时间（均为上午）是：9:00 和 9:45；9:30 和 10:00；9:50 和 10:15；10:00 和 10:30；10:10 和 10:25；10:30 和 10:55；10:45 和 11:00；10:55 和 11:15",
        "answer": "The 9:00–9:45 talk, the 9:50–10:15 talk, the 10:15–10:45 talk, the 11:00–11:15 talk",
        "answer_symbols": []
    },
    "3.1 58": {
        "question": "证明在解决报告厅安排一组演讲（如例 7 所示）的贪心算法中，如果在每一步都选择一个与其他演讲冲突最少的演讲，则不一定产生最优解",
        "answer": "Here is one counterexample, using 11 talks. Suppose the start and end times are as follows: A 1–3, B 3–5, C 5–7, D 7–9, E 2–4, F 2–4, G 2–4, H 4–6, J 6–8, K 6–8, L 6–8. The optimal schedule is talks A, B, C, and D. However, the talk with the fewest overlaps with other talks is H, which overlaps only with B and C (all the other talks overlap with three or four other talks). However, once we have decided to include talk H, we can no longer schedule four talks, so this algorithm will not produce an optimum solution.",
        "answer_symbols": [
            "-",
            "<",
            ">"
        ]
    },
    "3.1 59 a)": {
        "question": "设计一个贪心算法，给定每个讲座的开始时间和结束时间，确定容纳 n 个讲座所需要的最少的报告厅数目",
        "answer": "Order the talks by starting time. Number the lecture halls 1, 2, 3, and so on. For each talk, assign it to the lowest numbered lecture hall that is currently available.",
        "answer_symbols": []
    },
    "3.1 59 b)": {
        "question": "证明你的算法是最优的",
        "answer": "If this algorithm uses n lecture halls, then at the point the n-th hall was first assigned, it had to be used (otherwise a lower-numbered hall would have been assigned), which means that n talks were going on simultaneously (this talk just assigned and the n − 1 talks currently in halls 1 through n−1).",
        "answer_symbols": [
            "-",
            "+"
        ]
    },
    "3.1 60": {
        "question": "假设有三位男士 m_1, m_2 和 m_3，三位女士 w_1, w_2 和 w_3。再者，假设男士对三位女士的喜欢程度由高到低的排序是：m_1 : w_3, w_1, w_2; m_2 : w_1, w_2, w_3; m_3 : w_2, w_1, w_3；而女士对三位男士的喜欢程度由高到低的排序是：w_1 : m_1, m_2, m_3; w_2 : m_2, m_1, m_3; w_3 : m_3, m_2, m_1。对于构成三对夫妇的所有六种可能的每一种情况，判断该匹配是否是稳定的",
        "answer": "If all the men get their first choices, then the matching will be stable, because no man will be part of an unstable pair, preferring another woman to his assigned partner. Thus the pairing (m1w3, m2w1, m3w2) is stable. Similarly, if all the women get their first choices, then the matching will be stable, because no woman will be part of an unstable pair, preferring another man to her assigned partner. Thus the pairing (m1w1, m2w2, m3w3) is stable. Two of the other four matchings pair m1 with w2, and this cannot be stable, because m1 prefers w1 to w2, his assigned partner, and w1 prefers m1 to her assigned partner, whoever it is, because m1 is her favorite. In a similar way, the matching (m1w3, m2w2, m3w1) is unstable because of the unhappy unmatched pair m3w3 (each preferring the other to his or her assigned partner). Finally, the matching (m1w1, m2w3, m3w2) is stable, because each couple has a reason not to break up: w1 got her favorite and so is content, m3 got his favorite and so is content, and w3 only prefers m3 to her assigned partner but he doesn’t prefer her to his assigned partner.",
        "answer_symbols": [
            "(",
            ")",
            ",",
            "="
        ]
    },
    "3.1 61": {
        "question": "用伪代码写出延迟接受算法",
        "answer": "Here we assume that the men are the suitors and the women the suitees. procedure stable(M1, M2,..., Ms, W1, W2,..., Ws: preference lists) for i := 1 to s mark man i as rejected for i := 1 to s set man i’s rejection list to be empty for j := 1 to s set woman j's proposal list to be empty, while there are still rejected men. For i := 1 to s, if man i is marked as rejected, then add i to the proposal list of the highest-ranked woman j (but not in his rejection list), and mark i as not rejected. For j := 1 to s, if woman j's proposal list is non-empty, then delete all men i from j's proposal list except her most preferred man i0, and mark each such man i as rejected and add j to his rejection list. For j := 1 to s, match j with the unique man in her proposal list {this matching is stable}.",
        "answer_symbols": [
            ":=",
            "="
        ]
    },
    "3.1 62": {
        "question": "证明延迟接受算法可终止",
        "answer": "The algorithm given in the solution to Exercise 61 will terminate if at some point at the conclusion of the while loop, no man is rejected. If this happens, then that must mean that each man has one and only one proposal pending with some woman, because he proposed to only one in that round, and since he was not rejected, his proposal is the only one pending with that woman. It follows that at that point there are s pending proposals, one from each man, so each woman will be matched with a unique man. Finally, we argue that there are at most s^² iterations of the while loop, so the algorithm must terminate. Indeed, if at the conclusion of the while loop rejected men remain, then some man must have been rejected, because no man is marked as rejected at the conclusion of the proposal phase (first for loop inside the while loop). If a man is rejected, then his rejection list grows. Thus each pass through the while loop, at least one more of the s^² possible rejections will have been recorded, unless the loop is about to terminate. (Actually there will be fewer than s^² iterations, because no man is rejected by the woman with whom he is eventually matched.) There is one more subtlety we need to address. Is it possible that at the end of some round, some man has been rejected by every woman and therefore the algorithm cannot continue? We claim not. If at the end of some round some man has been rejected by every woman, then every woman has one pending proposal at the completion of that round (from someone she likes better—otherwise she never would have rejected that poor man), and of course these proposals are all from different men because a man proposes only once in each round. That means s men have pending proposals, so in fact our poor universally-rejected man does not exist.",
        "answer_symbols": [
            "(",
            ")",
            ",",
            "²",
            "<"
        ]
    },
    "3.1 63": {
        "question": "证明延迟接受算法终止时总可以产生一个稳定的匹配",
        "answer": "If the assignment is unstable, then there exists a man m and a woman w such that m prefers w to his assigned partner w', and w prefers m to her assigned partner. But m must have proposed to w before proposing to w', since he prefers the former. Since m is ultimately not matched with w, she must have rejected him. A woman only rejects a suitor when she receives a better proposal, and she will eventually be matched with a suitor who is at least as good as any she has previously rejected, so the man w is matched with must be at least as good as m, which contradicts our initial assumption. Therefore, the marriage is stable.",
        "answer_symbols": [
            "<",
            ">"
        ]
    },
    "3.1 64": {
        "question": "证明判断一个程序在给定一个输入时总会输出数字“1”这个问题是不可解的",
        "answer": "Suppose we had a program S that could tell whether a program with its given input ever prints the digit 1. Here is an algorithm for solving the halting problem: Given a program P and its input I, construct a program P', which is just like P but never prints anything (even if P did print something) except that if and when it is about to halt, it prints a 1 and halts. Then P halts on an input if and only if P' ever prints a 1 on that same input. Feed P' and I to S, and that will tell us whether or not P halts on input I. Since we know that the halting problem is in fact not solvable, we have a contradiction. Therefore no such program S exists.",
        "answer_symbols": [
            "'",
            "(",
            ")",
            ","
        ]
    },
    "3.1 65": {
        "question": "证明如下问题是可解的。给定两个程序以及它们的输入，并且已知其中恰有一个会终止，判断哪一个程序会终止",
        "answer": "Run both programs to process their inputs and report which program stops running.",
        "answer_symbols": []
    },
    "3.2 3": {
        "question": "用“f(x)是O(g(x))的”定义证明x^⁴+9x^³+4x+7是O(x^⁴)的。",
        "answer": "For all x > 9, x^4 + 9x^3 + 4x + 7 ≤ 4x^4; witness C = 4, k = 9",
        "answer_symbols": [
            "^",
            "+",
            "≤"
        ]
    },
    "3.2 5": {
        "question": "证明(x^²+1)/(x+1)是O(x)的。",
        "answer": "(x^2 + 1)/(x + 1) = x - 1 + 2/(x + 1) < x for all x > 1; witness C = 1, k = 1",
        "answer_symbols": [
            "^",
            "+",
            "/",
            "=",
            "-",
            "<"
        ]
    },
    "3.2 9": {
        "question": "证明 x^³ + 4x + 17 是 O(x^³) 的，但 x^³ 不是 O(x^³ + 4x + 17) 的。",
        "answer": "For all x > 17, x^2 + 4x + 17 ≤ 3x^3, therefore x^2 + 4x + 17 is O(x^3), witness C = 3, k = 17. However, if x^3 is O(x^2 + 4x + 17), then x^3 ≤ C(x^2 + 4x + 17) ≤ 3Cx^2 for some C, for all sufficiently large x, which implies x ≤ 3C for all sufficiently large x, which is impossible. Therefore, x^3 is not O(x^2 + 4x + 17).",
        "answer_symbols": [
            "^",
            "+",
            "≤",
            "<"
        ]
    },
    "3.2 11": {
        "question": "证明 3x^⁴ + 1 是 O(x^⁴/2) 的，而且 x^⁴/2 也是 O(3x^⁴ + 1) 的。",
        "answer": "For all x > 1, 3x^4 + 1 ≤ 4x^4 = 8(x^4/2), therefore 3x^4 + 1 is O(x^4/2), witness C = 8, k = 1. Similarly for all x > 0, x^4/2 ≤ 3x^4 + 1, therefore x^4/2 is O(3x^4 + 1), witness C = 1, k = 0.",
        "answer_symbols": [
            "^",
            "+",
            "≤",
            "="
        ]
    },
    "3.2 13": {
        "question": "证明 2^ⁿ 是 O(3^ⁿ) 的，但 3^ⁿ 不是 O(2^ⁿ) 的。",
        "answer": "Since for all n > 0, 2^n ≤ 3^n, 2^n is O(3^n), witness C = 1, k = 0. However, if 3^n is O(2^n), then for some C, 3^n ≤ C * 2^n for all sufficiently large n. This implies C ≥ (3/2)^n for all sufficiently large n, which is impossible. Therefore, 3^n is not O(2^n).",
        "answer_symbols": [
            "^",
            "≤",
            "*",
            "≥"
        ]
    },
    "3.2 14 a)": {
        "question": "对于下列每个函数 g(x)，判断 x^³ 是否是 O(g(x)) 的。（a）g(x) = x^²",
        "answer": "No, by an argument similar to Exercise 10.",
        "answer_symbols": []
    },
    "3.2 14 b)": {
        "question": "对于下列每个函数 g(x)，判断 x^³ 是否是 O(g(x)) 的。（b）g(x) = x^³",
        "answer": "Yes, since x^³ ≤ x^³ for all x (witnesses C= 1, k= 0).",
        "answer_symbols": [
            "≤"
        ]
    },
    "3.2 14 c)": {
        "question": "对于下列每个函数 g(x)，判断 x^³ 是否是 O(g(x)) 的。（c）g(x) = x^² + x^³",
        "answer": "Yes, since x^³ ≤ x^² + x^³ for all x (witnesses C= 1, k= 0).",
        "answer_symbols": [
            "≤",
            "+"
        ]
    },
    "3.2 14 d)": {
        "question": "对于下列每个函数 g(x)，判断 x^³ 是否是 O(g(x)) 的。（d）g(x) = x^² + x^⁴",
        "answer": "Yes, since x^³ ≤ x^² + x^⁴ for all x (witnesses C= 1, k= 0).",
        "answer_symbols": [
            "≤",
            "+"
        ]
    },
    "3.2 14 e)": {
        "question": "对于下列每个函数 g(x)，判断 x^³ 是否是 O(g(x)) 的。（e）g(x) = 3ˣ",
        "answer": "Yes, since x^³ ≤ 2x ≤ 3x for all x > 10 (see Exercise 2e). Thus we have witnesses C= 1 and k= 10.",
        "answer_symbols": [
            "≤",
            "<"
        ]
    },
    "3.2 14 f)": {
        "question": "对于下列每个函数 g(x)，判断 x^³ 是否是 O(g(x)) 的。（f）g(x) = x^³/2",
        "answer": "Yes, since x^³ ≤ 2 · (x^³/2) for all x (witnesses C= 2, k= 0).",
        "answer_symbols": [
            "≤",
            "·",
            "/"
        ]
    },
    "3.2 15": {
        "question": "试解释一个函数是 O(1) 的含义。",
        "answer": "All functions that have real numbers k and C such that |f(x)| ≤ C for x > k. These are the functions f(x) that are bounded on all sufficiently large x.",
        "answer_symbols": [
            "|",
            "≤",
            ">"
        ]
    },
    "3.2 16": {
        "question": "证明如果 f(x) 是 O(x) 的，那么 f(x) 是 O(x^²) 的。",
        "answer": "The given information says that |f(x)| ≤ C|x| for all x > k, where C and k are particular constants. Let k' be the larger of k and 1. Then since |x| ≤ |x^²| for all x > 1, we have |f(x)| ≤ C|x^²| for all x > k', as desired.",
        "answer_symbols": [
            "|",
            "≤",
            "²"
        ]
    },
    "3.2 17": {
        "question": "假定 f(x)、g(x) 和 h(x) 为函数，使得 f(x) 是 O(g(x)) 的，g(x) 是 O(h(x)) 的。证明 f(x) 是 O(h(x)) 的。",
        "answer": "There exist constants C1, C2, k1, and k2 such that |f(x)| ≤ C1|g(x)| for all x > k1 and |g(x)| ≤ C2|h(x)| for all x > k2. Therefore, for x > max(k1, k2), |f(x)| ≤ C1|g(x)| ≤ C1 C2|h(x)|. This shows that f(x) is O(h(x)).",
        "answer_symbols": [
            "|",
            "≤",
            ">",
            "max"
        ]
    },
    "3.2 18": {
        "question": "令 k 为正整数。证明 1ᵏ + 2ᵏ + … + nᵏ 是 O(n^(k+1)) 的。",
        "answer": "1^k + 2^k + · · · + n^k ≤ n^k + n^k + · · · + n^k = n · n^k = n^(k+1)",
        "answer_symbols": [
            "^",
            "+",
            "·",
            "≤"
        ]
    },
    "3.2 19": {
        "question": "判断函数 2^(n+1) 和 2^(2n) 是否是 O(2^ⁿ) 的。",
        "answer": "2^(n+1) is O(2^n); 2^(2n) is not.",
        "answer_symbols": [
            "^",
            ";"
        ]
    },
    "3.2 20": {
        "question": "判断函数 log(n+1) 和 log(n^² + 1) 是否是 O(log n) 的。",
        "answer": "They both are. For the first we have log(n + 1) < log(2n) = log n + log 2 < 2 log n for n > 2. For the second one we have log(n^² + 1) < log(2n^²) = 2 log n + log 2 < 3 log n for n > 2.",
        "answer_symbols": [
            "<",
            "=",
            "+",
            "²",
            "log"
        ]
    },
    "3.2 21": {
        "question": "将函数 √n、1000 log n、n log n、2n!、2^ⁿ、3^ⁿ 和 n^² / 1 000 000 排成一列使得每个函数是大 O 后面的函数。",
        "answer": "1000 log n, √n, n log n, n^2/1000000, 2^n, 3^n, 2^n!",
        "answer_symbols": [
            "log",
            "√",
            "^",
            "/"
        ]
    },
    "3.2 22": {
        "question": "将函数 (1.5)^ⁿ、n¹^⁰^⁰、(log n)^³、√n log n、10^ⁿ、(n!)^² 和 n^⁹ + n^⁸ 排成一列使得每个函数是大 O 后面的函数。",
        "answer": "The ordering is straightforward when we remember that exponential functions grow faster than polynomial functions, that factorial functions grow faster still, and that logarithmic functions grow very slowly. The order is (log n)^³, √n log n, n^⁹^⁹ + n^⁹^⁸, n¹^⁰^⁰, 1.5^n, 10^n, (n!)^².",
        "answer_symbols": [
            "³",
            "√",
            "log",
            "!",
            "²",
            "^",
            "+",
            ","
        ]
    },
    "3.2 23": {
        "question": "假设你有解决同一个问题的两个不同的算法。要解决大小为 n 的问题，第一个算法恰好使用了 n(log n) 步运算，而第二个算法恰好使用了 n^(3/2) 步运算。随着 n 的增长，哪个算法使用较少步运算？",
        "answer": "An algorithm using n log n operations",
        "answer_symbols": [
            "log"
        ]
    },
    "3.2 24": {
        "question": "假设你有解决同一个问题的两个不同的算法。要解决大小为 n 的问题，第一个算法恰好使用了 n^² 2^ⁿ 步运算，而第二个算法恰好使用了 n! 步运算。随着 n 的增长，哪个算法使用较少步运算？",
        "answer": "The first algorithm uses fewer operations because n^² 2^n is O(n!) but n! is not O(n^² 2^n). In fact, the second function overtakes the first function for good at n = 8, when 8^² · 2^⁸ = 16,384 and 8! = 40,320.",
        "answer_symbols": [
            "²",
            "·",
            "^",
            "!"
        ]
    },
    "3.2 26 a)": {
        "question": "给出下列各函数的大 O 估计。在你估计 f(x) 是 O(g(x)) 的时候使用一个阶最小的简单函数 g。（a）(n^² + n^² log n)(log n + 1) + (17 log n + 19)(n^² + 2)",
        "answer": "This is O(n^³ · log n + log n · n^³), which is the same as O(n^³ · log n).",
        "answer_symbols": [
            "³",
            "·",
            "log",
            "+"
        ]
    },
    "3.2 26 b)": {
        "question": "给出下列各函数的大 O 估计。在你估计 f(x) 是 O(g(x)) 的时候使用一个阶最小的简单函数 g。（b）(2^ⁿ + n^²)(n^² + 3^ⁿ)",
        "answer": "Since 2^n dominates n^², and 3^n dominates n^³, this is O(2^n · 3^n) = O(6^n).",
        "answer_symbols": [
            "^",
            "·",
            "="
        ]
    },
    "3.2 26 c)": {
        "question": "给出下列各函数的大 O 估计。在你估计 f(x) 是 O(g(x)) 的时候使用一个阶最小的简单函数 g。（c）(n^² + n 2^ⁿ + 5^ⁿ)(n! + 5^ⁿ)",
        "answer": "The dominant terms in the two factors are n^n and n!, respectively. Therefore this is O(n^n n!).",
        "answer_symbols": [
            "^",
            "!",
            "·"
        ]
    },
    "3.2 28 a)": {
        "question": "对练习 1 中的各函数，判断它是否为 Ω(x) 的和 Θ(x) 的。（a）f(x)=10",
        "answer": "This function is Θ(1), so it is not Θ(x), since 1 (or 10) grows more slowly than x. To be precise, x is not O(10). For the same reason, this function is not Ω(x).",
        "answer_symbols": [
            "Θ",
            "O",
            "Ω",
            "(",
            ")"
        ]
    },
    "3.2 28 b)": {
        "question": "对练习 1 中的各函数，判断它是否为 Ω(x) 的和 Θ(x) 的。（b）f(x)=3x+7",
        "answer": "This function is Θ(x); we can ignore the “+ 7” since it is a lower order term, and we can ignore the coefficient. Of course, since f(x) is Θ(x), it is also Ω(x).",
        "answer_symbols": [
            "Θ",
            "Ω",
            ";",
            "+",
            "(",
            ")",
            "f",
            "x"
        ]
    },
    "3.2 28 c)": {
        "question": "对练习 1 中的各函数，判断它是否为 Ω(x) 的和 Θ(x) 的。（c）f(x)=x^²+x+1",
        "answer": "This function grows faster than x. Therefore f(x) is not Θ(x) but it is Ω(x).",
        "answer_symbols": [
            "Θ",
            "Ω",
            "f",
            "x"
        ]
    },
    "3.2 28 d)": {
        "question": "对练习 1 中的各函数，判断它是否为 Ω(x) 的和 Θ(x) 的。（d）f(x)=5 log x",
        "answer": "This function grows more slowly than x. Therefore f(x) is not Θ(x) or Ω(x).",
        "answer_symbols": [
            "Θ",
            "Ω",
            "f",
            "x"
        ]
    },
    "3.2 28 e)": {
        "question": "对练习 1 中的各函数，判断它是否为 Ω(x) 的和 Θ(x) 的。（e）f(x)=|x|",
        "answer": "This function has values that are, for all practical purposes, equal to x (certainly ⌊x⌋ is always between x/2 and x, for x > 2), so it is Θ(x) and therefore also Ω(x).",
        "answer_symbols": [
            "Θ",
            "Ω",
            "⌊",
            "⌋",
            "/",
            ">"
        ]
    },
    "3.2 28 f)": {
        "question": "对练习 1 中的各函数，判断它是否为 Ω(x) 的和 Θ(x) 的。（f）f(x)=[x/2]",
        "answer": "As in part (e) this function has values that are, for all practical purposes, equal to x/2, so it is Θ(x) and therefore also Ω(x).",
        "answer_symbols": [
            "Θ",
            "Ω",
            "/"
        ]
    },
    "3.2 30 a)": {
        "question": "证明下列函数对具有相同的阶。（a）3x + 7, x",
        "answer": "This follows from the fact that for all x > 7, x ≤ 3x + 7 ≤ 4x.",
        "answer_symbols": [
            "≤",
            "+",
            ">"
        ]
    },
    "3.2 30 b)": {
        "question": "证明下列函数对具有相同的阶。（b）2x^² + x - 7, x^²",
        "answer": "For large x, clearly x^² ≤ 2x^² + x − 7. On the other hand, for x ≥ 1 we have 2x^² + x − 7 ≤ 3x^².",
        "answer_symbols": [
            "≤",
            "+",
            "−",
            "≥",
            "²"
        ]
    },
    "3.2 30 c)": {
        "question": "证明下列函数对具有相同的阶。（c）⌊x + 1/2⌋, x",
        "answer": "For x > 2 we certainly have ⌊x + 1/2⌋ ≤ 2x and also x ≤ 2⌊x + 1/2⌋.",
        "answer_symbols": [
            "⌊",
            "⌋",
            "≤",
            "+",
            "/"
        ]
    },
    "3.2 30 d)": {
        "question": "证明下列函数对具有相同的阶。（d）log(x^² + 1), log₂ x",
        "answer": "For x > 2, log(x^² + 1) ≤ log(2x^²) = 1 + 2 log x ≤ 3 log x (recall that log means log₂). On the other hand, since x < x^² + 1 for all positive x, we have log x ≤ log(x^² + 1).",
        "answer_symbols": [
            "log",
            "≤",
            "+",
            "²",
            "<"
        ]
    },
    "3.2 30 e)": {
        "question": "证明下列函数对具有相同的阶。（e）log₁₀ x, log₂ x",
        "answer": "This follows from the fact that log₁₀ x = C(log₂ x), where C = 1/log₂ 10.",
        "answer_symbols": [
            "log",
            "=",
            "(",
            ")",
            "/"
        ]
    },
    "3.2 31": {
        "question": "证明 f(x) 是 Θ(g(x)) 的当且仅当 f(x) 是 O(g(x)) 的且 g(x) 是 O(f(x)) 的。",
        "answer": "If f(x) is Θ(g(x)), then there exist constants C1 and C2 such that C1|g(x)| ≤ |f(x)| ≤ C2|g(x)|. This means |f(x)| ≤ C2|g(x)| and |g(x)| ≤ (1/C1)|f(x)| for x > k. Therefore, f(x) is O(g(x)) and g(x) is O(f(x)). Conversely, assume f(x) is O(g(x)) and g(x) is O(f(x)). Then there exist constants C1, C2, k1, and k2 such that |f(x)| ≤ C1|g(x)| for x > k1 and |g(x)| ≤ C2|f(x)| for x > k2. We can assume C2 > 0 (we can always increase C2). Then we have (1/C2)|g(x)| ≤ |f(x)| ≤ C1|g(x)| for x > max(k1, k2). Therefore, f(x) is Θ(g(x)).",
        "answer_symbols": [
            "Θ",
            "O",
            "|",
            "≤",
            ">",
            "max"
        ]
    },
    "3.2 32": {
        "question": "证明如果 f(x) 和 g(x) 是从实数集到实数集的函数，则 f(x) 是 O(g(x)) 的当且仅当 g(x) 是 Ω(f(x)) 的。",
        "answer": "We just need to look at the definitions. To say that f(x) is O(g(x)) means that there are constants C and k such that |f(x)| ≤ C|g(x)| for all x > k. Note that without loss of generality we may take C and k to be positive. To say that g(x) is Ω(f(x)) is to say that there are positive constants C' and k' such that |g(x)| ≥ C'|f(x)| for all x > k. These are saying exactly the same thing if we set C' = 1/C and k' = k.",
        "answer_symbols": [
            "|",
            "≤",
            "≥",
            "/",
            "="
        ]
    },
    "3.2 33": {
        "question": "证明如果 f(x) 和 g(x) 是从实数集到实数集的函数，则 f(x) 是 Θ(g(x)) 的当且仅当存在正常数 k、C₁ 和 C₂ 使得当 x > k 时有 C₁ |g(x)| ≤ |f(x)| ≤ C₂ |g(x)|。",
        "answer": "If f(x) is Θ(g(x)), then f(x) is both O(g(x)) and Ω(g(x)). Therefore, there exist positive constants C1, k1, C2, and k2 such that |f(x)| ≤ C2|g(x)| for all x > k2 and |f(x)| ≥ C1|g(x)| for all x > k1. This means C1|g(x)| ≤ |f(x)| ≤ C2|g(x)| for x > k, where k = max(k1, k2). Conversely, if there exist positive constants C1, C2, and k such that C1|g(x)| ≤ |f(x)| ≤ C2|g(x)| for x > k, then taking k1 = k2 = k shows that f(x) is both O(g(x)) and Ω(g(x)).",
        "answer_symbols": [
            "Θ",
            "O",
            "Ω",
            "|",
            "≤",
            ">",
            "max"
        ]
    },
    "3.2 34 a)": {
        "question": "找出练习 33 中要求的 k、C₁ 和 C₂ 来直接证明 3x^² + x + 1 是 Θ(3x^²) 的。",
        "answer": "By Exercise 31 we have to show that 3x^² + x + 1 is O(3x^²) and that 3x^² is O(3x^² + x + 1). The latter is trivial, since 3x^² ≤ 3x^² + x + 1 for x > 0. The former is almost as trivial, since 3x^² + x + 1 ≤ 3x^² + 3x^² = 2 * 3x^² for all x > 1. What we have shown is that 1 * 3x^² ≤ 3x^² + x + 1 ≤ 2 * 3x^² for all x > 1; in other words, C1 = 1 and C2 = 2 in Exercise 33.",
        "answer_symbols": [
            "+",
            "*",
            "≤",
            "="
        ]
    },
    "3.2 29": {
        "question": "对练习 2 中的各函数，判断它是否为 Ω(x^²) 的和 Θ(x^²) 的。",
        "answer": "a) Not Ω(x^2) nor O(x^2) b) Ω(x^2) and O(x^2) c) Not Ω(x^2) nor O(x^2) d) Ω(x^2), but not O(x^2) e) Ω(x^2), but not O(x^2) f) Ω(x^2) and O(x^2)",
        "answer_symbols": [
            "Ω",
            "O",
            "not",
            "and",
            "but"
        ]
    },
    "3.2 35": {
        "question": "用图形表示 f(x) 是 Θ(g(x)) 的这一关系。画出 f(x) 、 C_1 |g(x)| 、 C_2 |g(x)| 的图形，并在 x 轴上标出常数 k 。",
        "answer": "k xy C2g(x)C1g(x)f(x)",
        "answer_symbols": [
            "k",
            "x",
            "y",
            "C2",
            "g",
            "(",
            "x",
            ")",
            "C1",
            "f"
        ]
    },
    "3.2 36": {
        "question": "解释函数为 Ω(1) 的含义。",
        "answer": "Looking at the definition, we see that to say that f(x) is Ω(1) means that |f(x)| ≥ C when x > k, for some positive constants k and C. In other words, f(x) keeps at least a certain distance away from 0 for large enough x. For example, 1/x is not Ω(1), since it gets arbitrarily close to 0; but (x - 2)(x - 10) is Ω(1), since f(x) ≥ 9 for x > 11.",
        "answer_symbols": [
            "|",
            "≥",
            "/"
        ]
    },
    "3.2 37": {
        "question": "解释函数为 Θ(1) 的含义。",
        "answer": "If f(x) is Θ(1), then |f(x)| is bounded between positive constants C1 and C2. In other words, f(x) cannot be greater than a certain fixed bound or less than the negative of that bound, and it must not approach 0 beyond a certain fixed bound.",
        "answer_symbols": [
            "Θ",
            "|",
            "≤",
            ">",
            "not"
        ]
    },
    "3.2 38": {
        "question": "给出前 n 个奇正整数之乘积的一个大 O 估计。",
        "answer": "The nth odd positive integer is 2n - 1. Thus each of the first n odd positive integers is at most 2n. Therefore their product is at most (2n)^ⁿ, so one answer is O((2n)^ⁿ). Of course other answers are possible as well.",
        "answer_symbols": [
            "-",
            "^",
            "(",
            ")",
            "*"
        ]
    },
    "3.2 39": {
        "question": "证明如果 f 和 g 为实数值函数使得 f(x) 是 O(g(x)) 的，则对每个正整数 n 有 f^n(x) 是 O(g^n(x)) 的。[注意 f^n(x) = (f(x))^n ]",
        "answer": "Since f(x) is O(g(x)), there exist constants C and k such that |f(x)| ≤ C|g(x)| for x > k. Therefore, |f^n(x)| ≤ C^n|g^n(x)| for x > k, by taking the constant to be C^n, f^n(x) is O(g^n(x)).",
        "answer_symbols": [
            "O",
            "|",
            "≤",
            ">",
            "^"
        ]
    },
    "3.2 40": {
        "question": "证明对于所有实数 a 和 b 且 a > 1 及 b > 1 ，如果 f(x) 是 O(log_a x) 的，则 f(x) 是 O(log_b x) 的。",
        "answer": "This follows from the fact that log_b x and log_a x are the same except for a multiplicative constant, namely d = log_b a. Thus if f(x) ≤ C log_b x, then f(x) ≤ C * d * log_a x.",
        "answer_symbols": [
            "log",
            "≤",
            "*",
            "="
        ]
    },
    "3.2 41": {
        "question": "假设 f(x) 是 O(g(x)) 的，其中 f 和 g 是无限增长函数。证明 log |f(x)| 是 O(log |g(x)|) 的。",
        "answer": "Since f(x) and g(x) are increasing and unbounded, we can assume for sufficiently large x, f(x) ≥ 1 and g(x) ≥ 1. There exist constants C and k such that f(x) ≤ Cg(x) for x > k. This implies log f(x) ≤ log C + log g(x) < 2 log g(x) for sufficiently large x. Therefore, log f(x) is O(log g(x)).",
        "answer_symbols": [
            "O",
            "log",
            "≤",
            ">",
            "+",
            "<"
        ]
    },
    "3.2 42": {
        "question": "假定 f(x) 是 O(g(x)) 的。能否推断出 2^f(x) 是 O(2^g(x)) 的？",
        "answer": "This does not follow. Let f(x) = 2x and g(x) = x. Then f(x) is O(g(x)). Now 2^f(x) = 2^(2x) = 4x, and 2^g(x) = 2x, and 4x is not O(2x). Indeed, 4x / 2x = 2x, so the ratio grows without bound as x grows—it is not bounded by a constant.",
        "answer_symbols": [
            "=",
            "^",
            "/",
            "*"
        ]
    },
    "3.2 43": {
        "question": "令 f_1(x) 和 f_2(x) 为从实数集合到正实数集合的函数。证明如果 f_1(x) 和 f_2(x) 均为 Θ(g(x)) 的，其中 g(x) 是从实数集合到正实数集合的一个函数，则 f_1(x) + f_2(x) 是 Θ(g(x)) 的。如果 f_1(x) 和 f_2(x) 能取负值，这一结论还成立吗？",
        "answer": "By definition, there exist positive constants C1, C1', C2, C2', k1, k1', k2, and k2' such that f1(x) ≥ C1|g(x)| for all x > k1, f1(x) ≤ C1'|g(x)| for all x > k1', f2(x) ≥ C2|g(x)| for all x > k2, and f2(x) ≤ C2'|g(x)| for all x > k2'. Adding the first two and third inequalities shows that f1(x) + f2(x) ≥ (C1 + C2)|g(x)| for all x > k, where",
        "answer_symbols": [
            "≥",
            "≤",
            ">",
            "+",
            "|"
        ]
    },
    "3.2 44": {
        "question": "假定 f(x) 、 g(x) 和 h(x) 是函数使得 f(x) 是 Θ(g(x)) 的， g(x) 是 Θ(h(x)) 的。证明 f(x) 是 Θ(h(x)) 的。",
        "answer": "The definition of “f(x) is Θ(g(x))” is that f(x) is both O(g(x)) and Ω(g(x)). That means that there are positive constants C1, k1, C2, and k2 such that |f(x)| ≤ C2|g(x)| for all x > k2 and |f(x)| ≥ C1|g(x)| for all x > k1. Similarly, we have that there are positive constants C1', k1', C2', and k2' such that |g(x)| ≤ C2'|h(x)| for all x > k2' and |g(x)| ≥ C1'|h(x)| for all x > k1'. We can combine these inequalities to obtain |f(x)| ≤ C2 * C2'|h(x)| for all x > max(k2, k2') and |f(x)| ≥ C1 * C1'|h(x)| for all x > max(k1, k1'). This means that f(x) is Θ(h(x)).",
        "answer_symbols": [
            "|",
            "≤",
            "≥",
            "*",
            "=",
            "(",
            ")",
            "'"
        ]
    },
    "3.2 45": {
        "question": "如果 f_1(x) 、 f_2(x) 为从正整数集合到正实数集合的函数，且 f_1(x) 和 f_2(x) 都是 Θ(g(x)) 的， (f_1 - f_2)(x) 是否也是 Θ(g(x)) 的？或证明它成立或给出一个反例。",
        "answer": "This is false. Let f1 = x^² + 2x, f2(x) = x^² + x, and g(x) = x^². Then f1(x) and f2(x) are both O(g(x)), but (f1 - f2)(x) is not.",
        "answer_symbols": [
            "²",
            "+",
            "(",
            ")",
            "-",
            "O"
        ]
    },
    "3.2 46": {
        "question": "证明如果 f_1(x) 和 f_2(x) 为从正整数集合到实数集合的函数，且 f_1(x) 是 Θ(g_1(x)) 的， f_2(x) 是 Θ(g_2(x)) 的，则 (f_1 f_2)(x) 是 Θ((g_1 g_2)(x)) 的。",
        "answer": "The definitions tell us that there are positive constants C1, k1, C2, and k2 such that |f1(x)| ≤ C2|g1(x)| for all x > k2 and |f1(x)| ≥ C1|g1(x)| for all x > k1, and that there are positive constants C1', k1', C2', and k2' such that |f2(x)| ≤ C2'|g2(x)| for all x > k2' and |f2(x)| ≥ C1'|g2(x)| for all x > k1'. We can multiply these inequalities to obtain |f1(x)f2(x)| ≤ C2 * C2'|g1(x)g2(x)| for all x > max(k2, k2') and |f1(x)f2(x)| ≥ C1 * C1'|g1(x)g2(x)| for all x > max(k1, k1'). This means that f1(x)f2(x) is Θ(g1(x)g2(x)).",
        "answer_symbols": [
            "|",
            "≤",
            "≥",
            "*",
            "=",
            "(",
            ")",
            "'"
        ]
    },
    "3.2 47": {
        "question": "找出从正整数集合到实数集合的函数 f 和 g 使得 f(n) 不是 O(g(n)) 的，且 g(n) 也不是 O(f(n)) 的。",
        "answer": "Take f(n) to be the function with f(n) = n if n is an odd positive integer and f(n) = 1 if n is an even positive integer and g(n) to be the function with g(n) = 1 if n is an odd positive integer and g(n) = n if n is an even positive integer.",
        "answer_symbols": [
            "=",
            "if",
            "odd",
            "positive",
            "integer",
            "even"
        ]
    },
    "3.2 49": {
        "question": "证明如果 f_1(x) 是 Θ(g_1(x)) 的， f_2(x) 是 Θ(g_2(x)) 的，且对所有实数 x > 0 ， f_2(x) ≠ 0 ， g_2(x) ≠ 0 ，则 (f_1 / f_2)(x) 是 Θ((g_1 / g_2)(x)) 的。",
        "answer": "There are positive constants C1, C2, C1', C2', k1, k1', k2, and k2' such that |f1(x)| ≥ C1 |g1(x)| for all x > k1, |f1(x)| ≤ C1' |g1(x)| for all x ≥ k1', |f2(x)| > C2 |g2(x)| for all x > k2, and |f2(x)| ≤ C2' |g2(x)| for all x > k2'. Because f2 and g2 are never zero, the last two inequalities can be rewritten as |1/f2(x)| ≤ (1/C2) |1/g2(x)| for all x > k2 and |1/f2(x)| ≥ (1/C2') |1/g2(x)| for all x > k2'. Multiplying the first and rewritten fourth inequalities shows that |f1(x)/f2(x)| ≥ (C1/C2') |g1(x)/g2(x)| for all x > max(k1, k2'), and multiplying the second and rewritten third inequalities gives |f1(x)/f2(x)| ≤ (C1'/C2) |g1(x)/g2(x)| for all x > max(k1', k2). It follows that f1/f2 is big-Theta of g1/g2.",
        "answer_symbols": [
            "|",
            "≥",
            "≤",
            ">",
            "<",
            "=",
            "/",
            "max",
            "big-Theta"
        ]
    },
    "3.2 51": {
        "question": "试定义语句 f(x, y) 是 Θ(g(x, y)) 的。",
        "answer": "There exist positive constants C1, C2, k1, k2, k1', k2' such that |f(x, y)| ≤ C1 |g(x, y)| for all x > k1 and y > k2 and |f(x, y)| ≥ C2 |g(x, y)| for all x > k1' and y > k2'.",
        "answer_symbols": [
            "|",
            "≤",
            "≥",
            ">"
        ]
    },
    "3.2 53": {
        "question": "证明 (x^2 + xy + x log y)^3 是 O(x^6 y^3) 的。",
        "answer": "(x^² + xy + x log y)^³ < (3x^² y^³) = 27x^⁶ y^³ for x > 1 and y > 1, because x^² < x^² y, xy < x^² y, and x log y < x^² y. Hence, (x^² + xy + x log y)^³ is O(x^⁶ y^³).",
        "answer_symbols": [
            "²",
            "³",
            "<",
            "=",
            "+",
            "log",
            "O"
        ]
    },
    "3.2 55": {
        "question": "证明 |xy| 是 O(xy) 的。",
        "answer": "For all positive real numbers x and y, xʸ ≤ xʸ. Hence, xʸ is O(xʸ) from the definition, taking C = 1 and k1 = k2 = 0.",
        "answer_symbols": [
            "≤",
            "O",
            "="
        ]
    },
    "3.2 57": {
        "question": "(需要微积分知识) 证明如果 c > d > 0 ，则 n^c 是 O(n^d) 的，但 n^c 不是 O(n^d) 的。",
        "answer": "Clearly nᵈ < nᶜ for all n ≥ 2; therefore nᵈ is O(nᶜ). The ratio nᵈ/nᶜ = n^(d-c) is unbounded so there is no constant C such that nᵈ ≤ Cnᶜ for large n.",
        "answer_symbols": [
            "<",
            "O",
            "=",
            "≥",
            "unbounded",
            "≤"
        ]
    },
    "3.2 59": {
        "question": "(需要微积分知识) 证明如果 d 是正的且 b > 1 ，则 n^d 是 O(b^n) 的，但 b^n 不是 O(n^d) 的。",
        "answer": "If f and g are positive-valued functions such that lim n→∞ f(x)/g(x) = C < ∞, then f(x) < (C+1)g(x) for large enough x, so f(n) is O(g(n)). If that limit is ∞, then clearly f(n) is not O(g(n)). Here repeated applications of L'Hôpital's rule shows that lim x→∞ xᵈ/bˣ = 0 and lim x→∞ bˣ/xᵈ = ∞.",
        "answer_symbols": [
            "lim",
            "→",
            "∞",
            "<",
            ">",
            "O",
            "=",
            "L'Hôpital's rule"
        ]
    },
    "3.2 60": {
        "question": "(需要微积分知识) 证明如果 c > b > 1 ，则 b^n 是 O(c^n) 的，但 c^n 不是 O(b^n) 的。",
        "answer": "只需考虑 lim (n→∞) (b^n/c^n) = (b/c)^n 和 lim (n→∞) (c^n/b^n) = (c/b)^n。因为 c > b > 1，所以 0 < b/c < 1 且 c/b > 1，因此前一个极限显然是 0，后一个极限显然是 ∞。",
        "answer_symbols": [
            "lim",
            "→",
            "∞",
            "^",
            "/",
            ">",
            "<"
        ]
    },
    "3.2 62 a)": {
        "question": "(需要微积分知识)a) 证明如果函数 f(x) 和 g(x) 使得 f(x) 是 o(g(x)) 的，且 c 为常数，则 cf(x) 是 o(g(x)) 的，其中 (cf)(x) = cf(x) 。",
        "answer": "在假设条件下，lim (x→∞) [cf(x) / g(x)] = c * lim (x→∞) [f(x) / g(x)] = c * 0 = 0。",
        "answer_symbols": [
            "lim",
            "→",
            "∞",
            "[",
            "]",
            "*",
            "=",
            "/"
        ]
    },
    "3.2 62 b)": {
        "question": "b) 证明如果 f_1(x) 、 f_2(x) 和 g(x) 是函数使得 f_1(x) 是 o(g(x)) 的， f_2(x) 是 o(g(x)) 的，则 (f_1 + f_2)(x) 是 o(g(x)) 的，其中 (f_1 + f_2)(x) = f_1(x) + f_2(x) 。",
        "answer": "在假设条件下，lim (x→∞) [(f₁(x) + f₂(x)) / g(x)] = lim (x→∞) [f₁(x) / g(x)] + lim (x→∞) [f₂(x) / g(x)] = 0 + 0 = 0。",
        "answer_symbols": [
            "lim",
            "→",
            "∞",
            "[",
            "]",
            "+",
            "=",
            "/"
        ]
    },
    "3.2 63": {
        "question": "(需要微积分知识) 通过画出 x log x 、 x^2 及 x log x/x^2 的图来表示 x log x 是 o(x^2) 的。试解释该图是如何证明 x log x 是 o(x^2) 的。",
        "answer": "x y x log x x log x x 2x log x x 2 = 0 lim x x 2",
        "answer_symbols": [
            "log",
            "lim",
            "→",
            "∞",
            "²",
            "³",
            "x",
            "y"
        ]
    },
    "3.2 64": {
        "question": "(需要微积分知识) 用图来表示 f(x) 是 o(g(x)) 的关系。画出 f(x) 、 g(x) 和 f(x)/g(x) 的图。",
        "answer": "f 和 g 单独的行为并不是真正的问题所在；重要的是 f(x) / g(x) 是否在 x → ∞ 时接近 0。因此，如图所示，可能会发生 f 和 g 的图像上升，但 f 比 g 增长得足够快，使得比值变小。在图中，我们可以看到 f(x) / g(x) 渐近于 x 轴。",
        "answer_symbols": [
            "→",
            "∞",
            "/",
            "<"
        ]
    },
    "3.2 65": {
        "question": "(需要微积分知识) 假定 f(x) 是 o(g(x)) 的。能否由此推出 2^f(x) 是 o(2^g(x)) 的？",
        "answer": "No. Take f(x) = 1/x^² and g(x) = 1/x.",
        "answer_symbols": [
            "=",
            "²",
            "/"
        ]
    },
    "3.2 66": {
        "question": "(需要微积分知识) 假定 f(x) 是 o(g(x)) 的。能否由此推出 log |f(x)| 是 o(log |g(x)|) 的？",
        "answer": "不是。设 f(x) = x 和 g(x) = x^²。那么显然 f(x) 是 o(g(x))，但对数绝对值的比值是一个常数 2，而 2 并不接近 0。因此在这个例子中，并不是 log |f(x)| 是 o(log |g(x)|)。",
        "answer_symbols": [
            "=",
            "²",
            "o",
            "|",
            "log",
            "→",
            "∞"
        ]
    },
    "3.2 68": {
        "question": "(需要微积分知识) 证明如果 f(x) 是 n 阶多项式，而 g(x) 是 m 阶多项式，且 m ≥ n ，则 f(x) 是 o(g(x)) 的。",
        "answer": "这是因为在这种情况下 f(x) / g(x) 的极限为 0，这可以通过将分子和分母除以 x^ⁿ 来最清楚地看到（此时分子是有界的，而分母的绝对值随着 x → ∞ 无限增大）。",
        "answer_symbols": [
            "→",
            "∞",
            "/",
            "lim",
            "∞",
            "ⁿ",
            "(",
            ")",
            "=",
            "0"
        ]
    },
    "3.2 69": {
        "question": "(需要微积分知识) 证明如果 f_1(x) 是 O(g(x)) 的， f_2(x) 是 o(g(x)) 的，那么 f_1(x) + f_2(x) 是 O(g(x)) 的。",
        "answer": "Because f₂(x) is o(g(x)), from Exercise 67(a) it follows that f₂(x) is O(g(x)). By Corollary 1, we have f₁(x) + f₂(x) is O(g(x)).",
        "answer_symbols": [
            "o",
            "O",
            "+"
        ]
    },
    "3.2 70": {
        "question": "(需要微积分知识) 令 H_n 为第 n 项调和数 H_n = 1 + 1/2 + 1/3 + ⋯ + 1/n 证明 H_n 是 O(log n) 的。[提示：首先通过证明对 j = 2, 3, ⋯, n ，以 j-1 到 j 为底，以 1/j 为高的所有这些长方形的面积之和小于曲线 y = 1/x 下面从 2 到 n 的这一面积来建立不等式 ∑_{j=2}^{n} 1/j < ∫_1^n 1/x dx ]",
        "answer": "由于 f(x) = 1/x 是一个递减函数，在 x = j 时的值为 1/x，因此在整个从 j - 1 到 j 的区间内，1/j < 1/x。对所有区间求和，j = 2, 3, ..., n，并注意到定积分是曲线下方的面积，我们得到提示中的不等式。因此：Hₙ = 1 + ∑(j=2 到 n) [1 / j] < 1 + ∫(1 到 n) [1 / x] dx = 1 + ln n = 1 + C log n ≤ 2C log n 对于 n > 2，其中 C = log e。",
        "answer_symbols": [
            "=",
            "/",
            "<",
            "∑",
            "∫",
            "dx",
            "ln",
            "log",
            "≤"
        ]
    },
    "3.2 71": {
        "question": "证明 n log n 是 O(log n!) 的。",
        "answer": "We can easily show that (n-i)(i+1) ≥ n for i = 0, 1, ..., n-1. Hence, (n!)^² = (n · 1)((n − 1) · 2)·((n − 2) · 3)···(2 · (n − 1))·(1 · n) ≥ n^ⁿ. Therefore, 2 log n! ≥ n log n.",
        "answer_symbols": [
            "≥",
            "!",
            "²",
            "·",
            "log"
        ]
    },
    "3.2 72": {
        "question": "判断 log n! 是否是 Θ(n log n) 的。给出理由。",
        "answer": "通过例 6，我们知道 log n! 是 O(n log n)。通过练习 71，n log n 是 O(log n!)。因此，通过练习 31，log n! 是 Θ(n log n)。",
        "answer_symbols": [
            "log",
            "!",
            "O",
            "Θ"
        ]
    },
    "3.2 73": {
        "question": "证明：对所有 n > 4 的数，有 log n! 大于 (n log n)/4 。[提示：从不等式 n! > n(n-1)(n-2) ⋯ [n/2] 开始。]",
        "answer": "Compute that log 5! ≈ 6.9 and (5 log 5)/4 ≈ 2.9, so the inequality holds for n = 5. Assume n ≥ 6. Because n! is the product of all the integers from n down to 1, we have n! > n(n − 1)(n − 2) ··· n/2 (because at least the term 2 is missing). Note that there are more than n/2 terms in this product, and each term is at least as big as n/2. Therefore the product is greater than (n/2)^(n/2). Taking the log of both sides of the inequality, we have log n! > log(n^²)n/2 = n/2 log n/2 = n/2(log n − 1) > (n log n)/4, because n > 4 implies log n − 1 > (log n)/2.",
        "answer_symbols": [
            "log",
            "!",
            "≈",
            ">",
            "²",
            "(",
            ")",
            "+",
            "−",
            "/"
        ]
    },
    "3.2 74 a)": {
        "question": "(需要微积分知识) 对下列每对函数，判断 f 和 g 是否渐近的。a) f(x) = x^2 + 3x + 7 ， g(x) = x^2 + 10",
        "answer": "当 x 趋向于无穷大时，(x^² + 3x + 7)/(x^² + 10) 的极限为 (1 + 3/x + 7/x^²)/(1 + 10/x^²) = 1，所以 f 和 g 是渐近的。",
        "answer_symbols": [
            "→",
            "∞",
            "+",
            "/",
            "²",
            "(",
            ")",
            "="
        ]
    },
    "3.2 74 b)": {
        "question": "b) f(x) = x^2 log x ， g(x) = x^2",
        "answer": "当 x 趋向于无穷大时，(x^² log x)/(x^³) 的极限为 (log x)/x = (1/x) * ln 2 = 0（我们使用了洛必达法则进行最后的等价转换），所以 f 和 g 不是渐近的。",
        "answer_symbols": [
            "→",
            "∞",
            "+",
            "/",
            "²",
            "³",
            "log",
            "ln",
            "*",
            "="
        ]
    },
    "3.2 74 c)": {
        "question": "c) f(x) = x^4 + log(3x^8 + 7) ， g(x) = (x^8 + 17x + 3)^2",
        "answer": "这里 f(x) 主要由其最高次项 x^⁴ 决定，而 g(x) 是一个四次多项式，因此比值接近 1，即最高次项系数的比值，与部分 (a) 类似。因此 f 和 g 是渐近的。",
        "answer_symbols": [
            "→",
            "∞",
            "⁴",
            "/"
        ]
    },
    "3.2 74 d)": {
        "question": "d) f(x) = (x^3 + x^2 + x + 1)^4 ， g(x) = (x^4 + x^3 + x^2 + x + 1)^3",
        "answer": "这里 f 和 g 都是十二次多项式，因此比值接近 1，即最高次项系数的比值，与部分 (a) 类似。因此 f 和 g 是渐近的。",
        "answer_symbols": [
            "→",
            "∞",
            "/"
        ]
    },
    "3.3 1": {
        "question": "试给出下面算法片段用到的运算次数的大O估计（这里运算是指加法或乘法）。 t := 0 for i := 1 to 3 for j := 1 to 4 t := t + ij",
        "answer": "O(1)",
        "answer_symbols": [
            "O"
        ]
    },
    "3.3 2": {
        "question": "试给出下面算法片段用到的加法次数的大O估计。 t := 0 for i := 1 to n for j := 1 to n t := t + i + j",
        "answer": "语句 t := t + i + j 被执行 n^² 次，所以操作次数为 O(n^²)。（具体来说，使用了 2n^² 次加法，不计算循环中所需的任何簿记算术。）",
        "answer_symbols": [
            "+",
            "²",
            "O"
        ]
    },
    "3.3 3": {
        "question": "试给出下面算法片段用到的运算次数的大O估计，这里运算是指比较或乘法（忽略在for循环中测试条件所需的比较，其中a₁，a₂，…，aₙ是正实数）。 m := 0 for i := 1 to n for j := i + 1 to n m := max(aᵢaⱼ，m)",
        "answer": "O(n^²)",
        "answer_symbols": [
            "O",
            "²"
        ]
    },
    "3.3 4": {
        "question": "试给出下面算法片段用到的运算次数的大O估计，这里运算是指加法或乘法（忽略在while循环中测试条件所需的比较）。 i := 1 t := 0 while i ≤ n t := t + i i := 2i",
        "answer": "i 的值不断翻倍，因此在 2^k > n 时，循环在 k 次迭代后终止。使这种情况发生的 k 值为 O(log n)，因为 2^(log n) = n。循环内有两次加法或乘法，所以问题的答案是 O(log n)。",
        "answer_symbols": [
            "^",
            ">",
            "log",
            "=",
            "O"
        ]
    },
    "3.3 5": {
        "question": "3.1节练习16给出的在n个自然数的序列中寻找最小自然数的算法需要使用多少次比较？",
        "answer": "2n − 1",
        "answer_symbols": [
            "−"
        ]
    },
    "3.3 6 a)": {
        "question": "用伪代码写一个算法，使用插入排序将任意长度的实数列表中前4项排列成递增序。",
        "answer": "我们可以通过复制算法 5 中的步骤但只到 j = 4 来对前四个元素进行排序。",
        "answer_symbols": []
    },
    "3.3 6 b)": {
        "question": "证明以比较次数度量算法的时间复杂度是O(1)。",
        "answer": "无论列表长度如何，这里只执行有限数量的步骤，因此该算法的时间复杂度为 O(1)。",
        "answer_symbols": [
            "O"
        ]
    },
    "3.3 7": {
        "question": "假定已知一个元素是一个有32个元素的列表的前4个元素中。线性搜索或二分搜索哪个会更快地定位到该元素?",
        "answer": "Linear",
        "answer_symbols": []
    },
    "3.3 8": {
        "question": "给定实数 x 和正整数 k，试给出计算 x^k 使用的乘法次数，计算方法是从 x 开始连续取平方（求 x^²、x^⁴ 等）。这样是否比通过在 x 乘上适当次数的自身来计算 x^k 更高效?",
        "answer": "如果我们连续平方 k 次，那么我们已经计算了 x^(2^k)。因此，我们可以用仅 k 次乘法来计算 x^(2^k)，而不是朴素算法所需的 2^k - 1 次乘法，因此这种方法效率更高。",
        "answer_symbols": [
            "^",
            "-"
        ]
    },
    "3.3 9": {
        "question": "给出下述算法所使用的比较次数的大 O 估计，通过检查串的每位是否为 1 来计算位串中 1 的个数（参见 3.1 节练习 25）。",
        "answer": "O(n)",
        "answer_symbols": [
            "O"
        ]
    },
    "3.3 10 a)": {
        "question": "证明下面的算法给出的是位串 S 中 1 的个数。procedure bit_count(S: 位串) count := 0 while S ≠ 0 count := count + 1 S := S ∧ (S - 1) return count (count 是 S 中 1 的个数) 其中 S - 1 是把 S 中最右边的位 1 改为位 0，同时把这一位右边的所有位 0 均改为位 1 得到的位串。 [S ∧ (S - 1)] 是 S 和 S - 1 的按位合取运算。",
        "answer": "通过 S - 1 的定义方式，很明显 S ∧ (S - 1) 与 S 相同，只是最右边的 1 位被改为 0。因此，每次遇到 1 位时，我们都会将计数器加 1（因为我们一旦 S = 0 就停止，即 S 只包含 0 位）。",
        "answer_symbols": [
            "-",
            "∧",
            "="
        ]
    },
    "3.3 10 b)": {
        "question": "用 a) 中的算法计算位串 S 中 1 的个数需要做多少次按位合取运算?",
        "answer": "显然，按位与操作的数量等于计数器的最终值，即 S 中 1 位的数量。",
        "answer_symbols": [
            "∧",
            "="
        ]
    },
    "3.3 11 a)": {
        "question": "假设有集合 {1, 2, ⋯, n} 的 n 个子集 S₁, S₂, ⋯, Sₙ。试写出一个蛮力算法来判定是否有一对子集是不相交的。[提示：算法应该针对子集进行循环；对于每个子集 Sᵢ，需要对所有其他子集进行循环；而对其他子集中的每个 Sⱼ，需要针对 Sᵢ 中所有元素 k 做循环以判定 k 是否也属于 Sⱼ。]",
        "answer": "procedure disjointpair(S1, S2, ..., Sn: subsets of {1, 2, ..., n}) answer := false for i := 1 to n for j := i+1 to n disjoint := true for k := 1 to n if k ∈ Si and k ∈ Sj then disjoint := false if disjoint then answer := true return answer",
        "answer_symbols": [
            "∈",
            ":="
        ]
    },
    "3.3 11 b)": {
        "question": "试给出算法用于判定一个整数是否在其中一个子集中的次数的大 O 估计。",
        "answer": "O(n^³)",
        "answer_symbols": [
            "O",
            "³"
        ]
    },
    "3.3 12 a)": {
        "question": "考虑下面的算法，以 n 个整数 a₁, a₂, ⋯, aₙ 的序列作为输入，生成一个矩阵 M = {mij} 作为输出，其中对于 j ≥ i 时 mij 是整数序列 ai, ai+1, ⋯, aj 中的最小项，否则 mij = 0 。初始化 M 使得当 j ≥ i 时 mij = ai ，否则 mij = 0 for i := 1 to n for j := i + 1 to n for k := i + 1 to j mij := min(mij, ak) return M = {mij} (mij 是 ai, ai+1, ⋯, aj 中的最小项) 证明这个算法使用 O(n^³) 次比较来计算矩阵 M。",
        "answer": "There are three loops, each nested inside the next. The outer loop is executed n times, the middle loop is executed at most n times, and the inner loop is executed at most n times. Therefore, the number of times the one statement inside the inner loop is executed is at most n^³. This statement requires one comparison, so the total number of comparisons is O(n^³).",
        "answer_symbols": [
            "n",
            "times",
            "³",
            "O",
            "(",
            ")",
            ","
        ]
    },
    "3.3 12 b)": {
        "question": "证明这个算法使用 Ω(n^³) 次比较来计算矩阵 M。利用该事实以及 a) 得出结论该算法使用 Θ(n^³) 次比较。[提示：在算法的两层外循环中只考虑当 i ≤ n/4 和 j ≥ 3n/4 的情形。]",
        "answer": "We follow the hint, not worrying about the fractions that might result from roundoff when dividing by 2 or 4 (these don’t affect the final answer in big-Omega terms). The outer loop is executed at least n/4 times, once for each value of i from 1 to n/4 (we ignore the rest of the values of i). The middle loop is executed at least n/4 times, once for each value of j from 3n/4 to n. The inner loop for these values of i and j is executed at least (3n/4) − (n/4) = n/2 times. Therefore, the statement within the inner loop, which requires one comparison, is executed at least (n/4)(n/4)(n/2) = n/32 times, which is Ω(n^³). The second statement follows by definition.",
        "answer_symbols": [
            "n",
            "/",
            "4",
            "times",
            "3n",
            "−",
            "(",
            ")",
            "=",
            "Ω",
            "(",
            "³",
            ")",
            "."
        ]
    },
    "3.3 13 a)": {
        "question": "按上述算法步骤计算 3x^² + x + 1 在 x = 2 处的值并给出每步赋值语句所赋的值。",
        "answer": "power := 1, y := 1; i := 1, power := 2, y := 3; i := 2, power := 4, y := 15",
        "answer_symbols": [
            ":="
        ]
    },
    "3.3 13 b)": {
        "question": "准确地说计算 n 阶多项式在 x = c 处的值需要使用多少次乘法和加法?（不要计算增加循环变量的值所做的加法。）",
        "answer": "2n multiplications and n additions",
        "answer_symbols": [
            "and"
        ]
    },
    "3.3 14 a)": {
        "question": "按上述算法步骤计算 3x^² + x + 1 在 x = 2 的值并给出每步赋值语句所赋的值。",
        "answer": "Initially y := 3. For i = 1, we set y to 3 * 2 + 1 = 7. For i = 2, we set y to 7 * 2 + 1 = 15, and we are done.",
        "answer_symbols": [
            ":=",
            "*",
            "+",
            "="
        ]
    },
    "3.3 14 b)": {
        "question": "准确地说此算法计算 n 阶多项式在 x = c 处的值需要使用多少次乘法和加法？（不要计算增加循环变量的值所做的加法。）",
        "answer": "There is one multiplication and one addition for each of the n passes through the loop, so there are n multiplications and n additions in all.",
        "answer_symbols": [
            "*",
            "+"
        ]
    },
    "3.3 15 a)": {
        "question": "log n",
        "answer": "2¹^⁰^⁹ ≈ 10^³ × 10^⁸",
        "answer_symbols": [
            "≈",
            "×",
            "¹⁰⁹",
            "³",
            "⁸"
        ]
    },
    "3.3 15 b)": {
        "question": "n",
        "answer": "10^⁹",
        "answer_symbols": [
            "⁹"
        ]
    },
    "3.3 15 c)": {
        "question": "n log n",
        "answer": "3.96 × 10^⁷",
        "answer_symbols": [
            "×",
            "⁷"
        ]
    },
    "3.3 15 d)": {
        "question": "n^2",
        "answer": "3.16 × 10^⁴",
        "answer_symbols": [
            "×",
            "⁴"
        ]
    },
    "3.3 15 e)": {
        "question": "2^n",
        "answer": "2^⁹",
        "answer_symbols": [
            "⁹"
        ]
    },
    "3.3 15 f)": {
        "question": "n!",
        "answer": "12",
        "answer_symbols": []
    },
    "3.3 16 a)": {
        "question": "log n",
        "answer": "If log n = 864 * 10¹^³, then n = 2^(864 * 10¹^³), which is an unfathomably huge number.",
        "answer_symbols": [
            "log",
            "*",
            "²",
            "^"
        ]
    },
    "3.3 16 b)": {
        "question": "1000n",
        "answer": "If 1000n = 864 * 10¹^³, then n = 864 * 10¹^⁰, which is still a very large number.",
        "answer_symbols": [
            "*",
            "="
        ]
    },
    "3.3 16 c)": {
        "question": "n^2",
        "answer": "If n^² = 864 * 10¹^³, then n = √(864 * 10¹^³), which works out to about 9.3 * 10^⁷.",
        "answer_symbols": [
            "²",
            "√",
            "*",
            "="
        ]
    },
    "3.3 16 d)": {
        "question": "1000n^2",
        "answer": "If 1000n^² = 864 * 10¹^³, then n = √(864 * 10¹^⁰), which works out to about 2.9 * 10^⁶.",
        "answer_symbols": [
            "²",
            "√",
            "*",
            "="
        ]
    },
    "3.3 16 e)": {
        "question": "n^3",
        "answer": "If n^³ = 864 * 10¹^³, then n = (864 * 10¹^³)^(1/3), which works out to about 2.1 * 10^⁵.",
        "answer_symbols": [
            "³",
            "*",
            "(",
            ")",
            "^",
            "/"
        ]
    },
    "3.3 16 f)": {
        "question": "2^n",
        "answer": "If 2^n = 864 * 10¹^³, then n = log₂(864 * 10¹^³) = 52. (Remember, we are taking log to the base 2.)",
        "answer_symbols": [
            "^",
            "log₂",
            "*",
            "="
        ]
    },
    "3.3 16 g)": {
        "question": "2^n",
        "answer": "If 2^(2n) = 864 * 10¹^³, then n = log₂(864 * 10¹^³) / 2 = 26.",
        "answer_symbols": [
            "^",
            "log₂",
            "*",
            "/",
            "="
        ]
    },
    "3.3 17 a)": {
        "question": "log log n",
        "answer": "2^²^⁶^⁰·10¹^²",
        "answer_symbols": [
            "·",
            "²⁶⁰",
            "¹²"
        ]
    },
    "3.3 17 b)": {
        "question": "log n",
        "answer": "2^⁶^⁰·10¹^²",
        "answer_symbols": [
            "·",
            "⁶⁰",
            "¹²"
        ]
    },
    "3.3 17 c)": {
        "question": "n^2",
        "answer": "2√60·10^⁶ ≈ 2 × 10^²^³^³¹^⁷^⁶^⁸",
        "answer_symbols": [
            "√",
            "·",
            "≈",
            "×",
            "⁶",
            "²³³¹⁷⁶⁸"
        ]
    },
    "3.3 17 d)": {
        "question": "1 000 000n",
        "answer": "60,000,000",
        "answer_symbols": []
    },
    "3.3 17 e)": {
        "question": "n^3",
        "answer": "7,745,966",
        "answer_symbols": []
    },
    "3.3 17 f)": {
        "question": "2^n",
        "answer": "45",
        "answer_symbols": []
    },
    "3.3 17 g)": {
        "question": "2^n",
        "answer": "61",
        "answer_symbols": []
    },
    "3.3 18 a)": {
        "question": "10",
        "answer": "1.224 × 10^⁻^⁶ seconds",
        "answer_symbols": [
            "×",
            "⁻⁶"
        ]
    },
    "3.3 18 b)": {
        "question": "20",
        "answer": "Approximately 1.05 × 10^⁻^³ seconds",
        "answer_symbols": [
            "×",
            "⁻³"
        ]
    },
    "3.3 18 c)": {
        "question": "50",
        "answer": "Approximately 1.13 × 10^⁶ seconds, which is about 13 days (nonstop)",
        "answer_symbols": [
            "×",
            "⁶"
        ]
    },
    "3.3 18 d)": {
        "question": "100",
        "answer": "Approximately 1.27 × 10^²¹ seconds, which is about 4 × 10¹^³ years (nonstop)",
        "answer_symbols": [
            "×",
            "²¹",
            "¹³"
        ]
    },
    "3.3 19 a)": {
        "question": "10^-8 秒",
        "answer": "36 years",
        "answer_symbols": []
    },
    "3.3 19 b)": {
        "question": "10^-9 秒",
        "answer": "13 days",
        "answer_symbols": []
    },
    "3.3 19 c)": {
        "question": "10^-12 秒",
        "answer": "19 minutes",
        "answer_symbols": []
    },
    "3.3 20 a)": {
        "question": "log log n",
        "answer": "Notice that log log 2n − log log n = log (log 2 + log n) − log n = log 1 + log (n / n). If n is large, the fraction in this expression is approximately equal to 1, and therefore the expression is approximately equal to 0. In other words, hardly any extra time is required. For example, in going from n = 1024 to n = 2048, the number of extra milliseconds is log (11/10) ≈ 0.14.",
        "answer_symbols": [
            "log",
            "−",
            "+",
            "(",
            ")",
            "/",
            "≈"
        ]
    },
    "3.3 20 b)": {
        "question": "log n",
        "answer": "Here we have log 2n − log n = log (2n / n) = log 2 = 1. One extra millisecond is required, independent of n.",
        "answer_symbols": [
            "log",
            "−",
            "(",
            ")",
            "=",
            "2"
        ]
    },
    "3.3 20 c)": {
        "question": "100n",
        "answer": "This time it makes more sense to use a ratio comparison, rather than a difference comparison. Because 100(2n) / (100n) = 2, we conclude that twice as much time is needed for the larger problem.",
        "answer_symbols": [
            "(",
            "/",
            "=",
            ")"
        ]
    },
    "3.3 20 d)": {
        "question": "n log n",
        "answer": "这里的控制因素是 n，而不是 log n，因此我们再次查看比率：2n log(2n) / n log n = 2 · (1 + log n) 对于大的 n，最终的分数接近 1，所以我们可以认为 2n 所需的时间比 n 多一点。",
        "answer_symbols": [
            "log",
            "/",
            "=",
            "+",
            "·"
        ]
    },
    "3.3 20 e)": {
        "question": "n^2",
        "answer": "因为 (2n)^2 / n^2 = 4，我们看到较大的问题所需的时间是原来的四倍。",
        "answer_symbols": [
            "^",
            "/",
            "="
        ]
    },
    "3.3 20 f)": {
        "question": "2^n",
        "answer": "因为 (3n)^2 / n^2 = 9，我们看到较大的问题所需的时间是原来的九倍。",
        "answer_symbols": [
            "^",
            "/",
            "="
        ]
    },
    "3.3 20 g)": {
        "question": "2^n",
        "answer": "相关的比率是 2^(2n) / 2^n，等于 2^n。如果 n 很大，那么这是一个巨大的数字。例如，从 n = 10 到 n = 20，毫秒数增加了超过 1000 倍。",
        "answer_symbols": [
            "^",
            "/",
            "="
        ]
    },
    "3.3 21 a)": {
        "question": "log n",
        "answer": "Less than 1 millisecond more",
        "answer_symbols": []
    },
    "3.3 21 b)": {
        "question": "100n",
        "answer": "100 milliseconds more",
        "answer_symbols": []
    },
    "3.3 21 c)": {
        "question": "n^2",
        "answer": "2n + 1 milliseconds more",
        "answer_symbols": [
            "+",
            "²"
        ]
    },
    "3.3 21 d)": {
        "question": "n^3",
        "answer": "3n^² + 3n + 1 milliseconds more",
        "answer_symbols": [
            "+",
            "²"
        ]
    },
    "3.3 21 e)": {
        "question": "2^n",
        "answer": "Twice as much time",
        "answer_symbols": []
    },
    "3.3 21 f)": {
        "question": "2^n",
        "answer": "2^(2n+1) times as many milliseconds",
        "answer_symbols": [
            "^",
            "+"
        ]
    },
    "3.3 21 g)": {
        "question": "n!",
        "answer": "n + 1 times as many milliseconds",
        "answer_symbols": [
            "+"
        ]
    },
    "3.3 22 a)": {
        "question": "用 3.1 节算法 1 寻找 n 个整数的序列的最大值。",
        "answer": "比较次数不依赖于 a1 到 an 的值。正如在示例 1 中确定的那样，使用了恰好 2n - 1 次比较。换句话说，最佳情况性能是 O(n)。",
        "answer_symbols": [
            "-",
            "="
        ]
    },
    "3.3 22 b)": {
        "question": "用线性搜索在 n 个元素的列表中定位一个元素。",
        "answer": "在最佳情况下 x = a1。我们在示例 4 中看到，在那种情况下使用了三次比较。因此，最佳情况性能是 O(1)。",
        "answer_symbols": [
            "="
        ]
    },
    "3.3 22 c)": {
        "question": "用二分搜索在 n 个元素的列表中定位一个元素。",
        "answer": "给出确切的答案很困难，因为它取决于数字 n 的二进制表示等其他因素。无论如何，最佳情况性能实际上与最坏情况性能没有太大的不同，即 O(log n)，因为列表在每次迭代中基本上被减半，并且算法直到列表只剩下一个元素时才会停止。",
        "answer_symbols": [
            "log"
        ]
    },
    "3.3 23": {
        "question": "试分析线性搜索的平均情形性能，如果恰有一半的情况 x 不在列表中；而且当 x 在列表中时它出现在列表中任何位置的可能性都一样。",
        "answer": "The average number of comparisons is (3n + 4)/2.",
        "answer_symbols": [
            "+",
            "/"
        ]
    },
    "3.3 24 a)": {
        "question": "证明 3.1 节算法 1 相对于整数比较的次数而言是最优的。[注意：这里不考虑用于循环管理中的比较。]",
        "answer": "为了找到 n 个元素列表中的最大元素，我们需要进行至少 n - 1 次比较，每次排除一个其他元素。由于第 3.1 节中的算法 1 使用的正是这个数量（不包括簿记），因此它是最优的。",
        "answer_symbols": [
            "-"
        ]
    },
    "3.3 24 b)": {
        "question": "线性搜索相对于整数比较次数是最优的吗？（不计循环管理中用到的比较。）",
        "answer": "线性搜索不是最优的，因为我们发现二分搜索更高效。这假设我们可以得到已经按递增顺序排序的列表。",
        "answer_symbols": []
    },
    "3.3 25": {
        "question": "描述 3.1 节练习 27 给出的三分搜索算法用比较次数度量的最坏情形时间复杂度。",
        "answer": "O(log n)",
        "answer_symbols": [
            "O",
            "log"
        ]
    },
    "3.3 26": {
        "question": "描述 3.1 节练习 28 中给出的搜索算法用比较次数度量的最坏情形时间复杂度。",
        "answer": "我们将计算列表中的元素与 x 的比较次数。（这忽略了下标的比较，但因为我们只对大 O 分析感兴趣，所以不会造成损害。）此外，我们将假设列表中的元素数量是 4 的幂，比如说 n = 4^k。就像二分搜索的情况一样，我们需要确定 while 循环的最大迭代次数。每次通过循环都会使仍在考虑的元素数量（下标从 i 到 j 的那些元素）减少四分之一。因此，在 k 次迭代后，活动部分的列表长度将为 1；也就是说，我们将有 i = j。此时循环终止。现在，循环的每次迭代在最坏情况下需要两次比较（一次与 am 比较，另一次与 al 或 au 比较）。最后还需要三次比较。因此，比较次数为 2k + 3，这是 O(k)。但 k = log4 n，这是 O(log n)，因为不同底数的对数仅相差乘法常数，因此该算法的时间复杂度（不仅是最坏情况，而是所有情况）是 O(log n)。",
        "answer_symbols": [
            "=",
            "log",
            "^",
            "+"
        ]
    },
    "3.3 27": {
        "question": "分析你为 3.1 节练习 29 设计的在非递减序整数表中定位一个众数的算法的最坏情形时间复杂度。",
        "answer": "O(n)",
        "answer_symbols": [
            "O"
        ]
    },
    "3.3 28": {
        "question": "分析你为 3.1 节练习 30 设计的在非递减序整数表中定位所有众数的算法的最坏情形时间复杂度。",
        "answer": "我们给出的查找所有众数的算法基本上只是遍历列表一次，在每一步做少量的簿记工作。特别是，在任何两个连续执行语句 i := i + 1 之间最多大约有八次操作（如比较 count 与 modecount，或重新初始化 value）。\n因此，总共最多大约执行 8n 步，因此所有情况下的时间复杂度都是 O(n)。",
        "answer_symbols": [
            "="
        ]
    },
    "3.3 29": {
        "question": "分析你为 3.1 节练习 31 设计的在整数序列中寻找第一个与它前面某项相等的项的算法的最坏情形时间复杂度。",
        "answer": "O(n^²)",
        "answer_symbols": [
            "O",
            "²"
        ]
    },
    "3.3 30": {
        "question": "分析你为 3.1 节练习 32 设计的求序列中所有那些大于其前面各项之和的项的算法的最坏情形时间复杂度。",
        "answer": "我们给出的算法显然是线性时间复杂度的，即 O(n)，因为我们可以不断更新前项的总和，而不需要每次都重新计算。这适用于所有情况，而不仅仅是最坏情况。",
        "answer_symbols": [
            "="
        ]
    },
    "3.3 31": {
        "question": "分析你为 3.1 节练习 33 设计的求序列中第一个小于前一项的项的算法的最坏情形时间复杂度。",
        "answer": "O(n)",
        "answer_symbols": [
            "O"
        ]
    },
    "3.3 32": {
        "question": "用比较次数作为度量来确定 3.1 节练习 5 的在整数排序表中寻找所有多次出现的值的算法的最坏情形时间复杂度。",
        "answer": "该算法遍历列表一次，并对每个术语进行了有限的工作。另一种说法是，在算法给定的解中 j 的增量之间只做了有限的工作。因此，复杂度是 O(n)。",
        "answer_symbols": [
            "="
        ]
    },
    "3.3 33": {
        "question": "用比较次数作为度量来确定 3.1 节练习 9 的判断一个 n 个字符的串是否是回文的算法的最坏情形时间复杂度。",
        "answer": "O(n)",
        "answer_symbols": [
            "O"
        ]
    },
    "3.3 34": {
        "question": "选择排序（参见 3.1 节练习 41 前的说明）给 n 个项排序要用多少次比较？基于你的答案，试给出以选择排序中的比较次数作为度量选择排序复杂度的大 O 估计。",
        "answer": "It takes n−1 comparisons to find the least element in the list, then n−2 comparisons to find the least element among the remaining elements, and so on. Thus the total number of comparisons is (n−1) + (n−2) + ... + 2 + 1 = n(n − 1)/2, which is O(n^²).",
        "answer_symbols": [
            "−",
            "+",
            "=",
            "(",
            ")",
            "/"
        ]
    },
    "3.3 35": {
        "question": "对于在 3.1 节练习 47 前的说明中描述的二分插入排序，以所使用的比较次数和所交换的项数来度量，找出其最坏情形复杂度的大 O 估计。",
        "answer": "O(log n) comparisons; O(n^²) swaps",
        "answer_symbols": [
            "O",
            "log",
            "²"
        ]
    },
    "3.3 36": {
        "question": "证明以比较次数作为度量时采用 25 美分、10 美分、5 美分和 1 美分硬币找 n 美分零钱的贪婪算法具有 O(n) 复杂度。",
        "answer": "Each iteration (determining whether we can use a coin of a given denomination) takes a bounded amount of time, and there are at most n iterations, since each iteration decreases the number of cents remaining. Therefore, there are O(n) comparisons.",
        "answer_symbols": [
            "(",
            ")",
            "−"
        ]
    },
    "3.3 37": {
        "question": "试找出通过检查讲座的所有可能子集的方式来安排讲座的蛮力算法的复杂度。[提示：利用 n 个元素的集合有 2^n 个子集的这一事实。]",
        "answer": "O(n^² 2^ⁿ)",
        "answer_symbols": [
            "O",
            "²",
            "^"
        ]
    },
    "3.3 38": {
        "question": "找出通过在每一步加入一个和那些已安排讲座兼容的结束时间最早的讲座的方式来安排最多讲座的贪婪算法的复杂度（3.1 节算法 7）。假设讲座还没有按最早结束时间排序，并且假设排序的最坏情形时间复杂度是 O(n log n)。",
        "answer": "First, we sort the talks by earliest end time; this takes O(n log n) time if there are n talks. We initialize a variable `opentime` to be 0; it will be updated whenever we schedule another talk to be the time at which that talk ends. Next, we go through the list of talks in order, and for each talk, we see whether its start time does not precede `opentime` (we already know that its ending time exceeds `opentime`). If so, then we schedule that talk and update `opentime` to be its ending time. This all takes O(1) time per talk, so the entire process after the initial sort has time complexity O(n). Combining this with the initial sort, we get an overall time complexity of O(n log n).",
        "answer_symbols": [
            "(",
            ")",
            "−",
            "+",
            "=",
            ">",
            "<",
            "≤",
            "≥",
            "log"
        ]
    },
    "3.3 39 a)": {
        "question": "线性搜索",
        "answer": "doubles",
        "answer_symbols": []
    },
    "3.3 39 b)": {
        "question": "二分搜索",
        "answer": "increases by 1",
        "answer_symbols": []
    },
    "3.3 40 a)": {
        "question": "冒泡排序",
        "answer": "The bubble sort algorithm uses about n^²/2 comparisons for a list of length n, and (2n)^²/2 = 2n^² comparisons for a list of length 2n. Therefore, the number of comparisons goes up by a factor of 4.",
        "answer_symbols": [
            "²",
            "/",
            "=",
            "(",
            ")",
            "−",
            "+"
        ]
    },
    "3.3 40 b)": {
        "question": "插入排序",
        "answer": "The analysis is the same as for bubble sort.",
        "answer_symbols": []
    },
    "3.3 40 c)": {
        "question": "选择排序（见 3.1 节练习 41 前的导言）",
        "answer": "The analysis is the same as for bubble sort.",
        "answer_symbols": []
    },
    "3.3 40 d)": {
        "question": "二分插入排序（见 3.1 节练习 47 前的导言）",
        "answer": "The binary insertion sort algorithm uses about Cn log n comparisons for a list of length n, where C is a constant. Therefore, it uses about C · 2n log 2n = C · 2n log 2 + C · 2n log n = C · 2n + C · 2n log n comparisons for a list of length 2n. Therefore, the number of comparisons increases by about a factor of 2 (for large n, the first term is small compared to the second and can be ignored).",
        "answer_symbols": [
            "·",
            "log",
            "−",
            "+",
            "=",
            "(",
            ")"
        ]
    },
    "3.3 41": {
        "question": "参考练习 41 中计算两个上三角矩阵乘积的算法，它忽略在计算中自动等于零的乘积项。",
        "answer": "Use Algorithm 1, where A and B are now n × n upper triangular matrices, by replacing m by n in line 1, and having q iterate only from i to j, rather than from 1 to k.",
        "answer_symbols": [
            "×",
            "i",
            "k",
            "j",
            "n"
        ]
    },
    "3.3 42": {
        "question": "给出练习 41 中计算两个上三角矩阵乘积算法的伪代码描述。",
        "answer": "In an n × n upper-triangular matrix, all entries aij are zero unless i ≤ j. Therefore, we can store such matrices in about half the space that would be required to store an ordinary n × n matrix. In implementing something like Algorithm 1, then, we need only do the computations for those values of the indices that can produce nonzero entries. The following algorithm does this. We follow the usual notation: A = [aij] and B = [bij]. procedure triangular_matrix_multiplication(A, B: upper-triangular matrices) for i := 1 to n for j := i to n {since we want j ≥ i} cij := 0 for k := i to j {the only relevant part} cij := cij + aik * bkj {the upper-triangular matrix C = [cij] is the product of A and B}",
        "answer_symbols": [
            "×",
            "≤",
            "≥",
            ":",
            "[",
            "]",
            "(",
            ")",
            "+",
            "*",
            "="
        ]
    },
    "3.3 43": {
        "question": "练习 41 中计算两个 n×n 上三角矩阵乘积算法需要用到多少次元素乘法？",
        "answer": "n(n + 1)(n + 2)/6",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "×",
            "/"
        ]
    },
    "3.3 44": {
        "question": "计算乘积 ABC 的最佳次序是什么，如果 A、B 和 C 分别是 3×9、9×4 和 4×2 矩阵？",
        "answer": "We have two choices: (AB)C or A(BC). For the first choice, it takes 3 · 9 · 4 = 144 multiplications to form the 3 × 4 matrix AB, and then 3 · 4 · 2 = 24 multiplications to get the final answer, for a total of 168 multiplications. For the second choice, it takes 9 · 4 · 2 = 72 multiplications to form the 9 × 2 matrix BC, and then 3 · 9 · 2 = 54 multiplications to get the final answer, for a total of 126 multiplications. The second method uses fewer multiplications and so is the better choice.",
        "answer_symbols": [
            "·",
            "=",
            "(",
            ")",
            "+",
            "−"
        ]
    },
    "3.3 45": {
        "question": "计算乘积 ABCD 的最佳次序是什么，如果 A、B、C 和 D 分别是 30×10、10×40、40×50 和 50×30 矩阵？",
        "answer": "A((B C) D)",
        "answer_symbols": [
            "(",
            ")",
            "A",
            "B",
            "C",
            "D"
        ]
    },
    "3.3 46 a)": {
        "question": "试解释如何用蛮力算法在一个 n 个字符的串（称为文本）中寻找一个给定的 m 个字符的串（称为目标）的第一次出现，其中 m≤n。[提示：考虑寻找目标的第一个字符的一个匹配，然后检查连续字符的匹配，如果它们不是全部吻合，将开始位置向右移一个字符。]",
        "answer": "Let us call the text s1s2...sn and call the target t1t2...tm. We want to find the first occurrence of t1t2...tm in s1s2...sn, which means we want to find the smallest k ≥ 0 such that t1t2...tm = sk+1sk+2...sk+m. The brute force algorithm will try k = 0, 1, ..., n−m and for each such k check whether tj = sk+j for j = 1, 2, ..., m. If these equalities all hold, the value k+1 will be returned (that’s where the target starts); otherwise, 0 will be returned (as a code for \"not there\").",
        "answer_symbols": [
            "=",
            "≥",
            "−",
            "+",
            "..."
        ]
    },
    "3.3 46 b)": {
        "question": "用伪代码写出你的算法。",
        "answer": "The implementation is straightforward.过程 findit(s1s2... sn, t1t2... tm: 字符串)\n找到 := false\nk := 0\n当 k ≤ m - n 且未找到时\n    找到 := 真\n    对于 j := i 到 m\n        如果 tj ≠ sk+j 那么 找到 := 假\n    如果 找到 那么 返回 k + 1 {目标 t1t2... tm 在文本 s1s2... sn 中的起始位置}\n返回 0 {目标 t1t2... tm 不出现在文本 s1s2... sn 中}",
        "answer_symbols": []
    },
    "3.3 46 c)": {
        "question": "给出你所描述的蛮力算法在最坏情形时间复杂度的大 O 估计。",
        "answer": "由于嵌套循环，最坏情况下的时间复杂度将是 O(mn)。",
        "answer_symbols": []
    },
    "3 Supplementary Exercises 1 b)": {
        "question": "估计一下所用到的比较次数。",
        "answer": "2n - 1 = O(n) 比较次数",
        "answer_symbols": [
            "-",
            "=",
            "O",
            "n"
        ]
    },
    "3 Supplementary Exercises 3 a)": {
        "question": "给出一个判断一个比特串中是否含两个相邻的 0 的算法。",
        "answer": "过程 pair_zeros(b1b2...bn: 位串, n ≥ 2) x := b1 y := b2 k := 2 当 k < n 且 (x = 0 或 y = 0) k := k + 1 x := y y := bk 如果 x = 0 且 y = 0 打印 \"YES\" 否则 打印 \"NO\"",
        "answer_symbols": [
            ":=",
            "<",
            "≥",
            "且",
            "或",
            "=",
            "≠"
        ]
    },
    "3 Supplementary Exercises 3 b)": {
        "question": "这个算法会用到多少次比较？",
        "answer": "O(n)",
        "answer_symbols": [
            "O",
            "n"
        ]
    },
    "3 Supplementary Exercises 5 a)": {
        "question": "修改 3.1 节算法 1 以寻找一个 n 个元素序列中的最大元素和最小元素，采用的方法在连续检查每个元素时更新临时最大元素和临时最小元素。",
        "answer": "过程 smallest_and_largest(a1, a2, ..., an: 整数) min := a1 max := a1 对于 i := 2 到 n 如果 ai < min min := ai 如果 ai > max max := ai {min 是输入中的最小整数，max 是最大整数}",
        "answer_symbols": [
            ":=",
            "<",
            ">",
            "{",
            "}"
        ]
    },
    "3 Supplementary Exercises 6 a)": {
        "question": "用汉语详细描述一个算法的步骤，该算法在一个 n 个元素的列表中寻找最大元素和最小元素，采用的方法是检查相邻元素对并记录下临时最大和临时最小元素。如果 n 是奇数，则临时最大元素和临时最小元素的初始值都等于第一个元素；如果 n 是偶数，则通过比较两个起始元素来找到临时最大元素和临时最小元素。临时最大元素和临时最小元素通过与所检查的元素对中的最大元素和最小元素相比较而获得更新。",
        "answer": "We follow the instructions given. If n is odd, then we start the loop at i = 2, and if n is even, then we start the loop at i = 3. Within the loop, we compare the next two elements to see which is larger and which is smaller. The larger is possibly the new maximum, and the smaller is possibly the new minimum.",
        "answer_symbols": [
            "=",
            "<"
        ]
    },
    "3 Supplementary Exercises 6 b)": {
        "question": "用伪代码描述 a) 中算法。",
        "answer": "procedure clever smallest and largest(a1, a2, ..., an: integers) if n is odd then min := a1 max := a1 else if a1 < a2 then min := a1 max := a2 else min := a2 max := a1 if n is odd then i := 2 else i := 3 while i < n if ai < ai+1 then smaller := ai bigger := ai+1 else smaller := ai+1 bigger := ai if smaller < min then min := smaller if bigger > max then max := bigger i := i + 2 { min is the smallest integer among the input, and max is the largest}",
        "answer_symbols": [
            ":=",
            "<",
            ">",
            "+",
            "<=",
            ">="
        ]
    },
    "3 Supplementary Exercises 11": {
        "question": "说明剃须刀排序为列表 3，5，1，4，6，2 排序时所用的步骤。",
        "answer": "第一次遍历结束时：3, 1, 4, 5, 2, 6；第二次遍历结束时：1, 3, 2, 4, 5, 6；第三次遍历结束时：1, 2, 3, 4, 5, 6；第四次遍历没有交换，算法终止",
        "answer_symbols": [
            ":",
            ";",
            ","
        ]
    },
    "3 Supplementary Exercises 1 a)": {
        "question": "描述在一整数列表中定位最大整数的最后一次出现的算法。",
        "answer": "过程 last_max(a1, ..., an: 整数) max := a1 last := 1 i := 2 当 i ≤ n 如果 ai ≥ max max := ai last := i i := i + 1 返回 last",
        "answer_symbols": [
            ":=",
            "≤",
            "≥"
        ]
    },
    "3 Supplementary Exercises 2 a)": {
        "question": "描述在一整数列表中寻找最大整数和次大整数的算法。",
        "answer": "我们需要在遍历列表时跟踪最大和第二大的元素，并在查看列表中的元素时进行更新。过程 toptwo(a1, a2,..., an: 整数) 最大值 := a1 第二大 := -∞ 对于 i := 2 到 n 如果 ai > 第二大 那么 第二大 := ai 如果 ai > 最大值 那么 第二大 := 最大值 最大值 := ai {最大值和第二大是所需值}",
        "answer_symbols": [
            ">",
            ":="
        ]
    },
    "3 Supplementary Exercises 2 b)": {
        "question": "估计一下所用到的比较次数。",
        "answer": "循环执行 n - 1 次，每次迭代有 2 次比较。因此（忽略管理开销）总共有 2n - 2 次比较。",
        "answer_symbols": [
            "-",
            "*",
            "+",
            ">"
        ]
    },
    "3 Supplementary Exercises 4 a)": {
        "question": "假定一整数列表按从大到小的次序排列，而且整数可以重复出现。设计一个寻找整数 x 在该整数列表中的所有出现位置的算法。",
        "answer": "由于列表已排序，所有出现的位置都是连续的。因此我们算法的输出将是一对数字，first 和 last，分别给出 x 出现的第一个位置和最后一个位置。first 和 last 之间的所有数字也是 x 出现的位置。如果没有 x 的出现，我们将 first 设为 0 以表示这一事实。过程 all(x, a1, a2,..., an: 整数，其中 a1 ≥ a2 ≥ · · · ≥ an) i := 1 当 i ≤ n 且 ai < x i := i + 1 如果 i = n + 1 那么 first := 0 否则如果 ai > x 那么 first := 0 否则 first := i i := i + 1 当 i ≤ n 且 ai = x i := i + 1 last := i - 1 {参见上述变量的解释}",
        "answer_symbols": [
            "<",
            "=",
            "≥",
            "≤",
            ">",
            ":="
        ]
    },
    "3 Supplementary Exercises 4 b)": {
        "question": "估计一下所用到的比较次数。",
        "answer": "比较次数取决于数据。大致来说，在最坏情况下我们需要遍历整个列表。这需要将 x 与每个元素进行比较，总共 n 次比较（不包括管理开销）。实际情况比这更复杂，但无论如何答案是 O(n)。",
        "answer_symbols": [
            "=",
            "<",
            ">",
            "≤",
            "≥",
            "O"
        ]
    },
    "3 Supplementary Exercises 5 c)": {
        "question": "这个算法要执行多少次序列中元素的比较？（不计人那些用来判断是否到达序列结尾的比较。）",
        "answer": "2n - 2",
        "answer_symbols": [
            "-",
            "="
        ]
    },
    "3 Supplementary Exercises 6 c)": {
        "question": "这个算法要执行多少次序列中元素的比较？（不计入那些用来判断是否到达序列结尾的比较。）这与练习 5 中的比较次数相比有何区别？",
        "answer": "If n is even, then pairs of elements are compared (first with second, third with fourth, and so on), which accounts for n/2 comparisons, and there are an additional 2((n/2) − 1) = n − 2 comparisons to determine whether to update min and max. This gives a total of (3n − 4)/2 comparisons. If n is odd, then there are (n − 1)/2 pairs to compare and 2((n − 1)/2) = n − 1 comparisons for the updates, for a total of (3n − 3)/2. Note that in either case, this total is 3n/2 − 2 (see Exercise 7).",
        "answer_symbols": [
            "=",
            "/",
            "−",
            "+",
            "(",
            ")",
            "<",
            ">"
        ]
    },
    "3 Supplementary Exercises 7": {
        "question": "证明就比较次数而言在 n 个元素列表中寻找最大元素和最小元素的算法的最坏情形复杂度至少是 3n/2 - 2。",
        "answer": "在进行任何比较之前，每个元素都有可能是最大值和最小值。这意味着有 2n 种不同的可能性，需要通过元素的比较消除 2n - 2 种可能性，因为我们需要找到唯一最大值和唯一最小值。我们将两个元素的比较分类为“初始”或“非初始”，具体取决于这两个被比较的元素是否参与过任何之前的比较。一个初始比较消除了较大者是最小值和较小者是最大值的可能性；因此每次初始比较可以消除两种可能性，但显然不能更多。一个非初始比较必须是在仍有可能成为最大值的两个元素之间或仍有可能成为最小值的两个元素之间进行，并且至少有一个元素不可能成为另一类的最大值或最小值。例如，我们可能在比较 x 和 y，已知 x 已经被排除作为最小值。如果在这种情况下发现 x > y，那么只有一种可能性被排除——我们现在知道 y 不是最大值。因此，在最坏的情况下，一次非初始比较只能排除一种可能性。（其他非初始比较的情况类似。）现在最多有 n/2 次从未比较过的元素之间的比较，每次排除两种可能性；它们总共排除了 2n/2 种可能性。因此，为了在最坏情况下找到答案，我们还需要 2n - 2 - 2n/2 次比较，这些比较每次只能排除一种可能性，因为需要排除 2n - 2 种可能性。这使我们总共需要 2n - 2 - 2n/2 + n/2 次比较。但是 2n - 2 - 2n/2 + n/2 = 2n - 2 - n/2 = 2n - 2 + -n/2 = 2n - n/2 - 2 = 3n/2 - 2，如预期。",
        "answer_symbols": [
            "-",
            "+",
            "/",
            "=",
            ">",
            "<",
            "且",
            "或",
            "≠"
        ]
    },
    "3 Supplementary Exercises 8": {
        "question": "设计一个有效算法在一个 n 个元素列表中寻找第二大元素并确定算法的最坏情形复杂度。",
        "answer": "The naive approach would be to keep track of the largest element found so far and the second largest element found so far. Each new element is compared against the largest, and if it is smaller, also compared against the second largest, and the 'best-so-far' values are updated if necessary. This would require about 2n comparisons in all. We can do it more efficiently by taking Exercise 6 as a hint. If n is odd, set l to be the first element in the list, and set s to be −∞. If n is even, set l to be the larger of the first two elements and s to be the smaller. At each stage, l will be the largest element seen so far, and s the second largest. Now consider the remaining elements two by two. Compare them and set a to be the larger and b the smaller. Compare a with l. If a > l, then a will be the new largest element seen so far, and the second largest element will be either l or b; compare them to find out which. If a < l, then l is still the largest element, and we can compare a and s to determine the second largest. Thus it takes only three comparisons for every pair of elements, rather than the four needed with the naive approach. The counting of comparisons is exactly the same as in Exercise 6: 3n/2 − 2.",
        "answer_symbols": [
            "<",
            ">",
            "=",
            "−",
            "+",
            "/"
        ]
    },
    "3 Supplementary Exercises 9": {
        "question": "设计一个算法在 n 个数的序列中寻找所有两项之和相等的对子，并确定算法的最坏情形复杂度。",
        "answer": "以下算法的最坏情况复杂度为 O(n^4)。 过程 equal_sums(a1, a2, ..., an) 对于 i := 1 到 n 对于 j := i + 1 到 n {因为我们要 i < j} 对于 k := 1 到 n 对于 l := k + 1 到 n {因为我们要 k < l} 如果 ai + aj = ak + al 且 (i, j) ≠ (k, l) 输出这些对",
        "answer_symbols": [
            "O",
            "n",
            ":",
            "=",
            "+",
            "<",
            "≠",
            "{",
            "}"
        ]
    },
    "3 Supplementary Exercises 10": {
        "question": "设计一个算法在一个 n 个整数的序列中寻找最近的整数对，并确定算法的最坏情形复杂度。[提示：将序列排序。利用排序能在最坏情形时间复杂度 O(n log n) 内完成的事实。]",
        "answer": "Following the hint, we first sort the list and call the resulting sorted list a1, a2, ..., an. To find the last occurrence of a closest pair, we initialize diff to ∞ and then for i from 1 to n − 1 compute ai+1 − ai. If this value is less than diff, then we reset diff to be this value and set k to equal i. Upon completion of this loop, ak and ak+1 are a closest pair of integers in the list. Clearly the time complexity is O(n log n), the time needed for the sorting, because the rest of the procedure takes time O(n).",
        "answer_symbols": [
            "−",
            "<",
            "=",
            "∞",
            "log"
        ]
    },
    "3 Supplementary Exercises 12": {
        "question": "用伪代码描述剃须刀排序。",
        "answer": "We start with the solution to Exercise 37 in Section 3.1 and modify it to alternately examine the list from the procedure shakersort(a1, ..., an) front := 1 back := n still_interchanging := true while front < back and still_interchanging if n + back + front is odd then {process from front to back} still_interchanging := false for j := front to back − 1 if aj > aj+1 then still_interchanging := true interchange aj and aj+1 back := back − 1 else {process from back to front} still_interchanging := false for j := back down to front + 1 if aj−1 > aj then still_interchanging := true interchange aj−1 and aj front := front + 1 {a1, ..., an is in nondecreasing order}",
        "answer_symbols": [
            ":=",
            "<",
            ">",
            "+",
            "-",
            "−",
            "="
        ]
    },
    "3 Supplementary Exercises 13": {
        "question": "证明以比较次数来度量时剃须刀排序具有 O(n^2) 复杂度。",
        "answer": "可能有多达 n 次遍历列表，每次遍历使用 O(n) 次比较。因此总共使用 O(n^2) 次比较。",
        "answer_symbols": [
            "O",
            "n",
            "^",
            "×"
        ]
    },
    "3 Supplementary Exercises 15": {
        "question": "证明 (n log n + n^2)^3 是 O(n^4)。",
        "answer": "因为 log n < n，我们有 (n log n + n^2)^3 ≤ (n^2 + n^2)^3 ≤ (2n^2)^3 = 8n^6 对所有 n > 0。这证明了 (n log n + n^2)^3 是 O(n^6)，证人 C = 8 和 k = 0。",
        "answer_symbols": [
            "<",
            ">",
            "log",
            "n",
            "(",
            ")",
            "+",
            "^",
            "≤",
            "=",
            "O"
        ]
    },
    "3 Supplementary Exercises 17": {
        "question": "给出 (x^2 + x log x)^3 * (2^x + x^2) 的大 O 估计。",
        "answer": "O(x^2 2^x)",
        "answer_symbols": [
            "O",
            "x",
            "^",
            "2"
        ]
    },
    "3 Supplementary Exercises 19": {
        "question": "证明 n! 不是 O(2^n) 的。",
        "answer": "注意到 2^n / n! = n^2 * (n - 1) / 2 * ... * 2 / 3 * 2 / 2 * 2 / 1 > n^2 * 1 * 1 * ... * 1 * 2 / 1 = n^4。",
        "answer_symbols": [
            "!",
            "n",
            "*",
            "/",
            ">",
            "="
        ]
    },
    "3 Supplementary Exercises 21": {
        "question": "在这个函数列表中找出所有同阶的函数对：n^2 + (log n)^2，n^2 + n，n^2 + log 2^n + 1，(n + 1)^3 - (n - 1)^3 和 (n + log n)^2。",
        "answer": "所有这些函数都是同一阶的。",
        "answer_symbols": []
    },
    "3 Supplementary Exercises 23": {
        "question": "找出整数 n(n > 2) 使得 n^100 < 2^n。",
        "answer": "2^1072",
        "answer_symbols": [
            "^"
        ]
    },
    "3 Supplementary Exercises 25": {
        "question": "将函数 n^2，(log n)^2，n^1.0001，(1.0001)^n，2√n 和 n(log log n) 排成列表使得每个函数是大 O 后面的函数。[提示：可以用算法来判断其中某些函数的相对大小。]",
        "answer": "(log n)^2, 2 √(log^2 n), n (log n)^1001, n^1.0001, 1.0001^n, n^n",
        "answer_symbols": [
            "log",
            "n",
            "(",
            ")",
            "^",
            "√",
            ",",
            "×"
        ]
    },
    "3 Supplementary Exercises 27": {
        "question": "试给出一个例子，两个从正整数集合到正整数集合的递增函数 f(n) 和 g(n) 使得 f(n) 不是 O(g(n)) 的，同时 g(n) 也不是 O(f(n)) 的。",
        "answer": "例如，f(n) = n^2 n^(n/2 + 1) 和 g(n) = n^2 n^(n/2)",
        "answer_symbols": [
            "=",
            "n",
            "^",
            "+",
            "×"
        ]
    },
    "3 Supplementary Exercises 29 a)": {
        "question": "用伪代码描述一个蛮力算法，当给定 n 个正整数的序列作为输入时，该算法判定序列中是否存在两个不同的项和是第三项。算法应该对序列项的所有三元组作循环，检查前两项之和是否等于第三项。",
        "answer": "过程 brute(a1, a2, ..., an: 整数) 对于 i := 1 到 n - 1 对于 j := i + 1 到 n 对于 k := 1 到 n 如果 ai + aj = ak 返回 true 否则 返回 false",
        "answer_symbols": [
            ":=",
            "<",
            "=",
            "+",
            "true",
            "false"
        ]
    },
    "3 Supplementary Exercises 29 b)": {
        "question": "试给出 a) 中蛮力算法复杂度的大 O 估计。",
        "answer": "O(n^3)",
        "answer_symbols": [
            "O",
            "n",
            "^"
        ]
    },
    "3 Supplementary Exercises 31": {
        "question": "试找出每位男士和每位女士的所有合法伴侣，假设有三位男士 m1、m2 和 m3，以及三位女士 w1、w2 和 w3，男士对女士的喜好列表从高到低为：m1、w3、w1、w2；m2、w3、w2、w1；m3、w2、w1、w3；女士对男士的喜好列表从高到低为：w1、m3、m2、m1；w2、m1、m3、m2；w3、m1、m2、m1。",
        "answer": "对于 m1: w1 和 w2；对于 m2: w1 和 w3；对于 m3: w2 和 w3；对于 w1: m1 和 m2；对于 w2: m1 和 m3；对于 w3: m2 和 m3",
        "answer_symbols": [
            ":",
            ";",
            "和"
        ]
    },
    "3 Supplementary Exercises 33": {
        "question": "试定义一个女性最优的匹配和一个男性最差的匹配的含义。",
        "answer": "将每位女性分配给她偏好列表中排名最高的有效伴侣的匹配是女性最优的；将每位男性分配给他偏好列表中排名最低的有效伴侣的匹配是男性最差的。",
        "answer_symbols": [
            ":",
            ";",
            "最优",
            "最差"
        ]
    },
    "3 Supplementary Exercises 35 a)": {
        "question": "在这个练习中我们考虑匹配问题，其中男士和女士数量可以不一样，因此不可能为每个人匹配一位异性。a) 扩展 3.1 节练习 60 前导言中给出的稳定匹配的定义，使其涵盖男士和女士数量不等的情形。要避免所有这样的情况其中一位男士和一位女士更喜欢对方而不是当前匹配中的伴侣，包括那些未被匹配的人。（假设一位未匹配的人更喜欢和一位异性成员匹配，而不是剩余未匹配的人。）",
        "answer": "修改第 3.1 节练习 60 的前言，使得有 s 个男人 m1, m2, ..., ms 和 t 个女人 w1, w2, ..., wt。一个匹配将包含 min(s, t) 个婚姻。稳定婚姻的定义相同，理解为每个人更喜欢任何伴侣而不是单身。",
        "answer_symbols": [
            "min",
            "s",
            "t",
            "个",
            "婚姻",
            "稳定婚姻"
        ]
    },
    "4.1 1 a)": {
        "question": "17 能整除 68 吗？",
        "answer": "是",
        "answer_symbols": []
    },
    "4.1 1 b)": {
        "question": "17 能整除 84 吗？",
        "answer": "否",
        "answer_symbols": []
    },
    "4.1 1 c)": {
        "question": "17 能整除 357 吗？",
        "answer": "是",
        "answer_symbols": []
    },
    "4.1 1 d)": {
        "question": "17 能整除 1001 吗？",
        "answer": "否",
        "answer_symbols": []
    },
    "4.1 2 a)": {
        "question": "如果 a 是不为 0 的整数，则 1 整除 a。",
        "answer": "1 divides a since a = 1 · a.",
        "answer_symbols": [
            "·",
            "÷"
        ]
    },
    "4.1 2 b)": {
        "question": "如果 a 是不为 0 的整数，则 a 整除 0。",
        "answer": "a divides 0 since 0 = a · 0.",
        "answer_symbols": [
            "·",
            "÷"
        ]
    },
    "4.1 3": {
        "question": "证明定理 1 的第 (ii) 部分成立.",
        "answer": "假设 a 不整除 b。那么存在一个整数 k 使得 ka= b。因为 a(ck)= bc，所以 a 整除 bc。",
        "answer_symbols": [
            "≠",
            "="
        ]
    },
    "4.1 4": {
        "question": "证明定理 1 的第 (iii) 部分成立.",
        "answer": "Suppose a divides b, so that b = a · t for some t, and b divides c, so that c = b · s for some s. Then substituting the first equation into the second, we obtain c = (a · t) · s = a · (t · s). This means that a divides c, as desired.",
        "answer_symbols": [
            "·",
            "÷",
            "="
        ]
    },
    "4.1 5": {
        "question": "如果 a | b 且 b | a，其中 a 和 b 为整数，则 a = b 或 a = -b。",
        "answer": "如果 a 整除 b 且 b 整除 a，则存在整数 c 和 d 使得 b= ac 和 a= bd。因此 a= acd。因为 a ≠ 0，所以 cd= 1。因此 c= d= 1 或 c= d= -1。因此 a= b 或 a= -b。",
        "answer_symbols": [
            "≠",
            "=",
            "≥",
            "≤"
        ]
    },
    "4.1 6": {
        "question": "如果 a、b、c 和 d 为整数且 a ≠ 0 使得 a | c 及 b | d，则 ab | cd。",
        "answer": "Under the hypotheses, we have c = a · s and d = b · t for some s and t. Multiplying we obtain c · d = a · b · (s · t), which means that a · b divides c · d, as desired.",
        "answer_symbols": [
            "·",
            "÷",
            "="
        ]
    },
    "4.1 7": {
        "question": "如果 a、b、c 为整数，其中 a ≠ 0 且 c ≠ 0，使得 ac | bc，则 a | b。",
        "answer": "因为 ac 整除 bc，存在一个整数 k 使得 ack= bc。因此 ak= b，所以 a 整除 b。",
        "answer_symbols": [
            "≠",
            "=",
            "≥",
            "≤"
        ]
    },
    "4.1 8": {
        "question": "如果 a ∣ bc，这里 a, b, c 均为正整数且 a ≠ 0，则 a ∣ b 或者 a ∣ c。",
        "answer": "The simplest counterexample is provided by a = 4 and b = c = 2.",
        "answer_symbols": [
            "="
        ]
    },
    "4.1 9 a)": {
        "question": "19 除以 7 的商和余数是多少？",
        "answer": "2, 5",
        "answer_symbols": []
    },
    "4.1 9 b)": {
        "question": "-111 除以 11 的商和余数是多少？",
        "answer": "-11, 10",
        "answer_symbols": []
    },
    "4.1 9 c)": {
        "question": "789 除以 23 的商和余数是多少？",
        "answer": "34, 7",
        "answer_symbols": []
    },
    "4.1 9 d)": {
        "question": "1001 除以 13 的商和余数是多少？",
        "answer": "77, 0",
        "answer_symbols": []
    },
    "4.1 9 e)": {
        "question": "0 除以 19 的商和余数是多少？",
        "answer": "0, 0",
        "answer_symbols": []
    },
    "4.1 9 f)": {
        "question": "3 除以 5 的商和余数是多少？",
        "answer": "0, 3",
        "answer_symbols": []
    },
    "4.1 9 g)": {
        "question": "-1 除以 3 的商和余数是多少？",
        "answer": "-1, 2",
        "answer_symbols": []
    },
    "4.1 9 h)": {
        "question": "4 除以 11 的商和余数是多少？",
        "answer": "4, 0",
        "answer_symbols": []
    },
    "4.1 10 a)": {
        "question": "44 除以 8 的商和余数是多少？",
        "answer": "Since 8 · 5 = 40 and 44 - 40 = 4, we have quotient 44 div 8 = 5 and remainder 44 mod 8 = 4.",
        "answer_symbols": [
            "·",
            "-",
            "=",
            "÷",
            "mod"
        ]
    },
    "4.1 10 b)": {
        "question": "777 除以 21 的商和余数是多少？",
        "answer": "Since 21 · 37 = 777, we have quotient 777 div 21 = 37 and remainder 777 mod 21 = 0.",
        "answer_symbols": [
            "·",
            "=",
            "÷",
            "mod"
        ]
    },
    "4.1 10 c)": {
        "question": "-123 除以 19 的商和余数是多少？",
        "answer": "As above, we can compute 123 div 19 = 6 and 123 mod 19 = 9. However, since the dividend is negative and the remainder is nonzero, the quotient is -(6 + 1) = -7 and the remainder is 19 - 9 = 10. To check that -123 div 19 = -7 and -123 mod 19 = 10, we note that -123 = (-7)(19) + 10.",
        "answer_symbols": [
            "·",
            "+",
            "-",
            "=",
            "÷",
            "mod"
        ]
    },
    "4.1 10 d)": {
        "question": "-1 除以 23 的商和余数是多少？",
        "answer": "Since 1 div 23 = 0 and 1 mod 23 = 1, we have -1 div 23 = -1 and -1 mod 23 = 22.",
        "answer_symbols": [
            "÷",
            "mod"
        ]
    },
    "4.1 10 e)": {
        "question": "-2002 除以 87 的商和余数是多少？",
        "answer": "Since 2002 div 87 = 23 and 2002 mod 87 = 1, we have -2002 div 87 = -24 and 2002 mod 87 = 86.",
        "answer_symbols": [
            "÷",
            "mod"
        ]
    },
    "4.1 10 f)": {
        "question": "0 除以 17 的商和余数是多少？",
        "answer": "Clearly 0 div 17 = 0 and 0 mod 17 = 0.",
        "answer_symbols": [
            "÷",
            "mod"
        ]
    },
    "4.1 10 g)": {
        "question": "1234567 除以 1001 的商和余数是多少？",
        "answer": "We have 1234567 div 1001 = 1233 and 1234567 mod 1001 = 334.",
        "answer_symbols": [
            "÷",
            "mod"
        ]
    },
    "4.1 10 h)": {
        "question": "-100 除以 101 的商和余数是多少？",
        "answer": "Since 100 div 101 = 0 and 100 mod 101 = 100, we have -100 div 101 = -1 and -100 mod 101 = 1.",
        "answer_symbols": [
            "÷",
            "mod"
        ]
    },
    "4.1 11 a)": {
        "question": "12 小时制的钟表上显示的时间是 11 点之后的 80 小时几点？",
        "answer": "7:00",
        "answer_symbols": []
    },
    "4.1 11 b)": {
        "question": "12 小时制的钟表上显示的时间是 12 点之前的 40 小时几点？",
        "answer": "8:00",
        "answer_symbols": []
    },
    "4.1 11 c)": {
        "question": "12 小时制的钟表上显示的时间是 6 点之后的 100 小时几点？",
        "answer": "10:00",
        "answer_symbols": []
    },
    "4.1 12 a)": {
        "question": "24 小时制的钟表上显示的时间是 2 点之后的 100 小时几点？",
        "answer": "Because 100 mod 24 = 4, the clock reads the same as 4 hours after 2:00, namely 6:00.",
        "answer_symbols": [
            "mod"
        ]
    },
    "4.1 12 b)": {
        "question": "24 小时制的钟表上显示的时间是 12 点之前的 45 小时几点？",
        "answer": "Essentially we are asked to compute 12 - 45 mod 24 = -33 mod 24 = -33 + 48 mod 24 = 15. The clock reads 15:00.",
        "answer_symbols": [
            "-",
            "mod",
            "+"
        ]
    },
    "4.1 12 c)": {
        "question": "24 小时制的钟表上显示的时间是 19 点之后的 168 小时几点？",
        "answer": "Because 168 ≡ 0 (mod 24), the clock read 19:00.",
        "answer_symbols": [
            "≡",
            "mod"
        ]
    },
    "4.1 13 a)": {
        "question": "假设 a 和 b 是整数，a ≡ 4 (mod 13) 且 b ≡ 9 (mod 13)。试找出满足 0 ≤ c ≤ 12 的整数 c 使得 c ≡ 9a (mod 13)",
        "answer": "10",
        "answer_symbols": []
    },
    "4.1 13 b)": {
        "question": "假设 a 和 b 是整数，a ≡ 4 (mod 13) 且 b ≡ 9 (mod 13)。试找出满足 0 ≤ c ≤ 12 的整数 c 使得 c ≡ 11b (mod 13)",
        "answer": "8",
        "answer_symbols": []
    },
    "4.1 13 c)": {
        "question": "假设 a 和 b 是整数，a ≡ 4 (mod 13) 且 b ≡ 9 (mod 13)。试找出满足 0 ≤ c ≤ 12 的整数 c 使得 c ≡ a + b (mod 13)",
        "answer": "0",
        "answer_symbols": []
    },
    "4.1 13 d)": {
        "question": "假设 a 和 b 是整数，a ≡ 4 (mod 13) 且 b ≡ 9 (mod 13)。试找出满足 0 ≤ c ≤ 12 的整数 c 使得 c ≡ 2a + 3b (mod 13)",
        "answer": "9",
        "answer_symbols": []
    },
    "4.1 13 e)": {
        "question": "假设 a 和 b 是整数，a ≡ 4 (mod 13) 且 b ≡ 9 (mod 13)。试找出满足 0 ≤ c ≤ 12 的整数 c 使得 c ≡ a^² + b^² (mod 13)",
        "answer": "6",
        "answer_symbols": []
    },
    "4.1 13 f)": {
        "question": "假设 a 和 b 是整数，a ≡ 4 (mod 13) 且 b ≡ 9 (mod 13)。试找出满足 0 ≤ c ≤ 12 的整数 c 使得 c ≡ a^³ - b^³ (mod 13)",
        "answer": "11",
        "answer_symbols": []
    },
    "4.1 14 a)": {
        "question": "假设 a 和 b 是整数，a ≡ 11 (mod 19) 且 b ≡ 3 (mod 19)。试找出满足 0 ≤ c ≤ 18 的整数 c 使得 c ≡ 13a (mod 19)",
        "answer": "13 · 11 = 143 ≡ 10 (mod 19)",
        "answer_symbols": [
            "·",
            "≡",
            "mod"
        ]
    },
    "4.1 14 b)": {
        "question": "假设 a 和 b 是整数，a ≡ 11 (mod 19) 且 b ≡ 3 (mod 19)。试找出满足 0 ≤ c ≤ 18 的整数 c 使得 c ≡ 8b (mod 19)",
        "answer": "8 · 3 = 24 ≡ 5 (mod 19)",
        "answer_symbols": [
            "·",
            "≡",
            "mod"
        ]
    },
    "4.1 14 c)": {
        "question": "假设 a 和 b 是整数，a ≡ 11 (mod 19) 且 b ≡ 3 (mod 19)。试找出满足 0 ≤ c ≤ 18 的整数 c 使得 c ≡ a - b (mod 19)",
        "answer": "11 - 3 = 8 (mod 19)",
        "answer_symbols": [
            "-",
            "mod"
        ]
    },
    "4.1 14 d)": {
        "question": "假设 a 和 b 是整数，a ≡ 11 (mod 19) 且 b ≡ 3 (mod 19)。试找出满足 0 ≤ c ≤ 18 的整数 c 使得 c ≡ 7a + 3b (mod 19)",
        "answer": "7 · 11 + 3 · 3 = 86 ≡ 10 (mod 19)",
        "answer_symbols": [
            "·",
            "+",
            "≡",
            "mod"
        ]
    },
    "4.1 14 e)": {
        "question": "假设 a 和 b 是整数，a ≡ 11 (mod 19) 且 b ≡ 3 (mod 19)。试找出满足 0 ≤ c ≤ 18 的整数 c 使得 c ≡ 2a^² + 3b^² (mod 19)",
        "answer": "2 · 11^² + 3 · 3^² = 269 ≡ 3 (mod 19)",
        "answer_symbols": [
            "·",
            "²",
            "+",
            "≡",
            "mod"
        ]
    },
    "4.1 14 f)": {
        "question": "假设 a 和 b 是整数，a ≡ 11 (mod 19) 且 b ≡ 3 (mod 19)。试找出满足 0 ≤ c ≤ 18 的整数 c 使得 c ≡ a^³ + 4b^³ (mod 19)",
        "answer": "11^³ + 4 · 3^³ = 1439 ≡ 14 (mod 19)",
        "answer_symbols": [
            "³",
            "·",
            "+",
            "≡",
            "mod"
        ]
    },
    "4.1 15": {
        "question": "令 m 为正整数。证明如果 a mod m = b mod m，则 a ≡ b (mod m)。",
        "answer": "如果 a mod m= b mod m，则 a 和 b 在被 m 除时有相同的余数。因此 a= q1m+ r 和 b= q2m+ r，其中 0 ≤ r < m。因此 a−b= (q1−q2)m，所以 m 整除 (a−b)。因此 a ≡ b (mod m)。",
        "answer_symbols": [
            "≠",
            "=",
            "≥",
            "≤",
            "+",
            "-",
            "≡"
        ]
    },
    "4.1 16": {
        "question": "令 m 为正整数。证明如果 a ≡ b (mod m)，则 a mod m = b mod m。",
        "answer": "Assume that a ≡ b (mod m). This means that m divides a - b, say a - b = m · c, so that a = b + m · c. Now let us compute a mod m. We know that b = q · m + r for some nonnegative r less than m (namely, r = b mod m). Therefore we can write a = q · m + r + m · c = (q + c) · m + r. By definition this means that r must also equal a mod m. That is what we wanted to prove.",
        "answer_symbols": [
            "≡",
            "mod",
            "·",
            "-",
            "=",
            "+"
        ]
    },
    "4.1 17": {
        "question": "证明如果 n 和 k 均为正整数，则有 ⌊n/k⌋ = ⌊(n-1)/k⌋ + 1。",
        "answer": "存在某个 b 使得 (b − 1)k< n ≤ bk。因此 (b − 1)k ≤ n − 1 < bk。除以 k 得到 b − 1 < n/ k ≤ b 和 b − 1 ≤ (n− 1)/ k < b。因此 n/ k= b 和 (n−1)/ k= b−1。",
        "answer_symbols": [
            "≠",
            "=",
            "≥",
            "≤",
            "+",
            "-",
            "<",
            ">"
        ]
    },
    "4.1 19": {
        "question": "试找出与整数 a 模 m 同余的绝对值最小的整数的计算公式，这里 m 为一正整数。",
        "answer": "如果 x mod m ≤ m/2 则 x mod m；如果 x mod m > m/2 则 (x mod m) − m",
        "answer_symbols": [
            "≠",
            "=",
            "≥",
            "≤",
            "+",
            "-",
            "<",
            ">"
        ]
    },
    "4.1 21 a)": {
        "question": "计算 13 mod 3。",
        "answer": "1",
        "answer_symbols": []
    },
    "4.1 21 b)": {
        "question": "计算 -97 mod 11。",
        "answer": "2",
        "answer_symbols": []
    },
    "4.1 21 c)": {
        "question": "计算 155 mod 19。",
        "answer": "3",
        "answer_symbols": []
    },
    "4.1 21 d)": {
        "question": "计算 -221 mod 23。",
        "answer": "9",
        "answer_symbols": []
    },
    "4.1 23 a)": {
        "question": "找出 a ÷ m 和 a mod m，a = 228, m = 119。",
        "answer": "1, 109",
        "answer_symbols": []
    },
    "4.1 23 b)": {
        "question": "找出 a ÷ m 和 a mod m，a = 9009, m = 223。",
        "answer": "40, 89",
        "answer_symbols": []
    },
    "4.1 23 c)": {
        "question": "找出 a ÷ m 和 a mod m，a = -10101, m = 333。",
        "answer": "-31, 222",
        "answer_symbols": []
    },
    "4.1 25 a)": {
        "question": "找出整数 a 使得 a ≡ -15 (mod 27) 且 -26 ≤ a ≤ 0。",
        "answer": "-15",
        "answer_symbols": []
    },
    "4.1 25 b)": {
        "question": "找出整数 a 使得 a ≡ 24 (mod 31) 且 -15 ≤ a ≤ 15。",
        "answer": "-7",
        "answer_symbols": []
    },
    "4.1 25 c)": {
        "question": "找出整数 a 使得 a ≡ 99 (mod 41) 且 100 ≤ a ≤ 140。",
        "answer": "140",
        "answer_symbols": []
    },
    "4.1 27": {
        "question": "列出在 -100 到 100 之间所有模 25 同余 -1 的整数。",
        "answer": "-1, -26, -51, -76, 24, 49, 74, 99",
        "answer_symbols": []
    },
    "4.1 29 a)": {
        "question": "判断 80 是否模 17 同余 5。",
        "answer": "否",
        "answer_symbols": []
    },
    "4.1 29 b)": {
        "question": "判断 103 是否模 17 同余 5。",
        "answer": "否",
        "answer_symbols": []
    },
    "4.1 29 c)": {
        "question": "判断 -29 是否模 17 同余 5。",
        "answer": "是",
        "answer_symbols": []
    },
    "4.1 29 d)": {
        "question": "判断 -122 是否模 17 同余 5。",
        "answer": "否",
        "answer_symbols": []
    },
    "4.2 1 a)": {
        "question": "把下列整数从十进制表示转换为二进制表示。（a）231",
        "answer": "1110 0111",
        "answer_symbols": []
    },
    "4.2 1 b)": {
        "question": "把下列整数从十进制表示转换为二进制表示。（b）4532",
        "answer": "1 0001 1011 0100",
        "answer_symbols": []
    },
    "4.2 1 c)": {
        "question": "把下列整数从十进制表示转换为二进制表示。（c）97 644",
        "answer": "1 0111 1101 0110 1100",
        "answer_symbols": []
    },
    "4.2 2 a)": {
        "question": "把下列整数从十进制表示转换为二进制表示。（a）321",
        "answer": "因为 321/2 是 160 余 1，最右边的数字是 1。然后因为 160/2 是 80 余 0，从右数第二位数字是 0。我们继续这个过程，得到连续的商 40、20、10、5、2、1 和 0，以及余数 0、0、0、0、1、0 和 1。将所有这些余数从右到左排列，我们得到 (1 0100 0001)2 作为二进制表示。我们可以进行检查，展开这个二进制数：2^0 + 2^6 + 2^8 = 1 + 64 + 256 = 321。",
        "answer_symbols": [
            "/",
            "(",
            ")",
            "+",
            "^"
        ]
    },
    "4.2 2 b)": {
        "question": "把下列整数从十进制表示转换为二进制表示。（b）1023",
        "answer": "我们可以执行与 (a) 部分相同的过程。或者，我们可能会注意到 1023 = 1024 - 1 = 2^10 - 1。因此，二进制表示比 (100 0000 0000)2 小 1，显然是 (11 1111 1111)2。",
        "answer_symbols": [
            "-",
            "=",
            "^",
            "(",
            ")"
        ]
    },
    "4.2 2 c)": {
        "question": "把下列整数从十进制表示转换为二进制表示。（c）100 632",
        "answer": "如果我们执行除以 2 的操作，商分别为 50316、25158、12579、6289、3144、1572、786、393、196、98、49、24、12、6、3、1 和 0，余数分别为 0、0、0、1、1、0、0、0、1、0、0、1、0、0、0、1 和 1。将余数从右到左排列，我们有 (1 1000 1001 0001 1000)2。",
        "answer_symbols": [
            "/",
            "(",
            ")"
        ]
    },
    "4.2 3 a)": {
        "question": "把下列整数从二进制表示转换为十进制表示。（a）(1 1111)₂",
        "answer": "31",
        "answer_symbols": []
    },
    "4.2 3 b)": {
        "question": "把下列整数从二进制表示转换为十进制表示。（b）(10 0000 0001)₂",
        "answer": "513",
        "answer_symbols": []
    },
    "4.2 3 c)": {
        "question": "把下列整数从二进制表示转换为十进制表示。（c）(1 1010 0101)₂",
        "answer": "341",
        "answer_symbols": []
    },
    "4.2 3 d)": {
        "question": "把下列整数从二进制表示转换为十进制表示。（d）(110 1001 0001 0000)₂",
        "answer": "26,896",
        "answer_symbols": []
    },
    "4.2 4 a)": {
        "question": "把下列整数从二进制表示转换为十进制表示。（a）(1 1011)₂",
        "answer": "1 + 2 + 8 + 16 = 27",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "4.2 4 b)": {
        "question": "把下列整数从二进制表示转换为十进制表示。（b）(10 1011 0101)₂",
        "answer": "1 + 4 + 16 + 32 + 128 + 512 = 693",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "4.2 4 c)": {
        "question": "把下列整数从二进制表示转换为十进制表示。（c）(11 1011 1110)₂",
        "answer": "2 + 4 + 8 + 16 + 32 + 128 + 256 + 512 = 958",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "4.2 4 d)": {
        "question": "把下列整数从二进制表示转换为十进制表示。（d）(111 1100 0001 1111)₂",
        "answer": "1 + 2 + 4 + 8 + 16 + 1024 + 2048 + 4096 + 8192 + 16384 = 31775",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "4.2 5 a)": {
        "question": "把下列整数从八进制表示转换为二进制表示。（a）(572)₈",
        "answer": "1 0111 1010",
        "answer_symbols": []
    },
    "4.2 5 b)": {
        "question": "把下列整数从八进制表示转换为二进制表示。（b）(1604)₈",
        "answer": "11 1000 0100",
        "answer_symbols": []
    },
    "4.2 5 c)": {
        "question": "把下列整数从八进制表示转换为二进制表示。（c）(423)₈",
        "answer": "1 0001 0011",
        "answer_symbols": []
    },
    "4.2 5 d)": {
        "question": "把下列整数从八进制表示转换为二进制表示。（d）(2417)₈",
        "answer": "101 0000 1111",
        "answer_symbols": []
    },
    "4.2 6 a)": {
        "question": "把下列整数从二进制表示转换为八进制表示。（a）(1111 0111)₂",
        "answer": "(1111 0111)2 = (011 110 111)2 = (367)8",
        "answer_symbols": [
            "=",
            "(",
            ")"
        ]
    },
    "4.2 6 b)": {
        "question": "把下列整数从二进制表示转换为八进制表示。（b）(1010 1010 1010)₂",
        "answer": "(1010 1010 1010)2 = (101 010 101 010)2 = (5252)8",
        "answer_symbols": [
            "=",
            "(",
            ")"
        ]
    },
    "4.2 6 c)": {
        "question": "把下列整数从二进制表示转换为八进制表示。（c）(111 0111 0111 0111)₂",
        "answer": "(111 0111 0111 0111)2 = (111 011 101 110 111)2 = (73567)8",
        "answer_symbols": [
            "=",
            "(",
            ")"
        ]
    },
    "4.2 6 d)": {
        "question": "把下列整数从二进制表示转换为八进制表示。（d）(101 1010 1010 1010)₂",
        "answer": "(101 0101 0101 0101)2 = (101 010 101 010 101)2 = (52525)8",
        "answer_symbols": [
            "=",
            "(",
            ")"
        ]
    },
    "4.2 7 a)": {
        "question": "把下列整数从十六进制表示转换为二进制表示。（a）(80E)₁₆",
        "answer": "1000 0000 1110",
        "answer_symbols": []
    },
    "4.2 7 b)": {
        "question": "把下列整数从十六进制表示转换为二进制表示。（b）(135AB)₁₆",
        "answer": "1 0011 0101 1010 1011",
        "answer_symbols": []
    },
    "4.2 7 c)": {
        "question": "把下列整数从十六进制表示转换为二进制表示。（c）(ABBA)₁₆",
        "answer": "10101011 1011 1010",
        "answer_symbols": []
    },
    "4.2 7 d)": {
        "question": "把下列整数从十六进制表示转换为二进制表示。（d）(DEFACED)₁₆",
        "answer": "1101 1110 1111 1010 1100 1110 1101",
        "answer_symbols": []
    },
    "4.2 8": {
        "question": "把 (BADFACED)₁₆ 从十六进制表示转换为二进制表示。",
        "answer": "按照示例 7，我们只需写出每个数字的二进制等价形式。因为 (A)16 = (1010)2, (B)16 = (1011)2, (C)16 = (1100)2, (D)16 = (1101)2, (E)16 = (1110)2, (F)16 = (1111)2，所以我们有 (BADFACED)16 = (10111010110111111010110011101101)2。按照练习 3 中所示的惯例，将二进制数字按四位分组，我们可以将其写成更易读的形式 1011 1010 1101 1111 1010 1100 1110 1101。",
        "answer_symbols": [
            "=",
            "(",
            ")",
            ","
        ]
    },
    "4.2 9": {
        "question": "把 (ABCDEF)₁₆ 从十六进制表示转换为二进制表示。",
        "answer": "1010 1011 1100 1101 1110 1111",
        "answer_symbols": []
    },
    "4.2 10 a)": {
        "question": "把练习 6 中的整数从二进制表示转换为十六进制表示。（a）(1111 0111)₂",
        "answer": "(1111 0111)2 = (F7)16",
        "answer_symbols": [
            "=",
            "(",
            ")"
        ]
    },
    "4.2 10 b)": {
        "question": "把练习 6 中的整数从二进制表示转换为十六进制表示。（b）(1010 1010 1010)₂",
        "answer": "(1010 1010 1010)2 = (AAA)16",
        "answer_symbols": [
            "=",
            "(",
            ")"
        ]
    },
    "4.2 10 c)": {
        "question": "把练习 6 中的整数从二进制表示转换为十六进制表示。（c）(111 0111 0111 0111)₂",
        "answer": "(111 0111 0111 0111)2 = (7777)16",
        "answer_symbols": [
            "=",
            "(",
            ")"
        ]
    },
    "4.2 10 d)": {
        "question": "把练习 6 中的整数从二进制表示转换为十六进制表示。（d）(101 1010 1010 1010)₂",
        "answer": "(101 0101 0101 0101)2 = (5555)16",
        "answer_symbols": [
            "=",
            "(",
            ")"
        ]
    },
    "4.2 11": {
        "question": "把 (1011 0111 1011)₂ 从二进制表示转换为十六进制表示。",
        "answer": "(B7B)16",
        "answer_symbols": []
    },
    "4.2 12": {
        "question": "把 (1 1000 0110 0011)₂ 从二进制表示转换为十六进制表示。",
        "answer": "按照示例 7，我们只需写出每组四位二进制数字的十六进制等价形式。注意，我们从右开始分组，所以最左边的一组，即 1，变成 0001。因此我们有 (0001 1000 0110 0011)2 = (1863)16。",
        "answer_symbols": [
            "=",
            "(",
            ")",
            ","
        ]
    },
    "4.2 13": {
        "question": "证明一个正整数的十六进制展开式可以与其二进制展开式求得，方法是每四位二进制数字组成一组，必要时在开头加一些 0，把每组四个二进制数字转换成一个十六进制数字。",
        "answer": "如果必要的话，加上最多三个前导零，将二进制展开写成 (... b23b22b21b20b13b12b11b10b03b02b01b00)2。这个数字的值是 b00+ 2b01+ 4b02+ 8b03+ 2^4b10+ 2^5b11+ 2^6b12+ 2^7b13+ 2^8b20+ 2^9b21+ 2^10b22+ 2^11b23+ ...，可以重写为 b00+ 2b01+ 4b02+ 8b03+ (b10+ 2b11+ 4b12+ 8b13) · 2^4+ (b20+ 2b21+ 4b22+ 8b23) · 2^8+ ...。现在 (bi3bi2bi1bi0)2 转换为十六进制数字 hi。所以我们的数字是 h0+ h1 · 2^4+ h2 · 2^8+ ...= h0+ h1 · 16+ h2 · 16^2+ ...，这是十六进制展开 (... h1h1h0)16。",
        "answer_symbols": [
            "≠",
            "=",
            "≥",
            "≤",
            "+",
            "-",
            "≡",
            "^",
            "·",
            "mod"
        ]
    },
    "4.2 14": {
        "question": "证明一个正整数的二进制展开式可以与其十六进制展开式求得，方法是把每个十六进制数字转换成一组四个二进制数字。",
        "answer": "设 (... h2h1h0)16 是一个正整数的十六进制展开。该整数的值因此为 h0 + h1 · 16 + h2 · 16^2 + ... = h0 + h1 · 2^4 + h2 · 2^8 + ...。如果我们用每个十六进制数字 hi 的二进制展开 (bi3bi2bi1bi0)2 替换，则 hi = bi0 + 2bi1 + 4bi2 + 8bi3。因此整个数字的值为 b00 + 2b01 + 4b02 + 8b03 + (b10 + 2b11 + 4b12 + 8b13) · 2^4 + (b20 + 2b21 + 4b22 + 8b23) · 2^8 + ... = b00 + 2b01 + 4b02 + 8b03 + 2^4b10 + 2^5b11 + 2^6b12 + 2^7b13 + 2^8b20 + 2^9b21 + 2^10b22 + 2^11b23 + ...，这是二进制展开 (... b23b22b21b20b13b12b11b10b03b02b01b00)2 的值。",
        "answer_symbols": [
            "+",
            "·",
            "=",
            "(",
            ")",
            "^"
        ]
    },
    "4.2 15": {
        "question": "证明一个正整数的八进制展开式可以与其二进制展开式求得，方法是每三位二进制数字组成一组，必要时在开头加一些 0，把每组三个二进制数字转换成一个八进制数字。",
        "answer": "如果必要的话，加上最多两个前导零，将二进制展开写成 (... b22b21b20b12b11b10b02b01b00)2。这个数字的值是 b00+ 2b01+ 4b02+ 2^3b10+ 2^4b11+ 2^5b12+ 2^6b20+ 2^7b21+ 2^8b22+ ...，可以重写为 b00+ 2b01+ 4b02+ (b10+ 2b11+ 4b12) · 2^3+ (b20+ 2b21+ 4b22) · 2^6+ ...。现在 (bi2bi1bi0)2 转换为八进制数字 hi。所以我们的数字是 h0+ h1 · 2^3+ h2 · 2^6+ ...= h0+ h1 · 8+ h2 · 8^2+ ...，这是八进制展开 (... h1h1h0)8。",
        "answer_symbols": [
            "≠",
            "=",
            "≥",
            "≤",
            "+",
            "-",
            "≡",
            "^",
            "·",
            "mod"
        ]
    },
    "4.2 16": {
        "question": "证明一个正整数的二进制展开式可以从其八进制展开式求得，方法是把每个八进制数字转换成一组三个二进制数字。",
        "answer": "设 (... d2d1d0)8 是一个正整数的八进制展开。该整数的值因此为 d0 + d1 · 8 + d2 · 8^2 + ... = d0 + d1 · 2^3 + d2 · 2^6 + ...。如果我们用每个八进制数字 di 的二进制展开 (bi2bi1bi0)2 替换，则 di = bi0 + 2bi1 + 4bi2。因此整个数字的值为 b00 + 2b01 + 4b02 + (b10 + 2b11 + 4b12) · 2^3 + (b20 + 2b21 + 4b22) · 2^6 + ... = b00 + 2b01 + 4b02 + 2^3b10 + 2^4b11 + 2^5b12 + 2^6b20 + 2^6b21 + 2^8b22 + ...，这是二进制展开 (... b22b21b20b12b11b10b02b01b00)2 的值。",
        "answer_symbols": [
            "(",
            "=",
            "^",
            "·",
            ")",
            "2",
            "8",
            "[...]",
            "+"
        ]
    },
    "4.2 17": {
        "question": "把(7345321)₈ 转换为二进制表示，把(10 1011 1011)₂ 转换为八进制表示。",
        "answer": "1 11011100 1010 1101 0001, 1273)8",
        "answer_symbols": []
    },
    "4.2 18": {
        "question": "给出一个将整数的十六进制表示转换为八进制表示的过程，用二进制表示作为中间步骤。",
        "answer": "Since we have procedures for converting both octal and hexadecimal to and from binary (Example 7), to convert from hexadecimal to octal, we first convert from hexadecimal to binary and then convert from binary to octal.",
        "answer_symbols": []
    },
    "4.2 20": {
        "question": "试解释如何从二进制转换为 64 进制，从 64 进制转换为二进制，从八进制转换为 64 进制，以及从 64 进制转换为八进制。",
        "answer": "Note that 64 = 2^6 = 8^2. In base 64, we need 64 symbols, from 0 up to something representing 63 (maybe we could use, for example, digits up to 9, then lower and upper case letters from a to Z, and finally symbols @ and $ to represent 62 and 63). Corresponding to each such symbol would be a binary string of six digits, from 000000 for 0, through 001010 for a, 100011 for z, 100100 for A, 111101 for Z, 111110 for @, and 111111 for $. To translate from binary to base 64, we group the binary digits from the right in groups of 6 and use the list of correspondences to replace each six bits by one base-64 digit. To convert from base 64 to binary, we just replace each base-64 digit by its corresponding six bits. For conversions between octal and base 64, we change the binary strings in our table to octal strings, replacing each 6-bit string by its 2-digit octal equivalent, and then follow the same procedures as above, interchanging base-64 digits and 2-digit strings of octal digits.",
        "answer_symbols": [
            "=",
            "^"
        ]
    },
    "4.2 22 a)": {
        "question": "找出下列每一对数的和与积。答案用三进制表示。（a）(112)₃, (210)₃",
        "answer": "112 + 210 = 1022 (decimal: 14 + 21 = 35) 112 * 210 = 101,220 (decimal: 14 * 21 = 294)",
        "answer_symbols": [
            "+",
            "*",
            "=",
            "(",
            ")",
            ","
        ]
    },
    "4.2 22 b)": {
        "question": "找出下列每一对数的和与积。答案用三进制表示。（b）(2112)₃, (12021)₃",
        "answer": "2112 + 12021 = 21,210 (decimal: 68 + 142 = 210) 2112 * 12021 = 111,020,122 (decimal: 68 * 142 = 9656)",
        "answer_symbols": [
            "+",
            "*",
            "=",
            "(",
            ")",
            ","
        ]
    },
    "4.2 22 c)": {
        "question": "找出下列每一对数的和与积。答案用三进制表示。（c）(20001)₃, (1111)₃",
        "answer": "20001 + 1111 = 21,112 (decimal: 163 + 40 = 203) 20001 * 1111 = 22,221,111 (decimal: 163 * 40 = 6520)",
        "answer_symbols": [
            "+",
            "*",
            "=",
            "(",
            ")",
            ","
        ]
    },
    "4.2 22 d)": {
        "question": "找出下列每一对数的和与积。答案用三进制表示。（d）(120021)₃, (2002)₃",
        "answer": "120021 + 2002 = 122,100 (decimal: 412 + 56 = 468) 120021 * 2002 = 1,011,122,112 (decimal: 412 * 56 = 23,072)",
        "answer_symbols": [
            "+",
            "*",
            "=",
            "(",
            ")",
            ","
        ]
    },
    "4.2 23 a)": {
        "question": "找出下列每一对数的和与积。答案用八进制表示。（a）(763)₈, (147)₈",
        "answer": "1132, 144,305",
        "answer_symbols": []
    },
    "4.2 23 b)": {
        "question": "找出下列每一对数的和与积。答案用八进制表示。（b）(6001)₈, (272)₈",
        "answer": "6273, 2,134,272",
        "answer_symbols": []
    },
    "4.2 23 c)": {
        "question": "找出下列每一对数的和与积。答案用八进制表示。（c）(1111)₈, (777)₈",
        "answer": "2110, 1,107,667",
        "answer_symbols": []
    },
    "4.2 23 d)": {
        "question": "找出下列每一对数的和与积。答案用八进制表示。（d）(54321)₈, (3456)₈",
        "answer": "57,777, 237,326,216",
        "answer_symbols": []
    },
    "4.2 24 a)": {
        "question": "找出下列每一对数的和与积。答案用十六进制表示。（a）(1AE)₁₆, (BBC)₁₆",
        "answer": "1AB + BBC = D67 (decimal: 427 + 3004 = 3431) 1AB * BBC = 139,294 (decimal: 427 * 3004 = 1,282,708)",
        "answer_symbols": [
            "+",
            "*",
            "=",
            "(",
            ")",
            ","
        ]
    },
    "4.2 24 b)": {
        "question": "找出下列每一对数的和与积。答案用十六进制表示。（b）(20CBA)₁₆, (A01)₁₆",
        "answer": "20CBA + A01 = 21,6BB (decimal: 134,330 + 2561 = 136,891) 20CBA * A01 = 14,815,0BA (decimal: 134,330 * 2561 = 344,019,130)",
        "answer_symbols": [
            "+",
            "*",
            "=",
            "(",
            ")",
            ","
        ]
    },
    "4.2 24 c)": {
        "question": "找出下列每一对数的和与积。答案用十六进制表示。（c）(ABCDE)₁₆, (1111)₁₆",
        "answer": "ABCDE + 1111 = AC,DEF (decimal: 703,710 + 4369 = 708,079) ABCDE * 1111 = B7,414,8BE (decimal: 703,710 * 4369 = 3,074,508,990)",
        "answer_symbols": [
            "+",
            "*",
            "=",
            "(",
            ")",
            ","
        ]
    },
    "4.2 24 d)": {
        "question": "找出下列每一对数的和与积。答案用十六进制表示。（d）(E0000E)₁₆, (BAAA)₁₆",
        "answer": "E0000E + BAAA = E0B,AB8 (decimal: 14,680,078 + 47,786 = 14,727,864) E0000E * BAAA = A,354,CA3,54C (decimal: 14,680,078 * 47,786 = 701,502,207,308)",
        "answer_symbols": [
            "+",
            "*",
            "=",
            "(",
            ")",
            ","
        ]
    },
    "4.2 25": {
        "question": "用算法 5 求 7^44 mod 645。",
        "answer": "436",
        "answer_symbols": []
    },
    "4.2 26": {
        "question": "用算法 5 求 11^44 mod 645。",
        "answer": "In effect, this algorithm computes 11 mod 645, 11^² mod 645, 11^⁴ mod 645, 11^⁸ mod 645, 11¹^⁶ mod 645, ..., and then multiplies (modulo 645) the required values. Since 644 = (1010000100)₂, we need to multiply 11^⁴ mod 645, 11¹^²^⁸ mod 645 and 11^⁵¹^² mod 645, each step taking modulo 645. We compute by repeated squaring: 11^² mod 645 = 121, 11^⁴ mod 645 = 121^² mod 645 = 14641 mod 645 = 451, 11^⁸ mod 645 = 451^² mod 645 = 203401 mod 645 = 226, 11¹^⁶ mod 645 = 226^² mod 645 = 51076 mod 645 = 121. At this point, we notice that 121 has appeared before, so 11^³^² mod 645 = 121^² mod 645 = 451, 11^⁶^⁴ mod 645 = 451^² mod 645 = 226, 11¹^²^⁸ mod 645 = 226^² mod 645 = 121, 11^²^⁵^⁶ mod 645 = 451, 11^⁵¹^² mod 645 = 226. Therefore, our final answer will be the product of 451, 121, and 226, taken modulo 645. We compute these values sequentially: 451 × 121 mod 645 = 54571 mod 645 = 391, 391 × 226 mod 645 = 88366 mod 645 = 1. So 11^⁶^⁴^⁴ mod 645 = 1. Computer algebra systems can verify this; for example, using the command '1 &^ 644 mod 645' in Maple. The hyphen tells Maple to use modular exponentiation instead of first computing the integer 11^⁶^⁴^⁴ (which exceeds 600 digits), although it can handle such large numbers if required. The key is that modular exponentiation is faster and avoids handling such large numbers.",
        "answer_symbols": [
            "(",
            "mod",
            "₂",
            "¹⁶",
            "²",
            "⁸",
            "^",
            "⁶⁴",
            "¹²⁸",
            ")",
            "⁵¹²",
            "×",
            "³²",
            "²⁵⁶",
            "...",
            "⁴"
        ]
    },
    "4.2 27": {
        "question": "用算法 5 求 3^203 mod 99。",
        "answer": "27",
        "answer_symbols": []
    },
    "4.2 28": {
        "question": "用算法 5 求 123^101 mod 101。",
        "answer": "This algorithm actually computes 123 mod 101, 123^² mod 101, 123^⁴ mod 101, 123^⁸ mod 101, etc., and then multiplies the required values (modulo 101). Since 1001 = (1111101001)₂, we need to multiply 123 mod 101, 123^⁸ mod 101, 123^³^² mod 101, 123^⁶^⁴ mod 101, 123¹^²^⁸ mod 101, 123^²^⁵^⁶ mod 101, and 123^⁵¹^² mod 101, each step taking modulo 101. We compute by repeated squaring: 123 mod 101 = 22, 123^² mod 101 = 22^² mod 101 = 484 mod 101 = 80, 123^⁴ mod 101 = 80^² mod 101 = 6400 mod 101 = 37, 123^⁸ mod 101 = 37^² mod 101 = 1369 mod 101 = 56, 123¹^⁶ mod 101 = 56^² mod 101 = 3136 mod 101 = 5, 123^³^² mod 101 = 5^² mod 101 = 25, 123^⁶^⁴ mod 101 = 25^² mod 101 = 625 mod 101 = 19, 123¹^²^⁸ mod 101 = 19^² mod 101 = 361 mod 101 = 58, 123^²^⁵^⁶ mod 101 = 58^² mod 101 = 3364 mod 101 = 31, 123^⁵¹^² mod 101 = 31^² mod 101 = 961 mod 101 = 52. Therefore, our final answer will be the product of 22, 56, 25, 19, 58, 31, and 52. We compute these values sequentially modulo 101: 22 × 56 is 20, 20 × 25 is 96, 96 × 19 is 6, 6 × 58 is 45, 45 × 31 is 82, and finally 82 × 52 is 22. So 123¹^⁰^⁰¹ mod 101 = 22.",
        "answer_symbols": [
            "mod",
            "²",
            "⁴",
            "⁸",
            "¹⁶",
            "³²",
            "⁶⁴",
            "¹²⁸",
            "²⁵⁶",
            "⁵¹²",
            "×",
            "^"
        ]
    },
    "4.2 29": {
        "question": "证明每个正整数都可以唯一地表示为 2 的不同次幂的和。[提示：考虑整数的二进制展开式。]",
        "answer": "整数的二进制展开是唯一的此类和。",
        "answer_symbols": []
    },
    "4.2 30 a)": {
        "question": "可以证明每个整数都能表示为 e_k 3^k + e_{k-1} 3^{k-1} + ⋯ + e_1 3 + e_0 的形式，其中 e_j = -1, 0 或 1, j = 0, 1, 2, ⋯, k 。这一类展开称为平衡三进制展开式。求下列整数的平衡三进制展开式。（a）5",
        "answer": "5 = 9 - 3 - 1",
        "answer_symbols": [
            "-",
            "="
        ]
    },
    "4.2 30 b)": {
        "question": "可以证明每个整数都能表示为 e_k 3^k + e_{k-1} 3^{k-1} + ⋯ + e_1 3 + e_0 的形式，其中 e_j = -1, 0 或 1, j = 0, 1, 2, ⋯, k 。这一类展开称为平衡三进制展开式。求下列整数的平衡三进制展开式。（b）13",
        "answer": "13 = 9 + 3 + 1",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "4.2 30 c)": {
        "question": "可以证明每个整数都能表示为 e_k 3^k + e_{k-1} 3^{k-1} + ⋯ + e_1 3 + e_0 的形式，其中 e_j = -1, 0 或 1, j = 0, 1, 2, ⋯, k 。这一类展开称为平衡三进制展开式。求下列整数的平衡三进制展开式。（c）37",
        "answer": "37 = 27 + 9 + 1",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "4.2 30 d)": {
        "question": "可以证明每个整数都能表示为 e_k 3^k + e_{k-1} 3^{k-1} + ⋯ + e_1 3 + e_0 的形式，其中 e_j = -1, 0 或 1, j = 0, 1, 2, ⋯, k 。这一类展开称为平衡三进制展开式。求下列整数的平衡三进制展开式。（d）79",
        "answer": "79 = 81 - 3 + 1",
        "answer_symbols": [
            "-",
            "+",
            "="
        ]
    },
    "4.2 31": {
        "question": "证明一个正整数被 3 整除当且仅当它的十进制数字之和能被 3 整除。",
        "answer": "令 a= (an−1an−2... a1a0)10。则 a= 10^(n−1)an−1+ 10^(n−2)an−2+ ...+ 10a1+ a0 ≡ an−1+ an−2+ ...+ a1+ a0 (mod 3)，因为",
        "answer_symbols": [
            "≠",
            "=",
            "≥",
            "≤",
            "+",
            "-",
            "≡",
            "^"
        ]
    },
    "4.2 32": {
        "question": "证明一个正整数能被 11 整除当且仅当它的偶数位十进制数字之和与奇数位十进制数字之和的差能被 11 整除。",
        "answer": "The key fact is 10 ≡ -1 (mod 11), thus 10^k ≡ (-1)^k (mod 11). Therefore, when k is even, 10^k is congruent to 1; when k is odd, 10^k is congruent to -1. Let the decimal expansion of integer a be (aₙ₋₁aₙ₋₂...a₃a₂a₁a₀)₁₀. Thus a = 10^(n-1)aₙ₋₁ + 10^(n-2)aₙ₋₂ + ... + 10a₁ + a₀. Since 10^k ≡ (-1)^k (mod 11), we have a ≡ ±aₙ₋₁ ∓ aₙ₋₂ + ... - a₃ + a₂ - a₁ + a₀ (mod 11), where the signs alternate and depend on the parity of n. Therefore, a ≡ 0 (mod 11) if and only if (a₀ + a₂ + a₄ + ...) - (a₁ + a₃ + a₅ + ...) is congruent to 0 (mod 11). Since divisibility by 11 is equivalent to congruence to 0 (mod 11), we prove that a positive integer is divisible by 11 if and only if the sum of its decimal digits at even positions minus the sum of its decimal digits at odd positions is divisible by 11.",
        "answer_symbols": [
            "≡",
            "(",
            ")",
            "^",
            "+",
            "-",
            "=",
            "∓",
            "±"
        ]
    },
    "4.2 33": {
        "question": "求证一个正整数能被 3 整除当且仅当它的偶数位二进制数字之和与奇数位二进制数字之和的差能被 3 整除。",
        "answer": "设 a = (a(n-1)a(n-2)...a1a0)_2。则 a = a0 + 2a1 + 2^²a2 + ... + 2^(n-1)a(n-1) ≡ a0 - a1 + a2 - a3 + ... ± a(n-1) (mod 3)。因此，a 能被 3 整除当且仅当偶数位置上的二进制数字之和减去奇数位置上的二进制数字之和能被 3 整除。",
        "answer_symbols": [
            "+",
            "^",
            "≡",
            "mod",
            "-",
            "±"
        ]
    },
    "4.2 34 a)": {
        "question": "用长度为六的位串找出下列整数的 1 的补码表示。（a）22",
        "answer": "Since 22 in binary is 10110, the six-bit one's complement representation is 010110.",
        "answer_symbols": []
    },
    "4.2 34 b)": {
        "question": "用长度为六的位串找出下列整数的 1 的补码表示。（b）31",
        "answer": "Since 31 in binary is 11111, the six-bit one's complement representation is 011111.",
        "answer_symbols": []
    },
    "4.2 34 c)": {
        "question": "用长度为六的位串找出下列整数的 1 的补码表示。（c）-7",
        "answer": "Since 7 in binary is 111, we invert 000111 to get 111000 as the one's complement representation of -7.",
        "answer_symbols": []
    },
    "4.2 34 d)": {
        "question": "用长度为六的位串找出下列整数的 1 的补码表示。（d）-19",
        "answer": "Since 19 in binary is 10011, we invert 010011 to get 101100 as the one's complement representation of -19.",
        "answer_symbols": []
    },
    "4.2 36": {
        "question": "如果 m 是一个小于 2^(n-1) 的正整数，当用长度为 n 的位串时，怎样从 m 的 1 的补码表示求出 -m 的 1 的补码表示？",
        "answer": "Each 1 becomes 0, each 0 becomes 1.",
        "answer_symbols": []
    },
    "4.2 37": {
        "question": "怎样从两个整数的 1 的补码表示得到其和的 1 的补码表示？",
        "answer": "两个整数的一补码之和可以通过将这两个整数的一补码相加得到，但最高位的进位会被用作最后一位的进位。",
        "answer_symbols": []
    },
    "4.2 38": {
        "question": "怎样从两个整数的 1 的补码表示得到其差的 1 的补码表示？",
        "answer": "We combine the two ideas from exercises 36 and 37: to form a - b, we compute a + (-b), using exercise 36 to find -b and exercise 37 to find the sum.",
        "answer_symbols": [
            "-",
            "+"
        ]
    },
    "4.2 39": {
        "question": "证明 1 的补码表示为 (a_{n-1} a_{n-2} ⋯ a_1 a_0) 的整数 m 可以通过等式 m = -a_{n-1}(2^(n-1)-1) + a_{n-2} 2^(n-2) + ⋯ + a_1 2 + a_0 计算得到。",
        "answer": "如果 m ≥ 0，则一补码展开式的最高位 a(n-1) 为 0，公式变为 m = Σ(i=0 到 n-2) ai * 2^i。这是因为右侧是 m 的二进制展开式。当 m 是负数时，一补码展开式的最高位 a(n-1) 为 1。剩余的 n-1 位可以通过从 111...1（有 n-1 个 1）中减去 -m 得到，因为从 1 中减去一个位等同于对该位取反。因此，位串 a(n-2)...a0 是 (2^(n-1) - 1) - (-m) 的二进制展开式。解方程 (2^(n-1) - 1) - (-m) = Σ(i=0 到 n-2) ai * 2^i 可以得到所需的方程，因为 a(n-1) = 1。",
        "answer_symbols": [
            "≥",
            "Σ",
            "*",
            "^",
            "-",
            "(",
            ")",
            "="
        ]
    },
    "4.2 40 a)": {
        "question": "解答练习34，这次使用2的补码表示并用长度为六的位串。（a）22",
        "answer": "Since 22 is positive, and its binary expansion is 10110, the answer is 010110.",
        "answer_symbols": []
    },
    "4.2 40 b)": {
        "question": "解答练习34，这次使用2的补码表示并用长度为六的位串。（b）31",
        "answer": "Since 31 is positive, and its binary expansion is 11111, the answer is 011111.",
        "answer_symbols": []
    },
    "4.2 40 c)": {
        "question": "解答练习34，这次使用2的补码表示并用长度为六的位串。（c）-7",
        "answer": "Since −7 is negative, we first find the 5-bit binary expansion of 25 − 7 = 25, namely 11001, and precede it by a 1, obtaining 111001.",
        "answer_symbols": [
            "-",
            "="
        ]
    },
    "4.2 40 d)": {
        "question": "解答练习34，这次使用2的补码表示并用长度为六的位串。（d）-19",
        "answer": "Since −19 is negative, we first find the 5-bit binary expansion of 25 − 19 = 13, namely 01101, and precede it by a 1, obtaining 101101.",
        "answer_symbols": [
            "-",
            "="
        ]
    },
    "4.2 42": {
        "question": "用2的补码表示解答练习36。",
        "answer": "We can experiment a bit to find a convenient algorithm. We saw in Exercise 40 that the expansion of −7 is 111001, while of course the expansion of 7 is 000111. Apparently to find the expansion of −m from that of m we complement each bit and then add 1, working in base 2. Similarly, the expansion of −8 is 111000, whereas the expansion of 8 is 001000; again 110111 + 1 = 111000. At the extremes (using six bits) we have 1 represented by 000001, so −1 is represented by 111110 + 1 = 111111; and 31 is represented by 011111, so −31 is represented by 100000 + 1 = 100001.",
        "answer_symbols": [
            "-",
            "=",
            "+"
        ]
    },
    "4.2 43": {
        "question": "用2的补码表示解答练习37。",
        "answer": "要获得两个整数之和的二补码表示，将它们的二补码表示相加（如同二进制整数相加），并忽略最左边列的任何进位。然而，如果发生溢出，答案无效。这发生在两个整数的二补码表示的最高位相同而结果的最高位不同的情况下。",
        "answer_symbols": []
    },
    "4.2 44": {
        "question": "用2的补码表示解答练习38。",
        "answer": "We just combine the two ideas in Exercises 42 and 43. To form a − b, we compute a + (−b), using Exercise 42 to find −b and Exercise 43 to find the sum.",
        "answer_symbols": [
            "-",
            "+"
        ]
    },
    "4.2 45": {
        "question": "证明2的补码表示为 (a_{n-1}a_{n-2}…a_1a_0) 的整数 m 可以通过等式 m = -a_{n-1}·2^(n-1) + a_{n-2}·2^(n-2) + … + a_1·2 + a_0 计算得到。",
        "answer": "如果 m ≥ 0，则最高位 a(n-1) 为 0，公式变为 m = Σ(i=0 到 n-2) ai * 2^i。这是因为右侧是 m 的二进制展开式。如果 m < 0，其二补码展开式的最高位为 1，剩余的 n-1 位是 2^(n-1) - (-m) 的二进制展开式。这意味着 (2^(n-1)) - (-m) = Σ(i=0 到 n-2) ai * 2^i。解方程 (2^(n-1)) - (-m) = Σ(i=0 到 n-2) ai * 2^i 可以得到所需的方程，因为 a(n-1) = 1。",
        "answer_symbols": [
            "≥",
            "<",
            "Σ",
            "*",
            "^",
            "-",
            "(",
            ")",
            "="
        ]
    },
    "4.2 46": {
        "question": "试给出一个简单的算法从整数的1的补码表示构成其2的补码表示。",
        "answer": "If the number is positive (i.e., the left-most bit is 0), then the expansions are the same. If the number is negative (i.e., the left-most bit is 1), then we take the one’s complement representation and add 1, working in base 2. For example, the one’s complement representation of −19 using six bits is, from Exercise 34, 101100. Adding 1 we obtain 101101, which is the two’s complement representation of −19 using six bits, from Exercise 40.",
        "answer_symbols": [
            "-",
            "+"
        ]
    },
    "4.2 47": {
        "question": "有时通过用四位二进制展开式表示每个十进制数字来为整数编码。这就产生了整数的二进制编码的十进制形式。例如，用这种方式为791编码得011110010001。采用这种编码方式表示一个n位的十进制需要多少位？",
        "answer": "4n",
        "answer_symbols": [
            "*"
        ]
    },
    "4.2 48 a)": {
        "question": "求下列各数的康托展开式。（a）2",
        "answer": "2 = 2!",
        "answer_symbols": [
            "="
        ]
    },
    "4.2 48 b)": {
        "question": "求下列各数的康托展开式。（b）7",
        "answer": "7 = 3! + 1!",
        "answer_symbols": [
            "=",
            "+"
        ]
    },
    "4.2 48 c)": {
        "question": "求下列各数的康托展开式。（c）19",
        "answer": "19 = 3 · 3! + 1!",
        "answer_symbols": [
            "=",
            "·",
            "+"
        ]
    },
    "4.2 48 d)": {
        "question": "求下列各数的康托展开式。（d）87",
        "answer": "87 = 3 · 4! + 2 · 3! + 2! + 1!",
        "answer_symbols": [
            "=",
            "·",
            "+"
        ]
    },
    "4.2 48 e)": {
        "question": "求下列各数的康托展开式。（e）1000",
        "answer": "1000 = 6! + 2 · 5! + 4! + 2 · 3! + 2 · 2!",
        "answer_symbols": [
            "=",
            "·",
            "+"
        ]
    },
    "4.2 48 f)": {
        "question": "求下列各数的康托展开式。（f）1 000 000",
        "answer": "1000000 = 2 · 9! + 6 · 8! + 6 · 7! + 2 · 6! + 5 · 5! + 4! + 2 · 3! + 2 · 2!",
        "answer_symbols": [
            "=",
            "·",
            "+"
        ]
    },
    "4.2 49": {
        "question": "试描述找出整数的康托展开式的算法。",
        "answer": "过程 Cantor(x: 正整数) n := 1; f := 1 当 (n + 1) * f ≤ x n := n + 1 f := f * n y := x 当 n > 0 an := y / f y := y - an * f f := f / n n := n - 1 {x = an * n! + a(n-1) * (n-1)! + ... + a1 * 1!}",
        "answer_symbols": [
            ":=",
            "*",
            "+",
            "-",
            "/",
            "!"
        ]
    },
    "4.2 50": {
        "question": "试描述将两个整数的康托展开式相加的算法。",
        "answer": "The algorithm is essentially the same as the usual grade-school algorithm for adding. We add from right to left, one column at a time, carrying to the next column if necessary. A carry out of the column representing i! is needed whenever the sum obtained for that column is greater than i, in which case we subtract i + 1 from that digit and carry 1 into the next column (since (i + 1)! = (i + 1) · i!).",
        "answer_symbols": [
            "+",
            "-",
            "="
        ]
    },
    "4.2 51": {
        "question": "按照课本给出的加法算法步骤，一步一步把(10111)₂和(11010)₂相加。",
        "answer": "第一步：c = 0, d = 0, s0 = 1; 第二步：c = 0, d = 1, s1 = 0; 第三步：c = 1, d = 1, s2 = 0; 第四步：c = 1, d = 1, s3 = 0; 第五步：c = 1, d = 1, s4 = 1; 第六步：c = 1, s5 = 1",
        "answer_symbols": [
            "=",
            "+"
        ]
    },
    "4.2 52": {
        "question": "按照课本给出的乘法算法步骤，一步一步把(1110)₂和(101)₂相乘。",
        "answer": "The partial products are 11100 and 1110000, namely 1110 shifted one place and three places to the left. We add these two numbers, obtaining 10001100.",
        "answer_symbols": [
            "+"
        ]
    },
    "4.2 53": {
        "question": "试描述计算两个二进制展开式之差的算法。",
        "answer": "过程 subtract(a, b: 正整数, a > b, a = (a(n-1)a(n-2)...a1a0)_2, b = (b(n-1)b(n-2)...b1b0)_2) B := 0 {B 是借位} 对于 j := 0 到 n - 1 如果 aj ≥ bj + B sj := aj - bj - B B := 0 否则 sj := aj + 2 - bj - B B := 1 {(s(n-1)s(n-2)...s1s0)_2 是差值}",
        "answer_symbols": [
            ":=",
            ">",
            "≥",
            "+",
            "-",
            "}"
        ]
    },
    "4.2 54": {
        "question": "试估计两个二进制展开式的减法所需二进制位运算的次数。",
        "answer": "Subtraction is really just like addition, so the number of bit operations should be comparable, namely O(n). More specifically, if we analyze the algorithm for Exercise 53, we see that the loop is executed n times, and only a few operations are performed during each pass.",
        "answer_symbols": [
            "-",
            "+"
        ]
    },
    "4.2 55": {
        "question": "设计一个算法，给定整数a和b的二进制展开，判断是否有a>b，a=b，或者a<b。",
        "answer": "过程 compare(a, b: 正整数, a = (a(n)a(n-1)...a1a0)_2, b = (b(n)b(n-1)...b1b0)_2) k := n 当 ak = bk 且 k > 0 k := k - 1 如果 ak = bk 打印 \"a 等于 b\" 如果 ak > bk 打印 \"a 大于 b\" 如果 ak < bk 打印 \"a 小于 b\"",
        "answer_symbols": [
            ":=",
            "=",
            ">",
            "<",
            "-"
        ]
    },
    "4.2 56": {
        "question": "当整数a和b中较大的数的二进制展开式有n位时，练习55中的比较算法需要做多少次二进制位运算？",
        "answer": "In the worst case, each bit of a has to be compared to each bit of b, so O(n) comparisons are needed. An exact analysis of the procedure given in the solution to Exercise 55 shows that n + 1 comparisons of bits are needed in the worst case, assuming that the logical \"and\" condition in the while loop is evaluated efficiently from left to right (so that a0 is not compared to b0 there).",
        "answer_symbols": [
            "+",
            "<=",
            ">"
        ]
    },
    "4.2 57": {
        "question": "采用所需除法次数来衡量，试估计求整数n的b进制展开式的算法1的复杂度。",
        "answer": "O(log n)",
        "answer_symbols": [
            "O",
            "(",
            ")",
            "log"
        ]
    },
    "4.2 58": {
        "question": "证明算法5使用O((log m)^3 log n)次二进制位运算来计算b^m mod m。",
        "answer": "模乘法由两个整数相乘组成，每个整数最多为 log m 位（因为它们小于 m），然后除以 m，m 也是 log m 位。因此，这需要 (log m)^² 位操作，如示例 11 和文本中提到的算法 4 的分析所示。这是在算法 5 的循环内部发生的情况。循环迭代 log n 次。因此，总位操作数为 O((log m)^² log n)。",
        "answer_symbols": [
            "log",
            "(",
            ")",
            "*",
            "^",
            "O"
        ]
    },
    "4.2 59": {
        "question": "证明算法4使用O(k log |a|)次二进制位运算，假设a>d。",
        "answer": "算法中唯一耗时的部分是 while 循环，该循环迭代 q 次。内部的工作是对不大于 a 的整数进行减法操作，a 有 log a 位。现在结果从示例 9 跟随而来。",
        "answer_symbols": [
            "while",
            "log"
        ]
    },
    "4.3 3 a)": {
        "question": "求下列整数的素因子分解式。88",
        "answer": "2^³ * 11",
        "answer_symbols": [
            "*",
            "^"
        ]
    },
    "4.3 3 b)": {
        "question": "求下列整数的素因子分解式。126",
        "answer": "2 * 3^² * 7",
        "answer_symbols": [
            "*",
            "^"
        ]
    },
    "4.3 3 c)": {
        "question": "求下列整数的素因子分解式。729",
        "answer": "3^⁶",
        "answer_symbols": [
            "^"
        ]
    },
    "4.3 3 d)": {
        "question": "求下列整数的素因子分解式。1001",
        "answer": "7 * 11 * 13",
        "answer_symbols": [
            "*"
        ]
    },
    "4.3 3 e)": {
        "question": "求下列整数的素因子分解式。1111",
        "answer": "11 * 101",
        "answer_symbols": [
            "*"
        ]
    },
    "4.3 3 f)": {
        "question": "求下列整数的素因子分解式。909 090",
        "answer": "2 * 3^³ * 5 * 7 * 13 * 37",
        "answer_symbols": [
            "*",
            "^"
        ]
    },
    "4.3 5": {
        "question": "求10!的素因子分解式。",
        "answer": "2^⁸ * 3^⁴ * 5^² * 7",
        "answer_symbols": [
            "*",
            "^"
        ]
    },
    "4.3 6": {
        "question": "100!的尾部有多少个0？",
        "answer": "一个数字每有一个 10（= 2 * 5）的因子，其末尾就有一个 0。现在 100! 肯定有更多的 2 的因子，所以它拥有的 10 的因子数量与 5 的因子数量相同。每个二十个数字 5、10、15、...、100 都为 100! 贡献了一个 5 的因子，此外数字 25、50、75 和 100 还额外贡献了一个 5 的因子。因此，100! 中有 24 个 5 的因子，所以 100! 以恰好 24 个 0 结尾。",
        "answer_symbols": [
            "=",
            "*",
            "!"
        ]
    },
    "4.3 7": {
        "question": "试用伪代码表示用来判断一个整数是素数的试除法算法。",
        "answer": "过程 primetester(n: 大于 1 的整数) isprime := true d := 2 当 isprime 且 d ≤ √n 如果 n mod d = 0 isprime := false 否则 d := d + 1 返回 isprime",
        "answer_symbols": [
            ":=",
            ">",
            "≤",
            "√",
            "mod",
            "=",
            "+"
        ]
    },
    "4.3 8": {
        "question": "试用伪代码表示正文所描述的用来寻找一个整数素因子分解式的算法。",
        "answer": "输入是一个正整数 n。我们依次寻找小因子 d（从 d = 2 开始，并在确定 d 不再是剩余部分的因子后递增 d），这些因子必然是质数。当我们找到一个因子时，我们将其除掉并继续进行。我们将在找到因子时打印这些因子。（或者，可以将它们存储在某种列表中。）当剩余的数字为 1（所有因子都已找到）时停止。下面的伪代码实现了这一点。请注意，我们可以稍微复杂一点，只使用质数作为试除因子，但这似乎不值得花费时间，因为确定哪些试除因子是质数需要时间。或者，我们可以单独处理 d = 2，然后仅遍历奇数值的 d，从 3 开始，每次递增 2。",
        "answer_symbols": [
            "=",
            "<",
            ">",
            "+",
            "/"
        ]
    },
    "4.3 9": {
        "question": "证明a^n+1是合数，如果a和m是大于1的整数且m是奇数。[提示：证明x+1是多项式x^n+1的因子，如果m是奇数。]",
        "answer": "写 n = rs，其中 r > 1 和 s > 1。则 2^n - 1 = 2^(rs) - 1 = (2^r)^s - 1 = (2^r - 1)((2^r)^(s-1) + (2^r)^(s-2) + (2^r)^(s-3) + ... + 1)。第一个因子至少为 2^² - 1 = 3，第二个因子至少为 2^² + 1 = 5。这提供了 2^n - 1 的两个大于 1 的因子分解，因此 2^n - 1 是合数。",
        "answer_symbols": [
            "=",
            ">",
            "+",
            "-",
            "^",
            "(",
            ")",
            "…"
        ]
    },
    "4.3 10": {
        "question": "证明如果2^n+1是奇素数，则存在非负整数n使得m=2n。[提示：首先证明多项式恒等式x^n+1=(x^k + 1)(x^{k(t-1)} - x^{k(t-2)} + ⋯ - x^k + 1)成立，其中 m = kt 且 t 是奇数。]",
        "answer": "我们首先建立提示中的恒等式。如果令 y = x^k，则所声称的恒等式为 (y^t + 1) = (y + 1)(y^(t-1) - y^(t-2) + y^(t-3) - ... - y + 1)，通过展开右边并注意到“抵消”现象，很容易看出这是正确的。我们要证明 m 是 2 的幂，即它的唯一质因数是 2。假设相反，m 有一个奇质因数 t 并写成 m = kt，其中 k 是一个正整数。令 x = 2 代入提示中给出的恒等式，我们有 2^m + 1 = (2^k + 1)（另一个因子）。因为 2^k + 1 > 1 且质数 2^m + 1 不能有大于 1 的适当因子，所以我们必须有 2^m + 1 = 2^k + 1，从而 m = k 且 t = 1，这与 t 是质数的事实矛盾。这完成了反证法的证明。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "*",
            "^",
            ">",
            "(",
            ")"
        ]
    },
    "4.3 11": {
        "question": "证明 log_2 3 是无理数。回忆一下无理数是不能写成两个整数之比的实数 x。",
        "answer": "假设 log₂ 3 = a/b，其中 a, b ∈ Z+ 且 b ≠ 0。则 2^(a/b) = 3，所以 2^a = 3^b。这违反了算术基本定理。因此，log₂ 3 是无理数。",
        "answer_symbols": [
            "=",
            "∈",
            "≠",
            "^",
            "log"
        ]
    },
    "4.3 13": {
        "question": "证明或反驳存在 3 个连续的正奇数是素数，即形如 p、p+2、p+4 的奇素数。",
        "answer": "3, 5, 和 7 是所需形式的素数。",
        "answer_symbols": []
    },
    "4.3 15": {
        "question": "哪些小于 30 的正整数与 30 互素？",
        "answer": "1, 7, 11, 13, 17, 19, 23, 29",
        "answer_symbols": []
    },
    "4.3 17 a)": {
        "question": "判断下列各组整数是否两两互素：11, 15, 19",
        "answer": "是",
        "answer_symbols": []
    },
    "4.3 17 b)": {
        "question": "判断下列各组整数是否两两互素：14, 15, 21",
        "answer": "否",
        "answer_symbols": []
    },
    "4.3 17 c)": {
        "question": "判断下列各组整数是否两两互素：12, 17, 31, 37",
        "answer": "是",
        "answer_symbols": []
    },
    "4.3 17 d)": {
        "question": "判断下列各组整数是否两两互素：7, 8, 9, 11",
        "answer": "是",
        "answer_symbols": []
    },
    "4.3 19": {
        "question": "证明如果 2^n - 1 为素数，则 n 为素数。[提示：利用恒等式 2^n - 1 = (2^n - 1) · (2^(n-1) + 2^(n-2) + ⋯ + 2^0 + 1)。]",
        "answer": "假设 n 不是素数，即 n = ab，其中 a 和 b 是大于 1 的整数。因为 a > 1，根据提示中的恒等式，2^a - 1 是 2^n - 1 的一个大于 1 的因子，因此 2^n - 1 是合数。",
        "answer_symbols": [
            "=",
            ">",
            "-",
            "^"
        ]
    },
    "4.3 23": {
        "question": "当 p 为素数且 k 为正整数时 φ(p^k) 的值是什么？",
        "answer": "φ(p^k) = p^k - p^(k-1)",
        "answer_symbols": [
            "φ",
            "^",
            "-",
            "p",
            "k"
        ]
    },
    "4.3 29": {
        "question": "试求 gcd(92 928, 123 552) 和 lcm(92 928, 123 552)，并验证 gcd(92 928, 123 552) · lcm(92 928, 123 552) = 92 928 · 123 552。[提示：首先找出 92 928 和 123 552 的素因子分解式。]",
        "answer": "gcd(92928, 123552) = 1056; lcm(92928, 123552) = 10,872,576; 两个乘积都是 11,481,440,256。",
        "answer_symbols": [
            "gcd",
            "lcm",
            "="
        ]
    },
    "4.3 30": {
        "question": "如果两个整数的乘积为 2^7 3^8 5^5 7^11，而它们的最大公约数为 2^3 3^4 5，则它们的最小公倍数是什么？",
        "answer": "(2^7 * 3^8 * 5^2 * 7^11) / (2^3 * 3^4 * 5) = 2^4 * 3^4 * 5 * 7^11",
        "answer_symbols": [
            "*",
            "^",
            "/",
            "="
        ]
    },
    "4.3 31": {
        "question": "证明如果 a 和 b 为正整数，则 ab = gcd(a, b) · lcm(a, b)。[提示：利用 a 和 b 的素因子分解式以及根据素因子分解式给出的 gcd(a, b) 和 lcm(a, b) 的计算公式。]",
        "answer": "因为 min(x, y) + max(x, y) = x + y，所以 gcd(a, b) · lcm(a, b) 中素数 p_i 的指数是 a 和 b 的质因数分解中 p_i 的指数之和。",
        "answer_symbols": [
            "min",
            "max",
            "+",
            "=",
            "gcd",
            "lcm",
            "·"
        ]
    },
    "4.3 32 a)": {
        "question": "用欧几里得算法求 gcd(1, 5)",
        "answer": "gcd(1, 5) = gcd(1, 0) = 1",
        "answer_symbols": [
            "gcd",
            "=",
            "(",
            ")"
        ]
    },
    "4.3 32 b)": {
        "question": "用欧几里得算法求 gcd(100, 101)",
        "answer": "gcd(100, 101) = gcd(100, 1) = gcd(1, 0) = 1",
        "answer_symbols": [
            "gcd",
            "=",
            "(",
            ")"
        ]
    },
    "4.3 32 c)": {
        "question": "用欧几里得算法求 gcd(123, 277)",
        "answer": "gcd(123, 277) = gcd(123, 31) = gcd(31, 30) = gcd(30, 1) = gcd(1, 0) = 1",
        "answer_symbols": [
            "gcd",
            "=",
            "(",
            ")"
        ]
    },
    "4.3 32 d)": {
        "question": "用欧几里得算法求 gcd(1529, 14 039)",
        "answer": "gcd(1529, 14039) = gcd(1529, 278) = gcd(278, 139) = gcd(139, 0) = 139",
        "answer_symbols": [
            "gcd",
            "=",
            "(",
            ")"
        ]
    },
    "4.3 32 e)": {
        "question": "用欧几里得算法求 gcd(1529, 14 038)",
        "answer": "gcd(1529, 14038) = gcd(1529, 277) = gcd(277, 144) = gcd(144, 133) = gcd(133, 11) = gcd(11, 1) = gcd(1, 0) = 1",
        "answer_symbols": [
            "gcd",
            "=",
            "(",
            ")"
        ]
    },
    "4.3 32 f)": {
        "question": "用欧几里得算法求 gcd(11 111, 111 111)",
        "answer": "gcd(11111, 111111) = gcd(11111, 1) = gcd(1, 0) = 1",
        "answer_symbols": [
            "gcd",
            "=",
            "(",
            ")"
        ]
    },
    "4.3 34": {
        "question": "用欧几里得算法求 gcd(21, 34) 需要做多少次除法？",
        "answer": "我们需要依次除以34、21、13、8、5、3、2和1，所以需要进行八次除法。",
        "answer_symbols": []
    },
    "4.3 35": {
        "question": "用欧几里得算法求 gcd(34, 55) 需要做多少次除法？",
        "answer": "9",
        "answer_symbols": []
    },
    "4.3 36": {
        "question": "证明如果 a 和 b 为正整数，则 (2^a - 1) mod (2^b - 1) = 2^(a mod b) - 1。",
        "answer": "我们将2^a - 1除以2^b - 1。商的最高项是2^(a-b)（只要a ≥ b），此时的余数是2^(a-b) - 1。如果现在a - b ≥ b，则长除法的下一步会在商中产生下一个加项2^(a-2b)，此时的余数是2^(a-2b) - 1。这个长除法的过程继续进行，直到某个阶段的余数小于除数，即2^(a-kb) - 1 < 2^b - 1。但那时的余数是2^(a-kb) - 1，显然a - kb正好是a模b。这完成了证明。",
        "answer_symbols": [
            "^",
            "-",
            "<",
            "≥"
        ]
    },
    "4.4 1": {
        "question": "证明 15 是 7 模 26 的逆。",
        "answer": "15 · 7 = 105 ≡ 1 (mod 26)",
        "answer_symbols": [
            "·",
            "≡",
            "(",
            "mod",
            ")"
        ]
    },
    "4.4 2": {
        "question": "证明 937 是 13 模 2436 的逆。",
        "answer": "我们需要证明 13 * 937 ≡ 1 (mod 2436)，换句话说，13 * 937 - 1 = 12180 可以被 2436 整除。计算器显示这是正确的，因为 12180 = 2436 * 5。",
        "answer_symbols": [
            "*",
            "≡",
            "-",
            "=",
            "+",
            "*"
        ]
    },
    "4.4 3": {
        "question": "通过查看（就像例 1 所讨论的），找出 4 模 9 的逆。",
        "answer": "7",
        "answer_symbols": []
    },
    "4.4 4": {
        "question": "通过查看（就像例 1 所讨论的），找出 2 模 17 的逆。",
        "answer": "我们需要一个数，当它乘以 2 时，结果与 1 模 17 同余。由于 18 ≡ 1 (mod 17) 并且 2 * 9 = 18，所以 9 是 2 模 17 的逆元。",
        "answer_symbols": [
            "*",
            "≡",
            "="
        ]
    },
    "4.4 6 a)": {
        "question": "用例 2 中的方法对下列每对互素的整数找出 a 模 m 的逆。 a) a = 2, m = 17",
        "answer": "示例 1 中过程的第一步得到 17 = 8 * 2 + 1，这意味着 17 - 8 * 2 = 1，因此 -8 是一个逆元。我们也可以将其表示为 9，因为 -8 ≡ 9 (mod 17)。",
        "answer_symbols": [
            "=",
            "*",
            "+",
            "-",
            "≡"
        ]
    },
    "4.4 6 b)": {
        "question": "用例 2 中的方法对下列每对互素的整数找出 a 模 m 的逆。 b) a = 34, m = 89",
        "answer": "我们需要找到 s 和 t 使得 34s + 89t = 1。那么 s 就是我们所需要的逆元，因为 34s ≡ 1 (mod 89)（即 34s - 1 = -89t 可以被 89 整除）。为此，我们按照示例 2 的方法进行。首先通过欧几里得算法计算 gcd(34, 89) = 1：89 = 2 * 34 + 21 34 = 21 + 13 21 = 13 + 8 13 = 8 + 5 8 = 5 + 3 5 = 3 + 2 3 = 2 + 1 然后我们反向操作并写出 1 作为所需的线性组合：1 = 3 - 2 = 3 - (5 - 3) = 2 * 3 - 5 = 2 * (8 - 5) - 5 = 2 * 8 - 3 * 5 = 2 * 8 - 3 * (13 - 8) = 5 * 8 - 3 * 13 = 5 * (21 - 13) - 3 * 13 = 5 * 21 - 8 * 13 = 5 * 21 - 8 * (34 - 21) = 13 * 21 - 8 * 34 = 13 * (89 - 2 * 34) - 8 * 34 = 13 * 89 - 34 * 34 因此 s = -34，所以 34 模 89 的一个逆元是 -34，也可以写成 55。",
        "answer_symbols": [
            "=",
            "*",
            "+",
            "-",
            "≡",
            "gcd"
        ]
    },
    "4.4 6 c)": {
        "question": "用例 2 中的方法对下列每对互素的整数找出 a 模 m 的逆。 c) a = 144, m = 233",
        "answer": "我们需要找到 s 和 t 使得 144s + 233t = 1。显然 s 就是我们所需要的逆元，因为 144s ≡ 1 (mod 233)（即 144s - 1 = -233t 可以被 233 整除）。为此，我们按照示例 2 的方法进行。实际上，在下面的某个点之后，所有的工作已经在 (b) 部分完成。首先我们通过欧几里得算法计算 gcd(144, 233) = 1：233 = 144 + 89 144 = 89 + 55 89 = 55 + 34 55 = 34 + 21 34 = 21 + 13 21 = 13 + 8 13 = 8 + 5 8 = 5 + 3 5 = 3 + 2 3 = 2 + 1 然后我们反向操作并写出 1 作为所需的线性组合：1 = 3 - 2 = 3 - (5 - 3) = 2 * 3 - 5 = 2 * (8 - 5) - 5 = 2 * 8 - 3 * 5 = 2 * 8 - 3 * (13 - 8) = 5 * 8 - 3 * 13 = 5 * (21 - 13) - 3 * 13 = 5 * 21 - 8 * 13 = 5 * 21 - 8 * (34 - 21) = 13 * 21 - 8 * 34 = 13 * (55 - 34) - 8 * 34 = 13 * 55 - 21 * 34 = 13 * 55 - 21 * (89 - 55) = 34 * 55 - 21 * 89 = 34 * (144 - 89) - 21 * 89 = 34 * 144 - 55 * 89 = 34 * 144 - 55 * (233 - 144) = 89 * 144 - 55 * 233 因此 s = 89，所以 144 模 233 的逆元是 89，因为 144 * 89 = 12816 ≡ 1 (mod 233)。",
        "answer_symbols": [
            "=",
            "≡",
            "*",
            "-",
            "gcd",
            "+"
        ]
    },
    "4.4 6 d)": {
        "question": "用例 2 中的方法对下列每对互素的整数找出 a 模 m 的逆。 d) a = 200, m = 1001",
        "answer": "欧几里得算法计算的第一步是 1001 = 5 * 200 + 1。因此 -5 * 200 + 1001 = 1，且 -5（或 996）是所需的逆元。",
        "answer_symbols": [
            "=",
            "+",
            "*",
            "-"
        ]
    },
    "4.4 7": {
        "question": "证明如果 a 和 m 是互素的正整数，则 a 模 m 的逆是模 m 唯一的。[提示：假定同余式 ax ≡ 1 (mod m) 有两个解 b 和 c。再用定理 7 证明 b ≡ c (mod m)。]",
        "answer": "假设 b 和 c 都是 a 模 m 的逆元。那么 ba ≡ 1 (mod m) 和 ca ≡ 1 (mod m)。因此，ba ≡ ca (mod m)。因为 gcd(a, m) = 1，根据第 4.3 节的定理 7 可知 b ≡ c (mod m)。",
        "answer_symbols": [
            "≡",
            "(",
            "mod",
            ")",
            "gcd",
            "=",
            "定理"
        ]
    },
    "4.4 8": {
        "question": "证明如果 gcd(a, m) > 1，这里 a 是整数而 m > 2 是正整数，则 a 模 m 的逆不存在。",
        "answer": "如果 x 是 a 模 m 的逆元，则按定义有 ax - 1 = tm，其中 t 是某个整数。如果这个等式中的 a 和 m 都有一个大于 1 的公约数，那么 1 也必须具有相同的公约数，因为 1 = ax - tm。这是荒谬的，因为 1 的唯一正因数是 1。因此不存在这样的 x。",
        "answer_symbols": [
            "-",
            "*",
            "=",
            "gcd"
        ]
    },
    "4.4 9": {
        "question": "解同余方程 4x ≡ 5 (mod 9)，利用练习 5a 中找到的 4 模 9 的逆。",
        "answer": "8",
        "answer_symbols": []
    },
    "4.4 10": {
        "question": "解同余方程 2x ≡ 7 (mod 17)，利用练习 6a 中找到的 2 模 17 的逆。",
        "answer": "我们从练习 6 中知道 9 是 2 模 17 的逆元。因此如果我们把这个等式的两边都乘以 9，我们将得到 x ≡ 9 * 7 (mod 17)。因为 63 mod 17 = 12，所以解是所有与 12 模 17 同余的整数，如 12、29 和 -5。我们可以检查，例如，2 * 12 = 24 ≡ 7 (mod 17)。这个答案也可以表示为所有形如 12 + 17k 的整数，其中 k 属于 Z。",
        "answer_symbols": [
            "*",
            "≡",
            "+",
            "="
        ]
    },
    "4.4 12 a)": {
        "question": "利用练习 6b、c 和 d 中找到的模的逆求解下列同余方程。 a) 34x ≡ 77 (mod 89)",
        "answer": "我们发现 55 是 34 模 89 的逆元，所以 x ≡ 77 * 55 = 4235 ≡ 52 (mod 89)。检查：34 * 52 = 1768 ≡ 77 (mod 89)。",
        "answer_symbols": [
            "*",
            "≡",
            "="
        ]
    },
    "4.4 12 b)": {
        "question": "利用练习 6b、c 和 d 中找到的模的逆求解下列同余方程。 b) 144x ≡ 4 (mod 233)",
        "answer": "我们发现 89 是 144 模 233 的逆元，所以 x ≡ 4 * 89 = 356 ≡ 123 (mod 233)。检查：144 * 123 = 17712 ≡ 4 (mod 233)。",
        "answer_symbols": [
            "*",
            "≡",
            "="
        ]
    },
    "4.4 12 c)": {
        "question": "利用练习 6b、c 和 d 中找到的模的逆求解下列同余方程。 c) 200x ≡ 13 (mod 1001)",
        "answer": "我们发现 -5 是 200 模 1001 的逆元，所以 x ≡ 13 * (-5) = -65 ≡ 936 (mod 1001)。（我们也可以将答案保留为 -65。）检查：200 * 936 = 187200 ≡ 13 (mod 1001)。",
        "answer_symbols": [
            "*",
            "≡",
            "="
        ]
    },
    "4.4 13": {
        "question": "找出同余方程 15x^2 + 19x ≡ 5 (mod 11) 的解。[提示：证明该同余方程等价于同余方程 15x^2 + 19x + 6 ≡ 0 (mod 11)。对同余方程左边进行因子分解，证明二次同余方程的解就是两个不同的线性同余方程之一的解。]",
        "answer": "3 和 6",
        "answer_symbols": [
            "和"
        ]
    },
    "4.4 15": {
        "question": "证明如果 m 是大于 1 的正整数，且 ac ≡ bc (mod m)，则 a ≡ b (mod m/gcd(c, m))。",
        "answer": "令 m' = m / gcd(c, m)。因为 m 和 c 的所有公约数都被除去了，得到的 m' 与 c 互质。因为 m 整除 ac - bc = (a - b)c，所以 m' 整除 (a - b)c。根据第 4.3 节的引理 3，可知 m' 整除 a - b，所以 a ≡ b (mod m')。",
        "answer_symbols": [
            "=",
            "/",
            "gcd",
            "(",
            "mod",
            ")",
            "≡",
            "引理"
        ]
    },
    "4.4 17": {
        "question": "证明如果 p 为素数，则 x^2 ≡ 1 (mod p) 仅有的解是满足 x ≡ 1 (mod p) 或 x ≡ -1 (mod p) 的整数 x。",
        "answer": "假设 x^² ≡ 1 (mod p)。那么 p 整除 x^² - 1 = (x + 1)(x - 1)。根据引理 2 可知 p | x + 1 或 p | x - 1，所以 x ≡ -1 (mod p) 或 x ≡ 1 (mod p)。",
        "answer_symbols": [
            "≡",
            "(",
            "mod",
            ")",
            "|",
            "引理"
        ]
    },
    "4.4 21": {
        "question": "利用中国剩余定理证明中的构造法找出同余方程组 x ≡ 1 (mod 2), x ≡ 2 (mod 3), x ≡ 3 (mod 5) 和 x ≡ 4 (mod 11) 的所有解。",
        "answer": "所有形式为 323 + 330k 的整数，其中 k 是整数。",
        "answer_symbols": [
            "+",
            "·"
        ]
    },
    "4.4 23": {
        "question": "用反向替换方法求解练习 20 的同余方程组。",
        "answer": "所有形式为 53 + 60k 的整数，其中 k 是整数。",
        "answer_symbols": [
            "+",
            "·"
        ]
    },
    "4.4 24": {
        "question": "用反向替换方法求解练习 21 的同余方程组。",
        "answer": "By definition, the first congruence can be written as x = 2t + 1 where t is an integer. Substituting this expression for x into the second congruence tells us that 2t + 1 ≡ 2 (mod 3), which can easily be solved to show that t ≡ 2 (mod 3). From this, we can write t = 3u + 2 for some integer u. Thus x = 2t + 1 = 2(3u + 2) + 1 = 6u + 5. Next, we have 6u + 5 ≡ 3 (mod 5), which we solve to get u ≡ 3 (mod 5), so u = 5v + 3. Thus x = 6(5v + 3) + 5 = 30v + 23. For the last congruence, we have 30v + 23 ≡ 4 (mod 11); 题目稍难，但通过试错或应用例2的方法得到逆元，然后根据例3，v ≡ 10 (mod 11)。因此 x = 30(11w + 10) + 23 = 330w + 323。所以我们的解是所有与323模330同余的整数。我们通过确认 323 ≡ 1 (mod 2)，323 ≡ 2 (mod 3)，323 ≡ 3 (mod 5)，和 323 ≡ 4 (mod 11) 来检查答案。",
        "answer_symbols": [
            "≡",
            "mod"
        ]
    },
    "4.4 26": {
        "question": "找出同余方程组 x ≡ 5 (mod 6), x ≡ 3 (mod 10) 和 x ≡ 8 (mod 15) 的所有解，如果有解的话。",
        "answer": "我们不能直接应用中国剩余定理，因为模数不是两两互质的。\n然而，我们可以使用中国剩余定理将这些同余式转换为一组等价的同余式。由于我们要 x ≡ 5 (mod 6)，则必须有 x ≡ 5 ≡ 1 (mod 2) 和 x ≡ 5 ≡ 2 (mod 3)。同样地，从第二个同余式我们必有 x ≡ 1 (mod 2) 和 x ≡ 3 (mod 5)；而从第三个同余式我们必有 x ≡ 2 (mod 3) 和 x ≡ 3 (mod 5)。\n由于这六个陈述是一致的，我们看到我们的系统等价于系统 x ≡ 1 (mod 2)，x ≡ 2 (mod 3)，x ≡ 3 (mod 5)。这些可以使用中国剩余定理（见例5）求解，得出 x ≡ 23 (mod 30)。因此，解是所有形式为 23 + 30k 的整数，其中 k 是一个整数。\n",
        "answer_symbols": [
            "≡",
            "mod",
            ","
        ]
    },
    "4.4 28": {
        "question": "利用中国剩余定理证明满足 0 ≤ a < m = m_1 m_2 ⋯ m_n 的整数 a，其中正整数 m_1, m_2, ⋯, m_n 是两两互素，都能唯一地表示为 n 元组 (a mod m_1, a mod m_2, ⋯, a mod m_n)。",
        "answer": "这只是中国剩余定理的另一种表述。给定任何这样的 a，我们当然可以计算 a 模 m1，a 模 m2，...，a 模 mn 来表示它。中国剩余定理告诉我们只有一个小于 m 的非负整数产生每个 n 元组，因此表示是唯一的。",
        "answer_symbols": [
            "≡",
            "mod"
        ]
    },
    "4.4 30": {
        "question": "通过证明模两两互素的线性同余方程组的解相对于模数乘积为模时是唯一的来完成中国剩余定理的证明。[提示：假定 x 和 y 是方程组的两个解。证明对所有 i，m_i | x − y。再利用练习 29 得出 m = m_1 m_2 ⋯ m_n | x − y。]",
        "answer": "我们遵循提示并假设同余方程组有两个解。因此假设 x ≡ a_i (mod m_i) 和 y ≡ a_i (mod m_i) 对于每个 i 都成立。我们希望证明这些解在模 m 下相同；这将保证小于 m 的唯一非负解。这个假设当然意味着 x ≡ y (mod m_i) 对于每个 i 都成立。但是，根据第29题，x ≡ y (mod m)，如我们所愿。\n",
        "answer_symbols": [
            "≡",
            "mod",
            "和"
        ]
    },
    "4.4 32": {
        "question": "哪些整数被 5 除而被 3 除时余 1？",
        "answer": "要求解 x ≡ 0 (mod 5) 和 x ≡ 1 (mod 3)。我们知道根据中国剩余定理，存在唯一的模15解。最快的方法可能是通过将每个5的倍数除以3来寻找，我们立即看到 x = 10 满足条件。因此解是所有与10模15同余的整数。如果涉及的数字更大，则可以使用定理2证明中隐含的技术（见第53题）。\n",
        "answer_symbols": [
            "="
        ]
    },
    "4.4 34": {
        "question": "利用费马小定理找出 23^1002 mod 41。",
        "answer": "费马小定理告诉我们 23^40 ≡ 1 (mod 41)。因此 23^1002 = (23^40)^25 * 23^2 ≡ 1^25 * 529 = 529 ≡ 37 (mod 41)。",
        "answer_symbols": [
            "^",
            "≡",
            "mod"
        ]
    },
    "4.4 36": {
        "question": "利用练习 35 找出 5 模 41 的一个逆。",
        "answer": "根据第35题，5模41的逆元是539。我们可以在这里停止，但可能我们希望得到一个更简单的答案。这可以通过模幂运算计算（或者，从实用的角度来看，使用计算机代数软件）。最简单的形式是33，很容易验证 5 * 33 = 165 ≡ 1 (mod 41)。\n",
        "answer_symbols": [
            "^",
            "≡",
            "mod"
        ]
    },
    "4.4 38 a)": {
        "question": "利用费马小定理计算 3^102 mod 5, 3^102 mod 7 和 3^102 mod 11。",
        "answer": "根据费马小定理，我们知道 3^4 ≡ 1 (mod 5)；因此 3^300 = (3^4)^75 ≡ 1^75 ≡ 1 (mod 5)，所以 3^302 = 3^2 * 3^300 ≡ 9 * 1 = 9 (mod 5)，因此 3^302 模 5 = 4。类似地，3^6 ≡ 1 (mod 7)；因此 3^300 = (3^6)^50 ≡ 1 (mod 5)，所以 3^302 = 3^2 * 3^300 ≡ 9 (mod 7)，因此 3^302 模 7 = 2。最后，3^10 ≡ 1 (mod 11)；因此 3^300 = (3^10)^30 ≡ 1 (mod 11)，所以 3^302 = 3^2 * 3^300 ≡ 9 (mod 11)，因此 3^302 模 11 = 9。\n",
        "answer_symbols": [
            "*",
            "≡",
            "mod"
        ]
    },
    "4.4 38 b)": {
        "question": "利用 a) 中结果及中国剩余定理计算 3^102 mod 385。（注意 385 = 5 × 7 × 11。）",
        "answer": "由于 3^302 模 5、7 和 11 都等于 9，因此它也模 385 等于 9。（这是中国剩余定理的一个特别简单的应用。",
        "answer_symbols": [
            "^",
            "≡",
            "mod"
        ]
    },
    "4.4 40": {
        "question": "借助于费马小定理证明如果 n 是一个正整数，则 42 能整除 n^7 − n。",
        "answer": "注意 42 的素因数分解是 2 * 3 * 7。因此，只要证明 2 | n^7 - n，3 | n^7 - n，和 7 | n^7 - n 即可。第一个是平凡的（n^7 - n 要么是“奇减奇”，要么是“偶减偶”，两者都是偶数），后两个根据费马小定理立刻得出，因为 n^7 - n ≡ (n^2)^3 * n - n ≡ 1 * n - n = 0 (mod 3) 和 n^7 - n ≡ n - n = 0 (mod 7)。\n",
        "answer_symbols": [
            "^",
            "≡",
            "mod"
        ]
    },
    "4.4 42": {
        "question": "利用练习 41 判定 M_13 = 2^13 − 1 = 8191 以及 M_23 = 2^23 − 1 = 8 388 607 是否是素数。",
        "answer": "To decide whether 2^13 - 1 = 8191 is prime, we need only look for a prime factor not exceeding √8191 ≈ 90.5. By Exercise 41, every such prime divisor must be of the form 26k + 1. The only candidates are therefore 53 and 79. We easily check that neither is a divisor, and so we conclude that 8191 is prime.\nWe can take the same approach for 2^23 - 1 = 8,388,607, but we might worry that there will be far too many potential divisors to test, since we must go as far as 2896. By Exercise 41, every prime divisor of 2^23 - 1 must be of the form 46k + 1. The first candidate divisor is therefore 47. Luckily, 47 divides 8,388,607, so we conclude that this Mersenne number is not prime.\n",
        "answer_symbols": [
            "^",
            "≡",
            "mod"
        ]
    },
    "4.4 44": {
        "question": "证明如果 n 是素数，b 是正整数且 n ∤ b，则 n 能通过以 b 为底的米勒测试。",
        "answer": "Let x_k = b^(n-1)/2^k = b^(2s-k)t, for k = 0, 1, 2, ..., s. Because n is prime and n does not divide b, Fermat’s little theorem tells us that x_0 = b^(n-1) ≡ 1 (mod n). By Exercise 17, because x_1^2 = (b^(n-1)/2)^2 = x_0 ≡ 1 (mod n), either x_1 ≡ -1 (mod n) or x_1 ≡ 1 (mod n). If x_1 ≡ 1 (mod n), because x_2^2 = x_1 ≡ 1 (mod n), either x_2 ≡ -1 (mod n) or x_2 ≡ 1 (mod n). In general, if we have found that x_0 ≡ x_1 ≡ x_2 ≡ ... ≡ x_k ≡ 1 (mod n), with k < s, then, because x_(k+1)^2 = x_k ≡ 1 (mod n), we know that either x_(k+1) ≡ -1 (mod n) or x_(k+1) ≡ 1 (mod n). Continuing this procedure for k = 1, 2, ..., s, we find that either x_s = b^t ≡ 1 (mod n), or x_k ≡ -1 (mod n) for some integer k with 0 ≤ k ≤ s. Hence, n passes Miller’s test for the base b.\n",
        "answer_symbols": [
            "^",
            "≡",
            "mod"
        ]
    },
    "4.4 46": {
        "question": "证明 1729 是卡米切尔数。",
        "answer": "This follows from Exercise 49, taking m = 1. Alternatively, we can argue directly as follows. Factor 1729 = 7 * 13 * 19. We must show that this number meets the definition of Carmichael number, namely that b^1728 ≡ 1 (mod 1729) for all b relatively prime to 1729. Note that if gcd(b, 1729) = 1, then gcd(b, 7) = gcd(b, 13) = gcd(b, 19) = 1. Using Fermat’s little theorem, we find that b^6 ≡ 1 (mod 7), b^12 ≡ 1 (mod 13), and b^18 ≡ 1 (mod 19). It follows that b^1728 = (b^6)^288 ≡ 1 (mod 7), b^1728 = (b^12)^144 ≡ 1 (mod 13), and b^1728 = (b^18)^96 ≡ 1 (mod 19). By Exercise 29 (or the Chinese remainder theorem), it follows that b^1728 ≡ 1 (mod 1729), as desired.\n",
        "answer_symbols": [
            "^",
            "≡",
            "mod"
        ]
    },
    "4.4 48": {
        "question": "证明如果 n = p_1 p_2 ⋯ p_k ，其中 p_1, p_2, ⋯, p_k 是不同的素数且满足 p_j - 1 ∣ n - 1 ， j = 1, 2, ⋯, k ，则 n 是卡米切尔数。",
        "answer": "Let b be a positive integer with gcd(b, n) = 1. The gcd(b, p_j) = 1 for j = 1, 2, ..., k, and hence, by Fermat’s little theorem, b^(p_j-1) ≡ 1 (mod p_j) for j = 1, 2, ..., k. Because p_j - 1 divides n - 1, there are integers t_j with t_j(p_j - 1) = n - 1. Hence for each j, we know that b^(n-1) = b^(p_j-1)t_j = (b^(p_j-1))^t_j ≡ 1 (mod p_j). Therefore, b^(n-1) ≡ 1 (mod n), as desired.\n",
        "answer_symbols": [
            "^",
            "≡",
            "mod"
        ]
    },
    "4.4 50": {
        "question": "找出下列各对所表示的小于 28 的非负整数 a，其中每一对都表示 (a mod 4, a mod 7)。a) (0, 0) b) (1, 0) c) (1, 1) d) (2, 1) e) (2, 2) f) (0, 3) g) (2, 0) h) (3, 5) i) (3, 6)",
        "answer": "We could use the technique shown in the proof of Theorem 2 to solve each part, or use the approach in our solution to Exercise 32, but since there are so many to do here, it is simpler just to write out all the representations of 0 through 27 and find those given in each part. This task is easily done, since the pattern is clear:\n\n- 0 = (0, 0)\n- 7 = (3, 0)\n- 14 = (2, 0)\n- 21 = (1, 0)\n- 1 = (1, 1)\n- 8 = (0, 1)\n- 15 = (3, 1)\n- 22 = (2, 1)\n- 2 = (2, 2)\n- 9 = (1, 2)\n- 16 = (0, 2)\n- 23 = (3, 2)\n- 3 = (3, 3)\n- 10 = (2, 3)\n- 17 = (1, 3)\n- 24 = (0, 3)\n- 4 = (0, 4)\n- 11 = (3, 4)\n- 18 = (2, 4)\n- 25 = (1, 4)\n- 5 = (1, 5)\n- 12 = (0, 5)\n- 19 = (3, 5)\n- 26 = (2, 5)\n- 6 = (2, 6)\n- 13 = (1, 6)\n- 20 = (0, 6)\n- 27 = (3, 6)\n\nNow we can read off the answers:\n- a) 0\n- b) 21\n- c) 1\n- d) 22\n- e) 2\n- f) 24\n- g) 14\n- h) 19\n- i) 27",
        "answer_symbols": [
            "^",
            "≡",
            "mod"
        ]
    },
    "4.4 52": {
        "question": "试解释怎样用练习 51 中求出的数对来计算 4 加 7。",
        "answer": "To add 4 and 7, we first find that 4 is represented by (1, 4) and that 7 is represented by (1, 2). Adding coordinate-wise, we see that the sum is represented by (1+1, 4+2) = (2, 6) = (2, 1); we are working modulo 5 in the second coordinate. Then we find (2, 1) in the table and see that it represents 11. Therefore, we conclude that 4 + 7 = 11. Note that we can only compute answers less than 3 * 5 = 15 using this method.\n",
        "answer_symbols": [
            "^",
            "≡",
            "mod"
        ]
    },
    "4.5 4": {
        "question": "利用前面描述的双散列函数的过程并取 p = 4969 为下列社会保障号的雇员的档案分配内存地址：k1 = 123456789，k2 = 987654321，k3 = 567890123，k4 = 345678901。132489971, k2 = 509496993, k3 = 546332190, k4 = 034367980, k5 = 047900151, k6 = 329938157, k7 = 212228844, k8 = 325510778, k9 = 353354519, k10 = 053708912.",
        "answer": "We compute as follows: h(k1) = 1524 h(k2) = 578 h(k3) = 578, which collides, h(k3, 1) = 2505, so k3 is assigned memory location 2505 h(k4) = 2376 h(k5) = 3960 h(k6) = 1526 h(k7) = 2854 h(k8) = 1526, which collides, h(k8, 1) = 4927, so k8 is assigned memory location 4927 h(k9) = 3960, which collides, h(k9, 1) = 6100 ≡ 1131 (mod 4969), so k9 is assigned memory location 1131 h(k10) = 3960, which collides, h(k10, 1) = 4702, so k10 is assigned memory location 4702 Notice that we never had to go above i = 1 in the probing sequence.",
        "answer_symbols": [
            "=",
            "≡",
            "mod"
        ]
    },
    "4.5 2": {
        "question": "利用散列函数 h(k) = k mod 101 为下列社会保障号的保险公司客户记录分配的内存地址是多少? a) 104578690 b) 43222187 c) 372201919 d) 501338753",
        "answer": "In each case we need to compute k mod 101 by dividing by 101 and finding the remainders. This can be done with a calculator that keeps 13 digits of accuracy internally. Just divide the number by 101, subtract off the integer part of the answer, and multiply the fraction that remains by 101. The result will be almost exactly an integer, and that integer is the answer.",
        "answer_symbols": [
            "mod"
        ]
    },
    "4.5 6": {
        "question": "用线性同余生成器 xₙ₊₁ = (4xₙ + 1) mod 7 和种子 x₀ = 3 生成的伪随机数序列是什么？",
        "answer": "We just calculate using the formula. We are given x0 = 3. Then: x1 = (4 · 3 + 1) mod 7 = 13 mod 7 = 6 x2 = (4 · 6 + 1) mod 7 = 25 mod 7 = 4 x3 = (4 · 4 + 1) mod 7 = 17 mod 7 = 3 At this point the sequence must continue to repeat 3, 6, 4, 3, 6, 4, ... forever.",
        "answer_symbols": [
            "=",
            "·",
            "+",
            "mod"
        ]
    },
    "4.5 8": {
        "question": "试用伪代码写出利用线性同余生成器生成伪随机数序列的算法。",
        "answer": "We assume that the input to this procedure consists of a modulus (m ≥ 2), a multiplier (a), an increment (c), a seed (x0), and the number (n) of pseudorandom numbers desired. The output will be the sequence {xi}. Procedure pseudorandom(m, a, c, x0, n: nonnegative integers) for i := 1 to n xi := (a * xi-1 + c) mod m",
        "answer_symbols": [
            "≥",
            "(",
            ")",
            ":",
            "=",
            "*",
            "+",
            "mod"
        ]
    },
    "4.5 10": {
        "question": "试解释为什么在用平方取中法生成 4 位数伪随机数序列时以 3792 和 2916 作为起始项是不好的选择。",
        "answer": "We follow the instructions. Because 3792^² = 14379264, the middle four digits are 3792, which is the number we started with. So this sequence is not random at all—it’s constant! Similarly: 2916^² = 08503056 5030^² = 25300900 3009^² = 09054081 0540^² = 00291600 which gives us back the number we started with, so this sequence degenerates into a repeating sequence with period 4.",
        "answer_symbols": [
            "²"
        ]
    },
    "4.5 12": {
        "question": "找出幂次生成器生成的伪随机数序列，其中 p = 11, d = 2，种子 x₀ = 3。",
        "answer": "We are told to apply the formula xn+1 = x^²n mod 11, starting with x0 = 3. Thus: x1 = 3^² mod 11 = 9 x3 = 9^² mod 11 = 4 x4 = 4^² mod 11 = 5 x5 = 5^² mod 11 = 3 and we are back where we started. The sequence generated here is 3, 9, 4, 5, 3, 9, 4, 5, ...",
        "answer_symbols": [
            "=",
            "²",
            "mod"
        ]
    },
    "4.5 14": {
        "question": "证明奇偶校验位能够检测到位串中的错误当且仅当该串包含奇数个错误。",
        "answer": "If a string contains an odd number of errors, then the number of 1’s in the string with its check bit will differ by an odd number from what it should be, which means it will be an odd number, rather than the expected even number, and we will know that there is an error. If the string contains an even number of errors, then the number of 1’s in the string with its check bit will differ by an even number from what it should be, which means it will be an even number, as expected, and we will not know that anything is wrong.",
        "answer_symbols": []
    },
    "4.5 16": {
        "question": "《初等数论及其应用》第 6 版的 ISBN-10 是 0-321-500Q1-8，其中 Q 是一个数字。请找出 Q 的值。",
        "answer": "We know that 1 · 0 + 2 · 3 + 3 · 2 + 4 · 1 + 5 · 5 + 6 · 0 + 7 · 0 + 8 · Q + 9 · 1 + 10 · 8 ≡ 0 (mod 11). This simplifies to 130 + 8Q ≡ 0 (mod 11). We subtract 130 from both sides and simplify to 8Q ≡ 2 (mod 11), since -130 = -12 · 11 + 2. It is now a simple matter to use trial and error (or the methods of Section 4.4) to find that Q = 3 (since 24 ≡ 2 (mod 11)).",
        "answer_symbols": [
            "·",
            "+",
            "≡",
            "mod",
            "-",
            "="
        ]
    },
    "4.5 20 a)": {
        "question": "下列邮政汇票标识码中有一位数字被弄脏了。你能恢复这些数中由 Q 标记的被弄脏的数字吗？（a）Q1223139784",
        "answer": "Q + 1 + 2 + 2 + 3 + 1 + 3 + 9 + 7 + 8 ≡ 4 (mod 9) => Q ≡ 4 (mod 9) => Q = 4",
        "answer_symbols": [
            "+",
            "≡",
            "mod"
        ]
    },
    "4.5 20 b)": {
        "question": "下列邮政汇票标识码中有一位数字被弄脏了。你能恢复这些数中由 Q 标记的被弄脏的数字吗？（b）6702120Q988",
        "answer": "6 + 7 + 0 + 2 + 1 + 2 + 0 + Q + 9 + 8 ≡ 8 (mod 9) => Q + 8 ≡ 8 (mod 9) => Q ≡ 0 (mod 9). There are two single-digit Qs that satisfy this equation: Q = 0 and Q = 9, so the smudged digit cannot be determined.",
        "answer_symbols": [
            "+",
            "≡",
            "mod"
        ]
    },
    "4.5 20 c)": {
        "question": "下列邮政汇票标识码中有一位数字被弄脏了。你能恢复这些数中由 Q 标记的被弄脏的数字吗？（c）27Q41007734",
        "answer": "2 + 7 + Q + 4 + 1 + 0 + 0 + 7 + 7 + 3 ≡ 4 (mod 9) => Q + 4 ≡ 4 (mod 9) => Q ≡ 0 (mod 9). There are two single-digit Qs that satisfy this equation: Q = 0 and Q = 9, so the smudged digit cannot be determined.",
        "answer_symbols": [
            "+",
            "≡",
            "mod"
        ]
    },
    "4.5 20 d)": {
        "question": "下列邮政汇票标识码中有一位数字被弄脏了。你能恢复这些数中由 Q 标记的被弄脏的数字吗？（d）213279032Q1",
        "answer": "2 + 1 + 3 + 2 + 7 + 9 + 0 + 3 + 2 + Q ≡ 1 (mod 9) => Q + 2 ≡ 1 (mod 9) => Q ≡ 8 (mod 9) => Q = 8",
        "answer_symbols": [
            "+",
            "≡",
            "mod"
        ]
    },
    "4.5 22": {
        "question": "试确定 USPS 汇票码中哪位单一的数字错误能被检测出来。",
        "answer": "If a digit is changed to a value not congruent to it modulo 9, then the modular congruence relation implied by the formula in the introduction will no longer hold. Therefore, all single-digit errors can be detected except for replacing 0 with 9 or vice versa.",
        "answer_symbols": [
            "≡",
            "mod"
        ]
    },
    "4.5 24 a)": {
        "question": "为以下 11 位数字开始的 UPC 确定其校验码。（a）73232184434",
        "answer": "3 * 7 + 3 + 3 * 2 + 3 + 3 * 2 + 1 + 3 * 8 + 4 + 3 * 4 + 3 + 3 * 4 + x12 ≡ 0 (mod 10) => x12 = 5",
        "answer_symbols": [
            "*",
            "+",
            "≡",
            "mod"
        ]
    },
    "4.5 24 b)": {
        "question": "为以下 11 位数字开始的 UPC 确定其校验码。（b）63623991346",
        "answer": "3 * 6 + 3 + 3 * 6 + 2 + 3 * 3 + 9 + 3 * 9 + 1 + 3 * 3 + 4 + 3 * 6 + x12 ≡ 0 (mod 10) => x12 = 2",
        "answer_symbols": [
            "*",
            "+",
            "≡",
            "mod"
        ]
    },
    "4.5 24 c)": {
        "question": "为以下 11 位数字开始的 UPC 确定其校验码。（c）04587320720",
        "answer": "3 * 0 + 4 + 3 * 5 + 8 + 3 * 7 + 3 + 3 * 2 + 0 + 3 * 7 + 2 + 3 * 0 + x12 ≡ 0 (mod 10) => x12 = 0",
        "answer_symbols": [
            "*",
            "+",
            "≡",
            "mod"
        ]
    },
    "4.5 24 d)": {
        "question": "为以下 11 位数字开始的 UPC 确定其校验码。（d）93764323341",
        "answer": "3 * 9 + 3 + 3 * 7 + 6 + 3 * 4 + 3 + 3 * 2 + 3 + 3 * 3 + 4 + 3 * 1 + x12 ≡ 0 (mod 10) => x12 = 3",
        "answer_symbols": [
            "*",
            "+",
            "≡",
            "mod"
        ]
    },
    "4.5 26": {
        "question": "一个 UPC 码的校验码能检测出所有单错吗？证明你的答案或找出一个反例。",
        "answer": "Yes. Any single-digit error will change some digit x to y, and one side of the congruence given in the introduction will differ from its true value by x - y or 3(x - y). Since x - y ≠ 0 and 3(x - y) ≠ 0 (mod 10) (because 3 and 10 are coprime), the congruence will no longer hold.",
        "answer_symbols": [
            "-",
            "≠",
            "≡",
            "mod"
        ]
    },
    "4.5 28 a)": {
        "question": "找出以下 14 位数字开始的机票标识码的校验码 a₁₅。（a）10237424413392",
        "answer": "10237424413392 mod 7 = 1",
        "answer_symbols": [
            "mod",
            "="
        ]
    },
    "4.5 28 b)": {
        "question": "找出以下 14 位数字开始的机票标识码的校验码 a₁₅。（b）00003278181234",
        "answer": "00032781811234 mod 7 = 4",
        "answer_symbols": [
            "mod",
            "="
        ]
    },
    "4.5 28 c)": {
        "question": "找出以下 14 位数字开始的机票标识码的校验码 a₁₅。（c）000611232134231",
        "answer": "00611232134231 mod 7 = 5",
        "answer_symbols": [
            "mod",
            "="
        ]
    },
    "4.5 28 d)": {
        "question": "找出以下 14 位数字开始的机票标识码的校验码 a₁₅。（d）000193222543435",
        "answer": "00193222543435 mod 7 = 5",
        "answer_symbols": [
            "mod",
            "="
        ]
    },
    "4.5 30": {
        "question": "试确定 15 位机票标识码中哪位单一的数字错误能被检测出来。",
        "answer": "Any single-digit error in the nth column from right to left (n = 0 corresponds to the units place) of the first 14 digits of an airline ticket identification number will result in the 14-digit number differing from its correct value by (x - y)10^n. If this equals 0 mod 7, the error will not be detected. Because 7 and 10 are coprime, this occurs if and only if |x - y| = 7; thus, we can detect errors except for 0 ↔ 7, 1 ↔ 8, 2 ↔ 9. The same reasoning applies to the check digit (although of course 7, 8, and 9 are invalid digits for the check digit).",
        "answer_symbols": [
            "-",
            "≠",
            "≡",
            "mod",
            "|"
        ]
    },
    "4.5 32 a)": {
        "question": "对于下列 7 位开始的 ISSN，确定其校验码（有可能是字母 X）。（a）1570-868",
        "answer": "3 * 1 + 4 * 5 + 5 * 7 + 6 * 0 + 7 * 8 + 8 * 6 + 9 * 8 mod 11 = 3",
        "answer_symbols": [
            "*",
            "+",
            "mod",
            "="
        ]
    },
    "4.5 32 b)": {
        "question": "对于下列 7 位开始的 ISSN，确定其校验码（有可能是字母 X）。（b）1553-734",
        "answer": "3 * 1 + 4 * 5 + 5 * 5 + 6 * 3 + 7 * 7 + 8 * 3 + 9 * 4 mod 11 = 10, so the check digit is X.",
        "answer_symbols": [
            "*",
            "+",
            "mod",
            "="
        ]
    },
    "4.5 32 c)": {
        "question": "对于下列 7 位开始的 ISSN，确定其校验码（有可能是字母 X）。（c）1089-708",
        "answer": "3 * 1 + 4 * 0 + 5 * 8 + 6 * 9 + 7 * 7 + 8 * 0 + 9 * 8 mod 11 = 9",
        "answer_symbols": [
            "*",
            "+",
            "mod",
            "="
        ]
    },
    "4.5 32 d)": {
        "question": "对于下列 7 位开始的 ISSN，确定其校验码（有可能是字母 X）。（d）1383-811",
        "answer": "3 * 1 + 4 * 3 + 5 * 8 + 6 * 3 + 7 * 8 + 8 * 1 + 9 * 1 mod 11 = 3",
        "answer_symbols": [
            "*",
            "+",
            "mod",
            "="
        ]
    },
    "4.5 34": {
        "question": "一个 ISSN 的校验码是否能检测出 ISSN 中每个单错？用证明或反例来解释你的答案。",
        "answer": "Yes. Any single-digit error will change some digit x to y, and one side of the congruence given in the introduction will differ from its true value by a(x - y), where a ∈ {1, 3, 4, 5, 6, 7, 8, 9}. These a values are all coprime with 11, so a(x - y) ≠ 0 (mod 11), and the congruence will no longer hold.",
        "answer_symbols": [
            "-",
            "≠",
            "∈",
            "≡",
            "mod"
        ]
    },
    "4.6 3": {
        "question": "试通过把字母翻译成数字，再应用给定的加密函数，再将数字翻译回字母来加密消息WATCH YOUR",
        "answer": "ANS",
        "answer_symbols": []
    },
    "4.6 6": {
        "question": "假设当一个很长的文本串是用移位密码 f(p) = (p + k) mod 26 加密的，在密文中最常出现的字母是 X。假设文本中字母的分布具有典型的英文文本特性，k 最有可能的值是多少？",
        "answer": "Under these assumptions we guess that the plaintext E became the ciphertext X. Since the number for E is 4 and the number for X is 23, k = 23 − 4 = 19.",
        "answer_symbols": [
            "=",
            "−"
        ]
    },
    "4.6 7": {
        "question": "假设当英文文本串是用移位密码 f(p) = (p + k) mod 26 加密的，结果密文是 DY CVOOZ ZOBMRKXXMO DY NBOKW。请问原始明文是什么？",
        "answer": "TO SLEEP PERCHANCE TO DREAM",
        "answer_symbols": []
    },
    "4.6 8": {
        "question": "假设密文 DVE CFMV KF NFEUVI, REU KYRK ZJ KYV JVUU FW JTZVETV 是用移位密码对明文消息加密而成的。请问原始明文是什么？",
        "answer": "Because of the word JVVU we guess that the ciphertext V might be the plaintext E or O. If it is the former, then the shift would have to be 21 − 4 = 17. Applying the inverse of that shift to the message yields MEN LOVE TO WONDER, AND THAT IS THE SEED OF SCIENCE.",
        "answer_symbols": [
            "−",
            "="
        ]
    },
    "4.6 9": {
        "question": "假设密文 ERC WYJMGMRIRXPC EHIZERGIH XIGLRSPSKC MW MRHMWXMRKYMWLEFPFI JVSQ QEKMG 是用移位密码对明文消息加密而成的。请问原始明文是什么？",
        "answer": "ANY SUFFICIENTLY ADVANCED TECHNOLOGY IS INDISTINGUISHABLE FROM MAGIC",
        "answer_symbols": []
    },
    "4.6 10": {
        "question": "判断是否存在这样一个密钥使得移位密码的加密函数和解密函数相同。",
        "answer": "If the enciphering function is f(p) = (p + k) mod 26, then the deciphering function is f^⁻¹(p) = (p − k) mod 26. Thus we seek a k such that k ≡ −k (mod 26), and the unique solution is k = 13.",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "+",
            "−",
            "mod",
            "≡"
        ]
    },
    "4.6 11": {
        "question": "如果一个仿射密码的加密函数是 c = (15p + 13) mod 26，请问其解密函数是什么？",
        "answer": "p = 7c + 13 mod 26",
        "answer_symbols": [
            "=",
            "+",
            "mod"
        ]
    },
    "4.6 12": {
        "question": "找出仿射密码的所有整数对 (a, b) 使得其加密函数 c = (ap + b) mod 26 与相应的解密函数相同。",
        "answer": "If a is the inverse of a modulo 26, then the decryption function for the encryption function c = (ap + b) mod 26 is p = a(c − b) mod 26 = (ac − ab) mod 26. Clearly two different pairs (a, b) cannot give the same encryption function, so we need to solve the system of congruences a ≡ a (mod 26) and b ≡ −ab (mod 26). Only 1 and −1 (which is the same as 25) are their own multiplicative inverses modulo 26 (this can be verified by asking a computer algebra system to compute all the inverses), so there are two cases. If a = 1, then the second congruence becomes b ≡ −b (mod 26), whose solutions are b = 0 and b = 13. This says that the identity function c = p mod 26 satisfies the given condition (although that was obvious and not very interesting), and so does c = (p + 13) mod 26. If a = −1, then the second congruence becomes b ≡ b (mod 26), which is satisfied by all values of b. Therefore all encryption functions of the form c = (−p + b) mod 26 also have themselves as the corresponding decryption function. The answer to the question phrased in terms of pairs is (1, 0), (1, 13), and (−1, b) (or, equivalently, (25, b)) for all b.",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "+",
            "−",
            "mod",
            "≡",
            "≠"
        ]
    },
    "4.6 13": {
        "question": "假设用仿射密码 f(p) = (ap + b) mod 26 加密明文产生的一个长密文中最常出现和次常出现的字母分别是 Z 和 J。请问 a 和 b 的值最有可能是什么？",
        "answer": "a = 18, b = 5",
        "answer_symbols": [
            "=",
            ","
        ]
    },
    "4.6 14": {
        "question": "采用 5 个字母的分组以及基于 (1, 2, 3, 4, 5) 上的置换 σ 的换位密码对消息 GRIZZLY BEARS 进行加密，其中 σ(1) = 3, σ(2) = 5, σ(3) = 1, σ(4) = 2 和 σ(5) = 4。这个练习中需要时用字母 X 填充最后一个少于 5 个字母的分组。",
        "answer": "Within each block of five letters (GRIZZ LYBEA RSXXX) we send the first letter to the third letter, the second letter to the fifth letter, and so on. So the encrypted message is IZGZR BELAY XXRXS.",
        "answer_symbols": [
            "→"
        ]
    },
    "4.6 15": {
        "question": "试解密由 4 个字母的分组和基于 (1, 2, 3, 4) 上的置换 σ 的换位密码加密明文消息产生的密文消息 EABW EFRO ATMRA ASIN，其中 σ(1) = 3, σ(2) = 1, σ(3) = 4 和 σ(4) = 2。",
        "answer": "BEWARE OF MARTIANS",
        "answer_symbols": []
    },
    "4.6 16": {
        "question": "假设你知道密文是由换位密码加密明文产生的。你会如何去破解它？",
        "answer": "One method, using technology, would be to try all possibilities. For n = 2, 3, 4, ..., have the computer go through all n! permutations of {1, 2, 3, ..., n} and for each one permute blocks of n letters of the ciphertext, printing out the resulting plaintext on the computer screen. You, a human, can look at them and figure out which ones make sense as a message.",
        "answer_symbols": [
            "!",
            "→"
        ]
    },
    "4.6 17": {
        "question": "假设你截获了一则密文消息，并且当你在判定这则消息中的字母频率时，发现频率和英文文本的字母频率类似。你会怀疑这里使用了哪种密码？",
        "answer": "可能是某种仿射密码",
        "answer_symbols": []
    },
    "4.6 18": {
        "question": "利用维吉尼亚密码以及密钥 BLUE 加密消息 SNOWFALL。",
        "answer": "The plaintext string in numbers is 18-13-14-22-5-0-11-11. We add the string for the key repeated twice, 1-11-20-4-1-11-20-4, to obtain the string 19-24-8-0-6-11-5-15, which in letters is TYIAGLFP.",
        "answer_symbols": [
            "-",
            "+",
            "=",
            "→"
        ]
    },
    "4.6 19": {
        "question": "利用维吉尼亚密码以及密钥 HOT 加密明文消息所产生的密文是 OIKYWVHBX。请问明文消息是什么？",
        "answer": "HURRICANE",
        "answer_symbols": []
    },
    "4.6 20": {
        "question": "试将维吉尼亚密码表述为密码系统。",
        "answer": "A cryptosystem is a 5-tuple (P, C, K, E, D), as explained in Definition 1. We follow the discussion of Example 7. As there, P and C are strings of elements of Z26. The set of keys is the set of strings over Z26 as well. The set of encryption functions is the set of functions described in the preamble to Exercise 18. The set of decryption functions is the same, because decrypting with the string a-b-c-... is the same as encrypting with the string (-a)-(-b)-(-c)-...",
        "answer_symbols": [
            "(",
            ")",
            "→",
            "−"
        ]
    },
    "4.6 21": {
        "question": "假设当一个很长的文本串用维吉尼亚密码加密时，在密文的不同位置开始可以找到相同的串。试解释这个信息如何能有助于确定密钥的长度。",
        "answer": "密钥的长度可能是重复字符串起始位置之间距离的最大公约数（或其因子）",
        "answer_symbols": [
            "gcd"
        ]
    },
    "4.6 22": {
        "question": "一旦已知维吉尼亚密码的密钥长度，试解释如何确定其每个字符。假设明文足够长，这样其字母的频率合理地接近典型英文文本的字母频率。",
        "answer": "Suppose the length of the key string is l. We can apply the frequency method, explained in Example 5 and the preceding discussion, to the letters in positions 1, 1 + l, 1 + 2l, ... to determine the first letter of the key string (viewed as a number from 0 to 25), then do the same for the second letter, and so on up to the lth letter.",
        "answer_symbols": [
            "→",
            "...",
            "+",
            "="
        ]
    },
    "4.6 23": {
        "question": "证明当我们知道 n 是两个素数 p 和 q 的乘积，并且知道 (p - 1)(q - 1) 的值时，就可以很容易地分解 n 的因子。",
        "answer": "假设我们已知 n = pq 和 (p - 1)(q - 1)。为了找到 p 和 q，首先注意 (p - 1)(q - 1) = pq - p - q + 1 = n - (p + q) + 1。从这里我们可以找到 s = p + q。因为 q = s - p，我们有 n = p(s - p)。因此，p^² - ps + n = 0。现在我们可以使用二次公式来找到 p。一旦找到了 p，我们可以通过 q = n/p 来找到 q。",
        "answer_symbols": [
            "=",
            "-",
            "+",
            "*",
            "²",
            "/",
            "√"
        ]
    },
    "4.6 24": {
        "question": "利用 RSA 系统加密消息 ATTACK，其中 n = 43 · 59 且 e = 13，如例 8 所示，将每个字母翻译成整数，再按整数对分组。",
        "answer": "将字母转换为数字后，我们得到 0019 1900 0210。因此我们需要计算 C = P^13 mod 2537，其中 P 分别为 19、1900 和 210。通过快速模乘法或计算机代数系统进行这些计算的结果分别是 2299、1317 和 2117。因此加密后的消息是 2299 1317 2117。",
        "answer_symbols": [
            "=",
            "^",
            "mod"
        ]
    },
    "4.6 25": {
        "question": "利用 RSA 系统加密消息 UPLOAD，其中 n = 53 · 61 且 e = 17，如例 8 所示，将每个字母翻译成整数，再按整数对分组。",
        "answer": "2545 2757 1211",
        "answer_symbols": []
    },
    "4.6 26": {
        "question": "如果采用 RSA 系统以及 n = 53 · 61 且 e = 17 加密的消息是 3185 2038 2460 2550，则原始消息是什么？（为了解密，首先找出解密指数 d，这是 e = 17 模 52 · 60 的逆。）",
        "answer": "首先我们找到 d，即 e = 17 模 52 * 60 的逆元。计算机代数系统告诉我们 d = 2753。接下来我们让 CAS 计算每个给定数字的 c^d mod n：3185^2753 mod 3233 = 1816（这是字母 SQ），2038^2753 mod 3233 = 2008（这是字母 UI），2460^2753 mod 3233 = 1717（这是字母 RR），2550^2753 mod 3233 = 0411（这是字母 EL）。消息是 SQUIRREL。",
        "answer_symbols": [
            "=",
            "*",
            "mod",
            "^"
        ]
    },
    "4.6 27": {
        "question": "如果采用 RSA 系统以及 n = 43 · 59 且 e = 13 加密的消息是 0667 1947 0671，则原始消息是什么？（为了解密，首先找出解密指数 d，这是 e = 13 模 42 · 58 的逆。）",
        "answer": "SILVER",
        "answer_symbols": []
    },
    "4.6 28": {
        "question": "假设 (n, e) 是 RSA 的加密密钥，n = pq，这里 p 和 q 是大素数且 gcd(e, (p-1)(q-1)) = 1。再者，假设 d 是 e 模 (p-1)(q-1) 的逆。假设 C ≡ M^e (mod pq)。在正文中我们证明了当 gcd(M, pq) = 1 时 RSA 解密函数，即同余式 C^d ≡ M (mod pq) 成立。证明解密同余式当 gcd(M, pq) > 1 时也成立。[提示：利用模 p 和模 q 的同余式，应用中国剩余定理。]",
        "answer": "如果 M ≡ 0 (mod n)，那么 C ≡ M^e ≡ 0 (mod n)，所以 C^d ≡ 0 ≡ M (mod n)。否则，gcd(M, p) = p 且 gcd(M, q) = 1，或者 gcd(M, p) = 1 且 gcd(M, q) = q。由对称性，考虑第一种情况，即 M ≡ 0 (mod p)。我们有 C^d ≡ (M^e)^d ≡ (0^e)^d ≡ 0 ≡ M (mod p)。如同文本中考虑的情况一样，de = 1 + k(p - 1)(q - 1)，对于某个整数 k，所以 C^d ≡ M^(de) ≡ M^(1 + k(p - 1)(q - 1)) ≡ M * M^((q - 1)k(p - 1)) ≡ M * 1 ≡ M (mod q)，根据费马小定理。因此根据中国剩余定理，C^d ≡ M (mod pq)。",
        "answer_symbols": [
            "≡",
            "(",
            ")",
            "+",
            "*",
            "-",
            "mod",
            "^"
        ]
    },
    "4.6 29": {
        "question": "试描述当 Alice 和 Bob 利用迪菲-赫尔曼密钥交换协议来生成一个共享密钥时的步骤。假设采用素数 p = 23，a = 5，即 23 的一个原根，并且 Alice 选择 k₁ = 8 而 Bob 选择 k₂ = 5。（可以需要借助于计算工具。）",
        "answer": "Alice 发送 5^⁸ mod 23 = 16 给 Bob。Bob 发送 5^⁵ mod 23 = 20 给 Alice。Alice 计算 20^⁸ mod 23 = 6 并且 Bob 计算 16^⁵ mod 23 = 6。共享密钥是 6。",
        "answer_symbols": [
            "mod",
            "=",
            "^"
        ]
    },
    "4.6 30": {
        "question": "试描述当 Alice 和 Bob 利用迪菲-赫尔曼密钥交换协议来生成一个共享密钥时的步骤。假设采用素数 p = 101，a = 2，即 101 的一个原根，并且 Alice 选择 k₁ = 7 而 Bob 选择 k₂ = 9。（可以需要借助于计算工具。）",
        "answer": "我们按照文本中的步骤进行，p = 101，a = 2，k1 = 7，k2 = 9。使用 Maple，我们验证 2 是模 101 的原根，因为当 k 从 0 到 99 时，2^k 产生不同的值（当然 2^100 mod 101 = 1）。我们发现 2^7 mod 101 = 27。所以在步骤(2)中，Alice 发送 27 给 Bob。同样，在步骤(3)中，Bob 发送 2^9 mod 101 = 7 给 Alice。在步骤(4)中，Alice 计算 7^7 mod 101 = 90，而在步骤(5)中，Bob 计算 27^9 mod 101 = 90。这些当然是相同的，因此 90 是共享密钥。",
        "answer_symbols": [
            "=",
            "mod",
            "^"
        ]
    },
    "4.6 31": {
        "question": "Alice 想要给她所有朋友包括 Bob 发送消息“SELL EVERYTHING”以便他知道是她发送的。假设她利用 RSA 密码系统在消息上签名，她应该给她的朋友发送什么？",
        "answer": "2186 2087 1279 1251 0326 0816 1948",
        "answer_symbols": []
    },
    "4.6 32": {
        "question": "Alice 想要给 Bob 发送消息“BUY NOW”以便他知道是她发送的并且只有 Bob 能够阅读。假设她在消息上签名并利用 Bob 的公钥加密，她应该给 Bob 发送什么？",
        "answer": "当分解成块并转换为数字时，消息是 0120 2413 1422。Alice 应用她的解密变换 D(2867,7)(x) = x^1183 mod 2867 对每一块进行处理，我们使用 CAS 计算得到 1665 1728 2123。然后她应用 Bob 的加密变换 E(3127,21)(x) = x^21 mod 3127 对每一块进行处理，我们使用 CAS 计算得到 2806 1327 0412。她将这个发送给 Bob。只有 Bob 能读取它，他通过首先应用他的解密变换 D(3127,21)(x) = x^1149 mod 3127 对每一块进行处理，恢复 1665 1728 2123，然后应用 Alice 的加密变换 E(2867,7)(x) = x^7 mod 2867 对每一块进行处理，恢复原始的 0120 2413 1422，BUY NOW。",
        "answer_symbols": [
            "=",
            "mod",
            "^"
        ]
    },
    "4.6 33": {
        "question": "我们现在描述采用私钥密码学的一个基本密钥交换协议，许多更复杂的密钥交换协议都基于此。协议中的加密是采用被认为是安全的私钥密码系统（如 AES）完成的。协议涉及三方：Alice 和 Bob，他们希望交换的密钥，以及一个可信的第三方 Cathy。假设 Alice 拥有只有她和 Cathy 知道的密钥 k_Alice，而 Bob 拥有只有他和 Cathy 知道的密钥 k_Bob。协议分三个步骤：(i) Alice 给可信的第三方 Cathy 发送一则用 Alice 的密钥 k_Alice 加密的消息“请求与 Bob 共享一个密钥”。(ii) Cathy 返回 Alice 一个密钥 k_Alice, Bob，这是她生成并用密钥 k_Alice 加密的，接着发送同一个密钥 k_Alice, Bob，这次是用 Bob 的密钥 k_Bob 加密的。(iii) Alice 给 Bob 发送密钥 k_Alice, Bob，就是用只有 Bob 和 Cathy 知道的 k_Bob 加密的密钥。试解释为什么这个协议允许 Alice 和 Bob 共享只有他们和 Cathy 知道的私钥 k_Alice, Bob。",
        "answer": "Alice 可以解密 Cathy 消息的第一部分以了解密钥，而 Bob 可以解密 Alice 转发给他的 Cathy 消息的第二部分以了解密钥。除了 Cathy 之外，没有人可以了解密钥，因为所有这些通信都使用安全的私钥。",
        "answer_symbols": []
    },
    "4 Supplementary Exercises 19": {
        "question": "证明每个大于 11 的整数是两个合数之和。",
        "answer": "每个大于 11 的数都可以写成 8 + 2n 或 9 + 2n 的形式，其中 n ≥ 2。",
        "answer_symbols": [
            "+",
            "≥"
        ]
    },
    "4 Supplementary Exercises 20": {
        "question": "试找出五个最小的连续的合数。",
        "answer": "这个问题是要求差值为6的最小一对质数。查看质数表告诉我们这些是23和29，因此五个最小的连续合数整数是24、25、26、27和28。",
        "answer_symbols": []
    },
    "4 Supplementary Exercises 3": {
        "question": "找出四个与 5 模 17 同余的数。",
        "answer": "5, 22, -12, -29",
        "answer_symbols": [
            ","
        ]
    },
    "4 Supplementary Exercises 4": {
        "question": "证明如果 a 和 d 为正整数，则存在整数 q 和 r 使得 a = d⋅q + r，其中 -d/2 < r ≤ d/2。",
        "answer": "设 q = 向上取整((a - 1) / 2) 和 r = a - dq。那么我们已经强制 a = dq + r，剩下需要证明的是 -d/2 < r ≤ d/2。现在由于 q - 1 < (a - 1) / 2 ≤ q，我们有（通过两边乘以 d 并加上 d/2）dq - d/2 < a ≤ dq + d/2，所以 -d/2 < a - dq ≤ d/2，正如所愿。",
        "answer_symbols": [
            "=",
            "/",
            "<",
            "≤",
            "+",
            "-"
        ]
    },
    "4 Supplementary Exercises 5": {
        "question": "证明如果 a⋅c ≡ b⋅c (mod m)，其中 a, b, c 和 m 是整数且 m > 2, d = gcd(m, c)，则 a ≡ b (mod m/d)。",
        "answer": "因为 ac ≡ bc (mod m)，存在一个整数 k 使得 ac = bc + km。因此 a - b = km / c。因为 a - b 是一个整数，c | km。令 d = gcd(m, c)，写成 c = de。因为 e 的任何因数都不能除尽 m / d，所以 d | m 且 e | k。因此 a - b = (k / e)(m / d)，其中 k / e ∈ Z 且 m / d ∈ Z。因此 a ≡ b (mod m / d)。",
        "answer_symbols": [
            "≡",
            "=",
            "+",
            "*",
            "/",
            "∈",
            "gcd"
        ]
    },
    "4 Supplementary Exercises 6": {
        "question": "证明两个奇数的平方和不可能是一个整数的平方。",
        "answer": "根据第4.1节练习38，一个整数的平方模 4 同余于 0 或 1，显然奇数的平方模 4 同余于 1。这两个数的和因此同余于 2 模 4，所以不能是一个平方数。",
        "answer_symbols": [
            "≡",
            "mod",
            "+"
        ]
    },
    "4 Supplementary Exercises 7": {
        "question": "证明如果 n^² + 1 是完全数，其中 n 是整数，则 n 是偶数。",
        "answer": "证明反面：如果 n 是奇数，则 n = 2k + 1，对于某个整数 k。因此 n^² + 1 = (2k + 1)^² + 1 = 4k^² + 4k + 2 ≡ 2 (mod 4)。但偶数的完全平方在模 4 下同余于 0（因为 (2m)^² = 4m^²），奇数的完全平方在模 4 下同余于 1 或 3，所以 n^² + 1 不是一个完全平方数。",
        "answer_symbols": [
            "≡",
            "=",
            "+",
            "*",
            "²",
            "mod"
        ]
    },
    "4 Supplementary Exercises 8": {
        "question": "证明方程 x^² - 5y^² = 2 没有 x 和 y 的整数解。[提示：考虑该方程模 5 的情况。]",
        "answer": "如果这个方程有整数解，那么根据定义我们会有 x^² ≡ 2 (mod 5)。然而，我们很容易计算出（如第4.1节的习题40所示），形式为5k的整数的平方对5同余于0；形式为5k+1的整数的平方对5同余于1；形式为5k+2的整数的平方对5同余于4；形式为5k+3的整数的平方对5同余于4；形式为5k+4的整数的平方对5同余于1。这是一个矛盾，因此不存在解。",
        "answer_symbols": [
            "≡",
            "+",
            "(",
            ")",
            "k",
            "x",
            "5",
            "2",
            "4",
            "1",
            "0"
        ]
    },
    "4 Supplementary Exercises 9": {
        "question": "基于二进制展开式设计一个正整数能被 8 整除的整除性测试。",
        "answer": "n 能被 8 整除当且仅当 n 的二进制表示以 000 结尾。",
        "answer_symbols": [
            "≡"
        ]
    },
    "4 Supplementary Exercises 10": {
        "question": "基于二进制展开式设计一个正整数能被 3 整除的整除性测试。",
        "answer": "数字3在二进制中扮演的角色与数字11在十进制中的角色相同（基本上因为 (11)^² = 3）。十进制中11的可除性测试是 d_n d_(n-1)... d_2 d_1 d_0 可以被11整除当且仅当交错和 d_0 - d_1 + d_2 - ... + (-1)^n d_n 可以被11整除。相应的规则是 (d_n d_(n-1)... d_2 d_1 d_0)_2 可以被3整除当且仅当交错和 d_0 - d_1 + d_2 - ... + (-1)^n d_n 可以被3整除。例如，27 = (11011)_2 可以被3整除，因为 1 - 1 + 0 - 1 + 1 = 0 可以被3整除。证明来自于 2^n - 1 ≡ 0 (mod 3) 当n为偶数时，2^n + 1 ≡ 0 (mod 3) 当n为奇数时。因此我们有 (d_n d_(n-1)... d_2 d_1 d_0)_2 = d_0 + 2d_1 + 2^2 d_2 + 2^3 d_3 + ... + 2^n d_n = d_0 + (3k_1 - 1)d_1 + (3k_2 + 1)d_2 + (3k_3 - 1)d_3 + ... + (3k_n + (-1)^n)d_n = [d_0 - d_1 + d_2 - ... + (-1)^n d_n] + [3(k_1 d_1 + k_2 d_2 + k_3 d_3 + ... + k_n d_n)] 对于整数 k_1 = 1, k_2 = 1, k_3 = 3, k_4 = 5, k_5 = 11, .... 第二个括号内的表达式总是可以被3整除，所以整个数可以被3整除当且仅当交错和可以被3整除。",
        "answer_symbols": [
            "²",
            "=",
            "+",
            "-",
            "(",
            ")",
            "n",
            "d",
            "2",
            "1",
            "0",
            "3",
            "k",
            "^",
            "≡",
            "mod"
        ]
    },
    "4 Supplementary Exercises 11": {
        "question": "设计一个算法通过连续猜测二进制展开式中的每位来猜测一个 1 和 2^n - 1 之间的数。",
        "answer": "假设有人选择了一个小于 2^n 的正整数，我们要猜这个数。我们让这个人用前导零将其写成 n 位的二进制数。然后我们问“第一位是 1 吗？”，“第二位是 1 吗？”，“第三位是 1 吗？”等等。当我们知道这 n 个问题的答案后，我们就会知道这个数，因为我们知道了它的二进制表示。",
        "answer_symbols": [
            "="
        ]
    },
    "4 Supplementary Exercises 12": {
        "question": "在通过连续猜测二进制展开式中的每位来猜测一个 1 和 2^n - 1 之间的数的过程中，试按所需猜测次数确定其复杂度。",
        "answer": "从习题11可以看出，最多需要n个问题（猜测）。此外，至少也需要这么多的“是/否”问题，因为如果我们问的问题少于n个，那么根据鸽巢原理，两个数字会产生相同的答案集，我们无法准确地猜出数字。因此复杂度是n个问题。（不包括n=0的情况，因为在那种情况下不需要任何问题。）在整个练习和前一个练习中，我们都假设“之间”的含义是包含性的。",
        "answer_symbols": [
            "=",
            "<",
            ">",
            "n",
            "k"
        ]
    },
    "4 Supplementary Exercises 13": {
        "question": "证明一个整数能被 9 整除当且仅当其十进制数字之和能被 9 整除。",
        "answer": "(aₙ aₙ₋₁ ... a₁ a₀)₁₀ = ∑ₖ₌₀^ⁿ 10ᵏ aₖ ≡ ∑ₖ₌₀^ⁿ aₖ (mod 9)，因为对于每一个非负整数 k，10ᵏ ≡ 1 (mod 9)。",
        "answer_symbols": [
            "≡",
            "=",
            "∑",
            "ₖ",
            "₌",
            "ⁿ",
            "₁₀",
            "ₖ",
            "ₖ",
            "ₖ",
            "ₖ",
            "mod"
        ]
    },
    "4 Supplementary Exercises 14": {
        "question": "证明如果 a 和 b 是正无理数使得 1/a + 1/b = 1，则每个正整数都可以唯一表示为 [ka] 或 [kb]，其中 k 是正整数。",
        "answer": "首先注意，由于a和b都必须大于1，因此序列 {ka} 和 {kb} 不会列出任何正整数两次。问题是是否有任何正整数同时列在两个序列中，或者是否有某些正整数完全被省略。设N(x, n)表示集合 {kx | k 是正整数} 中小于或等于n的正整数的数量。那么只需证明对于所有正整数n，N(a, n) + N(b, n) = n。（这样当我们考虑所有数ka和kb时，就不会有正整数被遗漏或重复出现。）现在N(a, n)是满足ka < n + 1的正整数k的数量，因为a是无理数，这显然是 (n + 1)/a 的下取整。我们对b也有类似的结果。设f(x)表示x的小数部分（即 f(x) = x - [x]）。那么我们有 N(a, n) + N(b, n) = [(n + 1)/a] + [(n + 1)/b] = (n + 1)/a - f((n + 1)/a) + (n + 1)/b - f((n + 1)/b)。但是右边第一项和第三项的和是n + 1，因为我们已知 (1/a) + (1/b) = 1。第二项和第四项都是严格介于0和1之间的分数，整个表达式是一个整数，所以它们的和必须是1。因此显示的值是 n + 1 - 1 = n，正如所期望的那样。",
        "answer_symbols": [
            "<",
            "+",
            ">",
            "n",
            "k",
            "a",
            "b",
            "x",
            "f",
            "[",
            "]",
            "(",
            ")",
            "/",
            "-"
        ]
    },
    "4 Supplementary Exercises 15": {
        "question": "通过证明 Q_n = n! + 1 必定有大于 n 的素因子，其中 n 是正整数，从而证明存在无限多个素数。",
        "answer": "因为对于所有 k ≤ n，当 Qₙ 被 k 除时，余数为 1，所以小于或等于 n 的任何质数都不是 Qₙ 的因数。因此，根据算术基本定理，Qₙ 必须有一个大于 n 的质因数。",
        "answer_symbols": [
            "≤",
            "≠",
            "∈",
            "∃",
            "∀"
        ]
    },
    "4 Supplementary Exercises 16": {
        "question": "试找出一个正整数 n 使得 Q_n = n! + 1 不是素数。",
        "answer": "这些数的前几个是 Q1 = 2, Q2 = 3, Q3 = 7, Q4 = 25, 和 Q5 = 121。虽然前三个是素数，但接下来的两个不是。事实上，计算机代数系统告诉我们，Q4 到 Q10 = 3,628,801 = 11 * 329,891 都不是素数。前100个中唯一的其他素数是 Q11, Q27, Q37, Q41, Q73, 和 Q77。",
        "answer_symbols": [
            "=",
            "*",
            "Q",
            "1",
            "2",
            "3",
            "4",
            "5",
            "10",
            "11",
            "27",
            "37",
            "41",
            "73",
            "77"
        ]
    },
    "4 Supplementary Exercises 17": {
        "question": "利用狄利克雷定理，即在算术级数 ak + b 中存在无限多个素数，其中 gcd(a, b) = 1，证明存在无限多个十进制展开式最后一位是 1 的素数。",
        "answer": "取 a = 10 和 b = 1 在狄利克雷定理中。",
        "answer_symbols": [
            "=",
            "∈"
        ]
    },
    "4 Supplementary Exercises 18": {
        "question": "证明如果 n 是一个正整数使得 n 的因子之和是 n + 1，则 n 是素数。",
        "answer": "我们可以通过反证法给出一个很好的证明，即如果n不是素数，则其除数之和不是n + 1。有两种情况。如果n = 1，那么除数之和是1 ≠ 1 + 1。否则n是合数，因此可以写成 n = ab，其中a和b都是n的不同于1和n本身的除数。第112章 数论与密码学（尽管可能会出现a = b的情况）。那么n至少有三个不同的除数：1、a和n，它们的和显然不等于n + 1。这完成了反证法的证明。还应该注意的是，这个陈述的逆命题也是正确的：如果n是质数，那么它的除数之和为n + 1（因为它的唯一除数是1和它本身）。",
        "answer_symbols": [
            "n",
            "=",
            "≠",
            "b",
            "a",
            "+"
        ]
    },
    "4 Supplementary Exercises 21": {
        "question": "证明哥德巴赫猜想（即每个大于 2 的偶数是两个素数之和）等价于语句每个大于 5 的整数是三个素数之和。",
        "answer": "假设每个大于 2 的偶数都是两个素数的和，并设 n 是一个大于 5 的整数。如果 n 是奇数，写成 n = 3 + (n - 3) 并将 n - 3 = p + q 分解成两个素数的和；如果 n 是偶数，写成 n = 2 + (n - 2) 并将 n - 2 = p + q 分解成两个素数的和。对于逆命题，假设每个大于 5 的整数都是三个素数的和，并设 n 是一个大于 2 的偶数。写成 n + 2 为三个素数的和，其中一个必然是 2，所以 n + 2 = 2 + p + q，从而 n = p + q。",
        "answer_symbols": [
            "+",
            "=",
            "∈"
        ]
    },
    "4 Supplementary Exercises 22": {
        "question": "试找出以 7 开始长度为 6 只包含素数的算术级数。",
        "answer": "使用计算机代数系统，如Maple及其循环能力和内置的质数测试器，是解决这个问题的唯一合理方法。答案是7、37、67、97、127、157（即公差为30）。对于七个质数的类似问题，公差为150。对八个质数等差序列的搜索发现一个起始值为17，公差为6930。",
        "answer_symbols": []
    },
    "4 Supplementary Exercises 23": {
        "question": "证明如果 f(x) 是整系数非常量多项式，则存在整数 y 使得 f(y) 是合数。[提示：假设 f(x_0) = p 是素数。证明 p 整除 f(x_0 + k⋅p) 对所有 k 成立。从而得到与下列事实矛盾，即 n 次多项式在每个值最多取 n 次，其中 n > 1。]",
        "answer": "回忆一下，非常数多项式只能在有限次数内取相同的值。因此 f 只能在有限次数内取值 0 和 ±1，所以如果没有某个 y 使得 f(y) 是合数，那么必须存在某个 x₀ 使得 ±f(x₀) 是素数，设为 p。考虑 f(x₀ + kp)。当我们将 x₀ + kp 代入多项式并展开时，除了形成 f(x₀) 的项外，每一项都包含 p 的因子。因此 f(x₀ + kp) = f(x₀) + mp = (m ± 1)p 对于某个整数 m。随着 k 的变化，这个值只能在有限次内为 0、p 或 -p；因此它必须在某些 k 的值下是合数。",
        "answer_symbols": [
            "±",
            "=",
            "+",
            "∈",
            "∀",
            "∃"
        ]
    },
    "4 Supplementary Exercises 24": {
        "question": "在 100_p! 的二进制展开式中尾部有多少个 0？",
        "answer": "每个因数2在1到100的所有数字中都会在这个数字的末尾产生一个0。我们这样计算它们。所有偶数都有一个因数2，而100/2 = 50这样的数字。所有4的倍数还有另一个因数2，而100/4 = 25这样的数字。所有8的倍数还有另一个因数2，而100/8 = 12这样的数字，等等。因此答案是50 + 25 + 12 + 6 + 3 + 1 = 97。",
        "answer_symbols": [
            "/",
            "+",
            "="
        ]
    },
    "4 Supplementary Exercises 25": {
        "question": "用欧几里得算法求 10 233 和 33 341 的最大公约数。",
        "answer": "1",
        "answer_symbols": []
    },
    "4 Supplementary Exercises 26": {
        "question": "用欧几里得算法求 gcd(144, 233) 要做多少次除法？",
        "answer": "我们需要依次除以233、144、89、55、34、21、13、8、5、3、2和1，总共12次除法。",
        "answer_symbols": [
            "/"
        ]
    },
    "4 Supplementary Exercises 27": {
        "question": "求 gcd(2n + 1, 3n + 2)，其中 n 是正整数。[提示：用欧几里得算法。]",
        "answer": "1",
        "answer_symbols": []
    },
    "4 Supplementary Exercises 28 a)": {
        "question": "证明如果 a 和 b 为正整数，且 a ≥ b，则当 a = b 时 gcd(a, b) = a；当 a 和 b 都是偶数时 gcd(a, b) = 2⋅gcd(a/2, b/2)；当 a 为偶数 b 为奇数时 gcd(a, b) = gcd(a/2, b)；当 a 和 b 都是奇数时 gcd(a, b) = gcd(a - b, b)。",
        "answer": "第一个陈述很明显。对于第二个，如果a和b都是偶数，那么2显然是它们的最大公约数的一个因子，而补足因子必须是去掉这个2后得到的数字的最大公约数。对于第三个陈述，如果a是偶数而b是奇数，那么a中的2因子不会出现在最大公约数中，因此我们可以忽略它。最后一条陈述从第4.3节的引理1得出，取q = 1（尽管记号如此，引理1中的q不需要是商）。",
        "answer_symbols": [
            "=",
            "+"
        ]
    },
    "4 Supplementary Exercises 28 b)": {
        "question": "试解释如何利用 a) 来构造一个算法，不用除法，只用二进制展开式的比较、减法和移位来求两个正整数的最大公约数。",
        "answer": "实现部分(a)的算法所需的所有步骤都只需要比较、减法和偶数除以2的除法。由于除以2是一个向右移动一位的操作，这里提到的操作是唯一使用的。（注意该算法还需要两个额外的简化：如果a是奇数且b是偶数，则gcd(a, b) = gcd(a, b/2)，如果a < b，则交换a和b。）",
        "answer_symbols": [
            "<",
            "=",
            "/"
        ]
    },
    "4 Supplementary Exercises 2 a)": {
        "question": "试解释为什么 n div 7 等于 n 天中所含的完整的星期数。",
        "answer": "每周有七天。因此要找出 n 天中有多少个（完整的）星期，我们需要看 n 中有多少个 7。这正是 n div 7 告诉我们的。",
        "answer_symbols": [
            "div"
        ]
    },
    "4 Supplementary Exercises 2 b)": {
        "question": "试解释为什么 n div 24 等于 n 小时中所含的完整的天数。",
        "answer": "每天有 24 小时。因此要找出 n 小时中有多少个（完整的）天，我们需要看 n 中有多少个 24。这正是 n div 24 告诉我们的。",
        "answer_symbols": [
            "div"
        ]
    },
    "4 Supplementary Exercises 28 c)": {
        "question": "用这一算法求 gcd(1202, 4848)。",
        "answer": "我们将算法的操作表示为一串等式；每个等式是一个步骤。gcd(1202, 4848) = gcd(4848, 1202) = 2 gcd(2424, 601) = 2 gcd(1212, 601) = 2 gcd(606, 601) = 2 gcd(303, 601) = 2 gcd(601, 303) = 2 gcd(298, 303) = 2 gcd(303, 298) = 2 gcd(303, 149) = 2 gcd(154, 149) = 2 gcd(77, 149) = 2 gcd(149, 77) = 2 gcd(72, 77) = 2 gcd(77, 72) = 2 gcd(77, 36) = 2 gcd(77, 18) = 2 gcd(77, 9) = 2 gcd(68, 9) = 2 gcd(34, 9) = 2 gcd(17, 9) = 2 gcd(8, 9) = 2 gcd(9, 8) = 2 gcd(9, 4) = 2 gcd(9, 2) = 2 gcd(9, 1) = 2 gcd(8, 1) = 2 gcd(4, 1) = 2 gcd(2, 1) = 2 gcd(1, 1) = 2",
        "answer_symbols": [
            "="
        ]
    },
    "4 Supplementary Exercises 29": {
        "question": "改编(4.3 节定理 3)存在无限多个素数的证明来证明存在无限多个形如 6k+5 的素数，k=1, 2, …。",
        "answer": "如果 q₁, q₂, ..., qₙ 是所有形式为 6k + 5 的素数。令 Q = 6q₁q₂ ... qₙ - 1。注意 Q 是形式为 6k + 5 的数，其中 k = q₁q₂ ... qₙ - 1。令 Q = p₁p₂ ... pₜ 是 Q 的质因数分解。没有 pᵢ 是 2、3 或任何 qⱼ，因为 Q 被 2 除余 1，被 3 除余 2，被 qⱼ 除余 qⱼ - 1。除了 3 以外的所有奇素数都是形式为 6k + 1 或 6k + 5 的数，且形式为 6k + 1 的素数的乘积也是这种形式。因此至少有一个 pᵢ 必须是形式为 6k + 5 的数，矛盾。",
        "answer_symbols": [
            "+",
            "-",
            "≠",
            "≡",
            "∈",
            "∀",
            "∃"
        ]
    },
    "4 Supplementary Exercises 30": {
        "question": "试解释为什么不能直接改编(4.3 节定理 3)存在无限多个素数的证明来证明在算术级数 3k+1 中存在无限多个素数，k=1, 2, …。",
        "answer": "让我们尝试第4.3节定理3证明中使用的方法。假设p1, p2, ..., pn是形式为3k + 1的仅有质数。注意到这种形式的质数的乘积再次具有这种形式，因为(3k1 + 1)(3k2 + 1) = 9k1k2 + 3k1 + 3k2 + 1 = 3(3k1k2 + k1 + k2) + 1。我们可以尝试查看3p1p2 ... pn + 1，它再次具有这种形式。根据算术基本定理，它有质因数，显然没有pi是其因数。不幸的是，我们不能保证它的任何质因数都是形式为3k + 1的。因为两个不是这种形式的质数（即形式为 3k + 2）的乘积是形式为 3k + 1；实际上，(3k1 + 2)(3k2 + 2) = 9k1k2 + 6k1 + 6k2 + 4 = 3(3k1k2 + 2k1 + 2k2 + 1) + 1。因此证明在此处失败。",
        "answer_symbols": [
            "(",
            "=",
            ")",
            "*",
            "+"
        ]
    },
    "4 Supplementary Exercises 31": {
        "question": "试解释为什么不能直接改编(4.3 节定理 3)存在无限多个素数的证明来证明在算术级数 4k+1 中存在无限多个素数，k=1, 2, …。",
        "answer": "形式为 4k + 1 的数的乘积也是形式为 4k + 1 的数，但这种形式的数可能只有不是这种形式的数作为它们的唯一质因数。例如，49 = 4 * 12 + 1，但 49 的质因数分解是 7 * 7 = (4 * 1 + 3)(4 * 1 + 3)。",
        "answer_symbols": [
            "+",
            "=",
            "*"
        ]
    },
    "4 Supplementary Exercises 32": {
        "question": "证明如果正整数 n 的最小素因子 p 大于 √n，则 n/p 是素数或等于 1。",
        "answer": "我们通过反证法给出证明。假设 p > √3n，其中 p 是 n 的最小质因数，但 n/p 不是质数且不等于 1。那么 p^³ > n，所以 p^² > n/p。根据我们的假设，n/p = a * b，其中 a, b > 1。因为 a * b < p^²，a 和 b 中至少有一个小于 p；不妨设它是 a。那么 a 是 n 的一个比 p 小的除数，因此 a 的任何质因数都是 n 的比 p 小的质因数，这与我们的假设矛盾。",
        "answer_symbols": [
            ">",
            "<",
            "=",
            "*",
            "/",
            "√",
            "(",
            ")"
        ]
    },
    "4 Supplementary Exercises 33 a)": {
        "question": "判断下列各组整数是否是互素的。（a）8, 10, 12",
        "answer": "不互质",
        "answer_symbols": [
            "∈"
        ]
    },
    "4 Supplementary Exercises 33 b)": {
        "question": "判断下列各组整数是否是互素的。（b）12, 15, 25",
        "answer": "互质",
        "answer_symbols": [
            "∈"
        ]
    },
    "4 Supplementary Exercises 33 c)": {
        "question": "判断下列各组整数是否是互素的。（c）15, 21, 28",
        "answer": "互质",
        "answer_symbols": [
            "∈"
        ]
    },
    "4 Supplementary Exercises 33 d)": {
        "question": "判断下列各组整数是否是互素的。（d）21, 24, 28, 32",
        "answer": "互质",
        "answer_symbols": [
            "∈"
        ]
    },
    "4 Supplementary Exercises 34": {
        "question": "找一组 4 个互素的整数使得其中任何两个都不是互素的。",
        "answer": "我们需要安排四个数字中的每一对都有一个共同因子。有六对这样的数字，因此我们可以使用前六个质数作为共同因子。设这些数字为 a, b, c 和 d。我们将给 a 和 b 一个共同因子 2；a 和 c 一个共同因子 3；a 和 d 一个共同因子 5；b 和 c 一个共同因子 7；b 和 d 一个共同因子 11；c 和 d 一个共同因子 13。实现这一点的最简单方法是让 a = 2 * 3 * 5 = 30；b = 2 * 7 * 11 = 154；c = 3 * 7 * 13 = 273；d = 5 * 11 * 13 = 715。这些数字是互质的，因为没有一个数字是所有数字的因子（实际上，每个质数只作为其中两个数字的因子）。当然，还有许多其他可能的例子。",
        "answer_symbols": [
            "*",
            "=",
            "(",
            ")",
            ","
        ]
    },
    "4 Supplementary Exercises 35": {
        "question": "哪些正整数能使得 n^⁴+4^ⁿ 是素数?",
        "answer": "1",
        "answer_symbols": []
    },
    "4 Supplementary Exercises 36": {
        "question": "证明同余方程组 x≡2(mod 6) 和 x≡3(mod 9) 无解。",
        "answer": "如果 x ≡ 3 (mod 9)，那么 x = 3 + 9t，对于某个整数 t。这个方程告诉我们 3 | x。另一方面，第一个同余式说 x = 2 + 6s = 2 + 3 * (2s)，对于某个整数 s，这意味着 x 被 3 除的余数是 2。显然这两个结论是不一致的，因此这两个同余式没有同时的解。",
        "answer_symbols": [
            "≡",
            "+",
            "*",
            "=",
            "(",
            ")",
            "|",
            "mod"
        ]
    },
    "4 Supplementary Exercises 37": {
        "question": "找出同余方程组 x≡4(mod 6) 和 x≡13(mod 15) 的所有解。",
        "answer": "x ≡ 28 (mod 30)",
        "answer_symbols": [
            "≡",
            "mod"
        ]
    },
    "4 Supplementary Exercises 38 a)": {
        "question": "证明同余方程组 x≡a₁(mod m₁) 和 x≡a₂(mod m₂) 有解当且仅当 gcd(m₁, m₂) | a₁-a₂。",
        "answer": "这里有两个要证明的事情。首先假设 gcd(m1, m2) | a1 - a2；设 a1 - a2 = k * gcd(m1, m2)。根据第 4.3 节的定理 6，存在整数 s 和 t 使得 gcd(m1, m2) = s * m1 + t * m2。将两边都乘以 k 并代入我们的第一个方程，我们得到 a1 - a2 = k * s * m1 + k * t * m2，可以重写为 a1 - k * s * m1 = a2 + k * t * m2。这个共同值显然与 a1 模 m1 同余，并且与 a2 模 m2 同余，因此它是给定系统的解。反之，假设该系统有一个解 x。那么 x = a1 + s * m1 = a2 + t * m2，对于某些整数 s 和 t。这说明 a1 - a2 = t * m2 - s * m1。但是 gcd(m1, m2) 整除 m1 和 m2，因此也整除这个最后一个等式的右边。因此它也整除左边，a1 - a2，如我们所愿。",
        "answer_symbols": [
            "|",
            "=",
            "+",
            "*",
            "-",
            "(",
            ")",
            "gcd",
            "mod"
        ]
    },
    "4 Supplementary Exercises 38 b)": {
        "question": "证明如果 a) 中方程组有解，则解在模 lcm(m₁, m₂) 下是唯一的。",
        "answer": "我们遵循第 4.4 节练习 29 和 30 中概述的想法。首先我们证明如果 a ≡ b (mod m1) 和 a ≡ b (mod m2)，那么 a ≡ b (mod lcm(m1, m2))。第一个假设说 m1 | a - b；第二个假设说 m2 | a - b。因此 a - b 是 m1 和 m2 的公倍数。如果 a - b 不是 lcm(m1, m2) 的倍数，那么 (a - b) mod lcm(m1, m2) 也是一个公倍数，这与 lcm(m1, m2) 的定义相矛盾。因此 a - b 是 lcm(m1, m2) 的倍数，即 a ≡ b (mod lcm(m1, m2))。现在假设给定的同余系统有两个解。根据我们刚才证明的，由于这两个解模 m1 同余（因为它们都与 a1 同余）并且模 m2 同余（因为它们都与 a2 同余），它们必须模 lcm(m1, m2) 同余。这正是我们想要证明的。",
        "answer_symbols": [
            "≡",
            "|",
            "+",
            "*",
            "-",
            "(",
            ")",
            "lcm",
            "mod"
        ]
    },
    "4 Supplementary Exercises 39": {
        "question": "证明对于每个非负整数 n 有 30 整除 n^⁶-n。",
        "answer": "根据中国剩余定理，只需证明 n^⁹ - n ≡ 0 (mod 2)，n^⁹ - n ≡ 0 (mod 3)，和 n^⁹ - n ≡ 0 (mod 5)。每一种情况都可以通过应用费马小定理得出。",
        "answer_symbols": [
            "≡",
            "mod",
            "⁹",
            "-"
        ]
    },
    "4 Supplementary Exercises 40": {
        "question": "证明每个满足 gcd(n, 35)=1 的整数 n 有 n¹^²-1 可被 35 整除。",
        "answer": "注意 35 的质因数分解是 5 * 7。因此，只要证明 5 | n^12 - 1 和 7 | n^12 - 1 对于与 5 和 7 互质的整数 n 即可。对于这样的整数，费马小定理告诉我们 n^4 ≡ 1 (mod 5) 和 n^6 ≡ 1 (mod 7)。那么我们有 n^12 - 1 ≡ (n^4)^3 - 1 ≡ 1^3 - 1 = 0 (mod 5) 和 n^12 - 1 ≡ (n^6)^2 - 1 ≡ 1^2 - 1 = 0 (mod 7)。",
        "answer_symbols": [
            "|",
            "=",
            "^",
            "-",
            "(",
            ")",
            "≡",
            "mod"
        ]
    },
    "4 Supplementary Exercises 41": {
        "question": "证明如果 p 和 q 是不同的素数，则 p^(q-1)+q^(p-1)≡1(mod pq)。",
        "answer": "根据费马小定理，p^^⁽q-1^⁾ ≡ 1 (mod q) 且显然 q^^⁽p-1^⁾ ≡ 0 (mod q)。因此 p^^⁽q-1^⁾ + q^^⁽p-1^⁾ ≡ 1 + 0 = 1 (mod q)。类似地，p^^⁽q-1^⁾ + q^^⁽p-1^⁾ ≡ 1 (mod p)。根据中国剩余定理，p^^⁽q-1^⁾ + q^^⁽p-1^⁾ ≡ 1 (mod pq)。",
        "answer_symbols": [
            "≡",
            "mod",
            "⁽",
            "⁾",
            "+",
            "*"
        ]
    },
    "4 Supplementary Exercises 42 a)": {
        "question": "试判断下列 13 位数字是否是合法的 ISBN-13。（a）978-0-073-20679-1",
        "answer": "(9 + 8 + 0 + 3 + 0 + 7 + 1) + 3(7 + 0 + 7 + 2 + 6 + 9) mod 10 = 1; invalid",
        "answer_symbols": [
            "+",
            "*",
            "mod"
        ]
    },
    "4 Supplementary Exercises 42 b)": {
        "question": "试判断下列 13 位数字是否是合法的 ISBN-13。（b）978-0-45424-521-1",
        "answer": "(9 + 8 + 4 + 4 + 4 + 2 + 1) + 3(7 + 0 + 5 + 2 + 5 + 1) mod 10 = 2; invalid",
        "answer_symbols": [
            "+",
            "*",
            "mod"
        ]
    },
    "4 Supplementary Exercises 42 c)": {
        "question": "试判断下列 13 位数字是否是合法的 ISBN-13。（c）978-3-16-148410-0",
        "answer": "(9 + 8 + 1 + 1 + 8 + 1 + 0) + 3(7 + 3 + 6 + 4 + 4 + 0) mod 10 = 0; valid",
        "answer_symbols": [
            "+",
            "*",
            "mod"
        ]
    },
    "4 Supplementary Exercises 42 d)": {
        "question": "试判断下列 13 位数字是否是合法的 ISBN-13。（d）978-0-201-10179-9",
        "answer": "(9 + 8 + 2 + 1 + 0 + 7 + 9) + 3(7 + 0 + 0 + 1 + 1 + 9) mod 10 = 0; valid",
        "answer_symbols": [
            "+",
            "*",
            "mod"
        ]
    },
    "4 Supplementary Exercises 44": {
        "question": "试证明存在两个数字的换位错误不能被 ISBN-13 检测到。",
        "answer": "如果两个奇数位置的数字或两个偶数位置的数字被互换，则总和相同，因此这种错误将不会被检测到",
        "answer_symbols": []
    },
    "4 Supplementary Exercises 46": {
        "question": "证明 RTN 的校验码能够检测出所有单错。试判断 RTN 校验码能检测出哪些换位错，不能检测出哪些换位错。",
        "answer": "因为3、7和1都与10互质，所以改变一个数字到不同的值将改变模10的和，同余关系将不再成立。涉及仅d1、d4和d7（以及类似地在{d2, d5, d8}内或在{d3, d6, d9}内的互换）的移位错误显然无法检测。如果不同组之间的两个数字发生移位错误，如果移位值之间的差不是5，则会被检测到，但如果差是5则不会被检测到（即，1与6互换，或2与7互换等）。要了解为什么在一种情况下（其他情况类似），假设d1 = x和d2 = y被互换。那么总和增加了3(y - x) + 7(x - y) = 4(x - y)。这将是0模10当且仅当4(x - y)不是10的倍数，这等价于x - y不是5的倍数",
        "answer_symbols": [
            "+",
            "-",
            "*",
            "=",
            "mod"
        ]
    },
    "4 Supplementary Exercises 48 a)": {
        "question": "利用自动密钥密码加密消息 NOW IS THE TIME TO DECIDE（忽略空格），使用（a）密钥串是种子 X 加明文中的字母。",
        "answer": "种子是23(X)；将这个数模26加到明文的第一个字符13(N)，得到10，这是K。因此密文的第一个字符是K。密钥流的下一个字符是上述的13(N)；将其加到O(14)得到1(B)，所以密文的下一个字符是B。我们继续以这种方式，产生加密的消息KBK A LAL XBUQ XH RHGKLH",
        "answer_symbols": [
            "mod",
            "+"
        ]
    },
    "4 Supplementary Exercises 48 b)": {
        "question": "利用自动密钥密码加密消息 NOW IS THE TIME TO DECIDE（忽略空格），使用（b）密钥串是种子 X 加密文中的字母。",
        "answer": "再次种子是23(X)；将这个数模26加到明文的第一个字符13(N)，得到10，这是K。因此密文的第一个字符是K。密钥流的下一个字符是上述的K(10)；将其加到O(14)得到24(Y)，所以密文的下一个字符是Y。我们继续以这种方式，产生加密的消息KYU CU NUY RZLP IW ZDFNQU",
        "answer_symbols": [
            "mod",
            "+"
        ]
    },
    "5.1 1": {
        "question": "在一条火车线路上有无穷多个车站。假设火车在第一站停车，又假设如果火车在一个站停车，则它在下一站必停车。证明：火车在所有的车站都停车。",
        "answer": "设P(n)为列车停在车站n的陈述。基础步骤：我们被告知P(1)是真的。归纳步骤：我们被告知对于每个n ≥ 1，P(n)意味着P(n + 1)。因此，通过数学归纳法的原则，对于所有正整数n，P(n)是真的。",
        "answer_symbols": [
            "≥",
            "+"
        ]
    },
    "5.1 2": {
        "question": "在有无限个洞的高尔夫线路上，如果你知道一个选手能够打人第一个洞，且如果他打人第一个洞，那么他一定能打人下一个洞。证明：此选手能够打人线路上的每一个洞。",
        "answer": "我们可以通过数学归纳法来证明这一点。设P(n)是高尔夫球手打第n洞的陈述。我们想要证明对于所有正整数n，P(n)都是正确的。基础步骤是，我们知道P(1)是真的。对于归纳步骤，我们被告知P(k)隐含P(k + 1)，对于每个k ≥ 1。因此，根据数学归纳原理，对于所有正整数n，P(n)都是真的。",
        "answer_symbols": [
            "→",
            "≥"
        ]
    },
    "5.1 4 a)": {
        "question": "设 P(n) 是命题：对正整数 n 而言，1^³ + 2^³ + ⋯ + n^³ = n^²(n + 1)^²/4。命题 P(1) 是什么？",
        "answer": "代入n = 1，我们有P(1)的陈述为1^³ = [1 · (1 + 1) / 2]^²。",
        "answer_symbols": [
            "=",
            "·",
            "+",
            "/",
            "³",
            "²"
        ]
    },
    "5.1 4 b)": {
        "question": "设 P(n) 是命题：对正整数 n 而言，1^³ + 2^³ + ⋯ + n^³ = n^²(n + 1)^²/4。证明 P(1) 为真，完成基础步骤的证明。",
        "answer": "部分(a)中显示的P(1)的两边都等于1。",
        "answer_symbols": []
    },
    "5.1 4 c)": {
        "question": "设 P(n) 是命题：对正整数 n 而言，1^³ + 2^³ + ⋯ + n^³ = n^²(n + 1)^²/4。归纳假设是什么？",
        "answer": "归纳假设是陈述1^³ + 2^³ + ... + k^³ = (k(k + 1) / 2)^²。",
        "answer_symbols": [
            "=",
            "·",
            "+",
            "/",
            "³",
            "²",
            "..."
        ]
    },
    "5.1 4 d)": {
        "question": "设 P(n) 是命题：对正整数 n 而言，1^³ + 2^³ + ⋯ + n^³ = n^²(n + 1)^²/4。在归纳步骤中你需要证明什么？",
        "answer": "对于归纳步骤，我们希望证明对于每个k ≥ 1，P(k)隐含P(k + 1)。换句话说，我们希望证明假设归纳假设（见部分(c)），我们可以证明[1^³ + 2^³ + ... + k^³] + (k + 1)^³ = ((k + 1)(k + 2))^²。",
        "answer_symbols": [
            "=",
            "·",
            "+",
            "/",
            "³",
            "²",
            "...",
            "≥"
        ]
    },
    "5.1 4 e)": {
        "question": "设 P(n) 是命题：对正整数 n 而言，1^³ + 2^³ + ⋯ + n^³ = n^²(n + 1)^²/4。完成归纳步骤。",
        "answer": "用归纳假设替换部分(d)左侧括号中的量，我们有(k(k + 1) / 2)^² + (k + 1)^³ = (k + 1)^²(k^² / 4 + k + 1) = (k + 1)^²((k^² + 4k + 4) / 4) = ((k + 1)(k + 2))^²，如预期所示。",
        "answer_symbols": [
            "=",
            "·",
            "+",
            "/",
            "³",
            "²",
            "(",
            ")"
        ]
    },
    "5.1 4 f)": {
        "question": "设 P(n) 是命题：对正整数 n 而言，1^³ + 2^³ + ⋯ + n^³ = n^²(n + 1)^²/4。解释为什么只要 n 是一个正整数，则上述步骤就可以证明公式为真。",
        "answer": "我们已经完成了基础步骤和归纳步骤，因此根据数学归纳原理，该陈述对每个正整数n都是正确的。",
        "answer_symbols": []
    },
    "5.1 5": {
        "question": "证明：只要 n 是一个非负整数，则 1^³ + 3^³ + 5^³ + ⋯ + (2n+1)^³ = (n+1)(2n+1)(2n+3)/3",
        "answer": "设P(n)为“1^² + 3^² + ... + (2n + 1)^² = (n + 1)(2n + 1)(2n + 3) / 3。”基础步骤：P(0)是真的，因为1^² = 1 = (0 + 1)(2 * 0 + 1)(2 * 0 + 3) / 3。归纳步骤：假设P(k)是真的。那么1^² + 3^² + ... + (2k + 1)^² + [2(k + 1) + 1]^² = (k + 1)(2k + 1)(2k + 3) / 3 + (2k + 3)^² = (2k + 3)[(k + 1)(2k + 1) / 3 + (2k + 3)] = (2k + 3)(2k^² + 9k + 10) / 3 = (2k + 3)(2k + 5)(k + 2) / 3 = [(k + 1) + 1][2(k + 1) + 1][2(k + 1) + 3] / 3。",
        "answer_symbols": [
            "²",
            "=",
            "+",
            "(",
            ")",
            "[",
            "]",
            "*"
        ]
    },
    "5.1 6": {
        "question": "证明：只要 n 是一个正整数，则 1 · 1! + 2 · 2! + ⋯ + n · n! = (n+1)! - 1",
        "answer": "基础步骤很明显，因为1 · 1! = 2! - 1。假设归纳假设，我们则有1 · 1! + 2 · 2! + ... + k · k! + (k + 1) · (k + 1)! = (k + 1)! - 1 + (k + 1) · (k + 1)! = (k + 1)!(1 + k + 1) - 1 = (k + 2)! - 1，如预期所示。",
        "answer_symbols": [
            "=",
            "·",
            "!",
            "+",
            "-",
            "..."
        ]
    },
    "5.1 7": {
        "question": "证明：只要 n 是一个非负整数，则 3 + 3 · 5 + 3 · 5^² + ⋯ + 3 · 5^ⁿ = 3(5^ⁿ^⁺¹ - 1)/4",
        "answer": "设P(n)为“∑从j=0到n 3 * 5^j = 3(5^(n+1) - 1) / 4。”基础步骤：P(0)是真的，因为∑从j=0到0 3 * 5^j = 3 = 3(5^1 - 1) / 4。归纳步骤：假设∑从j=0到k 3 * 5^j = 3(5^(k+1) - 1) / 4。那么∑从j=0到k+1 3 * 5^j = (∑从j=0到k 3 * 5^j) + 3 * 5^(k+1) = 3(5^(k+1) - 1) / 4 + 3 * 5^(k+1) = 3(5^(k+1) + 4 * 5^(k+1) - 1) / 4 = 3(5^(k+2) - 1) / 4。",
        "answer_symbols": [
            "∑",
            "^",
            "*",
            "=",
            "+",
            "(",
            ")",
            "-"
        ]
    },
    "5.1 8": {
        "question": "证明：只要 n 是一个非负整数，则 2 - 2 · 7 + 2 · 7^² - ⋯ + 2(-7)^ⁿ = (1 - (-7)^ⁿ^⁺¹)/4",
        "answer": "要证明的命题是P(n)：2 - 2 · 7 + 2 · 7^² - ... + 2 · (-7)^ⁿ = 1 - (-7)^(n + 1) / 4。为了证明对于所有整数 n ≥ 0 都成立，我们首先证明基础步骤 P(0)，然后证明归纳步骤，即 P(k) 蕴含 P(k+1)。在 P(0) 中，左边只有一个项，即 2，而右边是 (1 - (-7)¹) / 4 = 8 / 4 = 2。因为 2 = 2，所以已经验证了 P(0) 是正确的。对于归纳步骤，我们假设 P(k) 是正确的（即上面显示的等式），并从中推导出 P(k+1) 的正确性，即等式：2 - 2 * 7 + 2 * 7^² - ... + 2 * (-7)ᵏ + 2 * (-7)^(k+1) = (1 - (-7)^(k+1) + 1) / 4 要证明这样的等式，通常最好从更复杂的一边开始，进行操作直到到达另一边。在这种情况下，我们从左边开始。注意，除了最后一项外，其余项构成了 P(k) 的左边，因此根据归纳假设，我们可以用 P(k) 的右边替换它。剩下的就是代数运算：2 - 2 * 7 + 2 * 7^² - ... + 2 * (-7)ᵏ + 2 * (-7)^(k+1) = (1 - (-7)ᵏ + 1) / 4 + 2 * (-7)^(k+1) = (1 - (-7)ᵏ + 1 + 8 * (-7)^(k+1)) / 4 = (1 + 7 * (-7)^(k+1)) / 4 = (1 - (-7) * (-7)^(k+1)) / 4 = (1 - (-7)^(k+1) + 1) / 4",
        "answer_symbols": [
            "(",
            "/",
            "=",
            "^",
            "·",
            ")",
            "-",
            "*",
            "...",
            "+"
        ]
    },
    "5.1 10 a)": {
        "question": "通过对较小的 n 值进行考察，猜想下面的求和公式：1/(1 × 2) + 1/(2 × 3) + ⋯ + 1/(n(n+1))",
        "answer": "通过计算前几个和并得到结果 1/2、2/3 和 3/4，我们猜测总和为 n / (n + 1)。",
        "answer_symbols": [
            "/",
            "+",
            "="
        ]
    },
    "5.1 10 b)": {
        "question": "证明你所猜想的公式。",
        "answer": "我们通过归纳法来证明这一点。当 n = 1 时，显然只有一项，即 1/2。假设 1 / (1 * 2) + 1 / (2 * 3) + ... + 1 / (k * (k + 1)) = k / (k + 1)。我们想要证明 1 / (1 * 2) + 1 / (2 * 3) + ... + 1 / (k * (k + 1)) + 1 / ((k + 1) * (k + 2)) = (k + 1) / (k + 2)。从左边开始，我们将括号中的量替换为 k / (k + 1)（根据归纳假设），然后进行代数运算：k / (k + 1) + 1 / ((k + 1) * (k + 2)) = (k^² + 2k + 1) / ((k + 1) * (k + 2)) = (k + 1) / (k + 2) 得到所需的表达式。",
        "answer_symbols": [
            "=",
            "/",
            "+",
            "*",
            "(",
            ")",
            "^"
        ]
    },
    "5.1 12": {
        "question": "证明：只要 n 是一个非负整数，则 ∑_(j=0)^ⁿ (-1/2)ʲ = (2^ⁿ^⁺¹ + (-1)^ⁿ)/(3 · 2^ⁿ)",
        "answer": "我们通过数学归纳法进行证明。基础步骤（n = 0）是陈述 (-1/2)^⁰ = (2 + 1) / (3 * 1)，这是一个真实的陈述，即 1 = 1。假设归纳假设：∑ (j=0 到 k) (-1/2)ʲ = (2k + 1 + (-1)ᵏ) / (3 * 2ᵏ) 我们想要证明：∑ (j=0 到 k+1) (-1/2)ʲ = (2k + 2 + (-1)^(k+1)) / (3 * 2^(k+1)) ∑ from j=0 to k+1 ( -1/2 )^j = ∑ from j=0 to k ( -1/2 )^j + ( -1/2 )^(k+1) = 2/(k+1) + ( -1 )^k / (3 * 2^k) + ( -1 )^(k+1) / 2^(k+1) = 2^(k+2) + 2( -1 )^k / (3 * 2^(k+1)) + 3( -1 )^(k+1) / (3 * 2^(k+1)) = 2^(k+2) + ( -1 )^(k+1) / (3 * 2^(k+1))",
        "answer_symbols": [
            "∑",
            "=",
            "+",
            "-",
            "/",
            "(",
            ")",
            "^"
        ]
    },
    "5.1 13": {
        "question": "证明：只要 n 是一个正整数，则 1^² - 2^² + 3^² - ⋯ + (-1)^ⁿ^⁻¹ n^² = (-1)^ⁿ^⁻¹ n(n+1)/2",
        "answer": "设P(n)为“1^² - 2^² + 3^² - ... + (-1)^(n-1)n^² = (-1)^(n-1)n(n + 1) / 2。”基础步骤：P(1)是真的，因为1^² = 1 = (-1)^0 * 1^²。归纳步骤：假设P(k)是真的。那么1^² - 2^² + 3^² - ... + (-1)^(k-1)k^² + (-1)^k(k + 1)^² = (-1)^(k-1)k(k + 1) / 2 + (-1)^k(k + 1)^² = (-1)^k(k + 1)[-k / 2 + (k + 1)] = (-1)^k(k + 1)[(k / 2) + 1] = (-1)^k(k + 1)(k + 2) / 2。",
        "answer_symbols": [
            "²",
            "=",
            "+",
            "-",
            "(",
            ")",
            "^",
            "*"
        ]
    },
    "5.1 14": {
        "question": "证明：对所有正整数 n 而言，都有 ∑_(k=1)^ⁿ k2ᵏ = (n-1)2^ⁿ^⁺¹ + 2",
        "answer": "We proceed by induction. Notice that the letter k has been used in this problem as the dummy index of summation, so we cannot use it as the variable for the inductive step. We will use n instead. For the basis step, we have 1 * 2^1 = (1 - 1) * 2^(1+1) + 2, which is the true statement 2 = 2. We assume the inductive hypothesis, that ∑ from k=1 to n ( k * 2^k ) = (n - 1) * 2^(n+1) + 2, and try to prove that ∑ from k=1 to n+1 ( k * 2^k ) = n * 2^(n+2) + 2. Splitting the left-hand side into its first n terms followed by its last term and invoking the inductive hypothesis, we have ∑ from k=1 to n+1 ( k * 2^k ) = (∑ from k=1 to n ( k * 2^k )) + (n + 1) * 2^(n+1) = (n - 1) * 2^(n+1) + 2 + (n + 1) * 2^(n+1) = 2n * 2^(n+1) + 2 = n * 2^(n+2) + 2, as desired.",
        "answer_symbols": [
            "∑",
            "=",
            "+",
            "-",
            "*",
            "^"
        ]
    },
    "5.1 15": {
        "question": "证明：对所有正整数 n 而言，都有 1 · 2 + 2 · 3 + ⋯ + n(n+1) = n(n+1)(n+2)/3",
        "answer": "设P(n)为“1 * 2 + 2 * 3 + ... + n(n + 1) = n(n + 1)(n + 2) / 3。”基础步骤：P(1)是真的，因为1 * 2 = 2 = 1(1 + 1)(1 + 2) / 3。归纳步骤：假设P(k)是真的。那么1 * 2 + 2 * 3 + ... + k(k + 1) + (k + 1)(k + 2) = [k(k + 1)(k + 2) / 3] + (k + 1)(k + 2) = (k + 1)(k + 2)[(k / 3) + 1] = (k + 1)(k + 2)(k + 3) / 3。",
        "answer_symbols": [
            "*",
            "=",
            "+",
            "(",
            ")",
            "[",
            "]"
        ]
    },
    "5.1 16": {
        "question": "证明：对所有正整数 n 而言，都有 1 · 2 · 3 + 2 · 3 · 4 + ⋯ + n(n+1)(n+2) = n(n+1)(n+2)(n+3)/4",
        "answer": "The basis step reduces to 6 = 6. Assuming the inductive hypothesis, we have 1 * 2 * 3 + 2 * 3 * 4 + ... + k(k+1)(k+2) + (k+1)(k+2)(k+3) = k(k+1)(k+2)(k+3) / 4 + (k+1)(k+2)(k+3) = (k+1)(k+2)(k+3)(4k + 1) / 4 = (k+1)(k+2)(k+3)(k+4) / 4.",
        "answer_symbols": [
            "=",
            "+",
            "*",
            "/"
        ]
    },
    "5.1 17": {
        "question": "证明：只要 n 是一个正整数，则 ∑_(j=1)^ⁿ j^⁴ = n(n+1)(2n+1)(3n^² + 3n - 1)/30",
        "answer": "设P(n)为“1^⁴ + 2^⁴ + 3^⁴ + ... + n^⁴ = n(n + 1)(2n + 1)(3n^² + 3n - 1) / 30。”P(1)是真的，因为1 * 2 * 3 * 5 / 30 = 1。假设P(k)是真的。那么(1^⁴ + 2^⁴ + 3^⁴ + ... + k^⁴) + (k + 1)^⁴ = k(k + 1)(2k + 1)(3k^² + 3k - 1) / 30 + (k + 1)^⁴ = [(k + 1) / 30][k(2k + 1)(3k^² + 3k - 1) + 30(k + 1)^³] = [(k + 1) / 30](6k^⁴ + 39k^³ + 91k^² + 89k + 30) = [(k + 1) / 30](k + 2)(2k + 3)[3(k + 1)^² + 3(k + 1) - 1]。这表明P(k + 1)是真的。",
        "answer_symbols": [
            "⁴",
            "=",
            "+",
            "(",
            ")",
            "[",
            "]",
            "*",
            "-"
        ]
    },
    "5.1 20": {
        "question": "证明：如果 n 是一个大于 6 的整数，则 3^n < n!。",
        "answer": "The basis step is n = 7, and indeed 3^⁷ < 7!, since 2187 < 5040. Assume the statement for k. Then 3^(k+1) = 3 * 3^k < (k+1) * 3^k < (k+1) * k! = (k+1)!, the statement for k+1.",
        "answer_symbols": [
            "!",
            "<",
            "=",
            "*",
            "^"
        ]
    },
    "5.1 21": {
        "question": "证明：如果 n 是一个大于 4 的整数，则 2^n > n^2。",
        "answer": "设P(n)为“2^n > n^²。”基础步骤：P(5)是真的，因为2^⁵ = 32 > 25 = 5^²。归纳步骤：假设P(k)是真的，即2^k > k^²。那么2^(k+1) = 2 * 2^k > k^² + k^² > k^² + 4k ≥ k^² + 2k + 1 = (k + 1)^²，因为k > 4。",
        "answer_symbols": [
            "^",
            ">",
            "+",
            "≥",
            "(",
            ")"
        ]
    },
    "5.1 22": {
        "question": "对怎样的非负整数 n，有 n^2 ≤ n!？证明你的答案。",
        "answer": "通过一些计算可以得出结论：n^² ≤ n! 对于 n= 0, 1 和所有 n ≥ 4 成立。（显然，对于 n= 2 或 n= 3，这个不等式不成立。）我们将用数学归纳法证明对于所有 n ≥ 4 不等式都成立。基础步骤很明显，因为 16 ≤ 24。现在假设对于某个给定的 n ≥ 4，n^² ≤ n! 成立。我们必须证明 (n + 1)^² ≤ (n + 1)!。展开左侧，应用归纳假设，然后使用一些有效的边界条件可以证明这一点：n^² + 2n + 1 ≤ n! + 2n + 1 ≤ n! + 2n + n = n! + 3n ≤ n! + n · n ≤ n! + n · n! = (n + 1)n! = (n + 1)!",
        "answer_symbols": [
            "!",
            "<",
            "=",
            "*",
            "^"
        ]
    },
    "5.1 23": {
        "question": "对怎样的非负整数 n，有 2n + 3 ≤ 2^n？证明你的答案。",
        "answer": "通过观察我们发现不等式2n + 3 ≤ 2^n不适用于n = 0, 1, 2, 3。设P(n)为这个不等式对正整数n成立的命题。P(4)，基础情况，是真的，因为2 * 4 + 3 = 11 ≤ 16 = 2^⁴。对于归纳步骤，假设P(k)是真的。那么，根据归纳假设，2(k + 1) + 3 = (2k + 3) + 2 < 2^k + 2。但因为k ≥ 1，2^k + 2 ≤ 2^k + 2k = 2^(k+1)。这表明P(k + 1)是真的。",
        "answer_symbols": [
            "+",
            "≤",
            "(",
            ")",
            "≥",
            "^"
        ]
    },
    "5.1 24": {
        "question": "证明：只要 n 是一个正整数，则 1/(2n) ≤ [1 · 3 · 5 ⋯ (2n-1)] / (2 · 4 ⋯ 2n)",
        "answer": "基础步骤很明显，因为 1/2 ≤ 1/2。我们假设归纳假设（练习中给出的不等式），并希望证明 n + 1 的类似不等式。我们按照以下方式继续，使用将 1/(2(n + 1)) 表示为 1/(2n) 的技巧，以便我们可以应用归纳假设：1 / 2(n + 1) = 1 / 2n * 2n / 2(n + 1) ≤ (1 * 3 * 5 * ... * (2n - 1)) / (2 * 4 * ... * 2n) * 2n / 2(n + 1) ≤ (1 * 3 * 5 * ... * (2n - 1)) / (2 * 4 * ... * 2n) * (2n + 1) / 2(n + 1) = (1 * 3 * 5 * ... * (2n - 1) * (2n + 1)) / (2 * 4 * ... * 2n * 2(n + 1))",
        "answer_symbols": [
            "!",
            "<",
            "=",
            "*",
            "^"
        ]
    },
    "5.1 25": {
        "question": "证明：对所有非负整数 n，如果 h > -1，则 1 + nh ≤ (1 + h)^n。该不等式称为伯努利不等式。",
        "answer": "设P(n)为“1 + nh ≤ (1 + h)^n, h > -1。”基础步骤：P(0)是真的，因为1 + 0 * h = 1 ≤ 1 = (1 + h)^⁰。归纳步骤：假设1 + kh ≤ (1 + h)^k。那么因为(1 + h) > 0，(1 + h)^(k+1) = (1 + h)(1 + h)^k ≥ (1 + h)(1 + kh) = 1 + (k + 1)h + kh^² ≥ 1 + (k + 1)h。",
        "answer_symbols": [
            "+",
            "≤",
            ">",
            "(",
            ")",
            "^",
            "*"
        ]
    },
    "5.1 26": {
        "question": "设 a 和 b 为实数，且 0 < b < a。证明：如果 a 是一个正整数，则 a^n - b^n ≤ na^(n-1)(a - b)。",
        "answer": "可以通过一些代数运算来得到这个证明。将给定的陈述视为 n * a^(n-1) * (a - b) ≥ a^n - b^n 更容易思考。基础步骤（n= 1）是正确的，即 a - b ≥ a - b。假设归纳假设，即 k * a^(k-1) * (a - b) ≥ a^k - b^k；我们需要证明 (k + 1) * a^k * (a - b) ≥ a^(k+1) - b^(k+1)。我们有 (k + 1) * a^k * (a - b) = k * a * a^(k-1) * (a - b) + a^k * (a - b) ≥ a * (a^k - b^k) + a^k * (a - b) = a^(k+1) - a * b^k + a^(k+1) - b * a^k。为了完成证明，我们需要证明 a^(k+1) - a * b^k + a^(k+1) - b * a^k ≥ a^(k+1) - b^(k+1)。这个不等式等价于 a^(k+1) - a * b^k - b * a^k + b^(k+1) ≥ 0，这可以分解成 (a^k - b^k) * (a - b) ≥ 0，并且这是真的，因为已知 a > b。",
        "answer_symbols": [
            "!",
            "<",
            "=",
            "*",
            "^"
        ]
    },
    "5.1 27": {
        "question": "证明：对每个正整数 n，有 1 + 1/√2 + 1/√3 + ⋯ + 1/√n > 2(√(n+1) - 1)",
        "answer": "设P(n)为“1/√1 + 1/√2 + 1/√3 + ... + 1/√n > 2(√(n + 1) - 1)。”基础步骤：P(1)是真的，因为1 > 2(√2 - 1)。归纳步骤：假设P(k)是真的。那么1 + 1/√2 + ... + 1/√k + 1/√(k + 1) > 2(√(k + 1) - 1) + 1/√(k + 1)。如果我们能证明2(√(k + 2) - √(k + 1)) < 1/√(k + 1)，那么P(k + 1)是真的。这个不等式等价于2(√(k + 2) - √(k + 1))(√(k + 2) + √(k + 1)) < √(k + 1) / √(k + 1) + √(k + 2) / √(k + 1)。这等价于2 < 1 + √(k + 2) / √(k + 1)，这是显然成立的。",
        "answer_symbols": [
            "√",
            "+",
            ">",
            "(",
            ")",
            "-"
        ]
    },
    "5.1 28": {
        "question": "证明：只要 n 是一个大于等于 3 的整数，则 n^2 - 7n + 12 就是非负的。",
        "answer": "基础情况是 n= 3。我们检查 4^² - 7 * 4 + 12 = 0 是非负的。接下来假设 n^² - 7n + 12 ≥ 0；我们必须证明 (n + 1)^² - 7(n + 1) + 12 ≥ 0。展开左侧，我们得到 n^² + 2n + 1 - 7n - 7 + 12 = (n^² - 7n + 12) + (2n - 6)。括号内的第一个表达式根据归纳假设是非负的；第二个表达式根据 n 至少为 3 的假设显然是非负的。因此它们的和是非负的，归纳步骤完成。",
        "answer_symbols": [
            "!",
            "<",
            "=",
            "*",
            "^"
        ]
    },
    "5.1 29": {
        "question": "证明：只要 n 是一个非负整数，则 H_n ≤ 1 + n。",
        "answer": "设P(n)为“H_2n ≤ 1 + n。”基础步骤：P(0)是真的，因为H_2^⁰ = H_1 = 1 ≤ 1 + 0。归纳步骤：假设H_2k ≤ 1 + k。那么H_2^(k+1) = H_2k + ∑从j=2^k+1到2^(k+1) 1/j ≤ 1 + k + 2^k(1/2^(k+1)) < 1 + k + 1 = 1 + (k + 1)。",
        "answer_symbols": [
            "∑",
            "≤",
            "+",
            "(",
            ")",
            "^",
            "/"
        ]
    },
    "5.1 30": {
        "question": "证明：H_1 + H_2 + ⋯ + H_n = (n + 1)H_n - n。",
        "answer": "当 n= 1 时，该命题为真，因为 H1 = 1 = 2 * 1 - 1。假设归纳假设，即该命题对 n 为真。那么一方面我们有 H1 + H2 + ... + Hn + Hn+1 = (n + 1)Hn - n + Hn+1 = (n + 1)Hn - n + Hn + 1 / (n + 1) = (n + 2)Hn - n + 1 / (n + 1)。",
        "answer_symbols": [
            "!",
            "<",
            "=",
            "*",
            "^"
        ]
    },
    "5.1 31": {
        "question": "证明：只要 n 是一个正整数，则 n^2 + n 可被 2 整除。",
        "answer": "基础步骤：1^² + 1 = 2可以被2整除。归纳步骤：假设归纳假设，即k^² + k可以被2整除。那么(k + 1)^² + (k + 1) = k^² + 2k + 1 + k + 1 = (k^² + k) + 2(k + 1)。",
        "answer_symbols": [
            "²",
            "+",
            "=",
            "(",
            ")"
        ]
    },
    "5.1 32": {
        "question": "证明：只要 n 是一个正整数，则 n^3 + 2n 可被 3 整除。",
        "answer": "The statement is true for the base case, n = 0, since 3 divides 0. Suppose that 3 divides (k^³ + 2k). We must show that 3 divides ((k + 1)^³ + 2(k + 1)). If we expand the expression in question, we obtain k^³ + 3k^² + 3k + 1 + 2k + 2 = (k^³ + 2k) + 3(k^² + k + 1). By the inductive hypothesis, 3 divides k^³ + 2k, and certainly 3 divides 3(k^² + k + 1), so 3 divides their sum, and we are done.",
        "answer_symbols": [
            "=",
            "+",
            "³",
            "²",
            "(",
            ")",
            "÷"
        ]
    },
    "5.1 33": {
        "question": "证明：只要 n 是一个非负整数，则 n^5 - n 可被 5 整除。",
        "answer": "命题 P(n): (2n - 1)^2 - 1 能被 8 整除。基础步骤: P(1) 是真的，因为 8 | 0。归纳步骤: 假设 P(k) 是真的。因为 [(2(k + 1) - 1]^2 - 1 = [(2k - 1)^2 - 1] + 8k，P(k + 1) 是真的，因为右边的两个项都能被 8 整除。这表明对于所有正整数 n，P(n) 都是真的，所以当 m 是一个奇正整数时，m^2 - 1 能被 8 整除。",
        "answer_symbols": [
            "^",
            "-",
            "+",
            "=",
            "(",
            ")",
            "|"
        ]
    },
    "5.1 34": {
        "question": "证明：只要 n 是一个非负整数，则 n^3 - n 可被 6 整除。",
        "answer": "The statement is true for the base case, n = 0, since 6 divides 0. Suppose that 6 divides (n^³ - n). We must show that 6 divides ((n + 1)^³ - (n + 1)). If we expand the expression in question, we obtain n^³ + 3n^² + 3n + 1 - n - 1 = (n^³ - n) + 3n(n + 1). By the inductive hypothesis, 6 divides the first term, n^³ - n. Furthermore, clearly 3 divides the second term, and the second term is also even, since one of n and n + 1 is even; therefore 6 divides the second term as well. This tells us that 6 divides the given expression, as desired. (Note that here we have, as promised, used n as the dummy variable in the inductive step, rather than k.)",
        "answer_symbols": [
            "=",
            "+",
            "³",
            "²",
            "(",
            ")",
            "÷",
            "-"
        ]
    },
    "5.1 35": {
        "question": "证明：只要 n 是一个正奇数，则 n^2 - 1 可被 8 整除。",
        "answer": "基础步骤: 11^(1+1) + 12^(2*1-1) = 121 + 12 = 133 归纳步骤: 假设归纳假设成立，即 11^(n+1) + 12^(2n-1) 能被 133 整除。那么 11^((n+1)+1) + 12^(2(n+1)-1) = 11 * 11^(n+1) + 144 * 12^(2n-1) = 11 * 11^(n+1) + (11 + 133) * 12^(2n-1) = 11(11^(n+1) + 12^(2n-1)) + 133 * 12^(2n-1)。括号内的表达式根据归纳假设能被 133 整除，显然第二项也能被 133 整除，所以整个量能被 133 整除，如所愿。",
        "answer_symbols": [
            "^",
            "+",
            "*",
            "=",
            "(",
            ")",
            "*"
        ]
    },
    "5.1 36": {
        "question": "证明：只要 n 是一个正整数，则 4^(n+1) + 5^(2n-1) 可被 21 整除。",
        "answer": "It is not easy to stumble upon the trick needed in the inductive step in this exercise, so do not feel bad if you did not find it. The form is straightforward. For the basis step (n = 1), we simply observe that 4^(1+1) + 5^(2*1-1) = 16 + 5 = 21, which is divisible by 21. Then we assume the inductive hypothesis, that 4^(n+1) + 5^(2n-1) is divisible by 21, and let us look at the expression when n + 1 is plugged in for n. We want somehow to manipulate it so that the expression for n appears. We have: 4^((n+1)+1) + 5^(2(n+1)-1) = 4 * 4^(n+1) + 25 * 5^(2n-1) = 4 * 4^(n+1) + (4 + 21) * 5^(2n-1) = 4(4^(n+1) + 5^(2n-1)) + 21 * 5^(2n-1). Looking at the last line, we see that the expression in parentheses is divisible by 21 by the inductive hypothesis, and obviously the second term is divisible by 21, so the entire quantity is divisible by 21, as desired.",
        "answer_symbols": [
            "=",
            "+",
            "^",
            "(",
            ")",
            "*",
            "÷"
        ]
    },
    "5.1 37": {
        "question": "证明：只要 n 是一个正整数，则 11^(n+1) + 12^(2n-1) 可被 133 整除。",
        "answer": "基础步骤: A1 ⊆ B1 逻辑上意味着 ⋂(从 1 到 1) Aj ⊆ ⋂(从 1 到 1) Bj。归纳步骤: 假设归纳假设成立，即如果 Aj ⊆ Bj 对于 j = 1, 2, ..., k，则 ⋂(从 1 到 k) Aj ⊆ ⋂(从 1 到 k) Bj。我们想要证明如果 Aj ⊆ Bj 对于 j = 1, 2, ..., k+1，则 ⋂(从 1 到 k+1) Aj ⊆ ⋂(从 1 到 k+1) Bj。令 x 是 ⋂(从 1 到 k+1) Aj = (⋂(从 1 到 k) Aj) ∩ Ak+1 的任意元素。因为 x ∈ ⋂(从 1 到 k) Aj，根据归纳假设我们知道 x ∈ ⋂(从 1 到 k) Bj；因为 x ∈ Ak+1，根据给定的事实 Ak+1 ⊆ Bk+1 我们知道 x ∈ Bk+1。因此，x ∈ (⋂(从 1 到 k) Bj) ∩ Bk+1 = ⋂(从 1 到 k+1) Bj。",
        "answer_symbols": [
            "⊆",
            "∩",
            "∈"
        ]
    },
    "5.1 38": {
        "question": "证明：如果 A_1, A_2, ⋯, A_n 和 B_1, B_2, ⋯, B_n 都是集合，且对 j = 1, 2, ⋯, n 满足 A_j ⊆ B_j，则 ∪(j=1 to n) A_j ⊆ ∪(j=1 to n) B_j",
        "answer": "The basis step is trivial, as usual: A₁ ⊆ B₁ implies that the union from j=1 to 1 of A_j is a subset of the union from j=1 to 1 of B_j because the union of one set is itself. Assume the inductive hypothesis that if A_j ⊆ B_j for j = 1, 2, ..., k, then the union from j=1 to k of A_j is a subset of the union from j=1 to k of B_j. We want to show that if A_j ⊆ B_j for j = 1, 2, ..., k + 1, then the union from j=1 to k+1 of A_j is a subset of the union from j=1 to k+1 of B_j. To show that one set is a subset of another, we show that an arbitrary element of the first set must be an element of the second set. So let x ∈ the union from j=1 to k+1 of A_j = (the union from j=1 to k of A_j) ∪ A_(k+1). Either x ∈ the union from j=1 to k of A_j or x ∈ A_(k+1). In the first case, we know by the inductive hypothesis that x ∈ the union from j=1 to k of B_j; in the second case, we know from the given fact that A_(k+1) ⊆ B_(k+1) that x ∈ B_(k+1). Therefore, in either case, x ∈ (the union from j=1 to k of B_j) ∪ B_(k+1) = the union from j=1 to k+1 of B_j. This is really easier to do directly than by using the principle of mathematical induction. For a noninductive proof, suppose that x ∈ the union from j=1 to n of A_j. Then x ∈ A_j for some j between 1 and n, inclusive. Since A_j ⊆ B_j, we know that x ∈ B_j. Therefore, by definition, x ∈ the union from j=1 to n of B_j.",
        "answer_symbols": [
            "⊆",
            "∪",
            "∈",
            "="
        ]
    },
    "5.1 39": {
        "question": "证明：如果 A_1, A_2, ⋯, A_n 和 B_1, B_2, ⋯, B_n 都是集合，且对 j = 1, 2, ⋯, n 满足 A_j ⊆ B_j，则 ∩(j=1 to n) A_j ⊆ ∩(j=1 to n) B_j",
        "answer": "命题 P(n): (A1 ∪ A2 ∪ ... ∪ An) ∩ B = (A1 ∩ B) ∪ (A2 ∩ B) ∪ ... ∪ (An ∩ B)。基础步骤: P(1) 显然是真的。归纳步骤: 假设 P(k) 是真的。那么 (A1 ∪ A2 ∪ ... ∪ Ak ∪ Ak+1) ∩ B = [(A1 ∪ A2 ∪ ... ∪ Ak) ∪ Ak+1] ∩ B = [(A1 ∪ A2 ∪ ... ∪ Ak) ∩ B] ∪ (Ak+1 ∩ B) = [(A1 ∩ B) ∪ (A2 ∩ B) ∪ ... ∪ (Ak ∩ B)] ∪ (Ak+1 ∩ B) = (A1 ∩ B) ∪ (A2 ∩ B) ∪ ... ∪ (Ak ∩ B) ∪ (Ak+1 ∩ B)。",
        "answer_symbols": [
            "∪",
            "∩",
            "="
        ]
    },
    "5.1 40": {
        "question": "证明：如果 A_1, A_2, ⋯, A_n 和 B 都是集合，则 (A_1 ∩ A_2 ∩ ⋯ ∩ A_n) ∪ B = (A_1 ∪ B) ∩ (A_2 ∪ B) ∩ ⋯ ∩ (A_n ∪ B)",
        "answer": "If n = 1 there is nothing to prove, and the n = 2 case is the distributive law (see Table 1 in Section 2.2). Those take care of the basis step. For the inductive step, assume that (A₁ ∩ A₂ ∩ ... ∩ A_n) ∪ B = (A₁ ∪ B) ∩ (A₂ ∪ B) ∩ ... ∩ (A_n ∪ B).",
        "answer_symbols": [
            "∩",
            "∪",
            "="
        ]
    },
    "5.1 41": {
        "question": "证明：如果 A_1, A_2, ⋯, A_n 和 B 都是集合，则 (A_1 ∪ A_2 ∪ ⋯ ∪ A_n) ∩ B = (A_1 ∩ B) ∪ (A_2 ∩ B) ∪ ⋯ ∪ (A_n ∩ B)",
        "answer": "命题 P(n): ⋃(从 1 到 n) Ak = ⋂(从 1 到 n) Ak。基础步骤: P(1) 显然是真的。归纳步骤: 假设 P(k) 是真的。那么 ⋃(从 1 到 k+1) Aj = (⋃(从 1 到 k) Aj) ∪ Ak+1 = (⋃(从 1 到 k) Aj) ∩ Ak+1 = (⋂(从 1 到 k) Aj) ∩ Ak+1 = ⋂(从 1 到 k+1) Aj。",
        "answer_symbols": [
            "∪",
            "∩",
            "="
        ]
    },
    "5.1 43": {
        "question": "证明：如果 A_1, A_2, ⋯, A_n 是全集 U 的子集，则 ¬(∪(k=1 to n) A_k) = ∪(k=1 to n) ¬A_k",
        "answer": "命题 P(n): 一个有 n 个元素的集合有 n(n-1)/2 个二元子集。基础步骤: P(2)，基础情况，是真的，因为一个有两个元素的集合有一个二元子集——即它本身——并且 2(2 - 1)/2 = 1。归纳步骤: 假设 P(k) 是真的。令 S 是一个有 k+1 个元素的集合。选择 S 中的一个元素 a 并令 T = S - {a}。S 的二元子集要么包含 a，要么不包含。那些不包含 a 的子集是 T 的二元子集；根据归纳假设，这些子集有 k(k-1)/2 个。S 中包含 a 的二元子集有 k 个，因为这样的子集包含 a 和 T 中的一个元素。因此，S 有 k(k-1)/2 + k = (k+1)k/2 个二元子集。这完成了归纳证明。",
        "answer_symbols": [
            "(",
            ")",
            "/",
            "*",
            "+",
            "="
        ]
    },
    "5.1 45": {
        "question": "证明：只要 n 是一个大于等于 2 的整数，则具有 n 个元素的集合中有 n(n-1)/2 个子集恰好含有 2 个元素。",
        "answer": "如果需要重新排序位置，使得 x1 ≤ x2 ≤ x3 ≤ ... ≤ xd。将第一个塔放置在位置 t1 = x1 + 1。假设塔 k 已经放置在位置 tk。然后将塔 k+1 放置在位置 tk+1 = x + 1，其中 x 是大于 tk + 1 的最小 xi。",
        "answer_symbols": [
            "≤",
            "+",
            "=",
            "(",
            ")",
            "∈"
        ]
    },
    "5.1 47": {
        "question": "设计一种贪心算法，此算法可以从路的起点开始在 x_1, x_2, …, x_d 位置上设置尽可能少的塔为 d 个建筑物提供通信服务。[提示：在每一步，在离尽可能远的位置设置通信塔，只要保证没有建筑物超出通信覆盖范围。]",
        "answer": "如果 n + 1 = 2，这两个集合不会重叠。实际上，条件语句 P(1) → P(2) 是假的。",
        "answer_symbols": [
            "+",
            "=",
            "→"
        ]
    },
    "5.1 48": {
        "question": "使用数学归纳法证明你设计的算法能为练习 47 产生一个优化解：即算法可以得到最少的塔为所有的建筑物提供蜂窝通信服务。",
        "answer": "我们将证明任何最小塔位配置可以转换为算法产生的配置。虽然这不完全是数学归纳法的形式，但精神是相同的。设 s1 < s2 < ... < sk 是塔的最佳位置（即最小化 k），t1 < t2 < ... < tl 是练习 47 中算法产生的位置。为了服务第一栋建筑，我们必须有 s1 ≤ x1 + 1 = t1。如果 s1 ≠ t1，那么我们可以将最佳解中的第一个塔移动到位置 t1 而不会失去任何建筑的信号覆盖。因此我们可以假设 s1 = t1。设 xj 是离 s1 塔最远的一栋建筑的位置；因此 xj > s1 + 1。为了服务该建筑，必须有一个塔 si 使得 si ≤ xj + 1 = t2。如果 i > 2，那么位置 s2 到 si-1 的塔是不必要的，矛盾。同样地，然后可以将第二个塔从 s2 移动到 t2。我们继续以这种方式处理给定最小解中的所有塔；因此 k = l。这证明了算法产生了一个最小解。",
        "answer_symbols": [
            "<",
            "≤",
            "≠",
            "=",
            ">",
            "+",
            "-"
        ]
    },
    "5.1 49": {
        "question": "下面的“证明”错在哪儿？所有的马都有相同的颜色。设 P(n) 是命题“n 匹马的集合中所有马都有相同的颜色”。基础步骤：显然 P(1) 为真。归纳步骤：假设 P(k) 为真，即 k 匹马的集合中所有马都有相同的颜色。考虑任意 k+1 匹马，将这些马编号为 1, 2, 3, …, k, k+1。我们有前 k 匹马必具有相同的颜色，而后 k 匹马也必具有相同的颜色。因为前 k 匹马的集合与后 k 匹马的集合是重叠的，因此，所有 k+1 匹马必有相同的颜色。这就证明了 P(k+1) 为真，归纳步骤证毕。",
        "answer": "错误在于应用归纳假设来查看 max(x-1, y-1)，因为即使 x 和 y 是正整数，x - 1 和 y - 1 也不必是（一个或两个都可能是 0）。",
        "answer_symbols": [
            "-",
            "(",
            ")",
            "∈"
        ]
    },
    "5.1 50": {
        "question": "下面的“证明”错在哪儿？“定理”：对每个正整数 n 而言，都有 ∑(i=1 to n) i = (n + 1/2)^2 / 2。基础步骤：当 n=1 时公式为真。归纳步骤：假设 ∑(i=1 to k) i = (k + 1/2)^2 / 2，则 ∑(i=1 to k+1) i = (∑(i=1 to k) i) + (k + 1)。根据归纳假设，∑(i=1 to k+1) i = (k + 1/2)^2 / 2 + k + 1 = (k^2 + k + 1/4) / 2 + k + 1 = (k^2 + 3k + 9/4) / 2 = (k + 3/2)^2 / 2 = ((k + 1) + 1/2)^2 / 2 归纳步骤证毕。",
        "answer": "当 n = 1 时，左边是 1，右边是 (1 + 12)^² / 2 = 9/8。因此基础步骤是错误的。",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "+",
            "²",
            "/",
            "≠"
        ]
    },
    "5.1 51": {
        "question": "下面的“证明”错在哪儿？“定理”：对每个正整数 n 而言，如果 x 和 y 是正整数，且 max(x, y) = n，则 x = y。基础步骤：设 n = 1。如果 max(x, y) = 1 且 x 和 y 是正整数，有 x = 1 和 y = 1。归纳步骤：设 k 是一个正整数。假定只要 max(x, y) = k 且 x 和 y 是正整数，则必有 x = y。现在令 max(x, y) = k + 1，其中 x 和 y 是正整数。于是有 max(x - 1, y - 1) = k，因此，根据归纳假设有 x - 1 = y - 1。由此得 x = y，归纳步骤证毕。",
        "answer": "对于基础步骤 (n = 2)，第一个人将蛋糕切成两份她认为每份都是蛋糕的一半，第二个人选择他认为至少是蛋糕一半的那一份（至少有一块必须满足这个条件）。对于归纳步骤，假设共有 k + 1 个人。根据归纳假设，我们可以假设前 k 个人已经将蛋糕分给他们自己，每个人都满意他得到了至少 1/k 的蛋糕。他们每个人现在将他的那块切成 k + 1 份等大的小块。最后一个人可以从前 k 个人的每一份中选择一块。这样做后，前 k 个人每个人都满意她仍然有 (1/k)(k/(k+1)) = 1/(k+1) 的蛋糕。为了验证最后一个人是否满意，假设他认为第 i 个人 (1 ≤ i ≤ k) 有蛋糕的一部分 pi，其中 ∑(从 1 到 k) pi = 1。通过选择他认为最大的那一块，他满意他得到了至少 ∑(从 1 到 k) pi/(k+1) = (1/(k+1))∑(从 1 到 k) pi = 1/(k+1) 的蛋糕。",
        "answer_symbols": [
            "=",
            "+",
            "/",
            "(",
            ")",
            "∑",
            "≤"
        ]
    },
    "5.1 52": {
        "question": "设 m, n 是正整数且 m > n，f 是集合 {1, 2, …, m} 到集合 {1, 2, …, n} 的函数。采用数学归纳法对变量 n 归纳证明 f 不是一个一对一函数。",
        "answer": "我们用数学归纳法证明一个函数 f: A → {1, 2, ..., n} 其中 |A| > n 不能是一对一的。对于基础步骤，n = 1 和 |A| > 1。设 x 和 y 是 A 中不同的元素。因为值域只有 1 个元素，我们必须有 f(x) = f(y)，所以按定义 f 不是一对一的。假设归纳假设，即没有从任何 A 到 {1, 2, ..., n} 的函数是 |A| > n 时一对一的，设 f 是从 A 到 {1, 2, ..., n, n + 1} 的函数，其中 |A| > n + 1。有三种情况。如果 n + 1 不在 f 的值域中，则归纳假设告诉我们 f 不是一对一的。如果 f(x) = n + 1 对于 A 中多于一个 x 值，则按定义 f 不是一对一的。唯一其他的情况是 f(a) = n + 1 恰好对于 A 中的一个元素 a。设 A' = A - {a}，并考虑函数 f' 定义为 f 在 A' 上的限制。由于 |A'| > n，由归纳假设 f' 不是一对一的，因此 f 也不是。",
        "answer_symbols": [
            "→",
            "{",
            "}",
            "|",
            ">",
            "=",
            "≠",
            "-",
            "+",
            "∈"
        ]
    },
    "5.1 53": {
        "question": "采用数学归纳法证明 n 个人能划分一个蛋糕（每一个人取得 1 份或者多块蛋糕）以保证蛋糕能公平分配。即每一个人至少取得蛋糕的 1/n。[提示：在归纳步骤，在前 k 个人中得到一个公平的划分，每一个人将自己的那份划分为 k + 1 等份，第 k + 1 个人从这前 k 个人中得到的份额中选取一部分。证明这样能对 k + 1 个人产生一个公平的划分，假设第 k + 1 个人认为第 i 个人得到了 p_i 份，∑(i=1 to k) p_i = 1。]",
        "answer": "我们使用 (i, j) 表示第 i 行第 j 列的方格，并对 i + j 使用归纳法来证明骑士可以到达每一个方格。基础步骤：有六个基本情况，即当 i + j ≤ 2 时的情况。骑士一开始就在 (0, 0)，所以空的移动序列可以到达那个方格。要到达 (1, 0)，骑士移动 (0, 0) → (2, 1) → (0, 2) → (1, 0)。同样地，要到达 (0, 1)，骑士移动 (0, 0) → (1, 2) → (2, 0) → (0, 1)。注意骑士在这个过程中已经到达了 (2, 0) 和 (0, 2)。对于最后一个基本情况，有 (0, 0) → (1, 2) → (2, 0) → (0, 1) → (2, 2) → (0, 3) → (1, 1)。归纳步骤：假设归纳假设成立，即骑士可以到达任何 i + j = k 的方格 (i, j)，其中 k 是大于 1 的整数。我们必须展示骑士如何到达每个 i + j = k + 1 的方格 (i, j)。因为 k + 1 ≥ 3，至少有一个 i 或 j 至少为 2。如果 i ≥ 2，那么根据归纳假设，有一系列移动以 (i - 2, j + 1) 结束，因为 i - 2 + j + 1 = i + j - 1 = k；从那里只需一步就可以到达 (i, j)；同样地，如果 j ≥ 2。",
        "answer_symbols": [
            "+",
            "-",
            "≤",
            "≥",
            "(",
            ")",
            "→"
        ]
    },
    "5.1 54": {
        "question": "用数学归纳法证明：给定一个具有 n + 1 个正整数的集合，其中每个数都不超过 2n，则该集合中至少存在一个整数可以整除集合中的另一个整数。",
        "answer": "基础案例是 n = 1。如果从 {1, 2} 中给出一个包含两个元素的集合，那么确实其中一个元素能被另一个整除。假设归纳假设，并考虑从 {1, 2, ..., 2n, 2n + 1, 2n + 2} 中选择 n + 2 个元素的集合 A。我们必须证明这些元素中至少有一个能被另一个整除。如果 A 中最多有 n + 1 个元素小于 2n + 1，那么所需的结论直接从归纳假设得出。因此我们可以假设 2n + 1 和 2n + 2 都在 A 中，加上 n 个较小的元素。如果 n + 1 是这些较小的元素之一，那么我们就完成了，因为 n + 1 | 2n + 2。所以我们可以假设 n + 1 ∉ A。现在应用归纳假设到 B = A - {2n + 1, 2n + 2} ∪ {n + 1}。因为 B 是从 {1, 2, ..., 2n} 中选择的 n + 1 个数字的集合，归纳假设保证 B 中的一个元素能被另一个整除。如果 n + 1 不是这两个数字之一，那么我们就完成了。所以我们可以假设 n + 1 是这两个数字之一。当然 n + 1 不能是除数，因为它的最小倍数太大而不能在 B 中，所以存在某个 k ∈ B 能整除 n + 1。但现在 k 和 2n + 2 是 A 中的数字，且 k 能整除 n + 2，我们就完成了。第 6.2 节的例 11 给出了这个定理的另一种证明。",
        "answer_symbols": [
            "{",
            "}",
            "|",
            "∈",
            "∪",
            "-",
            "+",
            "<",
            ">",
            "="
        ]
    },
    "5.1 55": {
        "question": "棋盘上的骑士可以一次沿水平方向（任意两个方向）移动一格，沿垂直方向（任意两个方向）移动两格，或者他可以一次沿水平方向（任意两个方向）移动两格，沿垂直方向（任意两个方向）移动一格。假设",
        "answer": "基础步骤：基本情况 n = 0 和 n = 1 是真的，因为 x^0 的导数是 0，x^1 = x 的导数是 1。归纳步骤：使用乘积法则、归纳假设和基础步骤显示 d/dx x^(k+1) = d/dx (x * x^k) + x^k * d/dx x = x * kx^(k-1) + x^k * 1 = kx^k + x^k = (k+1)x^k。",
        "answer_symbols": [
            "^",
            "=",
            "+",
            "*",
            "d/dx",
            "(",
            ")"
        ]
    },
    "5.1 56": {
        "question": "设 A = [a 0; 0 b]，其中a、b是实数。证明：对每个正整数n而言，都有 A^n = [a^n 0; 0 b^n]",
        "answer": "基础案例 n = 1 时不需要证明，因为 A = A。对于归纳步骤，我们只需调用归纳假设和矩阵乘法的定义：A^(n+1) = AA^n = [a 0 b][a^n 0 b^n] = [a * a^n + 0 * 0 a * 0 + 0 * b^n 0 * a^n + b * 0 0 * 0 + b * b^n] = [a^(n+1) 0 b^(n+1)]",
        "answer_symbols": [
            "=",
            "[",
            "]",
            "*",
            "^",
            "+",
            "≠"
        ]
    },
    "5.1 57": {
        "question": "(需要微积分知识)用数学归纳法证明：只要n是一个正整数，则f(x) = x^n的导数就等于nx^(n-1)。(在归纳步骤中使用导数乘积的规则。)",
        "answer": "基础步骤：对于 k = 0，1 ≡ 1 (mod m)。归纳步骤：假设 a ≡ b (mod m) 和 a^k ≡ b^k (mod m)；我们必须证明 a^(k+1) ≡ b^(k+1) (mod m)。根据第 4.1 节的定理 5，a * a^k ≡ b * b^k (mod m)，这由定义得出 a^(k+1) ≡ b^(k+1) (mod m)。",
        "answer_symbols": [
            "≡",
            "^",
            "*",
            "(",
            ")",
            "mod"
        ]
    },
    "5.1 58": {
        "question": "设A、B都是方阵，且满足AB = BA。证明：对每个正整数n而言，都有AB^n = BA^n",
        "answer": "基础步骤是显然的，因为我们已经知道 AB = BA。接下来假设归纳假设，即 AB^n = B^nA，尝试证明 AB^(n+1) = B^(n+1)A。我们计算如下：AB^(n+1) = AB^nB = B^nAB = B^nBA = B^(n+1)A。注意我们使用了矩阵幂的定义（B^(n+1) = B^nB）、归纳假设和基础步骤。",
        "answer_symbols": [
            "=",
            "[",
            "]",
            "*",
            "^",
            "≠"
        ]
    },
    "5.1 60": {
        "question": "用数学归纳法证明：当p1、p2、…、pn都是命题时，则(p1 ∧ p2 ∧ … ∧ pn)等价于(p1 ∧ (p2 ∧ (p3 ∧ … ∧ pn)))",
        "answer": "这个题目与习题43相同，只是用“或”代替了“并集”，用“且”代替了“交集”，用“非”代替了补集。基础步骤是平凡的，因为它仅仅表示非p1等价于其自身。假设归纳假设成立，我们考虑非(p1或p2或...或pn或pn+1)。根据德摩根定律（将最后一个项以外的所有项组合在一起），这相当于非(p1或p2或...或pn)且非pn+1。但根据归纳假设，这等于非p1且非p2且...且非pn且非pn+1，如所需。",
        "answer_symbols": [
            "非",
            "或",
            "且"
        ]
    },
    "5.1 61": {
        "question": "证明：只要p1、p2、…、pn都是命题且n≥2，则 (p1 → p2) ∧ (p2 → p3) ∧ … ∧ (pn-1 → pn) → (p1 ∧ p2 ∧ … ∧ pn) 就是重言式",
        "answer": "Let P(n) be “[(p1 → p2) ∧ (p2 → p3) ∧ ··· ∧ (pn−1 → pn)] → [(p1 ∧ ··· ∧ pn−1) → pn].” Basis step: P(2) is true because (p1 → p2) → (p1 → p2) is a tautology. Inductive step: Assume P(k) is true. To show [(p1 → p2) ∧ ··· ∧ (pk−1 → pk) ∧ (pk → pk+1)] → [(p1 ∧ ··· ∧ pk−1 ∧ pk) → pk+1] is a tautology, assume that the hypothesis of this conditional statement is true. Because both the hypothesis and P(k) are true, it follows that (p1 ∧ ··· ∧ pk−1) → pk is true. Because this is true, and because pk → pk+1 is true (it is part of the assumption), it follows by hypothetical syllogism that (p1 ∧ ··· ∧ pk−1) → pk+1 is true. The weaker statement (p1 ∧ ··· ∧ pk−1 ∧ pk) → pk+1 follows from this.",
        "answer_symbols": [
            "→",
            "∧",
            "¬",
            "(",
            ")",
            "···"
        ]
    },
    "5.1 62": {
        "question": "证明：如果n条直线中任何两条都不平行，任何三条都不共点，则这些直线就能把平面分成(n^2 + n + 2)/2个区域",
        "answer": "当n=1时，命题为真，因为一条线将平面分成两个区域，而(1^2 + 1 + 2)/2 = 2。假设归纳假设成立，即n条给定类型的线将平面分为(n^2 + n + 2)/2个区域。考虑n+1条线的布局。移除最后一条线。那么根据归纳假设，有(n^2 + n + 2)/2个区域。现在我们将最后一条线放回，慢慢画出，并观察区域的变化。当我们从无穷远处进来时，这条线将一个无限区域分为两部分（每边各一个）；这种分离在直线碰到前n条线之一时完成。然后，当我们继续从第一个交点画到第二个交点时，这条线再次将一个区域分为两部分。我们继续这样做。每次我们到达另一条直线和已存在的图形之间的另一个交点时，就会再增加一个区域。此外，一旦我们离开最后一个交点并将直线画向无穷远，我们又会将另一个区域分为两部分。因此，形成的额外区域数量等于交点的数量加一。现在有n个交点，因为我们的直线必须在不同的点与其它每条线相交（这是使用几何假设的地方）。因此，这个布局比n条线的布局多n+1个交点，即((n^2 + n + 2)/2) + (n + 1)，经过一些代数运算后，简化为((n + 1)^2 + (n + 1) + 2)/2，正是所需的。",
        "answer_symbols": [
            "^",
            "+",
            "/",
            "(",
            ")",
            "="
        ]
    },
    "5.1 63": {
        "question": "设a1、a2、…、an都是正实数，这些数的算术均值定义为A = (a1 + a2 + … + an)/n，而这些数的几何均值定义为G = (a1a2…an)^(1/n)。用数学归纳法证明：A ≥ G",
        "answer": "We will first prove the result when n is a power of 2, that is, if n = 2^k, k = 1, 2,.... Let P(k) be the statement A ≥ G, where A and G are the arithmetic and geometric means, respectively, of a set of n = 2^k positive real numbers. Basis step: k = 1 and n = 2^1 = 2. Note that (√a1 − √a2)^² ≥ 0. Expanding this shows that a1 − 2√a1a2 + a2 ≥ 0, that is, (a1 + a2)/2 ≥ (a1a2)^(1/2). Inductive step: Assume that P(k) is true, with n = 2^k. We will show that P(k+1) is true. We have 2^(k+1) = 2n. Now (a1 + a2 + ··· + a2n)/(2n) = [(a1 + a2 + ··· + an)/n + (an+1 + an+2 + ··· + a2n)/n]/2 and similarly (a1a2 ··· a2n)^(1/(2n)) = [(a1 ··· an)^(1/n)(an+1 ··· a2n)^(1/n)]^(1/2). To simplify the notation, let A(x, y,...) and G(x, y,...) denote the arithmetic mean and geometric mean of x, y,..., respectively. Also, if x ≤ x′, y ≤ y′, and so on, then A(x, y,...) ≤ A(x′, y′,...) and G(x, y,...) ≤ G(x′, y′,...). Hence, A(a1,..., a2n) = A(A(a1,..., an), A(an+1,..., a2n)) ≥ A(G(a1,..., an), G(an+1,..., a2n)) ≥ G(G(a1,..., an), G(an+1,..., a2n)) = G(a1,..., a2n). This finishes the proof for powers of 2. Now if n is not a power of 2, let m be the next higher power of 2, and let an+1,..., am all equal A(a1,..., an) = a. Then we have [(a1a2 ··· an)a^(m−n)]^(1/m) ≤ A(a1,..., am), because m is a power of 2. Because A(a1,..., am) = a, it follows that (a1 ··· an)^(1/m)a^(1−n/m) ≤ a^(n/m). Raising both sides to the (m/n)th power gives G(a1,..., an) ≤ A(a1,..., an).",
        "answer_symbols": [
            "=",
            "^",
            "≥",
            "≤",
            "√",
            "(",
            ")",
            "+",
            "−",
            "·",
            "/",
            "···"
        ]
    },
    "5.1 64": {
        "question": "用数学归纳法证明4.3节中的引理3，其命题为：如果p是素数，且p | a1a2…an，其中ai(i = 1, 2, 3, …, n)都是整数，则必存在某个整数i，使得p | ai",
        "answer": "对于基本情况n=1，没有什么需要证明的。假设归纳假设成立，并假设给出p | a1a2...anan+1。我们必须证明存在某个i使得p | ai。让我们看看gcd(p, a1a2...an)。由于p的唯一除数是1和p，所以这个值要么是1，要么是p。如果它是1，那么根据第4.3节中的引理2，我们有p | an+1（这里a=p，b=a1a2...an，c=an+1），如所需。另一方面，如果最大公约数是p，这意味着p | a1a2...an。现在根据归纳假设，对于某些i ≤ n，p | ai，同样如所需。",
        "answer_symbols": [
            "|",
            "gcd",
            "≤"
        ]
    },
    "5.1 65": {
        "question": "证明：只要n是一个正整数，则 ∑(i=1 to n) 1/i = n (这里的求和是对前n个最小正整数所构成的集合的所有非空子集进行的)",
        "answer": "Basis step: For n = 1, the left-hand side is just 1^1, which is 1. For n = 2, there are three nonempty subsets {1}, {2}, and {1, 2}, so the left-hand side is 1^1 + 2^1 + 1^1·2 = 2. Inductive step: Assume that the statement is true for k. The set of the first k+1 positive integers has many nonempty subsets, but they fall into three categories: a nonempty subset of the first k positive integers together with k+1, a nonempty subset of the first k positive integers, or just {k+1}. By the inductive hypothesis, the sum of the first category is k. For the second category, we can factor out 1/(k+1) from each term of the sum and what remains is just k by the inductive hypothesis, so this part of the sum is k/(k+1). Finally, the third category simply yields 1/(k+1). Hence, the entire summation is k + k/(k+1) + 1/(k+1) = k + 1.",
        "answer_symbols": [
            "=",
            "^",
            "+",
            "·",
            "(",
            ")",
            "/"
        ]
    },
    "5.1 66": {
        "question": "利用良序性公理证明下列形式的数学归纳法的证明是有效的。证明：对所有正整数n而言，P(n)为真。基础步骤：P(1)和P(2)都为真。归纳步骤：对每个正整数k，如果P(k)和P(k+1)都为真，则P(k+2)为真",
        "answer": "假设通过这种方法已经证明了一个命题∀nP(n)。令S为P的反例集合，即S={ n | ¬P(n)}。我们将证明S=∅。如果S≠∅，则令n为S的最小元素（由良序性质保证存在）。显然n≠1且n≠2，由我们证明方法的基础步骤可知。但由于n是S的最小元素且n ≥ 3，我们知道P(n − 1)和P(n − 2)为真。因此根据我们证明方法的归纳步骤，我们知道P(n)也为真。这与选择n矛盾。因此S=∅，如所需。",
        "answer_symbols": [
            "∀",
            "¬",
            "∅",
            "∈",
            "≥",
            "−",
            "∧"
        ]
    },
    "5.1 67": {
        "question": "证明：如果A1、A2、…、An是集合，其中n≥2，且对所有满足1≤i<j≤n的整数对i和j，要么Ai是Aj的子集，要么Aj是Ai的子集，则必存在一个整数i，1≤i≤n，使得对所有的整数j，1≤j≤n，都有Ai是Aj的子集",
        "answer": "Basis step: If A1 ⊆ A2, then A1 satisfies the condition of being a subset of each set in the collection; otherwise A2 ⊆ A1, so A2 satisfies the condition. Inductive step: Assume the inductive hypothesis, that the conditional statement is true for k sets, and suppose we are given k+1 sets that satisfy the given conditions. By the inductive hypothesis, there must be a set Ai for some i ≤ k such that Ai ⊆ Aj for 1 ≤ j ≤ k. If Ai ⊆ Ak+1, then we are done. Otherwise, we know that Ak+1 ⊆ Ai, and this tells us that Ak+1 satisfies the condition of being a subset of Aj for 1 ≤ j ≤ k+1.",
        "answer_symbols": [
            "⊆",
            "≤",
            "≤"
        ]
    },
    "5.1 68": {
        "question": "在一个聚会上，如果所有客人都认识其中的一位客人，而这个人却不认识其他任何一个人，则这个人就称为名人。在一个聚会上，最多只有一个名人，因为如果有两个名人，则他们必然相互认识。某个特定的聚会上也可能没有名人。你的任务是在一个聚会上寻找一个名人，如果该聚会上确实有名 人，而你只允许向每个客人提问一种类型的问题——询问他是否认识另一个客人。每个客人必须如实回答你的问题。也就是说，如爱丽丝和鲍勃是聚会的两个客人，你可以询问爱丽丝是否认识鲍勃，她必须如实回答。利用数学归纳法证明：如果聚会上有n位客人，且有一位名人，那么你只需要询问3(n-1)次客人，你就能找到这位名人。[提示：你首先提出一次问题，以排除一位客人是名人的可能。然后用归纳假设去识别一个可能的名人。最后再问两次问题，以确定这位可能的名人是否是真正的名人。]",
        "answer": "基础步骤是n=1和n=2。如果有一个人在场，那么他或她就是一个空洞的名人，不需要提问；这与3(n − 1)的值一致。如果有两个人在场，那么确实可以确定谁是名人（或确定他们都不是）只需三个问题。实际上，两个问题就足够了（问每个人是否认识另一个人）。假设归纳假设成立，即如果有k个人在场（k ≥ 2），那么我们可以用最多3(k − 1)个问题确定是否有名人。我们要证明k+1的情况，即如果有k+1人在聚会，那么我们可以用3k个问题找到名人（或确定没有名人）。假设Alex和Britney是其中两位客人。问Alex是否认识Britney。如果他说是，那么我们知道他不是名人。如果他说不是，那么我们知道Britney不是名人。不失一般性，假设我们已经排除了Alex作为可能的名人。现在对排除Alex的k位客人应用归纳假设，问3(k − 1)个问题。如果没有名人，那么我们知道聚会上没有名人。如果有，假设它是人x（可能是Britney，也可能是其他人）。然后我们",
        "answer_symbols": [
            "=",
            "≥",
            "−",
            "∈"
        ]
    },
    "5.1 69": {
        "question": "求 G(1)、G(2)、G(3) 和 G(4)。",
        "answer": "G(1) = 0, G(2) = 1, G(3) = 3, G(4) = 4",
        "answer_symbols": [
            "="
        ]
    },
    "5.1 71": {
        "question": "证明：对 n≥4，有 G(n)=2n-4",
        "answer": "To show that 2n − 4 calls are sufficient to exchange all the gossip, select persons 1, 2, 3, and 4 to be the central committee. Every person outside the central committee calls one person on the central committee. At this point the central committee members as a group know all the scandals. They then exchange information among themselves by making the calls 1-2, 3-4, 1-3, and 2-4 in that order. At this point, every central committee member knows all the scandals. Finally, again every person outside the central committee calls one person on the central committee, at which point everyone knows all the scandals. [The total number of calls is (n − 4) + 4 + (n − 4) = 2n − 4.] That this cannot be done with fewer than 2n − 4 calls is much harder to prove;",
        "answer_symbols": [
            "−",
            "+",
            "="
        ]
    },
    "5.1 73": {
        "question": "证明：如果 I1，I2，…，In 是实数轴上的一组开区间，其中 n≥2，且这些区间中任意两区间的交非空，即对任意的 1≤i≤n 和 1≤j≤n，都有 Ii∩Ij≠∅，那么所有这些集合的交非空，即 I1∩I2∩…∩In≠∅。（回顾开区间的概念：开区间是实数 x 的集合，其中 a<x<b，且 a、b 都是实数。）",
        "answer": "We prove this by mathematical induction. The basis step (n = 2) is true tautologically. For n = 3, suppose that the intervals are (a, b), (c, d), and (e, f), where without loss of generality we can assume that a ≤ c ≤ e. Because (a, b) ∩ (e, f) = ∅, we must have e < b; for a similar reason, e < d. It follows that the number halfway between e and the smaller of b and d is common to all three intervals. Now for the inductive step, assume that whenever we have k intervals that have pairwise nonempty intersections then there is a point common to all the intervals, and suppose that we are given intervals I1, I2,..., Ik+1 that have pairwise nonempty intersections. For each i from 1 to k, let Ji = Ii ∩ Ik+1. We claim that the collection J1, J2,..., Jk satisfies the inductive hypothesis, that is, that Ji1 ∩ Ji2 = ∅ for each choice of subscripts i1 and i2. This follows from the n = 3 case proved above, using the sets Ii1, Ii2, and Ik+1. We can now invoke the inductive hypothesis to conclude that there is a number common to all of the sets Ji for i = 1, 2,..., k, which perforce is in the intersection of all the sets Ii for i = 1, 2,..., k+1.",
        "answer_symbols": [
            "∩",
            "∅",
            "≤",
            "<",
            "=",
            "..."
        ]
    },
    "5.1 75": {
        "question": "设 n 是一个正的偶数。证明：当 n 个人站在院子中，彼此之间距离不同，每个人都同时用一个馅饼抛向并击打离他最近的人时，每个人都能受到馅饼的攻击",
        "answer": "Pair up the people. Have the people stand at mutually distinct small distances from their partners but far away from everyone else. Then each person throws a pie at his or her partner, so everyone gets hit.",
        "answer_symbols": []
    },
    "5.1 77": {
        "question": "用右三联骨牌覆盖一个去掉左上角格子的 8×8 棋盘",
        "answer": "Let P(n) be the statement that every 2n × 2n × 2n checkerboard with a 1 × 1 × 1 cube removed can be covered by tiles.",
        "answer_symbols": [
            "×",
            "−"
        ]
    },
    "5.1 78 a)": {
        "question": "证明或反驳：只要 n 是一个正整数，就可用右三联骨牌完全覆盖下述形状的所有棋盘。（a）3×2^n",
        "answer": "每个 3 × 2k 的棋盘都可以以一种明显的方式覆盖：将两块拼在一起形成一个 3 × 2 的矩形，然后将这些矩形并排放置。特别是，对于所有 n ≥ 1，3 × 2n 的矩形可以被覆盖。",
        "answer_symbols": [
            "×",
            "≥"
        ]
    },
    "5.1 78 b)": {
        "question": "证明或反驳：只要 n 是一个正整数，就可用右三联骨牌完全覆盖下述形状的所有棋盘。（b）6×2^n",
        "answer": "这类似于 (a) 部分。对于所有 k ≥ 1，使用 (a) 部分中的两个 3 × 2k 棋盘覆盖，将它们并排放置，很容易覆盖 6 × 2k 的棋盘。",
        "answer_symbols": [
            "×",
            "≥"
        ]
    },
    "5.1 78 c)": {
        "question": "证明或反驳：只要 n 是一个正整数，就可用右三联骨牌完全覆盖下述形状的所有棋盘。（c）3×3^n",
        "answer": "一些尝试和错误显示，31 × 31 的棋盘无法被覆盖。因此，并非所有的这种棋盘都可以被覆盖。",
        "answer_symbols": [
            "×"
        ]
    },
    "5.1 79": {
        "question": "证明：用去掉了 1×1×1 立方体块的 2×2×2 立方体，可以完全覆盖去掉了 1×1×1 立方体块的三维 2^n×2^n×2^n 棋盘",
        "answer": "对于边长为 2^k 的立方体，如果移除一个 1x1x1 的小立方体，则可以使用特定形状的瓷砖完全铺满。基础步骤 P(1) 成立，因为一个瓷砖与要铺的实体重合。假设 P(k) 成立。现在考虑一个 2^(k+1)x2^(k+1)x2^(k+1) 的立方体，其中移除了一个 1x1x1 的小立方体。将这个物体用平行于其面并通过中心的平面分成八个部分。缺失的 1x1x1 小立方体出现在这八个部分中的一个。现在将一个瓷砖放置在大物体的中心，使得缺失的 1x1x1 小立方体位于大物体缺少 1x1x1 小立方体的八分之一中。这形成了八个 2^kx2^kx2^k 的立方体，每个都缺少一个 1x1x1 的小立方体。根据归纳假设，我们可以用瓷砖填充这八个物体中的每一个。将这些铺法组合起来就产生了所需的铺法。",
        "answer_symbols": [
            "^",
            "x"
        ]
    },
    "5.1 80": {
        "question": "证明：如果 n 大于 5，且 n 不能被 3 整除，则可以用右三联骨牌完全覆盖去掉一个格子的 n×n 棋盘",
        "answer": "这个问题太复杂了，无法在这里讨论。有关解决方案，请参阅 I. P. Chu 和 R. Johnsonbaugh 的文章 “Tiling Deficient Boards with Trominoes”，Mathematics Magazine 59(1986) 34–40。（注意这个虚构单词的拼写变化。）",
        "answer_symbols": []
    },
    "5.1 82": {
        "question": "找出一个不能用右三联骨牌覆盖去掉了 一个格子的 5×5 棋盘。证明：对这样的棋盘，不存在右三联骨牌的覆盖",
        "answer": "为了解释这个论证，我们将 5 × 5 的棋盘上的方格标记为 11, 12,..., 15, 21,..., 25, ..., 51,..., 55，其中第一个数字表示行号，第二个数字表示列号。此外，为了谈论右三连方（L 形瓷砖），想象它放置成像字母 L；然后我们称顶上的方格为头，右下角的方格为尾，角落的方格为角。我们声称，移除方格 12 后的棋盘不能被铺满。首先注意到，为了覆盖方格 11，一个部件的位置是固定的。接下来我们考虑如何覆盖方格 13。有三种可能性。如果我们在那里放一个头，那么我们被迫在方格 15 放另一个部件的角。如果我们在那里放一个角，那么我们被迫在 15 放另一个部件的尾，而如果我们在那里放一个尾，那么方格 15 根本无法被覆盖。所以我们得出结论，方格 13, 14, 15, 23, 24, 和 25 必须由另外两块部件覆盖。通过对称性，同样的论点表明，另外两块部件必须覆盖方格 31, 41, 51, 32, 42, 和 52。这已经被迫完成，现在我们剩下棋盘左下角的一个 3 × 3 的方格需要用三块更多的部件覆盖。如果我们把角放在 33，那么我们立即陷入无法覆盖 53 和 35 的困境。如果我们把头放在 33，那么 53 无法被覆盖；而如果我们把尾放在 33，那么 35 无法被覆盖。所以，我们得出了矛盾，所需的覆盖不存在。",
        "answer_symbols": [
            "×"
        ]
    },
    "5.1 83": {
        "question": "利用数学归纳法原理证明：如果 P(b) 为真，且对满足 k≥b 的所有正整数 k，蕴含式 P(k)→P(k+1) 为真，则对 n=b，b+1，b+2，…，P(n) 为真，其中 b 是一个整数",
        "answer": "设 Q(n) 为 P(n + b - 1)。陈述 P(n) 对于 n = b, b + 1, b + 2, ... 是真的等同于陈述 Q(m) 对所有正整数 m 都是真的。我们已知 P(b) 是真的（即 Q(1) 是真的），并且对于所有 k ≥ b，P(k) → P(k + 1)（即对于所有正整数 m，Q(m) → Q(m + 1)）。因此，根据数学归纳原理，Q(m) 对所有正整数 m 都是真的。",
        "answer_symbols": [
            "→",
            "≥"
        ]
    },
    "5.2 1": {
        "question": "用强归纳法证明：如果你能跑一英里或两英里，且如果你能跑一个特定的英里数，那你就还能多跑两英里，证明你能跑任意的英里数。",
        "answer": "基础步骤：我们知道可以跑一英里，所以 P(1) 是真的。归纳步骤：假设归纳假设，即我们可以跑从 1 到 k 英里的任何距离。我们必须证明我们可以跑 k + 1 英里。如果 k = 1，那么我们已经知道可以跑两英里。如果 k > 1，那么归纳假设告诉我们可以跑 k - 1 英里，所以我们可以跑 (k - 1) + 2 = k + 1 英里。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            ">"
        ]
    },
    "5.2 2": {
        "question": "用强归纳法证明：如果你知道排列着无限长的多米诺骨牌中的前 3 个会倒下，且如果 1 个多米诺骨牌倒下，那么排在它后面的 3 个骨牌也会倒下，证明所有的多米诺骨牌都会倒下。",
        "answer": "设 P(n) 是第 n 个多米诺骨牌倒下的陈述。我们想证明对于所有正整数 n，P(n) 是正确的。对于基础步骤，给定条件告诉我们 P(1)，P(2)，和 P(3) 是正确的。对于归纳步骤，固定 k ≥ 3 并假设对于所有 j ≤ k，P(j) 是正确的。我们想证明 P(k + 1) 是正确的。由于 k ≥ 3，k - 2 是一个小于或等于 k 的正整数，因此根据归纳假设我们知道 P(k - 2) 是正确的。也就是说，我们知道第 (k - 2) 个多米诺骨牌倒下了。我们被告知“当一个多米诺骨牌倒下时，位于其后三个位置的多米诺骨牌也会倒下”，因此我们知道位置 (k - 2) + 3 = k + 1 处的多米诺骨牌会倒下。这就是 P(k + 1)。",
        "answer_symbols": [
            "≤",
            "=",
            "≥",
            "-",
            "+"
        ]
    },
    "5.2 3 a)": {
        "question": "设 P(n) 是命题：一份 n 分邮资可以只用 3 分和 5 分的邮票来构成。此练习简述了用强归纳法证明对 n ⩾ 8，P(n) 为真时的要点。证明 P(8)、P(9) 和 P(10) 为真，从而完成基础步骤的证明。",
        "answer": "P(8) 是真的，因为我们可以用一张 3 分邮票和一张 5 分邮票组成 8 分的邮资。P(9) 是真的，因为我们可以用三张 3 分邮票组成 9 分的邮资。P(10) 是真的，因为我们可以用两张 5 分邮票组成 10 分的邮资。",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "5.2 3 b)": {
        "question": "设 P(n) 是命题：一份 n 分邮资可以只用 3 分和 5 分的邮票来构成。此练习简述了用强归纳法证明对 n ⩾ 8，P(n) 为真时的要点。证明中的归纳假设是什么？",
        "answer": "使用仅 3 分和 5 分的邮票，我们可以组成所有 j 分的邮资，其中 8 ≤ j ≤ k，我们假设 k ≥ 10。",
        "answer_symbols": [
            "≤",
            "≥"
        ]
    },
    "5.2 3 c)": {
        "question": "设 P(n) 是命题：一份 n 分邮资可以只用 3 分和 5 分的邮票来构成。此练习简述了用强归纳法证明对 n ⩾ 8，P(n) 为真时的要点。在归纳步骤需要证明什么？",
        "answer": "假设归纳假设，我们可以用仅 3 分和 5 分的邮票组成 k + 1 分的邮资。",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "5.2 3 d)": {
        "question": "设 P(n) 是命题：一份 n 分邮资可以只用 3 分和 5 分的邮票来构成。此练习简述了用强归纳法证明对 n ⩾ 8，P(n) 为真时的要点。对 k ⩾ 10，完成归纳步骤。",
        "answer": "因为 k ≥ 10，我们知道 P(k - 2) 是真的，也就是说，我们可以组成 k - 2 分的邮资。再加一张 3 分的邮票，我们就组成了 k + 1 分的邮资。",
        "answer_symbols": [
            "≥",
            "+",
            "-"
        ]
    },
    "5.2 3 e)": {
        "question": "设 P(n) 是命题：一份 n 分邮资可以只用 3 分和 5 分的邮票来构成。此练习简述了用强归纳法证明对 n ⩾ 8，P(n) 为真时的要点。解释为什么上述步骤证明了：只要 n ⩾ 8，命题就为真。",
        "answer": "我们已经完成了基础步骤和归纳步骤，所以根据强归纳原理，该陈述对所有大于或等于 8 的整数 n 都是真的。",
        "answer_symbols": [
            "≥"
        ]
    },
    "5.2 4 a)": {
        "question": "设 P(n) 是命题：一份 n 分邮资可以只用 4 分和 7 分的邮票来构成。此练习简述了用强归纳法证明对 n ⩾ 18，P(n) 为真时的要点。证明 P(18)、P(19)、P(20) 和 P(21) 为真，从而完成基础步骤的证明。",
        "answer": "P(18) is true, because we can form 18 cents of postage with one 4-cent stamp and two 7-cent stamps. P(19) is true, because we can form 19 cents of postage with three 4-cent stamps and one 7-cent stamp. P(20) is true, because we can form 20 cents of postage with five 4-cent stamps. P(21) is true, because we can form 20 cents of postage with three 7-cent stamps.",
        "answer_symbols": []
    },
    "5.2 4 b)": {
        "question": "设 P(n) 是命题：一份 n 分邮资可以只用 4 分和 7 分的邮票来构成。此练习简述了用强归纳法证明对 n ⩾ 18，P(n) 为真时的要点。证明中的归纳假设是什么？",
        "answer": "The inductive hypothesis is the statement that using just 4-cent and 7-cent stamps we can form j cents postage for all j with 18 ≤ j ≤ k, where we assume that k ≥ 21.",
        "answer_symbols": [
            "≤",
            "≥"
        ]
    },
    "5.2 4 c)": {
        "question": "设 P(n) 是命题：一份 n 分邮资可以只用 4 分和 7 分的邮票来构成。此练习简述了用强归纳法证明对 n ⩾ 18，P(n) 为真时的要点。在归纳步骤需要证明什么？",
        "answer": "In the inductive step we must show, assuming the inductive hypothesis, that we can form k + 1 cents postage using just 4-cent and 7-cent stamps.",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "5.2 4 d)": {
        "question": "设 P(n) 是命题：一份 n 分邮资可以只用 4 分和 7 分的邮票来构成。此练习简述了用强归纳法证明对 n ⩾ 18，P(n) 为真时的要点。对 k ⩾ 21，完成归纳步骤。",
        "answer": "We want to form k + 1 cents of postage. Since k ≥ 21, we know that P(k − 3) is true, that is, that we can form k − 3 cents of postage. Put one more 4-cent stamp on the envelope, and we have formed k + 1 cents of postage, as desired.",
        "answer_symbols": [
            "≥",
            "−",
            "+",
            "="
        ]
    },
    "5.2 4 e)": {
        "question": "设 P(n) 是命题：一份 n 分邮资可以只用 4 分和 7 分的邮票来构成。此练习简述了用强归纳法证明对 n ⩾ 18，P(n) 为真时的要点。解释为什么上述步骤证明了：只要 n ⩾ 18，命题就为真。",
        "answer": "We have completed both the basis step and the inductive step, so by the principle of strong induction, the statement is true for every integer n greater than or equal to 18.",
        "answer_symbols": [
            "≥"
        ]
    },
    "5.2 5 a)": {
        "question": "确定只用 4 分和 11 分的邮票可以构成多少数量的邮资。",
        "answer": "4, 8, 11, 12, 15, 16, 19, 20, 22, 23, 24, 26, 27, 28 和所有大于或等于 30 的值",
        "answer_symbols": [
            ">="
        ]
    },
    "5.2 5 c)": {
        "question": "用强归纳法证明你对 a) 的回答。在该证明中，归纳假设与用数学归纳法原理证明中的归纳假设有什么不同？",
        "answer": "P(n) 与 b 部分相同。为了证明 P(n) 对所有 n ≥ 30 都是真的，我们检查基础步骤：30 = 11 + 11 + 4 + 4，31 = 11 + 4 + 4 + 4 + 4 + 4，32 = 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4，33 = 11 + 11 + 11。对于归纳步骤，假设归纳假设，即对于所有 30 ≤ j ≤ k 的 j，P(j) 是真的，其中 k 是任意一个大于或等于 33 的整数。我们想证明 P(k + 1) 是真的。因为 k - 3 ≥ 30，我们知道 P(k - 3) 是真的，也就是说，我们可以组成 k - 3 分的邮资。再加一张 4 分的邮票，我们就组成了 k + 1 分的邮资。在这个证明中，我们的归纳假设是 P(j) 对所有 30 到 k 之间的 j 都是真的，而不仅仅是 P(30) 是真的。",
        "answer_symbols": [
            "=",
            "+",
            "≥",
            "≤",
            "-"
        ]
    },
    "5.2 6 a)": {
        "question": "确定只用 3 分和 10 分的邮票可以构成多少数量的邮资。",
        "answer": "We can form the following amounts of postage as indicated: 3 = 3, 6 = 3 + 3, 9 = 3 + 3 + 3, 10 = 10, 12 = 3 + 3 + 3 + 3, 13 = 10 + 3, 15 = 3 + 3 + 3 + 3 + 3, 16 = 10 + 3 + 3, 18 = 3 + 3 + 3 + 3 + 3 + 3, 19 = 10 + 3 + 3 + 3, 20 = 10 + 10. By having considered all the combinations, we know that the gaps in this list cannot be filled. We claim that we can form all amounts of postage greater than or equal to 18 cents using just 3-cent and 10-cent stamps.",
        "answer_symbols": [
            "=",
            "+",
            "≥"
        ]
    },
    "5.2 6 b)": {
        "question": "用数学归纳法原理证明你对 a) 的回答。注意必须明确陈述归纳步骤中的归纳假设。",
        "answer": "Let P(n) be the statement that we can form n cents of postage using just 3-cent and 10-cent stamps. We want to prove that P(n) is true for all n ≥ 18. The basis step, n = 18, is handled above. Assume that we can form k cents of postage (the inductive hypothesis); we will show how to form k + 1 cents of postage. If the k cents included two 10-cent stamps, then replace them by seven 3-cent stamps (7 * 3 = 2 * 10 + 1). Otherwise, k cents was formed either from just 3-cent stamps, or from one 10-cent stamp and k − 10 cents in 3-cent stamps. Because k ≥ 18, there must be at least three 3-cent stamps involved in either case. Replace three 3-cent stamps by one 10-cent stamp, and we have formed k + 1 cents in postage (10 = 3 * 3 + 1).",
        "answer_symbols": [
            "≥",
            "=",
            "*",
            "+",
            "−"
        ]
    },
    "5.2 6 c)": {
        "question": "用强归纳法证明你对 a) 的回答。在该证明中，归纳假设与用数学归纳法原理证明中的归纳假设有什么不同？",
        "answer": "P(n) is the same as in part (b). To prove that P(n) is true for all n ≥ 18, we note for the basis step that from part (a), P(n) is true for n = 18, 19, 20. Assume the inductive hypothesis, that P(j) is true for all j with 18 ≤ j ≤ k, where k is a fixed integer greater than or equal to 20. We want to show that P(k + 1) is true. Because k − 2 ≥ 18, we know that P(k − 2) is true, that is, that we can form k − 2 cents of postage. Put one more 3-cent stamp on the envelope, and we have formed k + 1 cents of postage, as desired. In this proof our inductive hypothesis included all values between 18 and k inclusive, and that enabled us to jump back three steps to a value for which we knew how to form the desired postage.",
        "answer_symbols": [
            "≥",
            "≤",
            "−",
            "+",
            "="
        ]
    },
    "5.2 7": {
        "question": "只用 2 美元和 5 美元的钞票可以构成多少数量的钱？用强归纳法证明你的回答。",
        "answer": "我们可以组成所有金额，除了 1 美元和 3 美元。设 P(n) 为使用仅 2 美元和 5 美元的钞票组成 n 美元。我们要证明 P(n) 对所有 n ≥ 5 都是真的。（显然 1 美元和 3 美元不能组成，而 2 美元和 4 美元可以组成。）基础步骤：注意 5 = 5 和 6 = 2 + 2 + 2。假设归纳假设，即对于所有 5 ≤ j ≤ k 的 j，P(j) 是真的，其中 k 是任意一个大于或等于 6 的整数。我们想证明 P(k + 1) 是真的。因为 k - 1 ≥ 5，我们知道 P(k - 1) 是真的，也就是说，我们可以组成 k - 1 美元。再加一张 2 美元的钞票，我们就组成了 k + 1 美元。",
        "answer_symbols": [
            "=",
            "+",
            "≥",
            "≤",
            "-"
        ]
    },
    "5.2 8": {
        "question": "假设商店提供面额为 25 美元和 40 美元的礼券，确定用这些礼券可以构成多少可能的总量。用强归纳法证明你的回答。",
        "answer": "Since both 25 and 40 are multiples of 5, we cannot form any amount that is not a multiple of 5. So let’s determine for which values of n we can form 5n dollars using these gift certificates, the first of which provides 5 copies of $5, and the second of which provides 8 copies. We can achieve the following values of n: 5 = 5, 8 = 8, 10 = 5 + 5, 13 = 8 + 5, 15 = 5 + 5 + 5, 16 = 8 + 8, 18 = 8 + 5 + 5, 20 = 5 + 5 + 5 + 5 + 5, 21 = 8 + 8 + 5, 23 = 8 + 5 + 5 + 5, 24 = 8 + 8 + 8, 25 = 5 + 5 + 5 + 5 + 5, 26 = 8 + 8 + 5 + 5, 28 = 8 + 5 + 5 + 5 + 5, 29 = 8 + 8 + 8 + 5, 30 = 5 + 5 + 5 + 5 + 5 + 5, 31 = 8 + 8 + 5 + 5 + 5, 32 = 8 + 8 + 8 + 8. By having considered all the combinations, we know that the gaps in this list cannot be filled. We claim that we can form all amounts of postage greater than or equal to 18 cents using just 3-cent and 10-cent stamps.",
        "answer_symbols": [
            "≥",
            "+",
            "="
        ]
    },
    "5.2 9": {
        "question": "用强归纳法证明 √2 是无理数。[提示：设 P(n) 是命题：对任意正整数 b，√2 ≠ n/b。]",
        "answer": "设 P(n) 为不存在正整数 b 使得 √2 = n / b。基础步骤：P(1) 是真的，因为 √2 > 1 ≥ 1 / b 对所有正整数 b 都成立。归纳步骤：假设对于所有 j ≤ k，P(j) 是真的，其中 k 是任意一个正整数；我们通过反证法证明 P(k + 1) 是真的。假设 √2 = (k + 1) / b 对某个正整数 b 成立。那么 2b^² = (k + 1)^²，所以 (k + 1)^² 是偶数，因此 k + 1 是偶数。写成 k + 1 = 2t，其中 t 是某个正整数，于是 2b^² = 4t^² 和 b^² = 2t^²。通过相同的推理，b 是偶数，所以 b = 2s，其中 s 是某个正整数。那么 √2 = (k + 1) / b = (2t) / (2s) = t / s。但 t ≤ k，这与归纳假设矛盾，我们的归纳步骤证明完成。",
        "answer_symbols": [
            "√",
            "=",
            ">",
            "≥",
            "≤",
            "^",
            "/",
            "(",
            ")",
            "+",
            "²",
            "²"
        ]
    },
    "5.2 10": {
        "question": "假设一种巧克力棒由排列成长方形的 n 个方块组成。整个棒或棒的较小的长方形块可以沿着分隔方块的垂直线或水平线折断。假设一次只能折断一块，确定为了把整个棒折断成 n 个分开的方块，必须先后折断多少次。用强归纳法证明你的答案。",
        "answer": "We claim that breaking a chocolate bar (or any connected piece obtained by horizontal or vertical breaks) into n pieces requires exactly n - 1 breaks. We use strong induction. If n = 1, this is clearly true (one piece, no breaks needed). Assume the strong induction hypothesis, that the statement is true for splitting it into k or fewer pieces, and consider the task of splitting it into k + 1 pieces. We must show that this requires exactly k breaks. This process must start with one break, leaving two smaller pieces. We can think of the remaining process as splitting one part into i + 1 pieces and the other part into k - i pieces, where i ranges from 0 to k - 1 (inclusive). By the induction hypothesis, processing the first part requires exactly i breaks, and processing the second part requires exactly k - i - 1 breaks. Therefore, the total number of breaks will be 1 + i + (k - i - 1) = k, as desired.",
        "answer_symbols": [
            "+",
            "-",
            "=",
            "<=",
            ">="
        ]
    },
    "5.2 11": {
        "question": "考虑 Nim 游戏的如下变种。这个游戏从 n 根火柴开始。两名选手轮流取走火柴，每次取一根、两根或三根。取走最后一根火柴的选手落败。用强归纳法证明：如果每名选手按照最好可能的策略来玩游戏，那么若对于某个非负整数 j 来说，n = 4j、4j + 2 或 4j + 3 时，则第一名选手获胜，而在 n = 4j + 1 的其他情形下第二名选手获胜。",
        "answer": "基础步骤：有四种基本情况。如果 n = 1 = 4 * 0 + 1，那么显然第二个玩家赢。如果有两个、三个或四个火柴（n = 4 * 0 + 2，n = 4 * 0 + 3 或 n = 4 * 1），则第一个玩家可以通过移除所有但一个火柴来赢。归纳步骤：假设强归纳假设，在具有 k 或更少火柴的游戏中，如果 k ≡ 0, 2, 或 3 (mod 4)，则第一个玩家可以赢；如果 k ≡ 1 (mod 4)，则第二个玩家可以赢。假设我们有一个具有 k + 1 个火柴的游戏，其中 k ≥ 4。如果 k + 1 ≡ 0 (mod 4)，则第一个玩家可以移除三个火柴，留给另一个玩家 k - 2 个火柴。因为 k - 2 ≡ 1 (mod 4)，根据归纳假设，这是一个第二个玩家可以赢的游戏。如果 k + 1 ≡ 2 (mod 4)，则第一个玩家可以移除一个火柴；如果 k + 1 ≡ 3 (mod 4)，则第一个玩家可以移除两个火柴。如果 k + 1 ≡ 1 (mod 4)，则第一个玩家必须留给另一个玩家 k, k - 1, 或 k - 2 个火柴。因为 k ≡ 0 (mod 4)，k - 1 ≡ 3 (mod 4)，和 k - 2 ≡ 2 (mod 4)，根据归纳假设，这是第一个玩家在那个点（即我们的游戏中的第二个玩家）可以赢的游戏。",
        "answer_symbols": [
            "+",
            "mod",
            ")",
            "*",
            "(",
            "≥",
            "-",
            "≤",
            "≡",
            "="
        ]
    },
    "5.2 12": {
        "question": "用强归纳法证明：任意正整数 n 都可以写成 2 的不同幂次之和，即可以写成整数的一个子集 2^⁰ = 1、2¹ = 2、2^² = 4 等的和。[提示：对归纳步骤，分别考虑 k + 1 是偶数和奇数时的情况。当 k + 1 是偶数时，注意 (k + 1)/2 是整数。]",
        "answer": "The base step is to notice that 1 = 2^0. Note the subsequent steps: 2 = 2^1, 3 = 2^1 + 2^0, 4 = 2^2, 5 = 2^2 + 2^0, and so on. In fact, this is simply the binary representation (base two) of the numbers. Assume the induction hypothesis, that every positive integer up to k can be written as a sum of distinct powers of 2. We must show that k + 1 can also be written as a sum of distinct powers of 2. If k + 1 is odd, then k is even, so 2^0 is not in the sum for k. Therefore, the sum for k + 1 is the sum for k plus the additional term 2^0. If k + 1 is even, then (k + 1)/2 is a positive integer, so by the induction hypothesis, (k + 1)/2 can be written as a sum of distinct powers of 2. Doubling each exponent will double the value and give us the sum required for k + 1.",
        "answer_symbols": [
            "+",
            "^",
            "/",
            "="
        ]
    },
    "5.2 13": {
        "question": "拼板游戏是将拼板相接拼在一起而形成一块。每一步都将一片拼板拼到块上去或者将两块拼接在一起。用强归纳法证明：无论采用什么样的步骤，要拼成 n 片拼板的一块，都恰好需要 n-1 步才能完成。",
        "answer": "Let P(n) be the statement that exactly n - 1 moves are required to assemble a puzzle with n pieces. Now P(1) is trivially true. Assume that P(j) is true for all j ≤ k, and consider a puzzle with k + 1 pieces. The final move must be the joining of two blocks, of size j and k + 1 - j for some integer j with 1 ≤ j ≤ k. By the inductive hypothesis, it required j - 1 moves to construct the one block, and k + 1 - j - 1 = k - j moves to construct the other. Therefore, 1 + (j - 1) + (k - j) = k moves are required in all, so P(k + 1) is true.",
        "answer_symbols": [
            "=",
            "-",
            "+",
            "≤"
        ]
    },
    "5.2 14": {
        "question": "假设从一堆 n 块石头开始，通过连续地把一堆石头分成较小的两堆石头，把开始的这堆石头分成 n 堆，每堆只有 1 块石头。每次分开一堆石头时，就把所分出的较小的两堆石头的数目相乘，即如果分出的这两堆分别有 r 和 s 块石头，则计算出 rs。证明：无论如何分这些堆，每一步计算出来的乘积之和等于 n(n-1)/2。",
        "answer": "We use strong induction to prove this. When n = 1, it is clearly true, because no splits occur, so the total sum calculated is 0, which equals n(n - 1)/2 when n = 1. Assume the strong induction hypothesis, and suppose our first split divides the pile into i stones and n - i stones, where i is a positive integer less than n. This gives a product i(n - i). The rest of the products will be obtained by further splitting the piles thus formed, so by the induction hypothesis, the total sum of the products will be i(i - 1)/2 + (n - i)(n - i - 1)/2. We must show that for any i, i(n - i) + i(i - 1)/2 + (n - i)(n - i - 1)/2 = n(n - 1)/2. This can be shown by elementary algebra, completing our proof.",
        "answer_symbols": [
            "+",
            "-",
            "*",
            "/",
            "=",
            "(",
            ")"
        ]
    },
    "5.2 15": {
        "question": "证明：在 1.8 节例 12 的蚕食游戏中，如果初始格子是方形，那么第一选手具有一个获胜的策略。[提示：用强归纳法证明下面的策略是有效的。第一步，第一个选手咬掉除了左边和上边以外的所有饼干。在接下来的步骤中，当第二个选手咬掉上边或左边的饼干以后，第一个选手分别在左边或上边以相同的相对位置咬掉饼干。]",
        "answer": "Let the Chomp board have n rows and n columns. We claim that the first player can win the game by making the first move to leave just the top row and leftmost column. Let P(n) be the statement that if a player has presented his opponent with a Chomp configuration consisting of just n cookies in the top row and n cookies in the leftmost column, then he can win the game. We will prove ∀n P(n) by strong induction. We know that P(1) is true, because the opponent is forced to take the poisoned cookie at his first turn. Fix k ≥ 1 and assume that P(j) is true for all j ≤ k. We claim that P(k + 1) is true. It is the opponent’s turn to move. If she picks the poisoned cookie, then the game is over and she loses. Otherwise, assume she picks the cookie in the top row in column j, or the cookie in the left column in row j, for some j with 2 ≤ j ≤ k + 1. The first player now picks the cookie in the left column in row j, or the cookie in the top row in column j, respectively. This leaves the position covered by P(j - 1) for his opponent, so by the inductive hypothesis, he can win.",
        "answer_symbols": [
            "∀",
            "≤",
            "≥"
        ]
    },
    "5.2 16": {
        "question": "证明：在 1.8 节例 12 的蚕食游戏中，如果初始格子是两个方形，即台子是 2×n 的格子，那么第一选手具有获胜的策略。[提示：用强归纳法证明。第一个选手的第一步应该先咬掉最底层最右端的那块饼干。]",
        "answer": "We follow the hint to prove that the first player has a winning strategy in playing Chomp on a 2 × n board, starting by removing the rightmost cookie in the bottom row. Note that this leaves a board with n cookies in the top row and n - 1 cookies in the bottom row. It suffices to prove by strong induction on n that the player facing such a board will lose if the opponent plays correctly. We do this by showing how the opponent can restore the board to this form after any non-fatal move the player might make. The base step is n = 1, in which case only the poison cookie remains, so the player loses. Assume the induction hypothesis (that the statement is true for all smaller values of n). If the player chooses a non-poison cookie from the top row, this will leave another board with two rows of equal length, so the opponent again chooses the rightmost cookie in the bottom row, and we are back in the hopeless situation for some board with fewer than n cookies in the top row. If the player chooses the cookie in column m from the bottom row, then the opponent chooses the cookie in the (m + 1)st column from the left in the top row, and once again we are back to the hopeless situation, with m cookies in the top row.",
        "answer_symbols": [
            "(",
            "=",
            "<",
            "<=",
            "×",
            ")",
            "-",
            "+"
        ]
    },
    "5.2 17": {
        "question": "用强归纳法证明：如果对一个具有 4 条边的简单多边形进行三角形化，那么三角形化时至少有两个三角形都有两条边是该多边形的外部边界。",
        "answer": "Let P(n) be the statement that if a simple polygon with n sides is triangulated, then at least two of the triangles in the triangulation have two sides that border the exterior of the polygon. We will prove ∀n ≥ 4 P(n). The statement is clearly true for n = 4, because there is only one diagonal, leaving two triangles with the desired property. Fix k ≥ 4 and assume that P(j) is true for all j with 4 ≤ j ≤ k. Consider a polygon with k + 1 sides, and some triangulation of it. Pick one of the diagonals in this triangulation. First suppose that this diagonal divides the polygon into one triangle and one polygon with k sides. Then the triangle has two sides that border the exterior. Furthermore, the k-gon has, by the inductive hypothesis, two triangles that have two sides that border the exterior of that k-gon, and only one of these triangles can fail to be a triangle that has two sides that border the exterior of the original polygon. The only other case is that this diagonal divides the polygon into two polygons with j sides and k + 3 - j sides for some j with 4 ≤ j ≤ k - 1. By the inductive hypothesis, each of these two polygons has two triangles that have two sides that border their exterior, and in each case only one of these triangles can fail to be a triangle that has two sides that border the exterior of the original polygon.",
        "answer_symbols": [
            "∀",
            "≥",
            "≤",
            "+",
            "-"
        ]
    },
    "5.2 18": {
        "question": "用强归纳法证明：当把一个具有相邻顶点 v1, v2, …, vn 的凸多边形 P 三角形化为 n-2 个三角形时，这 n-2 个三角形可以编号为 1, 2, …, n-2，使得对 i=1, 2, …, n-2，都有 vi 是三角形的一个顶点。",
        "answer": "We prove something slightly stronger: If a convex n-gon whose vertices are labeled consecutively as v_m, v_(m+1), ..., v_(m+n−1) is triangulated, then the triangles can be numbered from m to m + n − 3 so that v_i is a vertex of triangle i for i = m, m + 1, ..., m + n − 3. (The statement we are asked to prove is the case m = 1.) The basis step is n = 3, and there is nothing to prove. For the inductive step, assume the inductive hypothesis that the statement is true for polygons with fewer than n vertices, and consider any triangulation of a convex n-gon whose vertices are labeled consecutively as v_m, v_(m+1), ..., v_(m+n−1). One of the diagonals in the triangulation must have either v_(m+n−1) or v_(m+n−2) as an endpoint (otherwise, the region containing v_(m+n−1) would not be a triangle). So there are two cases. If the triangulation uses diagonal v_k v_(m+n−1), then we apply the inductive hypothesis to the two polygons formed by this diagonal, renumbering v_(m+n−1) as v_(k+1) in the polygon that contains v_m. This gives us the desired numbering of the triangles, with numbers v_m through v_(k−1) in the first polygon and numbers v_k through v_(m+n−3) in the second polygon. If the triangulation uses diagonal v_k v_(m+n−2), then we apply the inductive hypothesis to the two polygons formed by this diagonal, renumbering v_(m+n−2) as v_(k+1) and v_(m+n−1) as v_(k+2) in the polygon that contains v_(m+n−1), and renumbering all the vertices by adding 1 to their indices in the other polygon. This gives us the desired numbering of the triangles, with numbers v_m through v_k in the first polygon and numbers v_(k+1) through v_(m+n−3) in the second polygon. Note that we did not need the convexity of our polygons.",
        "answer_symbols": [
            "+",
            "-",
            "…",
            "∈",
            "≠"
        ]
    },
    "5.2 19": {
        "question": "Pick 定理断言：平面上顶点都在格点上（即顶点都具有整数坐标的）的简单多边形的面积等于 I(P) + B(P)/2 - 1，其中 I(P) 和 B(P) 分别是 P 内和 P 的边界上格点的个数。利用强归纳法证明关于 P 的顶点数来证明 Pick 定理。[提示：关于基础步骤，首先对矩形证明定理成立，然后对直角三角形证明定理成立，最后注意到：一个三角形区域是由包含该三角形在内的一个较大的矩形区域减去至多三个三角形区域所得到的结果。关于归纳步骤，利用引理 1 即可。]",
        "answer": "Let P(n) be the statement that the area of a simple polygon with n sides and vertices all at lattice points is given by I(P) + B(P)/2 - 1. We will prove P(n) for all n ≥ 3. We begin with an additivity lemma: If P is a simple polygon with all vertices at lattice points, divided into polygons P1 and P2 by a diagonal, then I(P) + B(P)/2 - 1 = [I(P1) + B(P1)/2 - 1] + [I(P2) + B(P2)/2 - 1]. To prove this, suppose there are k lattice points on the diagonal, not counting its endpoints. Then I(P) = I(P1) + I(P2) + k and B(P) = B(P1) + B(P2) - 2k - 2; and the result follows by simple algebra. What this says in particular is that if Pick’s formula gives the correct area for P1 and P2, then it must give the correct formula for P, whose area is the sum of the areas for P1 and P2; and similarly if Pick’s formula gives the correct area for P and one of the Pi’s, then it must give the correct formula for the other Pi. Next we prove the theorem for rectangles whose sides are parallel to the coordinate axes. Such a rectangle necessarily has vertices at (a, b), (a, c), (d, b), and (d, c), where a, b, c, and d are integers with b < c and a < d. Its area is (c - b)(d - a). Also, B = 2(c - b + d - a) and I = (c - b - 1)(d - a - 1) = (c - b)(d - a) - (c - b) - (d - a) + 1. Therefore, I + B/2 - 1 = (c - b)(d - a) - (c - b) - (d - a) + 1 + (c - b + d - a) - 1 = (c - b)(d - a), which is the desired area. Next consider a right triangle whose legs are parallel to the coordinate axes. This triangle is half a rectangle of the type just considered, for which Pick’s formula holds, so by the additivity lemma, it holds for the triangle as well. For the next step, consider an arbitrary triangle with vertices at lattice points that is not of the type already considered. Embed it in as small a rectangle as possible. There are several possible ways this can happen, but in any case (and adding one more edge in one case), the rectangle will have been partitioned into the given triangle and two or three right triangles with sides parallel to the coordinate axes. Again by the additivity lemma, we are guaranteed that Pick’s formula gives the correct area for the given triangle. This completes the proof of P(3), the basis step in our strong induction proof. For the inductive step, given an arbitrary polygon, use Lemma 1 in the text to split it into two polygons. Then by the additivity lemma above and the inductive hypothesis, we know that Pick’s formula gives the correct area for this polygon.",
        "answer_symbols": [
            "∀",
            "≥",
            "+",
            "-",
            "*",
            "/",
            "=",
            "<"
        ]
    },
    "5.2 20": {
        "question": "设 P 是简单多边形，其顶点分别为 v1, v2, …, vn，相邻顶点之间都有一条边，且 v1 和 vn 之间也有一条边。如果连接 vi 的两个邻接的线段的一条内部对角线，则称顶点 vi 是一只耳朵。如果具有耳朵 vi 和它的两个邻接顶点所构成的三角形内部与耳朵 vj 和它的两个邻接顶点所构成的三角形内部不相交，则称耳朵 vi 和耳朵 vj 是不重叠的。证明：任何具有至少 4 个顶点的简单多边形都具有至少两只不重叠的耳朵。",
        "answer": "The proof takes several pages and can be found in an article entitled 'Polygons Have Ears' by Gary H. Meisters in The American Mathematical Monthly 82(1975) 648–651.",
        "answer_symbols": []
    },
    "5.2 21 a)": {
        "question": "在引理 1 的证明中曾提到过：关于寻找顶点 p，使得线段 bp 是 P 的一条内部对角线的许多不正确的方法也都得到了发表。该练习给出了一些错误证明中选择 p 的方法。考虑下图所示的两个多边形，证明对如下每种关于 p 的错误选择，线段 bp 不一定是 P 的一条内部对角线。p 是 P 的满足角∠abp 最小的顶点。",
        "answer": "In the left figure ∠abp is smallest, but bp is not an interior diagonal.",
        "answer_symbols": [
            "∠"
        ]
    },
    "5.2 21 b)": {
        "question": "在引理 1 的证明中曾提到过：关于寻找顶点 p，使得线段 bp 是 P 的一条内部对角线的许多不正确的方法也都得到了发表。该练习给出了一些错误证明中选择 p 的方法。考虑下图所示的两个多边形，证明对如下每种关于 p 的错误选择，线段 bp 不一定是 P 的一条内部对角线。p 是 P 的具有最小 x 坐标（b 除外）的顶点。",
        "answer": "In the right figure bd is not an interior diagonal.",
        "answer_symbols": []
    },
    "5.2 21 c)": {
        "question": "在引理 1 的证明中曾提到过：关于寻找顶点 p，使得线段 bp 是 P 的一条内部对角线的许多不正确的方法也都得到了发表。该练习给出了一些错误证明中选择 p 的方法。考虑下图所示的两个多边形，证明对如下每种关于 p 的错误选择，线段 bp 不一定是 P 的一条内部对角线。p 是 P 的与 b 距离最近的顶点。",
        "answer": "In the right figure bd is not an interior diagonal.",
        "answer_symbols": []
    },
    "5.2 23 a)": {
        "question": "解释当使用强归纳法证明对所有大于等于 4 的整数 n 证明 E(n) 为真时，会陷入困境之地。",
        "answer": "When we try to prove the inductive step and find a triangle in each subpolygon with at least two sides bordering the exterior, it may happen in each case that the triangle we are guaranteed in fact borders the diagonal (which is part of the boundary of that polygon). This leaves us with no triangles guaranteed to touch the boundary of the original polygon.",
        "answer_symbols": [
            "≥",
            "≤"
        ]
    },
    "5.2 24": {
        "question": "在 3.1 节练习 60 的说明中定义的稳定指派称为一个最佳指派。如果不存在这样的稳定指派，一个求婚者与一个他喜欢的被追求者配成了一对。用强归纳法证明：延期接纳算法对求婚者将产生一个最佳稳定指派。",
        "answer": "Call a suitee w and a suitor m 'possible' for each other if there exists a stable assignment in which m and w are paired. We will prove that if a suitee w rejects a suitor m, then w is impossible for m. Since the suitors propose in their preference order, the desired conclusion follows. The proof is by induction on the round in which the rejection happens. We will let m be Bob and w be Alice in our discussion. If it is the first round, then say that Bob and Ted both propose to Alice (necessarily the first choice of each of them). 假设爱丽丝拒绝了鲍勃，因为她更喜欢泰德。不可能存在一个稳定的分配，其中鲍勃与爱丽丝配对，因为那时爱丽丝和泰德将形成一个不稳定的配对（爱丽丝更喜欢泰德而不是鲍勃，而泰德更喜欢爱丽丝胜过任何人，因此特别更喜欢她而不是他的伴侣）。所以假设归纳假设，即到目前为止所有被拒绝的追求者对于所有拒绝他们的追求者来说都是不可能的。这时鲍勃向爱丽丝求婚，爱丽丝为了泰德而拒绝了他。泰德之所以向爱丽丝求婚是因为她是他在没有拒绝他的人中最喜欢的；但根据归纳假设，所有拒绝他的人对他来说都是不可能的。但现在不可能存在一个稳定的分配，其中鲍勃和爱丽丝配对，因为这样的分配会再次让爱丽丝和泰德不开心——爱丽丝因为她更喜欢泰德而不是鲍勃，而泰德因为他更喜欢爱丽丝而不是他最终配对的人（记住，根据归纳假设，他不可能与比爱丽丝更喜欢的人配对）。这完成了归纳步骤。\n更多信息，请参阅该主题的开创性文章（David Gale 和 Lloyd S. Shapley 在《美国数学月刊》69 (1962) 9-15 页发表的“大学录取和婚姻稳定性”）或权威书籍（Dan Gusfield 和 Robert W. Irving 出版的《稳定婚姻问题：结构和算法》(MIT Press, 1989)）。\n",
        "answer_symbols": []
    },
    "5.2 25 a)": {
        "question": "设 P(n) 是命题函数。确定对哪些正整数 n，命题 P(n) 必为真，验证你的答案，如果 P(1) 为真；对所有的正整数 n，如果 P(n) 为真，那么 P(n+2) 为真。",
        "answer": "P(3), P(5),... 都是正确的，但我们无法得出关于 P(2), P(4),... 的结论。",
        "answer_symbols": []
    },
    "5.2 25 b)": {
        "question": "设 P(n) 是命题函数。确定对哪些正整数 n，命题 P(n) 必为真，验证你的答案，如果 P(1) 和 P(2) 为真；对所有的正整数 n，如果 P(n) 和 P(n+1) 为真，那么 P(n+2) 为真。",
        "answer": "对于所有正整数 n，使用强归纳法可以证明 P(n) 是正确的。",
        "answer_symbols": []
    },
    "5.2 25 c)": {
        "question": "设 P(n) 是命题函数。确定对哪些正整数 n，命题 P(n) 必为真，验证你的答案，如果 P(1) 为真；对所有的正整数 n，如果 P(n) 为真，那么 P(2n) 为真。",
        "answer": "归纳步骤使我们能够得出 P(2), P(4), P(8), P(16),... 都是正确的，但当 n 不是 2 的幂时，我们无法得出关于 P(n) 的结论。",
        "answer_symbols": []
    },
    "5.2 25 d)": {
        "question": "设 P(n) 是命题函数。确定对哪些正整数 n，命题 P(n) 必为真，验证你的答案，如果 P(1) 为真；对所有的正整数 n，如果 P(n) 为真，那么 P(n+1) 为真。",
        "answer": "这是数学归纳法；我们可以得出对于所有正整数 n，P(n) 是正确的。",
        "answer_symbols": []
    },
    "5.2 26 a)": {
        "question": "设 P(n) 是命题函数。确定对哪些非负整数 n，命题 P(n) 必为真，如果 P(0) 为真；对所有的非负整数 n，如果 P(n) 为真，那么 P(n+2) 为真。",
        "answer": "显然这些条件告诉我们 P(n) 对于 n 的偶数值是成立的，即 0, 2, 4, 6, 8, ... 此外，显然我们无法确定 P(n) 对于其他值的 n 是否成立。",
        "answer_symbols": []
    },
    "5.2 26 b)": {
        "question": "设 P(n) 是命题函数。确定对哪些非负整数 n，命题 P(n) 必为真，如果 P(0) 为真；对所有的非负整数 n，如果 P(n) 为真，那么 P(n+3) 为真。",
        "answer": "显然这些条件告诉我们 P(n) 对于 n 是 3 的倍数时是成立的，即 0, 3, 6, 9, 12, ... 此外，显然我们无法确定 P(n) 对于其他值的 n 是否成立。",
        "answer_symbols": []
    },
    "5.2 26 c)": {
        "question": "设 P(n) 是命题函数。确定对哪些非负整数 n，命题 P(n) 必为真，如果 P(0) 和 P(1) 为真；对所有的非负整数 n，如果 P(n) 和 P(n+1) 为真，那么 P(n+2) 为真。",
        "answer": "这些条件足以通过归纳法证明 P(n) 对所有非负整数 n 都成立。",
        "answer_symbols": []
    },
    "5.2 26 d)": {
        "question": "设 P(n) 是命题函数。确定对哪些非负整数 n，命题 P(n) 必为真，如果 P(0) 为真；对所有的非负整数 n，如果 P(n) 为真，那么 P(n+2) 和 P(n+3) 为真。",
        "answer": "我们立即知道 P(0)，P(2)，和 P(3) 是成立的，显然我们无法确定 P(1) 是否成立。一旦我们有了 P(2) 和 P(3)，归纳步骤 P(n) → P(n + 2) 就使我们能够确定 P(n) 对所有 n ≥ 2 都成立。",
        "answer_symbols": [
            "→",
            "≥"
        ]
    },
    "5.2 27": {
        "question": "证明如果命题：对无限多的正整数 n P(n) 为真，且对所有正整数 n P(n+1)→P(n) 为真，那么，对所有正整数 n P(n) 为真。",
        "answer": "为了反证法，假设存在某个正整数 n 使得 P(n) 不正确。设 m 是大于 n 的最小正整数，使得 P(m) 是正确的；我们知道这样的 m 存在，因为对于无穷多个 m 值，P(m) 是正确的。但是我们知道 P(m) → P(m-1)，所以 P(m-1) 也是正确的。因此，m - 1 不能大于 n，所以 m - 1 = n 并且 P(n) 实际上是正确的。这个矛盾表明对于所有 n，P(n) 是正确的。",
        "answer_symbols": [
            "→"
        ]
    },
    "5.2 28": {
        "question": "设 b 是一个固定的整数，j 是一个固定的正整数。证明：如果对所有正整数 k≥b+j，都有 P(b)，P(b+1)，…，P(b+j) 为真，且 [P(b) ∧ P(b+1) ∧ … ∧ P(k)]→P(k+1) 为真 (k≥b+j)，则对所有 n≥b 的整数 n，P(n) 为真。",
        "answer": "我们通过强归纳法在 n 上证明 P(n) 对所有 n ≥ b 都成立。基础步骤是 n = b，这是由给定条件成立的。对于归纳步骤，固定一个整数 k ≥ b 并假设归纳假设，如果对于所有 b ≤ j ≤ k 的 j，P(j) 成立，则 P(k + 1) 成立。有两种情况。如果 k + 1 ≤ b + j，那么 P(k + 1) 由给定条件成立。另一方面，如果 k + 1 > b + j，那么给定的条件语句的前件由归纳假设成立，因此 P(k + 1) 又一次成立。",
        "answer_symbols": [
            "≥",
            "≤",
            ">",
            "→"
        ]
    },
    "5.2 29": {
        "question": "下面强归纳法的“证明”有什么错误？“定理”：对所有非负整数 n，都有 5×n=0。基础步骤：5×0=0。归纳步骤：假设对所有满足 0≤j≤k 的非负整数 j，都有 5j=0。设 k+1=i+j，其中 i、j 都是小于 k+1 的自然数。根据归纳假设，有 5(k+1)=5(i+j)=5i+5j=0+0=0。",
        "answer": "在从基本情况 n=0 到下一个情况 n=1 的过程中；我们不能将 1 写成两个更小的自然数的和。",
        "answer_symbols": []
    },
    "5.2 30": {
        "question": "找出下列“证明”的错误：当 a 是非零实数时，对所有非负整数 n 来说，有 a^n=1。基础步骤：根据 a^0 的定义，a^0=1 为真。归纳步骤：假设对满足 j≤k 的所有非负整数 j 来说，a^j=1。注意 a^(k+1) = a^k · a^k / a^(k-1) = 1 · 1 / 1 = 1。",
        "answer": "缺陷出现在归纳步骤中，我们隐式地假设 k ≥ 1 以便谈论 a(k - 1) 在分母中（否则指数不是非负整数，因此我们不能应用归纳假设）。我们的基础步骤是 n = 0，所以在尝试证明 k + 1 时的归纳步骤中，我们不能假设 k ≥ 1。实际上，正是在 n = 1 时命题失败了。",
        "answer_symbols": [
            "≥",
            "-",
            "/"
        ]
    },
    "5.2 31": {
        "question": "通过证明从良序性公理得出强归纳法来证明强归纳法是有效的证明方法。",
        "answer": "有序原则成立。假设 P(1) 是正确的，并且对于每个正整数 n，条件语句 [P(1) ∧ P(2) ∧ ... ∧ P(n)] → P(n+1) 是正确的。设 S 是 P(n) 为假的所有正整数 n 的集合。我们将证明 S = ∅。假设 S ≠ ∅。那么根据有序原则，S 中存在一个最小的整数 m。我们知道 m 不能是 1，因为 P(1) 是正确的。因为 n = m 是 P(n) 为假的最小整数，所以 P(1), P(2), ..., P(m-1) 都是正确的，并且 m-1 ≥ 1。因为 [P(1) ∧ P(2) ∧ ... ∧ P(m-1)] → P(m) 是正确的，所以 P(m) 必须也是正确的，这是矛盾的。因此，S = ∅。",
        "answer_symbols": [
            "∧",
            "→"
        ]
    },
    "5.2 32": {
        "question": "找出下面“证明”中的瑕疵：任意大于等于 3 分的邮资都可以只用 3 分和 4 分的邮票来构成。基础步骤：可以只用一张 3 分的邮票来构成 3 分的邮资，只用一张 4 分的邮票来构成 4 分的邮资。归纳步骤：假设对所有满足 j≤k 的非负整数 j，只用 3 分和 4 分的邮票就能构成 j 分的邮资。那么就可以通过用一张 4 分的邮票代替一张 3 分的邮票，或通过用三张 3 分的邮票代替两张 4 分的邮票来构成 k+1 分的邮资。",
        "answer": "当 k = 4 时，证明无效。我们不能通过指示的任何替换将邮资从 4 分增加到 5 分，因为没有 3 分的邮票，而且只有一个 4 分的邮票。归纳步骤中还有一个小缺陷，因为没有提到 j ≥ 3 的条件。",
        "answer_symbols": [
            "=",
            "≥"
        ]
    },
    "5.2 33 a)": {
        "question": "证明：如果能够证明如下命题，那么就可以证明：对所有的正整数 n 和 k，P(n, k) 为真。P(1, 1) 为真，且对所有的正整数 n 和 k，P(n, k)→[P(n+1, k) ∧ P(n, k+1)] 为真。",
        "answer": "选择 n + k 尽可能小的反例。我们不能有 n = 1 和 k = 1，因为已知 P(1, 1) 是正确的。因此，要么 n > 1 或者 k > 1。在前一种情况下，根据我们的反例选择，我们知道 P(n-1, k) 是正确的。但归纳步骤迫使 P(n, k) 也必须是正确的，这是矛盾的。后一种情况类似。因此，假设存在反例是错误的，P(n, k) 在所有情况下都是正确的。",
        "answer_symbols": []
    },
    "5.2 33 b)": {
        "question": "证明：如果能够证明如下命题，那么就可以证明：对所有的正整数 n 和 k，P(n, k) 为真。对所有的正整数 k，P(1, k) 为真，且对所有的正整数 n 和 k，P(n, k) → P(n + 1, k) 为真。",
        "answer": "选择 n 尽可能小的反例。我们不能有 n = 1，因为已知对于所有 k，P(1, k) 是正确的。因此，n > 1。根据我们的反例选择，我们知道 P(n-1, k) 是正确的。但归纳步骤迫使 P(n, k) 也必须是正确的，这是矛盾的。",
        "answer_symbols": []
    },
    "5.2 33 c)": {
        "question": "证明：如果能够证明如下命题，那么就可以证明：对所有的正整数 n 和 k，P(n, k) 为真。对所有的正整数 n，P(n, 1) 为真，且对所有的正整数 n 和 k，P(n, k) → P(n, k + 1) 为真。",
        "answer": "选择 k 尽可能小的反例。我们不能有 k = 1，因为已知对于所有 n，P(n, 1) 是正确的。因此，k > 1。根据我们的反例选择，我们知道 P(n, k-1) 是正确的。但归纳步骤迫使 P(n, k) 也必须是正确的，这是矛盾的。",
        "answer_symbols": []
    },
    "5.2 34": {
        "question": "证明：对所有的正整数 n 和 k，∑_{j=1}^{n} j(j + 1)(j + 2) ⋯ (j + k - 1) = n(n + 1)(n + 2) ⋯ (n + k) / (k + 1)。[提示：利用练习 33 中的技巧。]",
        "answer": "We need to prove the statement for n + 1, namely, ∑ from j=1 to n+1 of j(j + 1)(j + 2) ... (j + k - 1) = (n + 1)(n + 2) ... (n + k)(n + k + 1) / (k + 1). We have: ∑ from j=1 to n+1 of j(j + 1)(j + 2) ... (j + k - 1) = (∑ from j=1 to n of j(j + 1)(j + 2) ... (j + k - 1)) + (n + 1)(n + 2) ... (n + k) = (n(n + 1)(n + 2) ... (n + k) / (k + 1)) + (n + 1)(n + 2) ... (n + k) = (n + 1)(n + 2) ... (n + k) * (n / (k + 1) + 1) = (n + 1)(n + 2) ... (n + k) * ((n + k + 1) / (k + 1)), as desired.",
        "answer_symbols": [
            "!",
            "+",
            "*",
            "/",
            "=",
            "∑"
        ]
    },
    "5.2 35": {
        "question": "证明：若 a_1, a_2, ⋯, a_n 是 n 个不同的实数，则无论在它们的乘积中插入多少对括号，计算这 n 个数之积都要使用 n - 1 次乘法。[提示：利用强归纳法并且考虑最后一次的乘法。]",
        "answer": "令 P(n) 表示如果 x₁, x₂,..., xₙ 是 n 个不同的实数，则无论括号如何插入，计算这些数的乘积都需要 n-1 次乘法。我们将使用强归纳法证明 P(n) 是正确的。基本情况 P(1) 是正确的，因为 1-1 = 0 次乘法是计算 x₁（只有一个因数的乘积）所需的。假设对于 1 ≤ k ≤ n，P(k) 是正确的。计算 n+1 个不同实数 x₁, x₂,..., xₙ, xₙ₊₁ 的乘积的最后一次乘法是前 k 个数的乘积与最后 n+1-k 个数的乘积的乘法。根据归纳假设，无论括号如何插入，计算 k 个数的乘积需要 k-1 次乘法，计算其他 n+1-k 个数的乘积需要 n-k 次乘法。因为还需要一次乘法来计算所有 n+1 个数的乘积，所以总共使用的乘法次数等于 (k-1) + (n-k) + 1 = n。因此，P(n+1) 是正确的。",
        "answer_symbols": [
            "+",
            "-",
            "=",
            "≤"
        ]
    },
    "5.2 36 a)": {
        "question": "证明：S 非空。",
        "answer": "That S is nonempty is trivial, since letting s = 1 and t = 1 gives a + b, which is certainly a positive integer in S.",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "5.2 36 b)": {
        "question": "用良序性证明：S 有最小元 c。",
        "answer": "The well-ordering property asserts that every nonempty set of positive integers has a least element. Since we just showed that S is a nonempty set of positive integers, it has a least element, which we will call c.",
        "answer_symbols": []
    },
    "5.2 36 c)": {
        "question": "证明：若 d 是 a 和 b 的公因子，则 d 是 c 的因子。",
        "answer": "If d is a divisor of a and of b, then it is also a divisor of as and bt, and hence of their sum. Since c is such a sum, d is a divisor of c.",
        "answer_symbols": [
            "+",
            "÷"
        ]
    },
    "5.2 36 d)": {
        "question": "证明：c | a 和 c | b。[提示：首先假定 c | a。则 a = qc + r，其中 0 < r < c。证明 r ∈ S，这与对 c 的选择相矛盾。]",
        "answer": "This is the hard part. By symmetry, it is enough to show one of these, say that c divides a. Assume (for a proof by contradiction) that c does not divide a. Then by the division algorithm, we can write a = qc + r, where 0 < r < c. Now c = as + bt (for appropriate choices of s and t), since c ∈ S, so we can compute that r = a - qc = a - q(as + bt) = a(1 - qs) + b(-qt). This expresses the positive integer r as a linear combination with integer coefficients of a and b and hence tells us that r ∈ S. But since r < c, this contradicts the choice of c. Therefore, our assumption that c does not divide a is wrong, and c divides a, as desired.",
        "answer_symbols": [
            "<",
            "=",
            "+",
            "-",
            "÷"
        ]
    },
    "5.2 36 e)": {
        "question": "从 c) 和 d) 得出：a 和 b 的最大公因子存在。通过证明两个正整数的最大公因子是唯一的来完成证明。",
        "answer": "We claim that the c found in this exercise is the greatest common divisor of a and b. Certainly by part (d) it is a common divisor of a and b. On the other hand, part (c) tells us that every common divisor of a and b is a divisor of (and therefore no greater than) c. Thus c is a greatest common divisor of a and b. Of course, the greatest common divisor is unique, since one cannot have two numbers, each of which is greater than the other.",
        "answer_symbols": [
            "<",
            "÷"
        ]
    },
    "5.2 37": {
        "question": "设 a 是一个整数，d 是一个正整数。证明：满足 a = dq + r 及 0 ≤ r < d 的整数 q 和 r 是唯一的。q 和 r 的存在性已在例 5 中证明过了。",
        "answer": "假设 a = dq + r = dq' + r' 且 0 ≤ r < d 且 0 ≤ r' < d。则 d(q - q') = r' - r。因此，d 整除 r' - r。因为 -d < r' - r < d，所以我们有 r' - r = 0。因此，r' = r。由此可得 q = q'。",
        "answer_symbols": [
            "=",
            "<",
            ">",
            "-"
        ]
    },
    "5.2 38": {
        "question": "用数学归纳法证明：具有偶数个格子且去掉了一个黑格和一个白格的矩形棋盘可用多米诺骨牌覆盖。",
        "answer": "In Exercise 46 of Section 1.8, we found a closed path that snakes its way around an 8 x 8 checkerboard to cover all the squares, and using that we were able to prove that when one black and one white square are removed, the remaining board can be covered with dominoes. The same reasoning works for any size board, so it suffices to show that any board with an even number of squares has such a snaking path. Note that a board with an even number of squares must have either an even number of rows or an even number of columns, so without loss of generality, assume that it has an even number of rows, say 2n rows and m columns. Number the squares in the usual manner, so that the first row contains squares 1 to m from left to right, the second row contains squares m + 1 to 2m from left to right, and so on, with the final row containing squares (2n - 1)m + 1 to 2nm from left to right. We will prove the stronger statement that any such board contains a path that includes the top row traversed from left to right. The basis step is n = 1, and in that case the path is simply 1, 2, ..., m, 2m, 2m - 1, ..., m + 1, 1. Assume the inductive hypothesis and consider a board with 2n + 2 rows. By the inductive hypothesis, the board obtained by deleting the top two rows has a closed path that includes its top row.行从左到右（即，2m+1, 2m+2,..., 3m）。将这个子序列替换为2m+1, m+1, 1, 2, ..., m, 2m, 2m − 1,..., m+2, 2m+2,..., 3m，我们得到所需的路径。",
        "answer_symbols": [
            "+",
            "-",
            "=",
            "..."
        ]
    },
    "5.2 39": {
        "question": "你能用良序性证明下面的命题吗？“每一个正整数都可以用不超过 15 个英语单词来描述”。假定这些词取自某个特定的英语词典。[提示：假如存在正整数，它们不能用不超过 15 个英语单词来描述。那么，根据良序性公理，不能用不超过 15 个英语单词来描述的最小整数是存在的。]",
        "answer": "这是一个由自引用引起的悖论。答案显然是“否”。英语单词的数量是有限的，因此只有有限数量的 15 个或更少单词的字符串；因此，只有有限数量的正整数可以用这种方式描述，而不是所有的正整数。",
        "answer_symbols": []
    },
    "5.2 40": {
        "question": "用数学归纳法证明：若 x 和 y 是满足 x < y 的实数，则存在有理数 r 满足 x < r < y。[提示：证明存在正整数 A 满足 A > 1 / (y - x)。然后通过考虑数 [x] + j / A，其中 j 是正整数，来证明存在有理数 r 具有介于 x 和 y 之间的分母 A。]",
        "answer": "如果x < y，则y-x是一个正实数，其倒数1/(y-x)也是一个正实数，因此我们可以选择一个正整数A > 1/(y - x)。（技术上这是实数的阿基米德性质；见附录1。）现在查看/x0 + (j/A)对于正整数j。每个这样的数都是有理数。选择j为最小的正整数，使得这个数大于x。这样的j存在，因为根据良序性原理，显然如果j足够大，那么/x0 + (j/A)会超过x。（注意j = 0的结果值不大于x。）所以我们有r = /x0 + (j/A) > x但/x0 + ((j - 1)/A) = r - (1/A) ≤ x。从这个不等式的最后一部分，用y - x代替1/A（这只会使左边更小），我们有r - (y - x) < x，从而r < y，如所愿。\n",
        "answer_symbols": []
    },
    "5.2 41": {
        "question": "证明：如果把数学归纳法原理作为公理，那么良序性是可以证明的。",
        "answer": "假设有序原则是错误的。设 S 是一个没有最小元素的非空非负整数集。设 P(n) 表示“对于 i = 0, 1, ..., n，i ∈ S。” P(0) 是正确的，因为如果 0 ∈ S，则 S 有一个最小元素，即 0。现在假设 P(n) 是正确的。因此，0 ∈ S, 1 ∈ S, ..., n ∈ S。显然，n+1 不能在 S 中，因为如果它在 S 中，它将是 S 的最小元素。因此 P(n+1) 是正确的。所以根据数学归纳法原理，对于所有非负整数 n，n ∈ S。因此，S = ∅，这是矛盾的。",
        "answer_symbols": [
            "∈",
            "∅",
            "→"
        ]
    },
    "5.2 42": {
        "question": "证明：数学归纳法原理与强归纳法是等价的，即每一个的有效性都可利用另一个的有效性来证明。",
        "answer": "强归纳原则显然意味着普通归纳，因为如果已经证明了P(k) → P(k+1)，那么自动地可以得出[P(1) ∧ ... ∧ P(k)] → P(k+1)；换句话说，每当使用普通归纳时，都可以调用强归纳。\n相反，假设P(n)是可以用强归纳证明的陈述。令Q(n)为P(1) ∧ ... ∧ P(n)。显然∀nP(n)在逻辑上等价于∀nQ(n)。我们展示如何通过普通归纳来证明∀nQ(n)。首先，Q(1)为真，因为Q(1) = P(1)，而P(1)在通过强归纳证明∀nP(n)的基础步骤中为真。现在假设Q(k)为真，即P(1) ∧ ... ∧ P(k)为真。通过强归纳证明∀nP(n)可知P(k+1)为真。但Q(k) ∧ P(k+1)就是Q(k+1)。\n因此我们通过普通归纳证明了∀nQ(n)。",
        "answer_symbols": []
    },
    "5.2 43": {
        "question": "证明：如果我们不把良序性作为公理，而是把数学归纳法原理或强归纳法作为公理，那么良序性是可以证明的。",
        "answer": "强归纳法蕴含数学归纳法原理，因为如果已经证明了 P(k) → P(k+1) 是正确的，那么也已经证明了 [P(1) ∧ ... ∧ P(k)] → P(k+1) 是正确的。根据练习 41，数学归纳法原理蕴含有序原则。因此，假设强归纳法作为公理，我们可以证明有序原则。",
        "answer_symbols": [
            "→",
            "∧"
        ]
    },
    "5.3 1 a)": {
        "question": "求出 f(1)、f(2)、f(3) 和 f(4)，若 f(n) 递归地定义成：f(0) = 1，而且对 n = 0, 1, 2, ⋯ 来说，f(n+1) = f(n) + 2。",
        "answer": "f(1) = 3, f(2) = 5, f(3) = 7, f(4) = 9",
        "answer_symbols": [
            "="
        ]
    },
    "5.3 1 b)": {
        "question": "求出 f(1)、f(2)、f(3) 和 f(4)，若 f(n) 递归地定义成：f(0) = 1，而且对 n = 0, 1, 2, ⋯ 来说，f(n+1) = 3f(n)。",
        "answer": "f(1) = 3, f(2) = 9, f(3) = 27, f(4) = 81",
        "answer_symbols": [
            "="
        ]
    },
    "5.3 1 c)": {
        "question": "求出 f(1)、f(2)、f(3) 和 f(4)，若 f(n) 递归地定义成：f(0) = 1，而且对 n = 0, 1, 2, ⋯ 来说，f(n+1) = 2^f(n)。",
        "answer": "f(1) = 2, f(2) = 4, f(3) = 16, f(4) = 65,536",
        "answer_symbols": [
            "="
        ]
    },
    "5.3 1 d)": {
        "question": "求出 f(1)、f(2)、f(3) 和 f(4)，若 f(n) 递归地定义成：f(0) = 1，而且对 n = 0, 1, 2, ⋯ 来说，f(n+1) = f(n)^2 + f(n) + 1。",
        "answer": "f(1) = 3, f(2) = 13, f(3) = 183, f(4) = 33,673",
        "answer_symbols": [
            "="
        ]
    },
    "5.3 2 a)": {
        "question": "求出 f(1)、f(2)、f(3)、f(4) 和 f(5)，若 f(n) 递归地定义成：f(0) = 3，而且对 n = 0, 1, 2, ⋯ 来说，f(n+1) = -2f(n)。",
        "answer": "f(1) = -2f(0) = -2 × 3 = -6, f(2) = -2f(1) = -2 × (-6) = 12, f(3) = -2f(2) = -2 × 12 = -24, f(4) = -2f(3) = -2 × (-24) = 48, f(5) = -2f(4) = -2 × 48 = -96\n",
        "answer_symbols": []
    },
    "5.3 2 b)": {
        "question": "求出 f(1)、f(2)、f(3)、f(4) 和 f(5)，若 f(n) 递归地定义成：f(0) = 3，而且对 n = 0, 1, 2, ⋯ 来说，f(n+1) = 3f(n) + 7。",
        "answer": "f(1) = 3f(0) + 7 = 3 × 3 + 7 = 16, f(2) = 3f(1) + 7 = 3 × 16 + 7 = 55, f(3) = 3f(2) + 7 = 3 × 55 + 7 = 172, f(4) = 3f(3) + 7 = 3 × 172 + 7 = 523, f(5) = 3f(4) + 7 = 3 × 523 + 7 = 1576\n",
        "answer_symbols": []
    },
    "5.3 2 c)": {
        "question": "求出 f(1)、f(2)、f(3)、f(4) 和 f(5)，若 f(n) 递归地定义成：f(0) = 3，而且对 n = 0, 1, 2, ⋯ 来说，f(n+1) = f(n)^2 - 2f(n) - 2。",
        "answer": "f(1) = f(0)^2 - 2f(0) - 2 = 3^2 - 2 × 3 - 2 = 1, f(2) = f(1)^2 - 2f(1) - 2 = 1^2 - 2 × 1 - 2 = -3, f(3) = f(2)^2 - 2f(2) - 2 = (-3)^2 - 2 × (-3) - 2 = 13, f(4) = f(3)^2 - 2f(3) - 2 = 13^2 - 2 × 13 - 2 = 141, f(5) = f(4)^2 - 2f(4) - 2 = 141^2 - 2 × 141 - 2 = 19,597\n",
        "answer_symbols": []
    },
    "5.3 2 d)": {
        "question": "求出 f(1)、f(2)、f(3)、f(4) 和 f(5)，若 f(n) 递归地定义成：f(0) = 3，而且对 n = 0, 1, 2, ⋯ 来说，f(n+1) = 3^f(n)/3。",
        "answer": "首先注意到f(1) = 3f(0)/3 = 3^3/3 = 3 = f(0)。以同样的方式，f(n) = 3 对所有n都成立。",
        "answer_symbols": []
    },
    "5.3 3 a)": {
        "question": "求出 f(2)、f(3)、f(4) 和 f(5)，若 f 递归地定义成：f(0) = -1，f(1) = 2，而且对 n = 1, 2, … 来说，f(n + 1) = f(n) + 3f(n - 1)",
        "answer": "f(2) = -1, f(3) = 5, f(4) = 2, f(5) = 17",
        "answer_symbols": [
            "="
        ]
    },
    "5.3 3 b)": {
        "question": "求出 f(2)、f(3)、f(4) 和 f(5)，若 f 递归地定义成：f(0) = -1，f(1) = 2，而且对 n = 1, 2, … 来说，f(n + 1) = f(n)^² f(n - 1)",
        "answer": "f(2) = -4, f(3) = 32, f(4) = -4096, f(5) = 536,870,912",
        "answer_symbols": [
            "="
        ]
    },
    "5.3 3 c)": {
        "question": "求出 f(2)、f(3)、f(4) 和 f(5)，若 f 递归地定义成：f(0) = -1，f(1) = 2，而且对 n = 1, 2, … 来说，f(n + 1) = 3f(n)^² - 4f(n - 1)^²",
        "answer": "f(2) = 8, f(3) = 176, f(4) = 92,672, f(5) = 25,764,174,848",
        "answer_symbols": [
            "="
        ]
    },
    "5.3 3 d)": {
        "question": "求出 f(2)、f(3)、f(4) 和 f(5)，若 f 递归地定义成：f(0) = -1，f(1) = 2，而且对 n = 1, 2, … 来说，f(n + 1) = f(n - 1) / f(n)",
        "answer": "f(2) = -21, f(3) = -4, f(4) = 18, f(5) = -325",
        "answer_symbols": [
            "="
        ]
    },
    "5.3 4 a)": {
        "question": "求出 f(2)、f(3)、f(4) 和 f(5)，若 f 递归地定义成：f(0) = f(1) = 1，而且对 n = 1, 2, … 来说，f(n + 1) = f(n) - f(n - 1)",
        "answer": "f(2) = f(1) - f(0) = 1 - 1 = 0, f(3) = f(2) - f(1) = 0 - 1 = -1, f(4) = f(3) - f(2) = -1 - 0 = -1, f(5) = f(4) - f(3) = -1 - 1 = 0\n",
        "answer_symbols": []
    },
    "5.3 4 b)": {
        "question": "求出 f(2)、f(3)、f(4) 和 f(5)，若 f 递归地定义成：f(0) = f(1) = 1，而且对 n = 1, 2, … 来说，f(n + 1) = f(n)^² + f(n - 1)^²",
        "answer": "显然f(n) = 1 对所有n都成立，因为1 × 1 = 1。",
        "answer_symbols": []
    },
    "5.3 4 c)": {
        "question": "求出 f(2)、f(3)、f(4) 和 f(5)，若 f 递归地定义成：f(0) = f(1) = 1，而且对 n = 1, 2, … 来说，f(n + 1) = f(n)^² - f(n - 1)^²",
        "answer": "f(2) = f(1)^2 + f(0)^3 = 1^2 + 1^3 = 2, f(3) = f(2)^2 + f(1)^3 = 2^2 + 1^3 = 5, f(4) = f(3)^2 + f(2)^3 = 5^2 + 2^3 = 33, f(5) = f(4)^2 + f(3)^3 = 33^2 + 5^3 = 1214\n",
        "answer_symbols": []
    },
    "5.3 4 d)": {
        "question": "求出 f(2)、f(3)、f(4) 和 f(5)，若 f 递归地定义成：f(0) = f(1) = 1，而且对 n = 1, 2, … 来说，f(n + 1) = f(n) / f(n - 1)",
        "answer": "显然f(n) = 1 对所有n都成立，因为1/1 = 1。",
        "answer_symbols": []
    },
    "5.3 5 a)": {
        "question": "确定下列这些所谓的定义是否每个都是从非负整数集合到整数集合的函数 f 的有效递归定义。如果 f 是良定义，则求出当 n 是非负整数时 f(n) 的一个公式并证明这个公式是有效的。f(0) = 0，对于 n ≥ 1 来说 f(n) = 2f(n - 2)。",
        "answer": "无效",
        "answer_symbols": []
    },
    "5.3 5 b)": {
        "question": "确定下列这些所谓的定义是否每个都是从非负整数集合到整数集合的函数 f 的有效递归定义。如果 f 是良定义，则求出当 n 是非负整数时 f(n) 的一个公式并证明这个公式是有效的。f(0) = 1，对于 n ≥ 1 来说 f(n) = f(n - 1) - 1。",
        "answer": "f(n) = 1 - n。基本情况：f(0) = 1 = 1 - 0。归纳步骤：如果 f(k) = 1 - k，则 f(k+1) = f(k) - 1 = 1 - k - 1 = 1 - (k+1)。",
        "answer_symbols": [
            "-",
            "="
        ]
    },
    "5.3 5 c)": {
        "question": "确定下列这些所谓的定义是否每个都是从非负整数集合到整数集合的函数 f 的有效递归定义。如果 f 是良定义，则求出当 n 是非负整数时 f(n) 的一个公式并证明这个公式是有效的。f(0) = 2，f(1) = 3，对于 n ≥ 2 来说 f(n) = f(n - 1) - 1。",
        "answer": "如果 n > 0，则 f(n) = 4 - n，且 f(0) = 2。基本情况：f(0) = 2 且 f(1) = 3 = 4 - 1。归纳步骤（k ≥ 1）：f(k+1) = f(k) - 1 = (4 - k) - 1 = 4 - (k+1)。",
        "answer_symbols": [
            "-",
            "=",
            "≥"
        ]
    },
    "5.3 5 d)": {
        "question": "确定下列这些所谓的定义是否每个都是从非负整数集合到整数集合的函数 f 的有效递归定义。如果 f 是良定义，则求出当 n 是非负整数时 f(n) 的一个公式并证明这个公式是有效的。f(0) = 1，f(1) = 2，对于 n ≥ 2 来说 f(n) = 2f(n - 2)。",
        "answer": "f(n) = 2^(n+1)/2。基本情况：f(0) = 1 = 2^(0+1)/2 且 f(1) = 2 = 2^(1+1)/2。归纳步骤（k ≥ 1）：f(k+1) = 2f(k-1) = 2 * 2^(k/2) = 2^(k/2+1) = 2^((k+1)+1)/2。",
        "answer_symbols": [
            "^",
            "*",
            "/",
            "=",
            "≥"
        ]
    },
    "5.3 5 e)": {
        "question": "确定下列这些所谓的定义是否每个都是从非负整数集合到整数集合的函数 f 的有效递归定义。如果 f 是良定义，则求出当 n 是非负整数时 f(n) 的一个公式并证明这个公式是有效的。f(0) = 1，如果 n 是奇数且 n ≥ 1 则 f(n) = 3f(n - 1)；如果 n 是偶数且 n ≥ 2 则 f(n) = 9f(n - 2)。",
        "answer": "f(n) = 3^n。基本情况：显然成立。归纳步骤：对于奇数 n，f(n) = 3f(n-1) = 3 * 3^(n-1) = 3^n；对于偶数 n > 1，f(n) = 9f(n-2) = 9 * 3^(n-2) = 3^n。",
        "answer_symbols": [
            "^",
            "*",
            "=",
            ">"
        ]
    },
    "5.3 6 a)": {
        "question": "确定下列这些所谓的定义是否每个都是从非负整数集合到整数集合的函数 f 的有效递归定义。如果 f 是良定义，则求出当 n 是非负整数时 f(n) 的一个公式并证明这个公式是有效的。f(0) = 1，对于 n ≥ 1 来说 f(n) = -f(n - 1)。",
        "answer": "这是有效的，因为我们提供了n = 0处的值，并且每个后续值由前一个值确定。由于从一个值到下一个值唯一改变的是符号，我们猜测f(n) = (-1)^n。\n这在n = 0时为真，因为(-1)^0 = 1。如果它在n = k时为真，那么我们有f(k+1) = -f(k+1-1) = -f(k) = -(-1)^k 根据归纳假设，因此f(k+1) = (-1)^(k+1)。",
        "answer_symbols": []
    },
    "5.3 6 b)": {
        "question": "确定下列这些所谓的定义是否每个都是从非负整数集合到整数集合的函数 f 的有效递归定义。如果 f 是良定义，则求出当 n 是非负整数时 f(n) 的一个公式并证明这个公式是有效的。f(0) = 1，f(1) = 0，f(2) = 2，对于 n ≥ 3 来说 f(n) = 2f(n - 3)。",
        "answer": "这是有效的，因为我们提供了n = 0, 1, 和2处的值，并且每个后续值由三步前的值确定。我们计算序列的前几项：1, 0, 2, 2, 0, 4, 4, 0, 8, .... 我们猜测公式f(n) = 2^(n/3) 当 n ≡ 0 (mod 3)。f(n) = 0 when n ≡ 1 (mod 3), f(n) = 2(n+1)/3 when n ≡ 2 (mod 3).**\n\nTo prove this, first note that in the base cases we have:\n- f(0) = 1 = 2^0 / 3\n- f(1) = 0\n- f(2) = 2 = 2(2+1)/3\n\nAssume the inductive hypothesis that the formula is valid for smaller inputs. Then for n ≡ 0 (mod 3) we have:\n- f(n) = 2f(n−3) = 2 · 2(n−3)/3 = 2 · 2^n / 3 · 2^−1 = 2^n / 3, as desired.\n\nFor n ≡ 1 (mod 3) we have:\n- f(n) = 2f(n − 3) = 2 · 0 = 0, as desired.\n\nAnd for n ≡ 2 (mod 3) we have:\n- f(n) = 2f(n − 3) = 2 · 2(n−3+1)/3 = 2 · 2(n+1)/3 · 2^−1 = 2(n+1)/3, as desired.",
        "answer_symbols": []
    },
    "5.3 6 c)": {
        "question": "确定下列这些所谓的定义是否每个都是从非负整数集合到整数集合的函数 f 的有效递归定义。如果 f 是良定义，则求出当 n 是非负整数时 f(n) 的一个公式并证明这个公式是有效的。f(0) = 0，f(1) = 1，对于 n ≥ 2 来说，f(n) = 2f(n + 1)。",
        "answer": "This is invalid.** We are told that f(2) is defined in terms of f(3), but f(3) has not been defined.",
        "answer_symbols": []
    },
    "5.3 6 d)": {
        "question": "确定下列这些所谓的定义是否每个都是从非负整数集合到整数集合的函数 f 的有效递归定义。如果 f 是良定义，则求出当 n 是非负整数时 f(n) 的一个公式并证明这个公式是有效的。f(0) = 0，f(1) = 1，对于 n ≥ 1 来说，f(n) = 2f(n - 1)。",
        "answer": "This is invalid, because the value at n = 1 is defined in two conflicting ways—first as f(1) = 1 and then as f(1) = 2f(1 − 1) = 2f(0) = 2 · 0 = 0.",
        "answer_symbols": [
            "=",
            "·"
        ]
    },
    "5.3 6 e)": {
        "question": "确定下列这些所谓的定义是否每个都是从非负整数集合到整数集合的函数 f 的有效递归定义。如果 f 是良定义，则求出当 n 是非负整数时 f(n) 的一个公式并证明这个公式是有效的。f(0) = 2，如果 n 是奇数且 n ≥ 1 则 f(n) = f(n - 1)；如果 n ≥ 2 则 f(n) = 2f(n - 2)。",
        "answer": "This appears syntactically to be not valid, since we have conflicting instructions for odd n ≥ 3. On the one hand f(3) = f(2), but on the other hand f(3) = 2f(1). However, we notice that f(1) = f(0) = 2 and f(2) = 2f(0) = 4, so these apparently conflicting rules tell us that f(3) = 4 on the one hand and f(3) = 2 · 2 = 4 on the other hand. Thus we got the same answer either way. Let us show that in fact this definition is valid because the rules coincide. We compute the first several terms of the sequence: 2, 2, 4, 4, 8, 8, .... We conjecture the formula: f(n) = 2^((n+1)/2). To prove this inductively, note first that f(0) = 2 = 2^((0+1)/2). For larger values we have for n odd using the first part of the recursive step that: f(n) = f(n−1) = 2^((n−1+1)/2) = 2^(n/2) = 2^((n+1)/2), since n/2 is not an integer. For n ≥ 2, whether even or odd, using the second part of the recursive step we have: f(n) = 2f(n − 2) = 2 · 2^((n−2+1)/2) = 2 · 2^((n+1)/2) − 1 = 2 · 2^((n+1)/2) · 2^−1 = 2^((n+1)/2), as desired.",
        "answer_symbols": [
            "=",
            "+",
            "/",
            "^",
            "−",
            "·"
        ]
    },
    "5.3 7 a)": {
        "question": "给出序列 {a_n} 的递归定义，n = 1, 2, 3, …，若 a_n = 6n",
        "answer": "a(n+1) = a(n) + 6 对于 n ≥ 1 且 a1 = 6",
        "answer_symbols": [
            "=",
            "+",
            "≥"
        ]
    },
    "5.3 7 b)": {
        "question": "给出序列 {a_n} 的递归定义，n = 1, 2, 3, …，若 a_n = 2n + 1",
        "answer": "a(n+1) = a(n) + 2 对于 n ≥ 1 且 a1 = 3",
        "answer_symbols": [
            "=",
            "+",
            "≥"
        ]
    },
    "5.3 7 c)": {
        "question": "给出序列 {a_n} 的递归定义，n = 1, 2, 3, …，若 a_n = 10^n",
        "answer": "a(n+1) = 10 * a(n) 对于 n ≥ 1 且 a1 = 10",
        "answer_symbols": [
            "=",
            "*",
            "≥"
        ]
    },
    "5.3 7 d)": {
        "question": "给出序列 {a_n} 的递归定义，n = 1, 2, 3, …，若 a_n = 5",
        "answer": "a(n+1) = a(n) 对于 n ≥ 1 且 a1 = 5",
        "answer_symbols": [
            "=",
            "≥"
        ]
    },
    "5.3 8 a)": {
        "question": "给出序列 {a_n} 的递归定义，n = 1, 2, 3, …，若 a_n = 4n - 2",
        "answer": "Each term is 4 more than the term before it. We can therefore define the sequence by: a1 = 2 and an+1 = an + 4 for all n ≥ 1.",
        "answer_symbols": [
            "=",
            "+",
            "≥"
        ]
    },
    "5.3 8 b)": {
        "question": "给出序列 {a_n} 的递归定义，n = 1, 2, 3, …，若 a_n = 1 + (-1)^n",
        "answer": "We note that the terms alternate: 0, 2, 0, 2, and so on. Thus we could define the sequence by: a1 = 0, a2 = 2, and an = an−2 for all n ≥ 3.",
        "answer_symbols": [
            "=",
            "−",
            "≥"
        ]
    },
    "5.3 8 c)": {
        "question": "给出序列 {a_n} 的递归定义，n = 1, 2, 3, …，若 a_n = n(n + 1)",
        "answer": "The sequence starts out 2, 6, 12, 20, 30, and so on. The differences between successive terms are 4, 6, 8, 10, and so on. Thus the nth term is 2n greater than the term preceding it; in symbols: an = an−1 + 2n. Together with the initial condition a1 = 2, this defines the sequence recursively.",
        "answer_symbols": [
            "=",
            "+",
            "−",
            "≥"
        ]
    },
    "5.3 8 d)": {
        "question": "给出序列 {a_n} 的递归定义，n = 1, 2, 3, …，若 a_n = n^2",
        "answer": "The sequence starts out 1, 4, 9, 16, 25, and so on. The differences between successive terms are 3, 5, 7, 9, and so on—the odd numbers. Thus the nth term is 2n−1 greater than the term preceding it; in symbols: an = an−1 + 2n − 1. Together with the initial condition a1 = 1, this defines the sequence recursively.",
        "answer_symbols": [
            "=",
            "+",
            "−",
            "≥"
        ]
    },
    "5.3 9": {
        "question": "设 F 是这样的函数，使得 F(n) 是前 n 个正整数之和。给出 F(n) 的递归定义。",
        "answer": "F(0) = 0, F(n) = F(n − 1) + n 对于 n ≥ 1",
        "answer_symbols": [
            "=",
            "+",
            "−",
            "≥"
        ]
    },
    "5.3 10": {
        "question": "给出 S_m(n) 的递归定义，即整数 m 与非负整数 n 之和。",
        "answer": "The base case is that Sm(0) = m. The recursive part is that Sm(n+ 1) is the successor of Sm(n) (i.e., the integer that follows Sm(n), namely Sm(n) + 1).",
        "answer_symbols": [
            "=",
            "+",
            "≥"
        ]
    },
    "5.3 11": {
        "question": "给出 P_m(n) 的递归定义，即整数 m 与非负整数 n 之积。",
        "answer": "Pm(0) = 0, Pm(n + 1) = Pm(n) + m - 1",
        "answer_symbols": [
            "=",
            "+",
            "-"
        ]
    },
    "5.3 12": {
        "question": "证明：当 n 是正整数时，有 f_1 + f_2 + … + f_n = f_n * f_{n + 1}。",
        "answer": "The basis step (n = 1) is clear, since f1^² = f1f2 = 1. Assume the inductive hypothesis. Then: f1^² + f2^² + · · · + fn^² + fn+1^² = fnfn+1 + fn+1^² = fn+1(fn + fn+1) = fn+1fn+2, as desired.",
        "answer_symbols": [
            "=",
            "+",
            "·",
            "²",
            "…"
        ]
    },
    "5.3 13": {
        "question": "证明：当 n 是正整数时，有 f_1 + f_2 + … + f_{2n - 1} = f_{2n}。",
        "answer": "令 P(n) 为“f1 + f3 + ... + f(2n-1) = f(2n)”。基础步骤：P(1) 是正确的，因为 f1 = 1 = f2。归纳步骤：假设 P(k) 是正确的。那么 f1 + f3 + ... + f(2k-1) + f(2k+1) = f(2k) + f(2k+1) = f(2k+2) + f(2(k+1))。",
        "answer_symbols": [
            "=",
            "+",
            "...",
            "−"
        ]
    },
    "5.3 14": {
        "question": "证明：当 n 是正整数时，有 f_{n + 1} * f_{n - 1} - f_n^2 = (-1)^n。",
        "answer": "The basis step (n = 1) is clear, since f2f0 − f1^² = 1 · 0 − 1^² = −1 = (−1)¹. Assume the inductive hypothesis. Then we have: fn+2fn − fn+1^² = (fn+1 + fn)fn − fn+1^² = fn+1fn + fn^² − fn+1^² = −fn+1(fn+1 − fn) + fn^² = −fn+1fn−1 + fn^² = −(fn+1fn−1 − fn^²) = −(−1)^n = (−1)^(n+1).",
        "answer_symbols": [
            "=",
            "+",
            "−",
            "·",
            "²",
            "(",
            ")",
            "^"
        ]
    },
    "5.3 15": {
        "question": "证明：当 n 是正整数时，有 f_n * f_1 + f_1 * f_2 + … + f_{2n - 1} * f_{2n} = f_{2n}。",
        "answer": "基础步骤：f0 * f1 + f1 * f2 = 0 * 1 + 1 * 1 = 1^² = f2^²。归纳步骤：假设 f0 * f1 + f1 * f2 + ... + f(2k-1) * f(2k) = f(2k)^²。那么 f0 * f1 + f1 * f2 + ... + f(2k-1) * f(2k) + f(2k) * f(2k+1) + f(2k+1) * f(2k+2) = f(2k)^² + f(2k) * f(2k+1) + f(2k+1) * f(2k+2) = f(2k) * (f(2k) + f(2k+1)) + f(2k+1) * f(2k+2) = f(2k) * f(2k+2) + f(2k+1) * f(2k+2) = (f(2k) + f(2k+1)) * f(2k+2) = f(2k+2)^²。",
        "answer_symbols": [
            "*",
            "+",
            "=",
            "²",
            "−",
            "..."
        ]
    },
    "5.3 17": {
        "question": "确定用欧几里得算法求出斐波那契数 f_n 和 f_{n + 1} 的最大公约数所用的除法次数，其中 n 是非负整数。用数学归纳法验证你的答案。",
        "answer": "使用欧几里得算法找到 gcd(f(n+1), f(n)) 所需的除法次数对于 n = 0 时为 0，对于 n = 1 时为 1，对于 n ≥ 2 时为 n - 1。为了证明这个结果对于 n ≥ 2，我们使用数学归纳法。对于 n = 2，一次除法显示 gcd(f3, f2) = gcd(2, 1) = gcd(1, 0) = 1。现在假设 k - 1 次除法用于找到 gcd(f(k+1), f(k))。要找到 gcd(f(k+2), f(k+1))，首先将 f(k+2) 除以 f(k+1) 得到 f(k+2) = 1 * f(k+1) + f(k)。经过一次除法后，我们有 gcd(f(k+2), f(k+1)) = gcd(f(k+1), f(k))。根据归纳假设，接下来需要 k - 1 次除法。这表明需要 k 次除法来找到 gcd(f(k+2), f(k+1))，完成了归纳证明。",
        "answer_symbols": [
            "gcd",
            "(",
            ")",
            "=",
            "+",
            "*",
            "−",
            "≥"
        ]
    },
    "5.3 19": {
        "question": "通过在练习 18 中等式的两边取行列式，证明练习 14 中给出的恒等式。（本题依赖于 2×2 矩阵的行列式概念。）",
        "answer": "||A|| = -1。因此，||A^n|| = (-1)^n。由此得出 f(n+1) * f(n-1) - f(n)^² = (-1)^n。",
        "answer_symbols": [
            "||",
            "=",
            "*",
            "+",
            "−",
            "²",
            "^"
        ]
    },
    "5.3 23": {
        "question": "给出是 5 的倍数的正整数集合的递归定义。",
        "answer": "5 ∈ S，且如果 x, y ∈ S，则 x + y ∈ S。",
        "answer_symbols": [
            "∈",
            "+",
            ","
        ]
    },
    "5.3 25 a)": {
        "question": "给出下列集合的递归定义：正偶数集合",
        "answer": "0 ∈ S，且如果 x ∈ S，则 x + 2 ∈ S 和 x - 2 ∈ S。",
        "answer_symbols": [
            "∈",
            "+",
            "−",
            "和"
        ]
    },
    "5.3 25 b)": {
        "question": "给出下列集合的递归定义：模 3 与 2 同余的正整数的集合",
        "answer": "2 ∈ S，且如果 x ∈ S，则 x + 3 ∈ S。",
        "answer_symbols": [
            "∈",
            "+",
            "且"
        ]
    },
    "5.3 25 c)": {
        "question": "给出下列集合的递归定义：不能被 5 整除的正整数的集合",
        "answer": "1 ∈ S，2 ∈ S，3 ∈ S，4 ∈ S，且如果 x ∈ S，则 x + 5 ∈ S。",
        "answer_symbols": [
            "∈",
            "+",
            "且"
        ]
    },
    "5.3 27 a)": {
        "question": "设 S 是如下递归地定义的整数有序对的集合：基础步骤：(0, 0) 属于 S。递归步骤：如果 (a, b) 属于 S，则 (a, b + 1) 属于 S、(a + 1, b + 1) 属于 S 且 (a + 2, b + 1) 属于 S。列出递归定义的前 4 次应用所产生的 S 的元素。",
        "answer": "(0, 1), (1, 1), (2, 1); (0, 2), (1, 2), (2, 2), (3, 2), (4, 2); (0, 3), (1, 3), (2, 3), (3, 3), (4, 3), (5, 3), (6, 3); (0, 4), (1, 4), (2, 4), (3, 4), (4, 4), (5, 4), (6, 4), (7, 4), (8, 4)",
        "answer_symbols": [
            ",",
            ";"
        ]
    },
    "5.3 27 b)": {
        "question": "设 S 是如下递归地定义的整数有序对的集合：基础步骤：(0, 0) 属于 S。递归步骤：如果 (a, b) 属于 S，则 (a, b + 1) 属于 S、(a + 1, b + 1) 属于 S 且 (a + 2, b + 1) 属于 S。对定义的递归步骤的应用次数使用强归纳法来证明：当 (a, b) 属于 S 时，a ≤ 2b。",
        "answer": "令 P(n) 表示当 (a, b) ∈ S 通过 n 次递归步骤获得时，a ≤ 2b。基础步骤：P(0) 是正确的，因为在没有应用递归步骤的情况下获得的 S 的唯一元素是 (0, 0)，确实 0 ≤ 2 * 0。归纳步骤：假设当 (a, b) ∈ S 通过 k 次或更少的递归步骤获得时，a ≤ 2b，并考虑通过 k + 1 次递归步骤获得的元素。因为最后一次递归步骤应用于一个通过较少次递归步骤获得的元素 (a, b)，我们知道 a ≤ 2b。分别加上 0 ≤ 2, 1 ≤ 2, 和 2 ≤ 2，得到 a ≤ 2(b + 1), a + 1 ≤ 2(b + 1), 和 a + 2 ≤ 2(b + 1)，如所需。",
        "answer_symbols": [
            "∈",
            "≤",
            "*",
            "+",
            "和"
        ]
    },
    "5.3 27 c)": {
        "question": "设 S 是如下递归地定义的整数有序对的集合：基础步骤：(0, 0) 属于 S。递归步骤：如果 (a, b) 属于 S，则 (a, b + 1) 属于 S、(a + 1, b + 1) 属于 S 且 (a + 2, b + 1) 属于 S。用结构归纳法证明：当 (a, b) 属于 S 时，a ≤ 2b。",
        "answer": "这适用于基础步骤，因为 0 ≤ 0。如果这适用于 (a, b)，那么它也适用于从 (a, b) 在递归步骤中获得的元素，因为分别加上 0 ≤ 2, 1 ≤ 2, 和 2 ≤ 2 到 a ≤ 2b 会得到 a ≤ 2(b + 1), a + 1 ≤ 2(b + 1), 和 a + 2 ≤ 2(b + 1)。",
        "answer_symbols": [
            "≤",
            "+",
            "和"
        ]
    },
    "5.3 29 a)": {
        "question": "给出下列每个正整数有序对的集合的递归定义。用结构归纳法证明所找到的递归定义是正确的。提示：为了找出递归定义，把集合中的点画在平面上并且寻找模式。S = {(a, b) | a 属于 Z^⁺, b 属于 Z^⁺ 且 a + b 是偶数}",
        "answer": "定义 S 为 (1, 1) ∈ S，且如果 (a, b) ∈ S，则 (a + 2, b) ∈ S, (a, b + 2) ∈ S, 和 (a + 1, b + 1) ∈ S。所有放入 S 中的元素都满足条件，因为 (1, 1) 的坐标和为偶数，如果 (a, b) 的坐标和为偶数，则 (a + 2, b), (a, b + 2), 和 (a + 1, b + 1) 的坐标和也为偶数。相反，我们通过对坐标的和进行归纳证明，如果 a + b 是偶数，则 (a, b) ∈ S。如果和为 2，则 (a, b) = (1, 1)，基础步骤将 (a, b) 放入 S。否则和至少为 4，且 (a - 2, b), (a, b - 2), 和 (a - 1, b - 1) 中至少有一个具有正整数坐标，其和为小于 a + b 的偶数，因此必须在 S 中。然后一次递归步骤的应用表明 (a, b) ∈ S。",
        "answer_symbols": [
            "∈",
            "+",
            "−",
            "和",
            "="
        ]
    },
    "5.3 29 b)": {
        "question": "给出下列每个正整数有序对的集合的递归定义。用结构归纳法证明所找到的递归定义是正确的。提示：为了找出递归定义，把集合中的点画在平面上并且寻找模式。S = {(a, b) | a 属于 Z^⁺, b 属于 Z^⁺ 且 a 或 b 是奇数}",
        "answer": "定义 S 为 (1, 1), (1, 2), 和 (2, 1) 属于 S，且如果 (a, b) ∈ S，则 (a + 2, b) 和 (a, b + 2) 属于 S。为了证明我们的定义有效，我们首先注意到 (1, 1), (1, 2), 和 (2, 1) 都具有奇数坐标，如果 (a, b) 具有奇数坐标，则 (a + 2, b) 和 (a, b + 2) 也具有奇数坐标。相反，我们通过对坐标的和进行归纳证明，如果 (a, b) 至少有一个奇数坐标，则 (a, b) ∈ S。如果 (a, b) = (1, 1) 或 (a, b) = (1, 2) 或 (a, b) = (2, 1)，则基础步骤将 (a, b) 放入 S。否则 a 或 b 至少为 3，因此 (a - 2, b) 和 (a, b - 2) 中至少有一个具有正整数坐标，其和小于 a + b，因此必须在 S 中。然后一次递归步骤的应用表明 (a, b) ∈ S。",
        "answer_symbols": [
            "∈",
            "+",
            "−",
            "和",
            "="
        ]
    },
    "5.3 29 c)": {
        "question": "给出下列每个正整数有序对的集合的递归定义。用结构归纳法证明所找到的递归定义是正确的。提示：为了找出递归定义，把集合中的点画在平面上并且寻找模式。S = {(a, b) | a 属于 Z^⁺, b 属于 Z^⁺ 且 a + b 是奇数且 3 ∣ b}",
        "answer": "(1, 6) ∈ S 和 (2, 3) ∈ S，且如果 (a, b) ∈ S，则 (a + 2, b) ∈ S 和 (a, b + 6) ∈ S。为了证明我们的定义有效，我们首先注意到 (1, 6) 和 (2, 3) 满足条件，如果 (a, b) 满足条件，则 (a + 2, b) 和 (a, b + 6) 也满足条件。相反，我们通过对坐标的和进行归纳证明，如果 (a, b) 满足条件，则 (a, b) ∈ S。对于和为 5 和 7 的情况，唯一的点是 (1, 6)，基础步骤将其放入 S，(2, 3)，基础步骤将其放入 S，(4, 3) = (2 + 2, 3)，通过一次递归定义的应用属于 S。对于大于 7 的和，a ≥ 3 或者...a ≤ 2 and b ≥ 9, in which case either (a − 2, b) or (a, b − 6) must have positive integer coordinates whose sum is smaller than a + b and satisfy the condition for being in S. Then one application of the recursive step shows that (a, b) ∈ S.",
        "answer_symbols": [
            "∈",
            "+",
            "和",
            "="
        ]
    },
    "5.3 31": {
        "question": "定义由表示集合的变量和 {∪, ∩, −} 中的运算符所组成的集合的合式公式。",
        "answer": "如果 x 是一个集合或表示集合的变量，则 x 是一个良构公式。如果 x 和 y 都是良构公式，则 x, (x ∪ y), (x ∩ y), 和 (x − y) 也都是良构公式。",
        "answer_symbols": [
            "∪",
            "∩",
            "−"
        ]
    },
    "5.3 33 a)": {
        "question": "给出等于十进制数字的非空字符串中最小数字的函数 m(s) 的递归定义。",
        "answer": "如果 x ∈ D = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}，则 m(x) = x；如果 s = tx，其中 t ∈ D* 和 x ∈ D，则 m(s) = min(m(s), x)。",
        "answer_symbols": [
            "∈",
            "=",
            "min"
        ]
    },
    "5.3 33 b)": {
        "question": "用结构归纳法证明 m(st) = min(m(s), m(t))。",
        "answer": "令 t = wx，其中 w ∈ D* 和 x ∈ D。如果 w = λ，则 m(st) = m(sx) = min(m(s), x) = min(m(s), m(x)) 由定义的递归步骤和基础步骤得出。否则，m(st) = m((sw)x) = min(m(sw), x) 根据 m 的定义。现在 m(sw) = min(m(s), m(w)) 由结构归纳法的归纳假设，所以 m(st) = min(min(m(s), m(w)), x) = min(m(s), min(m(w), x)) 由 min 的意义。但 min(m(w), x) = m(wx) = m(t) 由 m 定义的递归步骤。因此，m(st) = min(m(s), m(t))。",
        "answer_symbols": [
            "=",
            "∈",
            "min"
        ]
    },
    "5.3 21 a)": {
        "question": "设 a1, a2, …, an 和 b1, b2, …, bn 都是实数。用练习 20 中给出的递归定义来证明：max(-a1, -a2, …, -an) = -min(a1, a2, …, an)",
        "answer": "通过归纳法证明。基础步骤：对于 n = 1，max(-a1) = -a1 = -min(a1)。对于 n = 2，有两种情况。如果 a2 ≥ a1，则 -a1 ≥ -a2，所以 max(-a1, -a2) = -a1 = -min(a1, a2)。如果 a2 < a1，则 -a1 < -a2，所以 max(-a1, -a2) = -a2 = -min(a1, a2)。归纳步骤：假设对 k 成立，其中 k ≥ 2。那么 max(-a1, -a2, ..., -ak, -a(k+1)) = max(max(-a1, ..., -ak), -a(k+1)) = max(-min(a1, ..., ak), -a(k+1)) = -min(min(a1, ..., ak), a(k+1)) = -min(a1, ..., a(k+1))。",
        "answer_symbols": [
            "max",
            "min",
            "=",
            "≥",
            "<",
            "...",
            "−"
        ]
    },
    "5.3 21 b)": {
        "question": "设 a1, a2, …, an 和 b1, b2, …, bn 都是实数。用练习 20 中给出的递归定义来证明：max(a1 + b1, a2 + b2, …, an + bn) ≤ max(a1, a2, …, an) + max(b1, b2, …, bn)",
        "answer": "通过数学归纳法证明。基础步骤：对于 n = 1，结果是恒等式 a1 + b1 = a1 + b1。对于 n = 2，首先考虑 a1 + b1 ≥ a2 + b2 的情况。那么 max(a1 + b1, a2 + b2) = a1 + b1。还注意到 a1 ≤ max(a1, a2) 和 b1 ≤ max(b1, b2)，所以 a1 + b1 ≤ max(a1, a2) + max(b1, b2)。因此，max(a1 + b1, a2 + b2) = a1 + b1 ≤ max(a1, a2) + max(b1, b2)。a1 + b1 < a2 + b2 的情况类似。归纳步骤：假设结果对 k 成立。那么 max(a1 + b1, a2 + b2, ..., a(k+1) + b(k+1)) = max(max(a1 + b1, a2 + b2, ..., ak + bk), a(k+1) + b(k+1)) ≤ max(max(a1, a2, ..., ak) + max(b1, b2, ..., bk), a(k+1) + b(k+1)) ≤ max(max(a1, a2, ..., ak), a(k+1)) + max(max(b1, b2, ..., bk), b(k+1)) = max(a1, a2, ..., ak, a(k+1)) + max(b1, b2, ..., bk, b(k+1))。",
        "answer_symbols": [
            "max",
            "=",
            "≥",
            "<",
            "+",
            "...",
            "≤"
        ]
    },
    "5.3 21 c)": {
        "question": "设 a1, a2, …, an 和 b1, b2, …, bn 都是实数。用练习 20 中给出的递归定义来证明：min(a1 + b1, a2 + b2, …, an + bn) ≥ min(a1, a2, …, an) + min(b1, b2, …, bn)",
        "answer": "与部分 (b) 相同，但将每个出现的“max”替换为“min”，并反转每个不等式。",
        "answer_symbols": [
            "min",
            "=",
            "≥",
            "<",
            "+",
            "...",
            "≤"
        ]
    },
    "5.3 35": {
        "question": "给出字符串的倒置的递归定义。[提示：首先定义空串的倒置。然后把长度为 n+1 的字符串 w 写成 xy，其中 x 是长度为 n 的字符串，并且利用 xR 和 y 来表示 w 的倒置。]",
        "answer": "λR = λ 和 (ux)R = x uR 对于 x ∈, u ∈*.",
        "answer_symbols": [
            "=",
            "∈"
        ]
    },
    "5.3 37": {
        "question": "给出 w 的递归定义，其中 w 是字符串而 i 是非负整数。（这里 wi 表示字符串 w 的 i 份复制品的连接。）",
        "answer": "w0 = λ 和 wn+1 = wwn。",
        "answer_symbols": [
            "=",
            "λ"
        ]
    },
    "5.3 38": {
        "question": "给出回文位串的集合的递归定义。",
        "answer": "回文有两种类型，因此我们需要两个基本情况，即空字符串λ是一个回文，每个符号x也是一个回文。递归步骤是如果α是一个回文且x是一个符号，则xαx也是回文。",
        "answer_symbols": [
            "λ"
        ]
    },
    "5.3 39": {
        "question": "位串集合 A 定义成 λ∈A 0x1∈A x∈A 其中 λ 是空串。哪些字符串属于 A？",
        "answer": "当字符串由 n 个 0 后跟 n 个 1 组成时，对于某些非负整数 n。",
        "answer_symbols": []
    },
    "5.3 40": {
        "question": "递归地定义：所包含的 0 比 1 多的位串的集合。",
        "answer": "这里的key事实是，如果一个长度大于1的位串中的0比1多，那么它要么是由两个这样的字符串连接而成，要么是在这两个字符串之间插入一个1，或者在第一个之前或最后一个之后插入一个1。这可以通过查看从左到右读取字符串时0比1多的数量来证明。因此，一个递归定义是0属于集合，如果x和y属于集合，那么xy、1xy、x1y和xy1也属于集合。",
        "answer_symbols": []
    },
    "5.3 41": {
        "question": "用练习 37 和数学归纳法证明：l(wi) = i·l(w)，其中 w 是位串而 i 是非负整数。",
        "answer": "令 P(i) 为 “l(wi) = i · l(w)”。P(0) 是正确的，因为 l(w0) = 0 = 0 · l(w)。假设 P(i) 是正确的。那么 l(wi+1) = l(wwi) = l(w) + l(wi) = l(w) + i · l(w) = (i + 1) · l(w)。",
        "answer_symbols": [
            "=",
            "+",
            "·"
        ]
    },
    "5.3 42": {
        "question": "证明：当 w 是位串而 i 是非负整数时，有 (wR)i = (wi)R。即证明一个字符串的倒置的 i 次幂是这个字符串的 i 次幂的倒置。",
        "answer": "回忆第37题中字符串的第i次幂的递归定义。我们还将使用第36题的结果以及以下引理：对于所有i≥0，w^(i+1)= w^i * w，这是显而易见的（或可以使用归纳法证明，利用连接的结合律）。现在要证明(w^R)^i = (w^i)^R，我们使用i上的归纳法。当i=0时，显然成立，因为(w^R)^0 = λ = λ^R = (w^i)^R。假设归纳假设成立，我们有(w^R)^(i+1) = w^R * (w^R)^i = w^R * (w^i)^R = (w^i * w)^R = (w^(i+1))^R，如所需。",
        "answer_symbols": [
            "^",
            "*",
            "λ",
            "R",
            "="
        ]
    },
    "5.3 43": {
        "question": "用结构归纳法证明：n(T) ≥ 2h(T) + 1，其中 T 是满二叉树，n(T) 等于 T 的顶点数，h(T) 是 T 的高度。可以递归地定义满二叉树的树叶和内点。基础步骤：树根 r 是恰有一个顶点 r 的满二叉树的树叶。这个树没有内点。递归步骤：树 T = T₁ ∪ T₂ 的树叶集合是 T₁ 的树叶集合与 T₂ 的树叶集合的并。T 的内点集合是 T 的树根 r 与 T₁ 的内点集合与 T₂ 的内点集合的并。",
        "answer": "基础步骤：对于仅包含根节点的完全二叉树，结果是正确的，因为 n(T) = 1 且 h(T) = 0，并且 1 ≥ 2 * 0 + 1。归纳步骤：假设 n(T1) ≥ 2^h(T1) + 1 和 n(T2) ≥ 2^h(T2) + 1。根据 n(T) 和 h(T) 的递归定义，我们有 n(T) = 1 + n(T1) + n(T2) 和 h(T) = 1 + max(h(T1), h(T2))。因此 n(T) = 1 + n(T1) + n(T2) ≥ 1 + 2^h(T1) + 1 + 2^h(T2) + 1 ≥ 1 + 2 * max(h(T1), h(T2)) + 2 = 1 + 2(max(h(T1), h(T2)) + 1) = 1 + 2h(T)。",
        "answer_symbols": [
            "=",
            "≥",
            "+",
            "^",
            "max"
        ]
    },
    "5.3 44": {
        "question": "用结构归纳法证明：满二叉树 T 的树叶数 l(T) 比 T 的内点数 i(T) 多 1。",
        "answer": "对于基础步骤，我们有一个只包含根节点的树，所以有一个叶子节点且没有内部节点，l(T) = i(T) + 1 成立。对于递归步骤，假设此关系对T1和T2成立，并考虑一个新的根，其子节点是T1和T2的根。新根是T的一个内部节点，T1和T2中的每个内部节点也是T的一个内部节点，因此i(T) = i(T1) + i(T2) + 1。同样地，T1和T2的叶子节点是T的叶子节点，因此l(T) = l(T1) + l(T2)。因此我们有l(T) = l(T1) + l(T2) = i(T1) + 1 + i(T2) + 1，由归纳假设，等于(i(T1) + i(T2) + 1) + 1 = i(T) + 1，如所需。",
        "answer_symbols": [
            "+",
            "=",
            "(",
            ")"
        ]
    },
    "5.3 45": {
        "question": "仿照例 13 用广义归纳法证明：如果把 am,n 递归地定义成 a0,0 = 0 并且 am,n = {am-1,n + 1 n = 0 且 m > 0 {am,n-1 + 1 n > 0 则对于所有 (m, n) ∈ N × N 来说，am,n = m + n。",
        "answer": "基础步骤：a0,0 = 0 = 0 + 0。归纳步骤：假设当 (m', n') 小于 (m, n) 时 am',n' = m' + n'。如果 n = 0 则 am,n = am-1,n + 1 = m - 1 + n + 1 = m + n。如果 n > 0，则 am,n = am,n-1 + 1 = m + n - 1 + 1 = m + n。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "<"
        ]
    },
    "5.3 46": {
        "question": "仿照例 15 用广义归纳法证明：如果把 am,n 递归地定义成 a1,1 = 5 并且 am,n = {am-1,n + 2 n = 1 且 m > 1 {am,n-1 + 2 n > 1 则对于所有 (m, n) ∈ Z^⁺ × Z^⁺ 来说，am,n = 2(m + n) + 1。",
        "answer": "基础步骤需要证明该公式在(m, n) = (1, 1)时成立。归纳步骤需要证明如果该公式在字典序小于(m, n)的所有对上成立，那么它也在(m, n)上成立。对于基础步骤，我们有a1,1 = 5 = 2(1 + 1) + 1。对于归纳步骤，假设当(m', n')小于(m, n)时am',n' = 2(m' + n') + 1。根据递归定义，如果n = 1，则am,n = am-1,n + 2；由于(m-1, n)小于(m, n)，归纳假设告诉我们am-1,n = 2(m-1 + n) + 1，因此am,n = 2(m-1 + n) + 1 + 2 = 2(m + n) + 1，如所需。现在假设n > 1，因此am,n = am,n-1 + 2。同样我们有am,n-1 = 2(m + n - 1) + 1，因此am,n = 2(m + n - 1) + 1 + 2 = 2(m + n) + 1，证明完成。",
        "answer_symbols": [
            "=",
            "+",
            "<",
            ">",
            "(",
            ")",
            ","
        ]
    },
    "5.3 47 a)": {
        "question": "正整数 n 的分拆是把 n 写成正整数之和的方式。例如，7 = 3 + 2 + 1 + 1 是 7 的分拆。设 Pm 等于 m 的不同分拆的数目，其中和式里项的顺序无关紧要，并设 Pm,n 是用不超过 n 的正整数之和来表示 m 的不同方式数。证明：Pm,m = Pm。",
        "answer": "Pm,m = Pm 因为超过 m 的数字不能用于 m 的划分。",
        "answer_symbols": [
            "="
        ]
    },
    "5.3 47 b)": {
        "question": "正整数 n 的分拆是把 n 写成正整数之和的方式。例如，7 = 3 + 2 + 1 + 1 是 7 的分拆。设 Pm 等于 m 的不同分拆的数目，其中和式里项的顺序无关紧要，并设 Pm,n 是用不超过 n 的正整数之和来表示 m 的不同方式数。证明：下面的 Pm,n 的递归定义是正确的。Pm,n = {1 m = 1 {Pm,m n = 1 {1 + Pm,m-1 m < n {Pm,n-1 + Pm-n,n m > n > 1",
        "answer": "由于只有一种方法可以划分 1，即 1 = 1，因此 P1,n = 1。由于只有一种方法可以将 m 划分为 1s，Pm,1 = 1。当 n > m 时，Pm,n = Pm,m 因为不能使用超过 m 的数字。Pm,m = 1 + Pm,m-1 因为当允许在划分中使用 m 时，会多出一种额外的划分，即 m = m。Pm,n = Pm,n-1 + Pm-n,n 如果 m > n，因为 m 的划分成不超过 n 的整数要么不使用任何 n 并且被计数在 Pm,n-1 中，或者使用 n 和 m - n 的划分，并且被计数在 Pm-n,n 中。",
        "answer_symbols": [
            "=",
            "+",
            ">",
            "-"
        ]
    },
    "5.3 49": {
        "question": "证明: 当 m ≥ 1 时, 有 A(m, 2) = 4。",
        "answer": "令 P(n) 为 “A(n, 2) = 4”。基础步骤：P(1) 是正确的，因为 A(1, 2) = A(0, A(1, 1)) = A(0, 2) = 2 * 2 = 4。归纳步骤：假设 P(n) 是正确的，即 A(n, 2) = 4。那么 A(n + 1, 2) = A(n, A(n + 1, 1)) = A(n, 2) = 4。",
        "answer_symbols": [
            "=",
            "*",
            "+"
        ]
    },
    "5.3 50": {
        "question": "证明: 当 n ≥ 1 时, 有 A(1, n) = 2^n。",
        "answer": "我们通过n上的归纳法来证明这一点。当n = 1时，显然A(1, 1) = 2 = 2^1。假设A(1, n) = 2^n。那么A(1, n + 1) = A(0, A(1, n)) = A(0, 2^n) = 2 * 2^n = 2^(n+1)，如所需。",
        "answer_symbols": [
            "=",
            "^",
            "*",
            "+",
            "(",
            ")"
        ]
    },
    "5.3 51 a)": {
        "question": "求出下列阿克曼函数的值。a) A(2, 3)",
        "answer": "16",
        "answer_symbols": []
    },
    "5.3 51 b)": {
        "question": "求出下列阿克曼函数的值。b) A(3, 3)",
        "answer": "65,536",
        "answer_symbols": []
    },
    "5.3 52": {
        "question": "求出 A(3, 4)。",
        "answer": "如果计算意味着写出一个漂亮的数字作为答案，这是不可能计算的。正如第51题的解答中所解释的那样，可以通过归纳法证明A(2, n)等于2的n个2的高塔。为了计算A(3, 4)，我们使用定义写成A(3, 4) = A(2, A(3, 3))。然而，在第51题的解答中我们看到A(3, 3) = 65536，因此A(3, 4) = A(2, 65536)。因此，A(3, 4)是一个2的高塔，其中有65536个2。没有更简洁的方式来表示或描述这个数字——它太大了。",
        "answer_symbols": [
            "=",
            "(",
            ")",
            ","
        ]
    },
    "5.3 53": {
        "question": "证明: 当 m 和 n 都是非负整数时, 有 A(m, n + 1) ≥ A(m, n)。",
        "answer": "使用双重归纳法证明更强的陈述：当 k > l 时 A(m, k) > A(m, l)。基础步骤：当 m = 0 时，陈述是正确的，因为 k > l 意味着 A(0, k) = 2k > 2l = A(0, l)。归纳步骤：假设对所有非负整数 x 和 y，当 x > y 时 A(m, x) > A(m, y)。我们将证明这隐含着当 k > l 时 A(m + 1, k) > A(m + 1, l)。基础步骤：当 l = 0 且 k > 0 时，A(m + 1, l) = 0 且 A(m + 1, k) = 2 或 A(m + 1, k) = A(m, A(m + 1, k - 1))。如果 m = 0，这是 2A(1, k - 1) = 2k。如果 m > 0，根据归纳假设，这是大于 0 的。在所有情况下，A(m + 1, k) > 0，实际上 A(m + 1, k) ≥ 2。如果 l = 1 且 k > 1，那么 A(m + 1, l) = 2 且 A(m + 1, k) = A(m, A(m + 1, k - 1))，其中 A(m + 1, k - 1) ≥ 2。因此，根据归纳假设，A(m, A(m + 1, k - 1)) ≥ A(m, 2) > A(m, 1) = 2。归纳步骤：假设对所有 r > s，s = 0, 1, ..., l，A(m + 1, r) > A(m + 1, s)。那么如果 k + 1 > l + 1，则 A(m + 1, k + 1) = A(m, A(m + 1, k)) > A(m, A(m + 1, k)) = A(m + 1, l + 1)。",
        "answer_symbols": [
            ">",
            "=",
            "+",
            "-",
            "≥"
        ]
    },
    "5.3 54": {
        "question": "证明: 当 m 和 n 都是非负整数时, 有 A(m + 1, n) ≥ A(m, n)。",
        "answer": "我们在这里使用双重归纳法，首先对 m 进行归纳，然后对 n 进行归纳。外部基本情况是 m = 0（n 任意）。那么 A(m, n) = 2n 对所有 n 都成立。而且 A(m + 1, n) = 2n 对 n = 0 和 n = 1 成立，并且在这些情况下 2n ≥ 2n；而 A(m + 1, n) = 2n 对所有 n > 1 成立（根据练习 50），并且在这些情况下 2n ≥ 2n 也成立。现在我们假设归纳假设，即 A(m + 1, t) ≥ A(m, t) 对所有 t 成立。我们将通过归纳法对 n 证明 A(m + 2, n) ≥ A(m + 1, n)。对于 n = 0，这简化为 0 ≥ 0，而对于 n = 1，它简化为 2 ≥ 2。假设内部归纳假设，即 A(m + 2, n) ≥ A(m + 1, n)。那么 A(m + 2, n + 1) = A(m + 1, A(m + 2, n)) ≥ A(m + 1, A(m + 1, n))（使用归纳假设和练习 53）≥ A(m, A(m + 1, n))（通过 m 上的归纳假设）= A(m + 1, n + 1)。",
        "answer_symbols": [
            "=",
            "≥",
            "(",
            ")",
            "+",
            ","
        ]
    },
    "5.3 55": {
        "question": "证明: 当 i 和 j 都是非负整数时, 有 A(i, j) ≥ j。",
        "answer": "从练习 54 可知 A(i, j) ≥ A(i - 1, j) ≥ ... ≥ A(0, j) = 2j ≥ j。",
        "answer_symbols": [
            "≥",
            "="
        ]
    },
    "5.3 56": {
        "question": "用数学归纳法证明: 通过规定 F(0) 和从 F(n) 获得 F(n + 1) 的规则所定义的函数 F 是良定义的。",
        "answer": "设 P(n) 是命题“F 在 n 处定义良好”。那么 P(0) 是真的，因为 F(0) 已经指定。假设 P(n) 是真的。那么 F 在 n + 1 处也定义良好，因为 F(n + 1) 是用 F(n) 表示的。因此，通过数学归纳法，P(n) 对所有 n 都是真的，即 F 作为非负整数集上的函数是定义良好的。",
        "answer_symbols": [
            "+",
            "(",
            ")",
            "="
        ]
    },
    "5.3 57": {
        "question": "用数学归纳法第二原理证明: 通过规定 F(0) 以及从 F(k) (k = 0, 1, 2, ⋯, n) 获得 F(n + 1) 的规则所定义的函数是良定义的。",
        "answer": "令 P(n) 为 “F(n) 是良定义的”。那么 P(0) 是正确的，因为 F(0) 已经指定。假设对所有 k < n，P(k) 是正确的。那么 F(n) 在 n 处是良定义的，因为 F(n) 是根据 F(0), F(1), ..., F(n - 1) 给出的。所以 P(n) 对所有整数 n 都成立。",
        "answer_symbols": [
            "<",
            "="
        ]
    },
    "5.3 58 a)": {
        "question": "证明: 下述每一个所谓的对正整数集合上的函数的递归定义都不能产生良定义的函数。a) 对 n ≥ 1 来说 F(n) = 1 + F(⌊ n/2 ⌋), 且 F(1) = 1。",
        "answer": "如果递归部分声明为 n ≥ 2，则这是一个正确的定义。然而，目前 F(1) 是模棱两可的，F(0) 未定义。",
        "answer_symbols": [
            "≥",
            "(",
            ")"
        ]
    },
    "5.3 58 b)": {
        "question": "证明: 下述每一个所谓的对正整数集合上的函数的递归定义都不能产生良定义的函数。b) 对 n ≥ 2 来说 F(n) = 1 + F(n - 3), 且 F(1) = 2 和 F(2) = 3。",
        "answer": "这个定义目前没有意义；F(3) 未定义，因为 F(0) 未定义。此外，F(2) 模棱两可。",
        "answer_symbols": [
            "(",
            ")"
        ]
    },
    "5.3 58 c)": {
        "question": "证明: 下述每一个所谓的对正整数集合上的函数的递归定义都不能产生良定义的函数。c) 对 n ≥ 2 来说 F(n) = 1 + F(n/2), 且 F(1) = 1 和 F(2) = 2。",
        "answer": "对于 n = 3，递归部分没有意义，因为我们必须知道 F(3/2)。此外，F(2) 模棱两可。",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "/"
        ]
    },
    "5.3 58 d)": {
        "question": "证明: 下述每一个所谓的对正整数集合上的函数的递归定义都不能产生良定义的函数。d) 若 n 是偶数且 n ≥ 2, 则 F(n) = 1 + F(n/2); 若 n 是奇数, 则 F(n) = 1 - F(n - 1), 且 F(1) = 1。",
        "answer": "定义对 n = 1 模棱两可，因为第二条和第三条似乎都适用。如果第三条仅适用于奇数 n ≥ 3，则这将是一个有效的定义。",
        "answer_symbols": [
            "=",
            "≥",
            "(",
            ")"
        ]
    },
    "5.3 58 e)": {
        "question": "证明: 下述每一个所谓的对正整数集合上的函数的递归定义都不能产生良定义的函数。e) 若 n 是偶数且 n ≥ 2, 则 F(n) = 1 + F(n/2); 若 n 是奇数且 n ≥ 3, 则 F(n) = F(3n - 1), 且 F(1) = 1。",
        "answer": "注意 F(1) 明确定义，F(2) 用 F(1) 定义，F(4) 用 F(2) 定义，F(3) 用 F(8) 定义，而 F(8) 用 F(4) 定义。到目前为止，一切顺利。然而，让我们看看定义对 F(5) 说了什么：F(5) = F(14) = 1 + F(7) = 1 + F(20) = 1 + 1 + F(10) = 1 + 1 + 1 + F(5)。这不仅使我们无法确定 F(5) 是什么，而且是一个矛盾，因为 0 ≠ 3。（如果我们在这个问题中将“3n - 1”替换为“3n + 1”，那么它就是一个未解决的问题——Collatz 猜想——即 F 是否定义良好；参见第 1.8 节的示例 23。）",
        "answer_symbols": [
            "=",
            "+",
            "≠",
            "(",
            ")",
            "-"
        ]
    },
    "5.3 59 a)": {
        "question": "证明: 下述每一个所谓的对正整数集合上的函数的递归定义都不能产生良定义的函数。a) 对 n ≥ 1 来说 F(n) = 1 + F(⌊ (n + 1)/2 ⌋), 且 F(1) = 1。",
        "answer": "F(1) 的值是模糊的。",
        "answer_symbols": []
    },
    "5.3 59 b)": {
        "question": "证明: 下述每一个所谓的对正整数集合上的函数的递归定义都不能产生良定义的函数。b) 对 n ≥ 2 来说 F(n) = 1 + F(n - 2), 且 F(1) = 0。",
        "answer": "F(2) 未定义，因为 F(0) 未定义。",
        "answer_symbols": []
    },
    "5.3 59 c)": {
        "question": "证明: 下述每一个所谓的对正整数集合上的函数的递归定义都不能产生良定义的函数。c) 对 n ≥ 3 来说 F(n) = 1 + F(n/3), 且 F(1) = 1, F(2) = 2, F(3) = 3。",
        "answer": "F(3) 是模糊的，F(4) 未定义，因为 F(43) 没有意义。",
        "answer_symbols": []
    },
    "5.3 59 d)": {
        "question": "证明: 下述每一个所谓的对正整数集合上的函数的递归定义都不能产生良定义的函数。d) 若 n 是偶数且 n ≥ 2, 则 F(n) = 1 + F(n/2); 若 n 是奇数, 则 F(n) = 1 + F(n - 2), 且 F(1) = 1。",
        "answer": "F(1) 的定义是模糊的，因为第二条和第三条似乎都适用。",
        "answer_symbols": []
    },
    "5.3 59 e)": {
        "question": "证明: 下述每一个所谓的对正整数集合上的函数的递归定义都不能产生良定义的函数。e) 若 n ≥ 2, 则 F(n) = 1 + F(F(n - 1)), 且 F(1) = 2。",
        "answer": "F(2) 无法计算，因为尝试计算 F(2) 得到 F(2) = 1 + F(F(1)) = 1 + F(2)。",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "5.3 60 a)": {
        "question": "求出下述的每一个值: a) log^(2) 16",
        "answer": "log(2) 16 = log log 16 = log 4 = 2，因为 2^4 = 16 且 2^2 = 4",
        "answer_symbols": [
            "=",
            "log",
            "^"
        ]
    },
    "5.3 60 b)": {
        "question": "求出下述的每一个值: b) log^(3) 256",
        "answer": "log(3) 256 = log log log 256 = log log 8 = log 3 ≈ 1.585",
        "answer_symbols": [
            "=",
            "log",
            "≈"
        ]
    },
    "5.3 60 c)": {
        "question": "求出下述的每一个值: c) log^(3) 2^265536",
        "answer": "log(3) 265536 = log log log 265536 = log log 65536 = log 16 = 4",
        "answer_symbols": [
            "=",
            "log"
        ]
    },
    "5.3 60 d)": {
        "question": "求出下述的每一个值: d) log^(4) 2^265536",
        "answer": "log(4) 2265536 = log log log log 2265536 = log log log 265536 = 4 （根据 (c) 部分）",
        "answer_symbols": [
            "=",
            "log",
            "("
        ]
    },
    "5.3 61 a)": {
        "question": "对下述的每一个 log* n 的值, 求出 n 的值: a) 2",
        "answer": "1",
        "answer_symbols": []
    },
    "5.3 61 b)": {
        "question": "对下述的每一个 log* n 的值, 求出 n 的值: b) 4",
        "answer": "2",
        "answer_symbols": []
    },
    "5.3 61 c)": {
        "question": "对下述的每一个 log* n 的值, 求出 n 的值: c) 8",
        "answer": "3",
        "answer_symbols": []
    },
    "5.3 61 d)": {
        "question": "对下述的每一个 log* n 的值, 求出 n 的值: d) 16",
        "answer": "3",
        "answer_symbols": []
    },
    "5.3 61 e)": {
        "question": "对下述的每一个 log* n 的值, 求出 n 的值: e) 256",
        "answer": "4",
        "answer_symbols": []
    },
    "5.3 61 f)": {
        "question": "对下述的每一个 log* n 的值, 求出 n 的值: f) 65536",
        "answer": "4",
        "answer_symbols": []
    },
    "5.3 61 g)": {
        "question": "对下述的每一个 log* n 的值, 求出 n 的值: g) 2^264",
        "answer": "5",
        "answer_symbols": []
    },
    "5.3 62": {
        "question": "求出使得 log* n = 5 的最小整数 n。确定这个数的十进制位数。",
        "answer": "注意 log(1) 2 = 1，log(2) 2^2 = 1，log(3) 2^2^2 = 1，log(4) 2^2^2^2 = 1，依此类推。一般来说，当 n 是一个 k 层 2 的塔时，log(k) n = 1；一旦 n 超过一个 k 层 2 的塔，log(k) n > 1。因此使得 log* n = k 的最大 n 是一个 k 层 2 的塔。这里 k = 5，所以答案是 2^2^2^2^2 = 2^65536。这个数字会使大多数计算器溢出。为了确定它的十进制位数，我们回忆一下正整数 x 的十进制位数是 [log10 x] + 1。因此 2^65536 的十进制位数是 [log10 2^65536] + 1 = [65536 * log10 2] + 1 = 19,729。",
        "answer_symbols": [
            "=",
            ">",
            "log",
            "^",
            "[",
            "]"
        ]
    },
    "5.3 63": {
        "question": "设 f(n) = n - a, 其中 a 是正整数。求出 f^(k)(n) 的公式。当 n 是正整数时, f*c(n) 的值是什么?",
        "answer": "f0 *(n) = n / a",
        "answer_symbols": [
            "=",
            "/"
        ]
    },
    "5.3 65": {
        "question": "设 f(n) = √n。求出 f^(k)(n) 的公式。当 n 是正整数时, f*c(n) 的值是什么?",
        "answer": "f2 *(n) = log log n 对于 n ≥ 2，f2 *(1) = 0",
        "answer_symbols": [
            "=",
            "log",
            "≥"
        ]
    },
    "5.4 5": {
        "question": "当给定m=5, n=11和b=3作为输入时，跟踪算法3。即，证明算法3中的所有步骤都是为了求3^11 mod 5",
        "answer": "在处理 if 子句时，我们看到 mpower(3, 0, 5) = 1。通过反向工作，我们可以得出 mpower(3, 1, 5) = (1^² mod 5 · 3 mod 5) mod 5 = 3，mpower(3, 2, 5) = 3^² mod 5 = 4，mpower(3, 5, 5) = (4^² mod 5 · 3 mod 5) mod 5 = 3，最后 mpower(3, 11, 5) = (3^² mod 5 · 3 mod 5) mod 5 = 2。我们得出结论 3¹¹ mod 5 = 2。",
        "answer_symbols": [
            "mod",
            "·",
            "²"
        ]
    },
    "5.4 7": {
        "question": "给出当n是正整数而x是整数时，只用加法计算nx的递归算法",
        "answer": "过程 mult(n: 正整数, x: 整数)如果 n = 1，则返回 x否则返回 x + mult(n - 1, x)",
        "answer_symbols": [
            "+",
            "-"
        ]
    },
    "5.4 9": {
        "question": "给出求前n个正奇数之和的递归算法",
        "answer": "过程 sum of odds(n: 正整数)如果 n = 1，则返回 1否则返回 sum of odds(n - 1) + 2n - 1",
        "answer_symbols": [
            "+",
            "-",
            "·"
        ]
    },
    "5.4 11": {
        "question": "给出求有限整数集合中的最小值的递归算法，利用事实：n个整数中的最小值是列表中最后一个整数与n-1个整数列表中最小值之间的较小者",
        "answer": "过程 smallest(a1,..., an: 整数)如果 n = 1，则返回 a1否则返回 min(smallest(a1,..., an-1), an)",
        "answer_symbols": [
            "min"
        ]
    },
    "5.4 12": {
        "question": "设计一个递归算法，当n, x和m都是正整数时，基于事实x^n mod m = (x^(n-1) mod m · x mod m) mod m，求出x^n mod m",
        "answer": "Procedure: power(x, n, m: positive integers) - If n = 1, then return x mod m - Else, return (x · power(x, n − 1, m)) mod m",
        "answer_symbols": [
            "=",
            "mod",
            "·",
            "−"
        ]
    },
    "5.4 13": {
        "question": "给出当n和m都是正整数时，求n! mod m的递归算法",
        "answer": "过程 modf actorial(n, m: 正整数)如果 n = 1，则返回 1否则返回 (n · modf actorial(n - 1, m)) mod m",
        "answer_symbols": [
            "·",
            "mod",
            "-"
        ]
    },
    "5.4 14": {
        "question": "给出求整数列表中的众数的递归算法。(众数是列表中出现的频率程度至少与其他每个元素一样的元素)",
        "answer": "The recursive algorithm will need to keep track not only of what the mode actually is, but also of how often the mode appears. - If n = 1 (the base case), then the output is that the mode is a1 and it appears 1 time. - For the recursive case (n > 1), form a new list L' by deleting from L the term an and all terms in L equal to an. Let k be the number of terms deleted. - If k = n (in other words, if L' is the empty list), then the output is that the mode is an and it appears n times. - Otherwise, apply the algorithm recursively to L', obtaining a mode m, which appears t times. Now if t ≥ k, then the output is that the mode is m and it appears t times; otherwise the output is that the mode is an and it appears k times.",
        "answer_symbols": [
            "=",
            ">",
            "≥"
        ]
    },
    "5.4 15": {
        "question": "设计一个递归算法，它计算假如gcd(a, b)=gcd(a, b-a)时，满足a < b的两个非负整数a和b的最大公因子",
        "answer": "过程 gcd(a, b: 非负整数) {假设 a < b}如果 a = 0，则返回 b否则如果 a = b - a，则返回 a否则如果 a < b - a，则返回 gcd(a, b - a)否则返回 gcd(b - a, a)",
        "answer_symbols": [
            "-",
            "<"
        ]
    },
    "5.4 16": {
        "question": "证明：练习8找到的求前n个正整数之和的递归算法是正确的",
        "answer": "The sum of the first one positive integer is 1, and that is the answer the recursive algorithm gives when n = 1, so the basis step is correct. Now assume that the algorithm works correctly for n = k. If n = k + 1, then the else clause of the algorithm is executed, and k + 1 is added to the (assumed correct) sum of the first k positive integers. Thus the algorithm correctly finds the sum of the first k + 1 positive integers.",
        "answer_symbols": [
            "=",
            "+",
            "−"
        ]
    },
    "5.4 17": {
        "question": "设计把两个非负整数 x 和 y 相乘的递归算法，基于这样的事实：当 y 是偶数时 xy = 2(x * (y/2))，当 y 是奇数时 xy = 2(x * ⌊y/2⌋) + x，以及初始条件：当 y = 0 时 xy = 0。",
        "answer": "过程 multiply(x, y: 非负整数)如果 y = 0，则返回 0否则如果 y 是偶数，则返回 2 · multiply(x, y / 2)否则返回 2 · multiply(x, (y - 1) / 2) + x",
        "answer_symbols": [
            "·",
            "+",
            "-",
            "/"
        ]
    },
    "5.4 18": {
        "question": "证明：当 n 是非负整数时，算法 1 关于求 n! 是正确的。",
        "answer": "We use mathematical induction on n. If n = 0, we know that 0! = 1 by definition, so the if clause handles this basis step correctly. Now fix k ≥ 0 and assume the inductive hypothesis—that the algorithm correctly computes k!. Consider what happens with input k + 1. Since k + 1 > 0, the else clause is executed, and the answer is whatever the algorithm gives as output for input k, which by inductive hypothesis is k!, multiplied by k + 1. But by definition, k! · (k + 1) = (k + 1)!, so the algorithm works correctly on input k + 1.",
        "answer_symbols": [
            "=",
            "!",
            "≥",
            ">",
            "·"
        ]
    },
    "5.4 19": {
        "question": "证明：当 a、b 是非负整数且 a < b 时，算法 3 关于求 gcd(a, b) 是正确的。",
        "answer": "我们对 a 使用强归纳法。基础步骤：如果 a = 0，我们知道 gcd(0, b) = b 对所有 b > 0 成立，这就是 if 子句所做的。归纳步骤：固定 k > 0，假设归纳假设——算法对其第一个参数小于 k 的所有值都能正确工作——并考虑输入 (k, b)，其中 k < b 的情况。因为 k > 0，所以执行 else 子句，并且答案是算法对于输入 (b mod k, k) 的输出。由于 b mod k < k，输入对是有效的。根据我们的归纳假设，这个输出实际上是 gcd(b mod k, k)，这等于 gcd(k, b)（由第 4.3 节中的引理 1 得出）。",
        "answer_symbols": [
            "gcd",
            ">",
            "<",
            "mod"
        ]
    },
    "5.4 20": {
        "question": "证明：练习 17 中设计的算法是正确的。",
        "answer": "Our induction is on the value of y. When y = 0, the product xy = 0, and the algorithm correctly returns that value. Assume that the algorithm works correctly for smaller values of y, and consider its performance on y. - If y is even (and necessarily at least 2), then the algorithm computes 2 times the product of x and y/2. Since it does the product correctly (by the inductive hypothesis), this equals 2(x · y/2), which equals xy by the commutativity and associativity of multiplication. - Similarly, when y is odd, the algorithm computes 2 times the product of x and (y − 1)/2 and then adds x. Since it does the product correctly (by the inductive hypothesis), this equals 2(x · (y − 1)/2) + x, which equals xy − x + x = xy, again by the rules of algebra.",
        "answer_symbols": [
            "=",
            "−",
            "+",
            "·",
            "/"
        ]
    },
    "5.4 21": {
        "question": "证明：练习 7 中找到的递归算法是正确的。",
        "answer": "如果 n = 1，则 nx = x，算法正确返回 x。假设算法能正确计算 kx。为了计算 (k + 1)x，它递归地计算 k + 1 - 1 = k 和 x 的乘积，然后加上 x。根据归纳假设，它正确计算了该乘积，因此返回的答案是 kx + x = (k + 1)x，这是正确的。",
        "answer_symbols": [
            "+",
            "-",
            "·"
        ]
    },
    "5.4 22": {
        "question": "证明：练习 10 中找到的递归算法是正确的。",
        "answer": "The largest in a list of one integer is that one integer, and that is the answer the recursive algorithm gives when n = 1, so the basis step is correct. Now assume that the algorithm works correctly for n = k. If n = k + 1, then the else clause of the algorithm is executed. First, by the inductive hypothesis, the algorithm correctly sets m to be the largest among the first k integers in the list. Next it returns as the answer either that value or the (k + 1)st element, whichever is larger. This is clearly the largest element in the entire list. Thus the algorithm correctly finds the maximum of a given list of integers.",
        "answer_symbols": [
            "=",
            "+",
            "−"
        ]
    },
    "5.4 23": {
        "question": "利用事实 (n + 1)^2 = n^2 + 2n + 1，设计一个求 n^2 的递归算法，其中 n 是一个非负整数。然后证明该算法的正确性。",
        "answer": "过程 square(n: 非负整数)如果 n = 0，则返回 0否则返回 square(n - 1) + 2(n - 1) + 1设 P(n) 表示此算法能正确计算 n^²。因为 0^² = 0，当输入为 0 时，算法使用 if 子句正确工作。假设算法对输入 k 能正确工作。那么对于输入 k + 1，它给出的输出（由于 else 子句）是在输入为 k 时的输出，再加上 2(k + 1 - 1) + 1。根据归纳假设，它在 k 处的输出是 k^²，因此在 k + 1 处的输出是 k^² + 2(k + 1 - 1) + 1 = k^² + 2k + 1 = (k + 1)^²，正如所期望的那样。",
        "answer_symbols": [
            "+",
            "-",
            "²",
            "·"
        ]
    },
    "5.4 24": {
        "question": "设计求 a^n 的递归算法，其中 a 是实数而 n 是正整数。[提示：利用等式 a^(n+1) = (a^n) * a]",
        "answer": "We use the hint. Procedure: twopower(n: positive integer, a: real number) - If n = 1, then return a^2 - Else, return twopower(n − 1, a)^2",
        "answer_symbols": [
            "=",
            "−",
            "^"
        ]
    },
    "5.4 25": {
        "question": "对于求 a^n 的值，练习 24 的算法所用的乘法次数与算法 2 所用的乘法次数相比较的结果如何？",
        "answer": "n 次乘法与 2n",
        "answer_symbols": [
            "·"
        ]
    },
    "5.4 26": {
        "question": "用练习 24 的算法，设计当 n 是非负整数时求 a^n 的值的算法。[提示：利用 n 的二进制展开式。]",
        "answer": "We use the idea in Exercise 24, together with the fact that a^n = (a^(n/2))^2 if n is even, and a^n = a · (a^((n−1)/2))^2 if n is odd, to obtain the following recursive algorithm. In essence, we are using the binary expansion of n implicitly.",
        "answer_symbols": [
            "=",
            "−",
            "+",
            "·",
            "/",
            "^"
        ]
    },
    "5.4 27": {
        "question": "对于求 a^n 的值，练习 26 的算法所用的乘法次数与算法 2 所用的乘法次数相比较的结果如何？",
        "answer": "O(log n) 与 n",
        "answer_symbols": [
            "log"
        ]
    },
    "5.4 29": {
        "question": "设计求一个序列的第 n 项的递归算法，该序列定义成：a_0 = 1，a_1 = 2，而且对 n = 2, 3, 4, ⋯ 来说有 a_n = a_n-1 + a_n-2。",
        "answer": "过程 a(n: 非负整数)如果 n = 0，则返回 1否则如果 n = 1，则返回 2否则返回 a(n - 1) · a(n - 2)",
        "answer_symbols": [
            "·",
            "-"
        ]
    },
    "5.4 31": {
        "question": "求练习 29 的序列的递归算法与迭代算法，哪个算法更有效？",
        "answer": "迭代",
        "answer_symbols": []
    },
    "5.4 33": {
        "question": "设计求练习 32 定义的序列的第 n 项的迭代算法。",
        "answer": "过程 iterative(n: 非负整数)如果 n = 0，则 z := 1否则如果 n = 1，则 z := 2否则 x := 1y := 2z := 3for i := 1 to n - 2w := x + y + zx := yy := zz := w返回 z {z 是序列的第 n 项}",
        "answer_symbols": [
            "+",
            "-"
        ]
    },
    "5.4 35": {
        "question": "给出求一个序列的第 n 项的递归算法和迭代算法，该序列定义成：a_0 = 1，a_1 = 3，a_2 = 5，而且 a_n = a_n-1 + a_n-2 + a_n-3。哪个算法更有效？",
        "answer": "我们首先给出一个递归过程，然后是一个迭代过程。过程 r(n: 非负整数)如果 n < 3，则返回 2n + 1否则返回 r(n - 1) · (r(n - 2))^² · (r(n - 3))^³过程 i(n: 非负整数)如果 n = 0，则 z := 1否则如果 n = 1，则 z := 3否则 x := 1y := 3z := 5for i := 1 to n - 2w := z · y^² · x^³x := yy := zz := w返回 z {z 是序列的第 n 项}迭代版本更高效。",
        "answer_symbols": [
            "<",
            "+",
            "·",
            "²",
            "³",
            "-"
        ]
    },
    "5.4 37": {
        "question": "给出求字符串的倒置的递归算法。",
        "answer": "过程 reverse(w: 位串)n := length(w)如果 n ≤ 1，则返回 w否则返回 substr(w, n, n) reverse(substr(w, 1, n - 1)) {substr(w, a, b) 是 w 中从第 a 个位置到第 b 个位置的子串}",
        "answer_symbols": [
            "≤",
            "-"
        ]
    },
    "5.4 39": {
        "question": "证明：练习 37 所给出的关于字符串倒置的递归算法是正确的。",
        "answer": "该过程正确地将空字符串 λ 的反转给出为 λ（基础步骤），并且因为字符串的反转由其最后一个字符加上前 n - 1 个字符的反转组成，当 n > 0 时，算法根据归纳假设正确运行。",
        "answer_symbols": [
            "+",
            "-",
            "λ",
            ">"
        ]
    },
    "5.4 43": {
        "question": "给出递归算法来计算阿克曼函数的值。[提示：见 5.3 节练习 48 前面的说明。]",
        "answer": "过程A(m, n: 非负整数) - 如果m=0，返回2^n - 否则，如果n=0，返回0 - 否则，如果n=1，返回2 - 否则，返回A(m − 1, A(m, n − 1))",
        "answer_symbols": [
            "-",
            "^"
        ]
    },
    "5.4 46": {
        "question": "为了用算法 10 来合并下面的成对的表，需要多少次比较？a) 1, 3, 5, 7, 9; 2, 4, 6, 8, 10 b) 1, 2, 3, 4, 5; 6, 7, 8, 9, 10 c) 1, 5, 6, 7, 8; 2, 3, 4, 9, 10",
        "answer": "根据引理 1 陈述前的分析，比较次数为 m + n - r，其中列表分别有 m 和 n 个元素，r 是一个列表耗尽时另一个列表中剩余的元素数量。在这个练习中，m = n = 5，因此答案总是 10 - r。",
        "answer_symbols": [
            "+",
            "-",
            "="
        ]
    },
    "5.4 47": {
        "question": "证明：存在着带有 m 个和 n 个元素的表，使得它们不能用算法 10 以少于 m + n - 1 次的比较来合并成一个有序表。",
        "answer": "设两个列表分别为1, 2,..., m − 1, m+ n − 1 和 m, m+ 1,..., m+ n − 2, m+ n",
        "answer_symbols": [
            "-",
            "+"
        ]
    },
    "5.4 49": {
        "question": "证明：归并排序算法是正确的。",
        "answer": "如果n=1，算法什么都不做，这是正确的，因为只有一个元素的列表已经是排序好的。假设算法对n=1到n=k都正确。如果n=k+1，则将列表分为两个子列表L1和L2。根据归纳假设，归并排序可以正确地对这两个子列表进行排序；此外，合并操作可以通过每次比较将L1 ∪ L2中尚未放入的最小元素放入其中，从而正确地将两个已排序的列表合并成一个。",
        "answer_symbols": [
            "∪"
        ]
    },
    "5.4 50": {
        "question": "用快速排序来排序 3，5，7，8，1，9，2，4，6。",
        "answer": "在第一遍中，我们将列表分成两个列表，第一个列表是所有小于 3 的元素（即 1 和 2），第二个列表是所有大于 3 的元素，即 5, 7, 8, 9, 4, 6（按此顺序）。一旦这两个列表通过快速排序递归地排序完成，我们就完成了。我们将在以下列表序列中展示整个过程。括号中的数字是当前递归级别上算法正确放置的数字，方括号中的元素是之前正确放置的元素。需要五个递归级别。12(3)578946, (1)2[3]4(5)7896, [1](2)[3](4)[5]6(7)89, [1][2][3][4][5](6)[7](8)9, [1][2][3][4][5][6][7][8](9)",
        "answer_symbols": [
            "<",
            ">"
        ]
    },
    "5.4 51": {
        "question": "设 a_1，a_2，…，a_n 是 n 个不同实数的表。从这个表构造两个子表，第一个子表包含小于 a_1 的元素而第二个子表包含大于 a_1 的元素，那么需要多少次比较？",
        "answer": "O(n)",
        "answer_symbols": [
            "("
        ]
    },
    "5.4 52": {
        "question": "用伪代码描述快速排序算法。",
        "answer": "在实践中，此算法的编码方式与我们这里展示的不同，需要更多的比较，但因为数据结构更简单（并且排序是在原地完成的），所以效率更高。我们用 a 表示列表 a1, a2, ..., an，并以类似的方式表示其他列表。此外，不是将 a1 放在第一个子列表的末尾，而是将其放在两个子列表之间，并且不必在任一子列表中处理它。过程 quick(a1, a2, ..., an) b := 空列表 c := 空列表 temp := a1 对于 i := 2 到 n 如果 ai < a1，则将 ai 添加到列表 b 的末尾 否则将 ai 添加到列表 c 的末尾 {注释：m = length(b) 和 k = length(c)} 如果 m ≠ 0，则 quick(b1, b2, ..., bm) 如果 k ≠ 0，则 quick(c1, c2, ..., ck) {现在将已排序的列表放回 a} 对于 i := 1 到 m ai := bi am+1 := temp 对于 i := 1 到 k am+i+1 := ci {列表 a 现在已排序}",
        "answer_symbols": [
            "<",
            "≠"
        ]
    },
    "5.4 53": {
        "question": "用快速排序算法来排序四个元素的表，需要的最大比较次数是什么？",
        "answer": "6",
        "answer_symbols": []
    },
    "5.4 54": {
        "question": "用快速排序算法来排序四个元素的表，需要的最小比较次数是什么？",
        "answer": "在最佳情况下，初始分割将需要 3 次比较并生成长度分别为 1 和 2 的子列表，这些子列表仍需排序。这些子列表分别需要 0 和 1 次比较，列表已经排序。因此答案是 3 + 0 + 1 = 4。",
        "answer_symbols": [
            "=",
            "+",
            "<"
        ]
    },
    "5.4 55": {
        "question": "就所用的比较次数而言，确定快速排序算法的最坏情形复杂性。",
        "answer": "O(n^²)",
        "answer_symbols": [
            "(",
            ")"
        ]
    },
    "5.5 1": {
        "question": "证明程序段 y := 1 z := x + y 相对于初始断言 x=0 和终结断言 z=1 是正确的。",
        "answer": "假设x=0。程序段首先将值1赋给y，然后将值x+ y=0+ 1=1赋给z。",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "5.5 2": {
        "question": "验证程序段 if x<0 then x := 0 相对于初始断言 T 和终结断言 x≥0 是正确的。",
        "answer": "有两种情况。如果 x ≥ 0 最初，则不执行任何操作，因此 x ≥ 0 在结束时。如果 x < 0 最初，则 x 被设置为 0，因此 x = 0 在结束时；因此再次 x ≥ 0 在结束时。",
        "answer_symbols": [
            "≥",
            "<",
            "="
        ]
    },
    "5.5 3": {
        "question": "验证程序段 x := 2 z := x + y if y≥0 then z := z + 1 else z := 0 相对于初始断言 y=3 和终结断言 z=6 是正确的。",
        "answer": "假设y=3。程序段将值2赋给x，然后将值x+ y=2+ 3=5赋给z。因为y=3>0，所以它将值z+1=5+1=6赋给z。",
        "answer_symbols": [
            "+",
            "=",
            ">"
        ]
    },
    "5.5 4": {
        "question": "验证程序段 if x<y then min := x else min := y 相对于初始断言 T 和终结断言 (x≤y ∧ min=x) ∨ (x>y ∧ min=y) 是正确的。",
        "answer": "有三种情况。如果 x < y 最初，则 min 被设置为 x，因此 (x ≤ y ∧ min = x) 为真。如果 x = y 最初，则 min 被设置为 y（等于 x），因此再次 (x ≤ y ∧ min = x) 为真。最后，如果 x > y 最初，则 min 被设置为 y，因此 (x > y ∧ min = y) 为真。因此，在所有情况下，析取式 (x ≤ y ∧ min = x) ∨ (x > y ∧ min = y) 为真。",
        "answer_symbols": [
            "<",
            ">",
            "=",
            "≤",
            "∧",
            "∨"
        ]
    },
    "5.5 5": {
        "question": "设计一条推理规则来验证形如 if condition 1 then S1 else if condition 2 then S2 : else Sn 的语句的部分正确性，其中 S1，S2，…，Sn 都是语句块。",
        "answer": "(p∧ 条件1){S1}q (p∧ ¬条件1 ∧ 条件2){S2}q ... (p∧ ¬条件1 ∧ ¬条件2 ... ∧ ¬条件(n − 1){Sn}q 因此 p{if 条件1 then S1; else if 条件2 then S2; ...; else Sn}q",
        "answer_symbols": [
            "∧",
            "¬",
            "(",
            ")",
            "{",
            "}",
            "-",
            "..."
        ]
    },
    "5.5 6": {
        "question": "使用在练习 5 讨论的推理规则来验证程序 if x<0 then y := -2 * |x| / x else if x>0 then y := 2 * |x| / x else if x=0 then y := 2 相对于初始断言 T 和终结断言 y=2 是正确的。",
        "answer": "有三种情况。如果 x < 0，则 y 被设置为 -2|x|/x = (-2)(-x)/x = 2。如果 x > 0，则 y 被设置为 2|x|/x = 2x/x = 2。如果 x = 0，则 y 被设置为 2。因此，在所有情况下，y = 2 在程序终止时。",
        "answer_symbols": [
            "<",
            ">",
            "=",
            "|",
            "/"
        ]
    },
    "5.5 7": {
        "question": "用循环不变量证明下述计算实数 x 的 n 次方幂的程序是正确的，其中 n 是正整数。 power := 1 i := 1 while i≤n power := power * x i := i+1",
        "answer": "我们将证明p：“power= x^(i-1) 且 i ≤ n+1”是一个循环不变量。注意，p最初是成立的，因为在循环开始之前，i=1且power=1=x^0=x^(1-1)。接下来，我们必须证明如果p成立且i ≤ n在执行循环后，p仍然成立。循环将i增加1。因此，由于在这次遍历前i ≤ n，这次遍历后i ≤ n+1。此外，循环将power · x赋值给power。根据归纳假设，我们可以看到power被赋值为x^(i-1) · x = x^i。因此，p仍然成立。此外，循环在n次遍历后终止，此时i=n+1，因为进入循环前i被赋值为1，每次遍历时i增加1，当i>n时循环终止。因此，在终止时power=x^n，如预期。",
        "answer_symbols": [
            "=",
            "^",
            "≤",
            "+",
            "·"
        ]
    },
    "5.5 8": {
        "question": "证明在 5.4 节给出的求 f_n 的迭代程序是正确的。",
        "answer": "我们证明第5.4节中的算法8是正确的。显然，如果 n = 0 或 n = 1，则它是正确的，因此我们假设 n ≥ 2。那么当 for 循环终止时，程序终止，因此我们将注意力集中在该循环上。在循环开始之前，我们有 x = 0 和 y = 1。设循环不变量 p 为 “(x = fi-1 ∧ y = fi) ∨ (i 未定义 ∧ x = f0 ∧ y = f1)”。这在循环开始时为真，因为 i 未定义且 f0 = 0 和 f1 = 1。我们现在必须证明的是 p ∧ (1 ≤ i < n) {S} p。如果 p ∧ (1 ≤ i < n)，则 x = fi-1 和 y = fi。因此，根据斐波那契数列的定义，z 变成 fi+1。现在 x 变成 y，即 fi，而 y 变成 z，即 fi+1，且 i 增加。因此，对于这个新的（已定义的）i，x = fi-1 且 y = fi，如所愿。因此，我们可以得出结论，在终止时 x = fi-1 ∧ y = fi ∧ i = n；因此 y = fn，如所愿。",
        "answer_symbols": [
            "=",
            "≥",
            "∧",
            "∨",
            "≤",
            "<",
            "+",
            "-"
        ]
    },
    "5.5 9": {
        "question": "给出在例 5 给出的正确性证明的所有细节。",
        "answer": "假设p是“m和n是整数”。那么如果条件n<0成立，S1执行后a=−n=|n|。如果条件n<0不成立，那么S1执行后a=n=|n|。因此，p{S1}q成立，其中q是p ∧ (a=|n|)。因为S2将0赋值给k和x，显然q{S2}r成立，其中r是q ∧ (k=0) ∧ (x=0)。假设r成立。令P(k)为“x=mk 且 k ≤ a”。我们可以证明P(k)是S3中循环的循环不变量。P(0)成立，因为在进入循环前x=0=m·0且0 ≤ a。现在假设P(k)成立且k<a。那么P(k+1)也成立，因为x被赋值为x+m=mk+m=m(k+1)。当k=a时，循环终止，此时x=ma。因此，r{S3}s成立，其中s是“a=|n| 且 x=ma”。现在假设s成立。那么如果n<0，则a=−n，所以x=−mn。在这种情况下，S4将−x=mn赋值给product。如果n>0，则x=ma=mn，所以S4将mn赋值给product。因此，s{S4}t成立。",
        "answer_symbols": [
            "=",
            "<",
            ">",
            "−",
            "|",
            "∧",
            "·",
            "≤"
        ]
    },
    "5.5 11": {
        "question": "假定程序断言 p(S)q_0 和蕴含式 q_0→q_1 都为真。证明 p(S)q_1 也必然为真。",
        "answer": "假设初始断言p成立。那么因为p{S}q0成立，S执行后q0成立。因为q0 → q1成立，所以S执行后q1也成立。因此，p{S}q1成立。",
        "answer_symbols": [
            "{",
            "}",
            "→"
        ]
    },
    "5.5 13": {
        "question": "用循环不变量验证欧几里得算法 (4.3 节算法 1) 相对于初始断言“a 和 b 都是正整数”和终结断言“x=gcd(a, b)”是部分正确的。",
        "answer": "我们将使用命题p：“gcd(a, b)=gcd(x, y) 且 y ≥ 0”作为循环不变量。注意，p在进入循环前是成立的，因为此时x=a，y=b，且y是一个正整数，使用初始断言。现在假设p成立且y>0；那么循环将再次执行。在循环内，x和y分别被替换为y和x mod y。根据第4.3节的引理1，gcd(x, y)=gcd(y, x mod y)。因此，执行循环后，gcd(x, y)的值与执行前相同。此外，因为y是余数，所以它至少为0。因此，p保持成立，所以它是循环不变量。此外，如果循环终止，那么y=0。在这种情况下，我们有gcd(x, y)=x，即最终断言。因此，该程序，其输出为x，正确计算了",
        "answer_symbols": [
            "=",
            "gcd",
            "mod",
            "≥",
            "→"
        ]
    },
    "5 Supplementary Exercises 1": {
        "question": "用数学归纳法证明 2/3 + 2/9 + 2/27 + ⋯ + 2/3^n = 1 - 1/3^n，其中 n 是正整数。",
        "answer": "2/3 = 1 - (1/3¹)",
        "answer_symbols": [
            "=",
            "-",
            "/"
        ]
    },
    "5 Supplementary Exercises 3": {
        "question": "证明：当 n 是正整数时，有 1 · 2^2 + 2 · 2^2 + 3 · 2^2 + ⋯ + n · 2^n = (n-1) · 2^n + 1。",
        "answer": "1 × 1 + 2 × 2 + ... + n × 2^(n-1) = (n - 1)2^n + 1",
        "answer_symbols": [
            "×",
            "+",
            "=",
            "^",
            "-"
        ]
    },
    "5 Supplementary Exercises 5": {
        "question": "证明：当 n 是正整数时，有 1/(1 · 4) + 1/(4 · 7) + ⋯ + 1/((3n-2)(3n+1)) = n/(3n+1)",
        "answer": "1/(1 × 4) + ... + 1/[(3n - 2)(3n + 1)] = n/(3n + 1)",
        "answer_symbols": [
            "+",
            "=",
            "/",
            "×",
            "-"
        ]
    },
    "5 Supplementary Exercises 7": {
        "question": "用数学归纳法证明：当 n 是大于 9 的正整数时，就有 2^n > n^3。",
        "answer": "2^n > n^³",
        "answer_symbols": [
            ">",
            "^"
        ]
    },
    "5 Supplementary Exercises 9": {
        "question": "用数学归纳法证明：当 n 是正整数时，a - b 是 a^n - b^n 的因子。",
        "answer": "a - b 是 a^n - b^n 的因数",
        "answer_symbols": [
            "-",
            "^"
        ]
    },
    "5 Supplementary Exercises 10": {
        "question": "用数学归纳法证明：当 n 是非负整数时，n^3 + (n+1)^3 + (n+2)^3 能被 9 整除。",
        "answer": "如果 n = 0（基本情况），则表达式等于 0 + 1 + 8 = 9，这是可以被 9 整除的。假设 n^³ + (n + 1)^³ + (n + 2)^³ 可以被 9 整除。我们必须证明 (n + 1)^³ + (n + 2)^³ + (n + 3)^³ 也可以被 9 整除。这两个表达式的差是 (n + 3)^³ - n^³ = 9n^² + 27n + 27 = 9(n^² + 3n + 3)，这是一个 9 的倍数。因此，由于第一个表达式可以被 9 整除，第二个表达式也可以被 9 整除。",
        "answer_symbols": [
            "+",
            "³",
            "-",
            "=",
            "²"
        ]
    },
    "5 Supplementary Exercises 11": {
        "question": "用数学归纳法证明：当 n 是正整数时，6^(n+1) + 7^(2n-1) 能被 43 整除。",
        "answer": "6^(n+1) + 7^(2n-1) = 43",
        "answer_symbols": [
            "+",
            "^",
            "="
        ]
    },
    "5 Supplementary Exercises 12": {
        "question": "用数学归纳法证明：当 n 是正整数时，3^(2n+2) + 56n + 55 能被 64 整除。",
        "answer": "我们要证明对于每一个正整数 n，64 可以整除 9^(n+1) + 56n + 55。当 n = 1 时，表达式等于 192 = 64 * 3。假设归纳假设 64 可以整除 9^(n+1) + 56n + 55，并考虑 9^(n+2) + 56(n + 1) + 55。我们有 9^(n+2) + 56(n + 1) + 55 = 9(9^(n+1) + 56n + 55) - 8 * 56n + 56 - 8 * 55 = 9(9^(n+1) + 56n + 55) - 64 * 7n - 6 * 64。第一项由归纳假设可以被 64 整除，第二项和第三项显然可以被 64 整除，所以我们的数学归纳法证明完成。",
        "answer_symbols": [
            "^",
            "+",
            "*",
            "(",
            ")",
            "-",
            "="
        ]
    },
    "5 Supplementary Exercises 13": {
        "question": "用数学归纳法证明等差数列各项之和的公式：a + (a + d) + ⋯ + (a + nd) = (n+1)(2a + nd)/2",
        "answer": "a + (a + d) + ... + (a + nd) = (n + 1)(2a + nd)/2",
        "answer_symbols": [
            "+",
            "=",
            "/",
            "×",
            "-"
        ]
    },
    "5 Supplementary Exercises 15": {
        "question": "证明：若 n 是正整数，则 ∑_(k=1)^(n) (k+4)/(k(k+1)(k+2)) = n(3n+7)/(2(n+1)(n+2))",
        "answer": "∑(i=1 到 k+1) (i + 4) / [i(i + 1)(i + 2)] = 1 (k + 1)(3(k + 1) + 7) / [2((k + 1) + 1)((k + 1) + 2)]",
        "answer_symbols": [
            "∑",
            "+",
            "/",
            "(",
            ")",
            "×",
            "="
        ]
    },
    "5 Supplementary Exercises 16": {
        "question": "对于哪些正整数 n，n+6 < (n^2 - 8n)/16？用数学归纳法证明你的答案。",
        "answer": "经过一些计算，我们推测对于所有 n ≥ 28，n + 6 < (n^² - 8n) / 16。（我们发现对于较小的 n 值不成立。）对于基础步骤，我们有 28 + 6 = 34 和 (28^² - 8 * 28) / 16 = 35，因此该陈述成立。假设该陈述对 n = k 成立。那么因为 k > 27，我们有 (k + 1)^² - 8(k + 1) / 16 = k^² - 8k / 16 + 2k - 7 / 16 > k + 6 + 2k - 7 由归纳假设 > k + 6 + 2 * 27 - 7 / 16 > k + 6 + 2.9 > (k + 1) + 6，如所需。",
        "answer_symbols": [
            "≥",
            "+",
            "<",
            "²",
            "*",
            "(",
            ")",
            "/",
            "-"
        ]
    },
    "5 Supplementary Exercises 17": {
        "question": "(需要微积分知识) 假设 f(x) = e^x 并且 g(x) = xe^x。用数学归纳法以及乘积求导规则和 f'(x) = e^x 的事实来证明：当 n 是正整数时，g^(n)(x) = (x+n)e^x。",
        "answer": "g^(k+1) = (x + (k + 1))e^x",
        "answer_symbols": [
            "=",
            "+",
            "(",
            ")",
            "^"
        ]
    },
    "5 Supplementary Exercises 18": {
        "question": "(需要微积分知识) 假设 f(x) = e^x 并且 g(x) = e^(cx)，其中 c 是常数。用数学归纳法以及复合求导规则和 f'(x) = e^x 的事实来证明：当 n 是正整数时，g^(n)(x) = c^n e^(cx)。",
        "answer": "当 n = 1 时，我们在寻找函数 g(x) = e^(cx) 的导数，通过链式法则，其导数为 ce^(cx)，因此该陈述在 n = 1 时成立。假设该陈述在 n = k 时成立，即第 k 阶导数为 g^(k) = c^k e^(cx)。再次通过链式法则求导（并记住 c^k 是常数），我们得到第 (k + 1) 阶导数：g^(k+1) = c * c^k e^(cx) = c^(k+1) e^(cx)，如所需。",
        "answer_symbols": [
            "=",
            "^",
            "(",
            ")",
            "*",
            "'",
            "e"
        ]
    },
    "5 Supplementary Exercises 19": {
        "question": "确定哪些斐波那契数是偶数，用数学归纳法的一种形式来证明你的猜想。",
        "answer": "如果 n ≡ 0 (mod 3)，则 f_n 是偶数，否则是奇数",
        "answer_symbols": [
            "≡",
            "(",
            ")",
            "mod"
        ]
    },
    "5 Supplementary Exercises 20": {
        "question": "确定哪些斐波那契数能被 3 整除，用数学归纳法的一种形式来证明你的猜想。",
        "answer": "我们查看前几个斐波那契数，看看是否有模式（所有同余都是模 3）：f0 = 0, f1 = 1, f2 = 1, f3 = 2, f4 = 3 ≡ 0, f5 = 5 ≡ 2, f6 = 8 ≡ 2, f7 = 13 ≡ 1, f8 = 21 ≡ 0, f9 = 34 ≡ 1。我们可能还没有看到模式，但请注意 f8 和 f9 模 3 后与 f0 和 f1 相同。因此从这一点开始，序列必须继续重复，因为递归定义仅基于 fn-1 和 fn-2。特别是，f10 ≡ f2 = 1, f11 ≡ f3 = 2，等等。由于模式的周期为 8，我们可以这样表述我们的猜想：fn ≡ 0 (mod 3) 如果 n ≡ 0 或 4 (mod 8)；fn ≡ 1 (mod 3) 如果 n ≡ 1, 2, 或 7 (mod 8)；fn ≡ 2 (mod 3) 如果 n ≡ 3, 5, 或 6 (mod 8)。通过数学归纳法证明这一点很繁琐。有两个基本情况，n = 0 和 n = 1。在每个情况下，猜想显然是正确的，因为 0 ≡ 0 (mod 8) 且 f0 ≡ 0 (mod 3)，1 ≡ 1 (mod 8) 且 f1 ≡ 1 (mod 3)。所以假设归纳假设，并考虑给定的 n + 1。根据 (n + 1) mod 8 的值，有八种情况需要考虑。我们将进行其中一种情况；其他七种情况类似。例如，如果 n + 1 ≡ 5 (mod 8)，那么 n - 1 和 n 分别与 3 和 4 模 8 同余。根据归纳假设，fn-1 ≡ 2 (mod 3) 且 fn ≡ 0 (mod 3)。因此 fn+1，即这两个数的和，等价于 2 + 0，或 2，模 3，如所需。",
        "answer_symbols": [
            ",",
            "=",
            ")",
            "mod",
            "(",
            "+",
            "≡",
            "-"
        ]
    },
    "5 Supplementary Exercises 21": {
        "question": "证明：对所有非负整数 n 来说，f_k f_n + f_(k+1) f_(n+1) = f_(k+n+1)，其中 k 是非负整数且 f_i 表示第 i 个斐波那契数。",
        "answer": "f_k f_n + f_(k+1) f_(n+1) = f_(n+k+1)",
        "answer_symbols": [
            "+",
            "=",
            "×",
            "_"
        ]
    },
    "5 Supplementary Exercises 22": {
        "question": "证明：当 n 是正整数时，有 f_n + f_(n+2) = L_(n+1)，其中 f_i 和 L_i 分别是第 i 个斐波那契数和第 i 个卢卡斯数。",
        "answer": "There are two base cases: for n = 0 we have f0 + f2 = 0 + 1 = 1 = l1, and f1 + f3 = 1 + 2 = 3 = l2, as desired. Assume the inductive hypothesis, that fk + fk+2 = lk+1 for all k ≤ n (we are using strong induction here). Then fn+1 + fn+3 = fn + fn−1 + fn+2 + fn+1 = (fn + fn+2) + (fn−1 + fn+1) = ln+1 + ln by the inductive hypothesis (with k = n and k = n − 1). This last expression equals ln+2 = l(n+1)+1, however, by the definition of the Lucas numbers, as desired.",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "≤",
            "(",
            ")",
            "∈"
        ]
    },
    "5 Supplementary Exercises 23": {
        "question": "证明：当 n 是非负整数且 L_i 是第 i 个卢卡斯数时，有 L_0^2 + L_1^2 + ⋯ + L_n^2 = L_n L_(n+1) + 2。",
        "answer": "l_0^² + l_1^² + ... + l_n^² = l_n l_(n+1) + 2",
        "answer_symbols": [
            "+",
            "=",
            "²",
            "×"
        ]
    },
    "5 Supplementary Exercises 24": {
        "question": "用数学归纳法证明：任意 n 个连续正整数的积能被 n! 整除。[提示：利用恒等式 m(m+1) ⋯ (m+n-1)/n! = (m-1)m(m+1) ⋯ (m+n-2)/n! + m(m+1) ⋯ (m+n-1)/n!]",
        "answer": "We follow the hint. Starting with the trivial identity (m + n − 1) choose n = (m − 1) choose n + 1 and multiplying both sides by m(m + 1) · · · (m + n − 2) / (n − 1)! we obtain the identity given in the hint: m(m + 1) · · · (m + n − 1) / n! = (m − 1)m(m + 1) · · · (m + n − 2) / n! + m(m + 1) · · · (m + n − 2) / (n − 1)! Now we want to show that the product of any n consecutive positive integers is divisible by n!. We prove this by induction on n. The case n = 1 is clear, since every integer is divisible by 1!. Assume the inductive hypothesis, that the statement is true for n−1. To prove the statement for n, now, we will give a proof using induction on the starting point of the sequence of n consecutive positive integers. Call this starting point m. The basis step, m = 1, is again clear, since the product of the first n positive integers is n!. Assume the inductive hypothesis that the statement is true for m−1. Note that we have two inductive hypotheses active here: the statement is true for n−1, and the statement is true also for m−1 and n. We are trying to prove the statement true for m and n. At this point we simply stare at the identity given above. The first term on the right-hand side is an integer by the inductive hypothesis about m−1 and n. The second term on the right-hand side is an integer by the inductive hypothesis about n−1. Therefore the expression is an integer. But the statement that the left-hand side is an integer is precisely what we wanted—that the product of the n positive integers starting with m is divisible by n!.",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "!",
            "·",
            "(",
            ")",
            "≤",
            "∈"
        ]
    },
    "5 Supplementary Exercises 25": {
        "question": "用数学归纳法证明：当 n 是正整数时，有 (cos x + i sin x)^n = cos nx + i sin nx。[提示：利用恒等式 cos(a+b) = cos a cos b - sin a sin b 和 sin(a+b) = sin a cos b + cos a sin b]",
        "answer": "cos((k+1)x) + i sin((k+1)x) = (cos x + i sin x)^(k+1)",
        "answer_symbols": [
            "+",
            "=",
            "(",
            ")",
            "×",
            "sin",
            "cos",
            "^"
        ]
    },
    "5 Supplementary Exercises 26": {
        "question": "用数学归纳法证明：当 n 是正整数且 sin(x/2) ≠ 0 时，有 ∑_(j=1)^(n) cos jx = cos[(n+1)x/2] sin(nx/2) sin(x/2)",
        "answer": "The algebra gets very messy here, but the ideas are not advanced. We will use the following standard trigonometric identity, which is proved using the standard formulae for the sine and cosine of sums and differences: cos A sin B = (sin(A + B) − sin(A − B)) / 2 The proof of the identity in this exercise is by induction, of course. The basis step (n = 1) is the true statement that cos x = cos x sin(x/2) / sin(x/2). Assume the inductive hypothesis: Sum from j=1 to n of cos(jx) = cos((n + 1)x/2) sin(nx/2) / sin(x/2) Now it is clear that the inductive step is equivalent to showing that adding the (n + 1)th term in the sum to the expression on the right-hand side of the last displayed equation yields the same expression with n + 1 substituted for n. In other words, we must show that cos((n + 1)x) + cos((n + 1)x/2) sin(nx/2) / sin(x/2) = cos((n + 2)x/2) sin((n + 1)x/2) / sin(x/2), which can be rewritten without fractions as sin(x/2) cos((n + 1)x) + cos((n + 1)x/2) sin(nx/2) = cos((n + 2)x/2) sin((n + 1)x/2).",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "(",
            ")",
            "∑",
            "cos",
            "sin",
            "/",
            "·"
        ]
    },
    "5 Supplementary Exercises 27": {
        "question": "用数学归纳法证明：对于每个正整数 n，∑j=1^n j^2 2^j = n^2 2^(n+1) - n 2^(n+2) + 3 * 2^(n+1) - 6",
        "answer": "∑(j=1 到 k+1) j^² 2^j = 2^(k+2)[(k + 1)^² - 2(k + 1) + 3] - 6",
        "answer_symbols": [
            "∑",
            "+",
            "=",
            "²",
            "[",
            "]",
            "×",
            "-",
            "^"
        ]
    },
    "5 Supplementary Exercises 29": {
        "question": "证明：如果 n 是正整数，且 n ≥ 2，则 ∑j=2^n 1/(j^2 - 1) = (n-1)(3n+2)/(4n(n+1))",
        "answer": "∑(j=1 到 k+1) 1/(j^² - 1) = (k - 1)(3k + 2) / [4k(k + 1)] + 1/[(k + 1)^² - 1]",
        "answer_symbols": [
            "∑",
            "+",
            "=",
            "/",
            "×",
            "(",
            ")",
            "²",
            "-"
        ]
    },
    "5 Supplementary Exercises 31": {
        "question": "如果平面上的点 (x, y) 中 x 和 y 都是整数，则称点 (x, y) 为格点。用数学归纳法证明：至少需要 n+1 条直线才能确保满足 x ≥ 0、y ≥ 0 及 x + y ≤ n 的格点 (x, y) 位于其中的一条直线上。",
        "answer": "We need at least one line to cover the one point at (0, 0). Inductive step: Assume the inductive hypothesis, that at least k + 1 lines are needed to cover the lattice points with x ≥ 0, y ≥ 0, and x + y ≤ k. Consider the triangle of lattice points defined by x ≥ 0, y ≥ 0, and x + y ≤ k + 1. By way of contradiction, assume that k + 1 lines could cover this set. Then these lines must cover the k + 2 points on the line x + y = k + 1. But only the line x + y = k + 1 itself can cover more than one of these points, because two distinct lines intersect in at most one point. Therefore none of the k + 1 lines that are needed (by the inductive hypothesis) to cover the set of lattice points within the triangle but not on this line can cover more than one of the points on this line, and this leaves at least one point uncovered. Therefore our assumption that k + 1 lines could cover the larger set is wrong, and our proof is complete.",
        "answer_symbols": [
            "≥",
            "+",
            "=",
            "≤",
            "≠"
        ]
    },
    "5 Supplementary Exercises 33": {
        "question": "设 B = MAM^⁻¹，其中 A 和 B 都是 n × n 矩阵，M 可逆。证明：对所有的正整数 k 都有 B^k = MA^kM^⁻¹。",
        "answer": "Let P(n) be B_k = M A_k M^{-1}. Basis step: Part of the given conditions. Inductive step: Assume the inductive hypothesis. Then B_{k+1} = B B_k = M A M^{-1} B_k = M A M^{-1} M A_k M^{-1} (by the inductive hypothesis) = M A I A_k M^{-1} = M A A_k M^{-1} = M A_{k+1} M^{-1}.",
        "answer_symbols": [
            "=",
            "^{-1}",
            "M",
            "A",
            "B",
            "I"
        ]
    },
    "5 Supplementary Exercises 34": {
        "question": "用数学归纳法证明：如果在平面上画线时，只需要用两种颜色来对所形成的区域着色，使得具有共同边界的区域都有不同的颜色。",
        "answer": "如果没有两个具有公共边界的区域有相同的颜色，则称这种着色为适当的。对于基础步骤，如果只有一条线，我们可以通过将平面的一侧涂成红色，另一侧涂成蓝色来产生一个适当的着色。假设使用 k 条线可以实现适当的着色。如果有 k+1 条线，移除一条线，对剩余线条产生的配置进行适当着色，然后放回最后一条线。反转最后一条线一侧的所有颜色。最终的着色将是适当的。",
        "answer_symbols": []
    },
    "5 Supplementary Exercises 35": {
        "question": "证明：当 n ≥ 3 时，n! 总可以表示成 n 的不同正因子之和。",
        "answer": "We prove by mathematical induction the following stronger statement: For every n ≥ 3, we can write n! as the sum of n of its distinct positive divisors, one of which is 1. That is, we can write n! = a_1 + a_2 + ... + a_n, where each a_i is a divisor of n!, the divisors are listed in strictly decreasing order, and a_n = 1. Basis step: 3! = 3 + 2 + 1. Inductive step: Assume that we can write k! as a sum of the desired form, say k! = a_1 + a_2 + ... + a_k, where each a_i is a divisor of n!, the divisors are listed in strictly decreasing order, and a_n = 1. Consider (k + 1)!. Then we have (k + 1)! = (k + 1) k! = (k + 1) (a_1 + a_2 + ... + a_k) = (k + 1) a_1 + (k + 1) a_2 + ... + (k + 1) a_k = (k + 1) a_1 + (k + 1) a_2 + ... + k * a_k + a_k. Because each a_i was a divisor of k!, each (k + 1) a_i is a divisor of (k + 1)!. Furthermore, k * a_k = k, which is a divisor of (k + 1)!, and a_k = 1, so the new last summand is again 1. (Notice also that our list of summands is still in strictly decreasing order.) Thus we have written (k + 1)! in the desired form.",
        "answer_symbols": [
            "!",
            "=",
            "+",
            "*",
            "k",
            "a"
        ]
    },
    "5 Supplementary Exercises 36": {
        "question": "用数学归纳法证明：如果 x₁, x₂, …, xₙ 都是正实数，且 n ≥ 2，则有 (x₁ + 1/x₁) (x₂ + 1/x₂) ⋯ (xₙ + 1/xₙ) ≥ (x₁ + 1/x₁) (x₂ + 1/x₂) ⋯ (xₙ₋₁ + 1/xₙ₋₁) (xₙ + 1/xₙ)",
        "answer": "为了方便清除分数，我们将两边都乘以所有 x 的乘积；这使得所需的不等式变为 (x₁^² + 1)(x₂^² + 1)· · ·(xₙ^² + 1) ≥ (x₁x₂ + 1)(x₂x₃ + 1)· · ·(xₙ₋₁xₙ + 1)(xₙx₁ + 1)。基础步骤是 (x₁^² + 1)(x₂^² + 1) ≥ (x₁x₂ + 1)(x₂x₁ + 1)。经过代数简化和因式分解后，这变为 (x₁ - x₂)^² ≥ 0，因此是正确的。对于归纳步骤，我们假设不等式对 n 成立，并希望证明 (x₁^² + 1)(x₂^² + 1)· · ·(xₙ^² + 1)(xₙ₊₁^² + 1) ≥ (x₁x₂ + 1)(x₂x₃ + 1)· · ·(xₙ₋₁xₙ + 1)(xₙxₙ₊₁ + 1)(xₙ₊₁x₁ + 1)。由于这个不等式的循环形式，我们可以不失一般性地假设 xₙ₊₁ 是给定数字中最大的（或并列最大）。由归纳假设我们有 (x₁^² + 1)(x₂^² + 1)· · ·(xₙ^² + 1)(xₙ₊₁^² + 1) ≥ (x₁x₂ + 1)(x₂x₃ + 1)· · ·(xₙ₋₁xₙ + 1)(xₙx₁ + 1)(xₙ₊₁^² + 1)，因此只需证明 (xₙx₁ + 1)(xₙ₊₁^² + 1) ≥ (xₙxₙ₊₁ + 1)(xₙ₊₁x₁ + 1)。但经过代数简化和因式分解后，这变为 (xₙ₊₁ - x₁)(xₙ₊₁ - xₙ) ≥ 0，这是由我们的假设 xₙ₊₁ 是列表中最大的数字得出的。",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "-",
            "·",
            "≥",
            "²",
            "₁",
            "₂",
            "ₙ",
            "ₙ₊₁",
            "₀",
            "₃",
            "₄",
            "₅",
            "₆",
            "₇",
            "₈",
            "₉",
            "₋₁",
            "₋₂",
            "₋₃",
            "₋₄",
            "₋₅",
            "₋₆",
            "₋₇",
            "₋₈",
            "₋₉"
        ]
    },
    "5 Supplementary Exercises 37": {
        "question": "用数学归纳法证明：若 n 个人站成一队，其中 n 是正整数，并且若该队中第一个人是女人，最后一个人是男人，则队中某处有一个女人直接站在一个男人的前面。",
        "answer": "When n = 1 the statement is vacuously true. Assume that the statement is true for n = k, and consider k + 1 people standing in a line, with a woman first and a man last. If the kth person is a woman, then we have that woman standing in front of the man at the end. If the kth person is a man, then the first k people in line satisfy the conditions of the inductive hypothesis for the first k people in line, so again we can conclude that there is a woman directly in front of a man somewhere in the line.",
        "answer_symbols": [
            "="
        ]
    },
    "5 Supplementary Exercises 38": {
        "question": "假设在一个国家中有直达的单行道路连接每一对城市。用数学归纳法证明：存在一个城市，从其他每个城市都可以直达这个城市，或者恰好经由一个其他城市而到达这个城市。",
        "answer": "（读者在跟随这个证明时画一个图会很有帮助。）我们用归纳法对城市数量 n 进行证明，当 n=1 或 n=2 时结果是显而易见的。假设归纳假设成立，假设我们有一个有 k+1 个城市，标记为 c₁ 到 cₖ₊₁ 的国家。移除 cₖ₊₁ 并应用归纳假设，找到一个城市 c，可以从 c₁ 到 cₖ 中的每个其他城市直接或通过一个中间站到达。如果从 cₖ₊₁ 到 c 有一条单向道路，那么我们就完成了，因此我们可以假设道路是从 c 到 cₖ₊₁。如果从 cₖ₊₁ 到任何一个有单向道路到 c 的城市有单向道路，那么我们也完成了，因此我们可以假设每条从 cₖ₊₁ 到一个有单向道路到 c 的城市之间的道路都是从这样的城市到 cₖ₊₁。因此 c 和所有有单向道路到 c 的城市都有直达 cₖ₊₁ 的道路。所有剩下的城市必须有一条单向道路通向一个有单向道路到 c 的城市（这是 c 的定义的一部分），所以它们通过某个这样的城市有长度为 2 的路径到 cₖ₊₁。因此 cₖ₊₁ 满足问题的条件，证明完成。",
        "answer_symbols": [
            "+",
            "₁",
            "₂",
            "ₖ",
            "ₖ₊₁",
            "→"
        ]
    },
    "5 Supplementary Exercises 39": {
        "question": "用数学归纳法证明：当 n 个圆周把平面分成区域时，这些区域可以用两种颜色着色，使得具有共同边界的区域都染成不同的颜色。",
        "answer": "Basis step: When n = 1 there is one circle, and we can color the inside blue and the outside red to satisfy the conditions. Inductive step: Assume the inductive hypothesis that if there are k circles, then the regions can be 2-colored such that no regions with a common boundary have the same color, and consider a situation with k + 1 circles. Remove one of the circles, producing a picture with k circles, and invoke the inductive hypothesis to color it in the prescribed manner. Then replace the removed circle and change the color of every region inside this circle. The resulting figure satisfies the condition, because if two regions have a common boundary, then either that boundary involved the new circle, in which case the regions on either side used to be the same region and now the inside portion is different from the outside, or else the boundary did not involve the new circle, in which case the regions are colored differently because they were colored differently before the new circle was restored.",
        "answer_symbols": []
    },
    "5 Supplementary Exercises 40": {
        "question": "假设有足够的燃料让环行赛道上一组汽车中的一辆跑完一圈。用数学归纳法证明：在这组汽车中存在一辆汽车，当它沿着赛道前进时，可以通过从其他汽车获得加油来跑完一圈。",
        "answer": "我们必须从问题的陈述中假设所有汽车在英里/加仑方面的效率相同。我们对组中的汽车数量 n 进行归纳证明。如果 n=1，那么这一辆汽车有足够的燃料完成一圈。假设归纳假设对 k 辆车的组成立，假设我们有一个 k+1 辆车的组。有助于将这些汽车视为静止不动的。我们声称组中至少有一辆车 c 有足够的燃料到达组中的下一辆车。如果不是这样，那么所有汽车中的总燃料量将不足以覆盖整个一圈（想象每辆车都在自己的燃料上尽可能远地行驶）。现在假装在 c 前面的那辆车 d 不在场，而是那辆车的燃料在 c 的油箱里。根据归纳假设（我们仍然有 k 辆车）",
        "answer_symbols": [
            "₂",
            "ₖ",
            "₁",
            "+",
            "ₖ₊₁"
        ]
    },
    "5 Supplementary Exercises 41": {
        "question": "证明：如果 n 是正整数，则有 ∑j=1^n (2j-1) (∑k=j^n 1/k) = n(n+1)/2",
        "answer": "If n = 1 then the equation reads 1 * 1 = 1 * 2 / 2, which is true. Assume that the equation is true for n and consider it for n + 1. Then ∑(j=1 to n+1) (2j - 1) (∑(k=j to n+1) 1/k) = ∑(j=1 to n) (2j - 1) (∑(k=j to n+1) 1/k) + [2(n + 1) - 1] * 1/(n + 1) = ∑(j=1 to n) (2j - 1) (1/(n + 1) + ∑(k=j to n) 1/k) + (2n + 1)/(n + 1) = (1/(n + 1) ∑(j=1 to n) (2j - 1)) + (∑(j=1 to n) (2j - 1) ∑(k=j to n) 1/(n + 1) = (1/(n + 1) * n^²) + n(n + 1)/2 + (2n + 1)/(n + 1) (by the inductive hypothesis) = (2n^² + n(n + 1)^² + (4n + 2)) / 2(n + 1) = 2(n + 1)^² + n(n + 1)^² / 2(n + 1) = (n + 1)(n + 2) / 2.",
        "answer_symbols": [
            "∑",
            "(",
            ")",
            "+",
            "-",
            "*",
            "/",
            "^",
            "n",
            "j",
            "k"
        ]
    },
    "5 Supplementary Exercises 42": {
        "question": "用数学归纳法证明：如果 a, b 和 c 是一个直角三角形的三条边长，c 是斜边的边长，则对于所有整数 n ≥ 3，有 a^n + b^n < c^n 成立。",
        "answer": "基础步骤是n = 3。由于直角三角形的斜边是最长的一边，因此c > a 和 c > b。因此 c^³ = c * c^² = c(a^² + b^²) = c * a^² + c * b^² > a * a^² + b * b^² = a^³ + b^³。对于归纳步骤，c^(k+1) = c * c^k > c(a^k + b^k) = c * a^k + c * b^k > a * a^k + b * b^k = a^(k+1) + b^(k+1)。也可以给出一个非归纳性的证明，大致沿用相同的思路：c^n = c^² * c^(n-2) = (a^² + b^²) * c^(n-2) = a^² * c^(n-2) + b^² * c^(n-2) > a^² * a^(n-2) + b^² * b^(n-2) = a^n + b^n",
        "answer_symbols": [
            "=",
            ">",
            "*",
            "^",
            "+",
            "-",
            "(",
            ")",
            "[",
            "]"
        ]
    },
    "5 Supplementary Exercises 43": {
        "question": "用数学归纳法证明：如果 n 为整数，序列 2 mod n, 2^² mod n, 2^³ mod n, 2^⁴ mod n, …，最后是一个常数。（即在有限个项以后的所有项都一样。）",
        "answer": "Let T(n) be the statement that the sequence of towers of 2 is eventually constant modulo n. We use strong induction to prove that T(n) is true for all positive integers n. Basis step: When n = 1 (and n = 2), the sequence of towers of 2 modulo n is the sequence of all 0s. Inductive step: Suppose that k is an integer with k ≥ 2. Suppose that T(j) is true for 1 ≤ j ≤ k - 1. In the proof of the inductive step we denote the rth term of the sequence modulo n by a_r. First suppose k is even. Let k = 2^s q where s ≥ 1 and q < k is odd. When j is large enough, a_(j-2) ≥ s, and for such j, a_j = 2^(2^(a_(j-2))) is a multiple of 2^s. It follows that for sufficiently large j, a_j ≡ 0 (mod 2^s). Hence, for large enough i, 2^s divides a_(i+1) - a_i. By the inductive hypothesis T(q) is true, so the sequence a_1, a_2, a_3, ... is eventually constant modulo q. This implies that for large enough i, q divides a_(i+1) - a_i. Because gcd(q, 2^s) = 1 and for sufficiently large i both q and 2^s divide a_(i+1) - a_i, k = 2^s q divides a_(i+1) - a_i for sufficiently large i. Hence, for sufficiently large i, a_(i+1) - a_i ≡ 0 (mod k). This means that the sequence is eventually constant modulo k. Finally, suppose k is odd. Then gcd(2, k) = 1, so by Euler’s theorem (found in elementary number theory books), we know that 2^φ(k) ≡ 1 (mod k). Let r = φ(k). Because r < k, by the inductive hypothesis T(r), the sequence a_1, a_2, a_3, ... is eventually constant modulo r, say equal to c. Hence for large enough i, for some integer t_i, a_i = t_i r + c. Hence a_(i+1) = 2^a_i = 2^(t_i r + c) = (2^r)^(t_i) 2^c ≡ 2^c (mod k). This shows that a_1, a_2, ... is eventually constant modulo k.",
        "answer_symbols": [
            "≡",
            "gcd",
            "mod",
            "φ",
            "^",
            "(",
            ")",
            "+",
            "-",
            "*",
            "="
        ]
    },
    "5 Supplementary Exercises 44": {
        "question": "单位分数或埃及分数是形如 1/n 的分数，其中 n 是正整数。在本题中，将用强归纳法证明：可以用贪心算法把每个满足 0 < p/q < 1 的有理数 p/q 表达成不同的单位分数之和。在算法的每一步，求出最小的正整数 n 使得这个和可以加上 1/n 而不超过 p/q。例如，为了表达 5/7，从 1/2 这个和开始。由于 5/7 - 1/2 = 3/14，所以把 1/5 加上这个和，因为 5 是最小的正整数 k 使得 1/k < 3/14。由于 3/14 - 1/5 = 1/70，所以算法终止，证明 5/7 = 1/2 + 1/5 + 1/70。设 T(p) 是命题：对于所有满足 0 < p/q < 1 的有理",
        "answer": "a) 基础步骤是证明该算法对所有形式为1/q的分数终止。由于这个分数已经是单位分数，所以没有什么可证的。b) 对于归纳步骤，假设算法对所有分子小于p的正真分数终止，假设我们从正真分数p/q开始，假设算法选择1/n作为算法的第一步。注意，必要时n > 1。因此我们可以写成p/q = p'/q' + 1/n。如果p/q = 1/n，我们就完成了，所以假设p/q > 1/n。通过找到一个共同的分母并减去，我们可以取p' = np - q和q' = nq。我们声称p' < p，这在代数上很容易看出等价于p/q < 1/(n - 1)，而这是通过选择n使得1/n是不超过p/q的最大单位分数而得到的。因此，根据归纳假设，我们可以将p'/q'写成具有递增分母的不同单位分数之和，从而将p/q写成单位分数之和。唯一剩下的检查是p'/q' < 1/n，这样算法就不会再次为p'/q'选择1/n。但如果这不是这种情况，那么p/q ≥ 2/n，结合上面给出的不等式p/q < 1/(n - 1)，我们将有2/n < 1/(n - 1)，这意味着n = 1，这是矛盾的。",
        "answer_symbols": [
            "=",
            ">",
            "<",
            "+",
            "-",
            "*",
            "/",
            "(",
            ")",
            "[",
            "]"
        ]
    },
    "5 Supplementary Exercises 45 a)": {
        "question": "通过连续地使用 M(n) 的定义规则求 M(102).",
        "answer": "92",
        "answer_symbols": []
    },
    "5 Supplementary Exercises 45 b)": {
        "question": "通过连续地使用 M(n) 的定义规则求 M(101).",
        "answer": "91",
        "answer_symbols": []
    },
    "5 Supplementary Exercises 45 c)": {
        "question": "通过连续地使用 M(n) 的定义规则求 M(99).",
        "answer": "91",
        "answer_symbols": []
    },
    "5 Supplementary Exercises 45 d)": {
        "question": "通过连续地使用 M(n) 的定义规则求 M(97).",
        "answer": "91",
        "answer_symbols": []
    },
    "5 Supplementary Exercises 45 e)": {
        "question": "通过连续地使用 M(n) 的定义规则求 M(87).",
        "answer": "91",
        "answer_symbols": []
    },
    "5 Supplementary Exercises 45 f)": {
        "question": "通过连续地使用 M(n) 的定义规则求 M(76).",
        "answer": "91",
        "answer_symbols": []
    },
    "5 Supplementary Exercises 46": {
        "question": "证明：函数 M(n) 是从正整数集合到正整数集合的良定义函数。[提示：证明对所有满足 n≤101 的正整数 n 来说都有 M(n)=91.]",
        "answer": "我们真正需要证明的是定义“终止”于每个n。可以想象尝试应用定义会让我们陷入某种无限循环，使用第二行；我们需要证明不会发生这种情况。我们将通过数学归纳法给出一种非常奇怪的证明。首先，按照提示，我们将证明定义告诉我们M(n) = 91对所有正整数n ≤ 101。我们通过反向归纳法来做这件事，从n = 101开始，向下到n = 1。有11个基本情况：n = 101, 100, 99, ..., 91。定义的第一行立即告诉我们M(101) = 101 - 10 = 91。为了计算M(100)，我们有M(100) = M(M(100 + 11)) = M(M(111)) = M(111 - 10) = M(101) = 91。最后一个等式来自我们已经计算出的M(101)。类似地，M(99) = M(M(99 + 11)) = M(M(110)) = M(110 - 10) = M(100) = 91，依此类推直到M(91) = M(M(91 + 11)) = M(M(102)) = M(102 - 10) = M(92) = 91。",
        "answer_symbols": [
            "=",
            ")",
            "∈",
            "(",
            "+",
            "]",
            "[",
            "-"
        ]
    },
    "5 Supplementary Exercises 47": {
        "question": "下述的证明当 n 是正整数时有 1/(1 * 2) + 1/(2 * 3) + ⋯ + 1/((n-1)n) = 3/2 - 1/n 是否正确？为你的答案给出理由。",
        "answer": "The basis step is incorrect because n = 1 for the sum shown.",
        "answer_symbols": [
            "="
        ]
    },
    "5 Supplementary Exercises 48": {
        "question": "设 A_1, A_2, …, A_n 是一组集合，且对 k=3, 4, …, n 都有 R_k = A_1 ⊕ A_k 及 R_k = R_(k-1) ⊕ A_k。利用数学归纳法证明：当且仅当 x 属于 A_1, A_2, …, A_n 中一个奇数下标的集合时，有 x ∈ R_n。（回忆 2.2 节中的定义：S ⊕ T 是集合 S 和 T 的对称差。）",
        "answer": "我们通过归纳法对n进行证明。当n = 2时，这只是对称差的定义。假设该陈述对n - 1成立；我们必须证明它对n也成立。根据定义，R_n = R_{n-1} ⊕ A_n。我们必须证明元素x属于R_n当且仅当它属于集合A1, A2, ..., A_n中的奇数个集合。归纳假设告诉我们x属于R_{n-1}当且仅当x属于集合A1, A2, ..., A_{n-1}中的奇数个集合。有四种情况。首先假设x ∈ R_{n-1}且x ∈ A_n。那么x属于集合A1, A2, ..., A_{n-1}中的奇数个集合，因此x属于集合A1, A2, ..., A_n中的偶数个集合；因此x ∉ R_n，这与⊕的定义一致。接下来假设x ∈ R_{n-1}且x ∉ A_n。那么x属于集合A1, A2, ..., A_{n-1}中的奇数个集合，因此x属于集合A1, A2, ..., A_n中的奇数个集合；因此x ∈ R_n，这再次与⊕的定义一致。第三种情况，假设x ∉ R_{n-1}且x ∈ A_n。那么x属于集合A1, A2, ..., A_{n-1}中的偶数个集合，因此x属于集合A1, A2, ..., A_n中的奇数个集合；因此x ∈ R_n，这再次与⊕的定义一致。最后一种情况 (x ∉ R_{n-1}且x ∉ A_n) 类似。",
        "answer_symbols": [
            "=",
            "∈",
            "∉",
            "⊕"
        ]
    },
    "5 Supplementary Exercises 49": {
        "question": "证明：若在 n 个圆中每两个都恰好相交于两点，而任意三个都没有公共点，则这些圆把平面划分成 n^2-n+2 个区域.",
        "answer": "Let P(n) be \"the plane is divided into n^² - n + 2 regions by n circles if every two of these circles have two common points but no three have a common point.\" Basis step: P(1) is true because a circle divides the plane into 2 = 1^² - 1 + 2 regions. Inductive step: Assume that P(k) is true, that is, k circles with the specified properties divide the plane into k^² - k + 2 regions. Suppose that a (k + 1)st circle is added. This circle intersects each of the other k circles in two points, so these points of intersection form 2k new arcs, each of which splits an old region. Hence, there are 2k regions split, which shows that there are 2k more regions than there were previously. Hence, k + 1 circles satisfying the specified properties divide the plane into (k^² - k + 2) + 2k = (k + 1)^² - (k + 1) + 2 regions.",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "²",
            "k",
            "n"
        ]
    },
    "5 Supplementary Exercises 50": {
        "question": "证明：若在 n 个平面上任意三个都有公共点，而任意四个都没有公共点，则这些平面把三维空间划分成 (n^3+5n+6)/6 个区域.",
        "answer": "这个问题类似于并使用第5.1节练习62的结果。我们需要的引理是：如果有n个平面满足所述条件，那么添加一个更多平面，该平面以描述的方式与原来的图形相交，将增加(n^² + n + 2) / 2个新区域。原因是这个新平面上由所有已存在平面与此平面的交线形成的图案具有(n^² + n + 2) / 2个区域（参见第5.1节练习62）；并且这些二维区域中的每一个都将通过它的三维区域分成两个三维区域。因此，本练习的归纳法证明归结为指出一个平面将空间分为(1^³ + 5 · 1 + 6) / 6 = 2个区域，并验证代数恒等式(n^³ + 5n + 6) / 6 + (n^² + n + 2) / 2 = ((n + 1)^³ + 5(n + 1) + 6) / 6。",
        "answer_symbols": [
            "=",
            "+",
            "·",
            "²",
            "³",
            "/",
            "(",
            ")"
        ]
    },
    "5 Supplementary Exercises 51": {
        "question": "用良序性证明：√2 是无理数。[提示：假定 √2 是有理数。证明形如 b√2 的正整数组成的集合有最小元素 a。然后证明 a√2-a 是具有这种形式的更小的正整数。]",
        "answer": "假设根号2是有理数。那么根号2 = a / b，其中 a 和 b 是正整数。由此可得集合 S = {n * 根号2 | n ∈ N} ∩ N 是一个非空的正整数集，因为 b * 根号2 = a 属于 S。设 t 是 S 中的最小元素，由良序性质知其存在。那么 t = s * 根号2 对于某个整数 s。我们有 t - s = s * 根号2 - s = s * (根号2 - 1)，所以 t - s 是一个正整数，因为根号2 > 1。因此，t - s 属于 S。这是矛盾的，因为 t - s = s * 根号2 - s < s。因此，根号2 是无理数",
        "answer_symbols": [
            "√",
            "/",
            "*",
            "+",
            "-",
            "=",
            "∩",
            "∈"
        ]
    },
    "5 Supplementary Exercises 52 a)": {
        "question": "若一个集合的每个非空子集合都有最小元素，则这个集合是良序性的。判断下面的每个集合是否良序性的.（a）整数集合",
        "answer": "这个集合不是良序的，因为集合本身没有最小元（负整数越来越小）。",
        "answer_symbols": []
    },
    "5 Supplementary Exercises 52 b)": {
        "question": "若一个集合的每个非空子集合都有最小元素，则这个集合是良序性的。判断下面的每个集合是否良序性的.（b）大于 -100 的整数的集合",
        "answer": "这个集合是良序的——部分(a)中存在的问题在这里不存在，因为整个集合的最小元是-99。每个子集也有最小元。",
        "answer_symbols": []
    },
    "5 Supplementary Exercises 52 c)": {
        "question": "若一个集合的每个非空子集合都有最小元素，则这个集合是良序性的。判断下面的每个集合是否良序性的.（c）正有理数集合",
        "answer": "这个集合不是良序的。例如，整个集合没有最小元，因为形式为1/n的数（n是正整数）越来越小。",
        "answer_symbols": [
            "/"
        ]
    },
    "5 Supplementary Exercises 52 d)": {
        "question": "若一个集合的每个非空子集合都有最小元素，则这个集合是良序性的。判断下面的每个集合是否良序性的.（d）分母小于 100 的正有理数的集合",
        "answer": "这个集合是良序的。情况类似于部分(b)。",
        "answer_symbols": []
    },
    "5 Supplementary Exercises 53 a)": {
        "question": "证明：若 a_1, a_2, …, a_n 都是正整数，则 gcd(a_1, a_2, …, a_(n-1), a_n) = gcd(a_1, a_2, …, a_(n-2), gcd(a_(n-1), a_n))",
        "answer": "设 d = gcd(a₁, a₂, ..., aₙ)。那么 d 是每个 aᵢ 的除数，因此必须是 gcd(aₙ₋₁, aₙ) 的除数。因此，d 是 a₁, a₂, ..., aₙ₋₂ 和 gcd(aₙ₋₁, aₙ) 的公因数。为了证明它是这些数的最大公因数，假设 c 是它们的公因数。那么 c 是 aᵢ (i = 1, 2, ..., n-2) 的除数，并且是 gcd(aₙ₋₁, aₙ) 的除数，因此它是 aₙ₋₁ 和 aₙ 的除数。因此，c 是 a₁, a₂, ..., aₙ₋₁, aₙ 的公因数。因此，c 是 d 的除数，即 a₁, a₂, ..., aₙ 的最大公因数",
        "answer_symbols": [
            "gcd",
            "∈",
            "|"
        ]
    },
    "5 Supplementary Exercises 53 b)": {
        "question": "利用 a) 和欧几里得算法得出一个计算 n 个正整数的最大公因子的递归算法.",
        "answer": "如果 n = 2，应用欧几里得算法。否则，对 aₙ₋₁ 和 aₙ 应用欧几里得算法，得到 d = gcd(aₙ₋₁, aₙ)，然后递归地对 a₁, a₂, ..., aₙ₋₂, d 应用该算法",
        "answer_symbols": [
            "gcd"
        ]
    },
    "5 Supplementary Exercises 54": {
        "question": "描述一个递归算法，把 n 个正整数的最大公因子表示成这些整数的线性组合.",
        "answer": "在第4.3节练习42的前言中，描述了一种算法，用于将两个正整数的最大公约数表示为这两个整数的线性组合（参见该节的定理6和例17）。我们可以使用该算法，结合练习53的结果，来解决这个问题。对于n = 1，没有什么可做的，因为a1 = a1，我们已经有一个n = 2的算法。对于n > 2，我们可以将gcd(a_{n-1}, a_n)表示为a_{n-1}和a_n的线性组合，比如说gcd(a_{n-1}, a_n) = c_{n-1} * a_{n-1} + c_n * a_n。",
        "answer_symbols": [
            "=",
            "+",
            "gcd",
            "*"
        ]
    },
    "5 Supplementary Exercises 55": {
        "question": "求出 f(n) 的显式公式，其中 f(1)=1 而且若 n ≥ 2 则 f(n) = f(n-1) + 2n-1。用数学归纳法证明你的结果.",
        "answer": "f(n) = n^²。设 P(n) 为 \"f(n) = n^²\"。基础步骤：P(1) 是真的，因为 f(1) = 1 = 1^²，这从 f 的定义中得出。归纳步骤：假设 f(n) = n^²。那么 f(n + 1) = f((n + 1) - 1) + 2(n + 1) - 1 = f(n) + 2n + 1 = n^² + 2n + 1 = (n + 1)^²",
        "answer_symbols": [
            "=",
            "²",
            "+",
            "-"
        ]
    },
    "5 Supplementary Exercises 56": {
        "question": "给出由所含有的 0 是 1 的两倍的位串所组成的集合的递归定义.",
        "answer": "下面的定义有效。空字符串属于该集合，并且如果 x 和 y 属于该集合，则 xy, 1x00, 00x1, 和 0x1y0 也属于该集合。一种理解方法是考虑为该集合中的字符串绘制 (0的数量) - 2 * (1的数量) 作为位置的函数的图形。此图必须从水平轴开始并结束于水平轴。如果它在轴上包含另一个点，则我们可以将字符串拆分为 xy，其中 x 和 y 都属于该集合。如果图形保持在轴上方，则字符串必须是 00x1 的形式；如果图形保持在轴下方，则字符串必须是 1x00 的形式。唯一其他的情况是图形在字符串中的1处穿过轴而不落在轴上。在这种情况下，字符串必须是 0x1y0 的形式。",
        "answer_symbols": [
            "-",
            "*",
            "=",
            "∈"
        ]
    },
    "5 Supplementary Exercises 57 a)": {
        "question": "设 S 是位串的集合，它递归地定义成：λ ∈ S，并且若 x ∈ S，则 0x ∈ S，x1 ∈ S，其中 λ 是空串.（a）求出 S 中所有长度不超过 5 的串.",
        "answer": "λ, 0, 1, 00, 01, 11, 000, 001, 011, 111, 0000, 0001, 0011, 0111, 1111, 00000, 00001, 00011, 00111, 01111, 11111",
        "answer_symbols": [
            "λ"
        ]
    },
    "5 Supplementary Exercises 57 b)": {
        "question": "设 S 是位串的集合，它递归地定义成：λ ∈ S，并且若 x ∈ S，则 0x ∈ S，x1 ∈ S，其中 λ 是空串.（b）给出对 S 中元素的显式描述.",
        "answer": "S = {αβ | α 是 m 个 0 的字符串，β 是 n 个 1 的字符串，m ≥ 0, n ≥ 0}",
        "answer_symbols": [
            "{",
            "}",
            "|",
            "≥"
        ]
    },
    "5 Supplementary Exercises 58 a)": {
        "question": "求出 S 中长度为 8 或更短的所有串。",
        "answer": "该集合包含三个长度为3的字符串，每个字符串使用第四到第七条规则可以生成四个更多长度为6的字符串，但存在一些重叠，实际上总共有13个字符串。这些字符串是：abc, bac, acb, abcabc, ababcc, aabcbc, abcbac, abbacc, abacbc, bacabc, abcacb, aacbbc, 和 acbabc。",
        "answer_symbols": []
    },
    "5 Supplementary Exercises 58 b)": {
        "question": "证明：S 中的每个元素都有能被 3 整除的长度。",
        "answer": "我们通过归纳法证明字符串的长度。基础步骤是显然成立的，因为集合中没有长度为0的字符串（无论如何这是显然的，因为0是3的倍数）。假设归纳假设对于较短的字符串是成立的，设 y 是集合 S 中的一个字符串。如果 y 通过前三条规则之一属于 S，则 y 的长度为3。如果 y 通过最后四条规则之一属于 S，则 y 的长度等于3加上 x 的长度。根据归纳假设，x 的长度是3的倍数，因此 y 的长度也是3的倍数。",
        "answer_symbols": [
            "+",
            "=",
            "∈"
        ]
    },
    "5 Supplementary Exercises 59": {
        "question": "证明：(()()) 是平衡的括号串而 (()) 不是平衡的括号串。",
        "answer": "将第一个递归步骤应用于 λ 得到 () ∈ B。将第二个递归步骤应用于这个字符串得到 ()() ∈ B。再将第一个递归步骤应用于这个字符串得到 (()()) ∈ B。由练习 62 可知，(())) 不在 B 中，因为左括号的数量不等于右括号的数量",
        "answer_symbols": [
            "∈",
            "(",
            ")"
        ]
    },
    "5 Supplementary Exercises 60": {
        "question": "求出所有恰好带 6 个符号的平衡的括号串。",
        "answer": "应用递归规则，我们得到以下列表：((())),(()()),()()(),()(()),(())()。",
        "answer_symbols": []
    },
    "5 Supplementary Exercises 61": {
        "question": "求出所有带 4 个或更少符号的平衡的括号串。",
        "answer": "λ, (), (()), ()()",
        "answer_symbols": [
            "λ",
            "(",
            ")"
        ]
    },
    "5 Supplementary Exercises 62": {
        "question": "用归纳法证明：若 x 是平衡的括号串，则在 x 左括号的个数等于右括号的个数。",
        "answer": "我们对括号平衡字符串 x 的长度使用归纳法。如果 x = λ，则陈述是正确的，因为 0 = 0。否则 x = (a) 或 x = ab，其中 a 和 b 是较短的括号平衡字符串。在第一种情况下，x 中每种类型的括号数量比 a 中对应数量多1，因此根据归纳假设，这些数量相等。在第二种情况下，x 中每种类型的括号数量是 a 和 b 中对应数量的和，因此根据归纳假设，这些数量相等。",
        "answer_symbols": [
            "=",
            "+",
            "∈"
        ]
    },
    "5 Supplementary Exercises 63 a)": {
        "question": "求 N(()())。",
        "answer": "0",
        "answer_symbols": []
    },
    "5 Supplementary Exercises 63 b)": {
        "question": "求 N(()(()()))。",
        "answer": "-2",
        "answer_symbols": [
            "-"
        ]
    },
    "5 Supplementary Exercises 63 c)": {
        "question": "求 N(((()(()))))。",
        "answer": "2",
        "answer_symbols": [
            "+"
        ]
    },
    "5 Supplementary Exercises 63 d)": {
        "question": "求 N(()(()(()(()))))。",
        "answer": "0",
        "answer_symbols": []
    },
    "5 Supplementary Exercises 64": {
        "question": "证明：括号串 w 是平衡的当且仅当 N(w) = 0，而且当 u 是 w 的前缀（即 w = uv）时，有 N(u) ≥ 0。",
        "answer": "我们通过归纳法证明平衡字符串 w 的“仅当”部分。如果 w = λ，则无需证明。如果 w = (x)，则根据归纳假设，N(x) = 0 并且如果 a 是 x 的前缀，则 N(a) ≥ 0。那么 N(w) = 1 + 0 + (-1) = 0；并且如果 b 是 w 的非空前缀，则 N(b) ≥ 1 ≥ 0，因为 b = (a。如果 w = xy，则根据归纳假设，N(x) = N(y) = 0；并且如果 a 是 x 或 y 的前缀，则 N(a) ≥ 0。那么 N(w) = 0 + 0 = 0；并且如果 b 是 w 的前缀，则 N(b) ≥ 0，因为 b 要么是 x 的前缀，要么是 xa，其中 a 是 y 的前缀。我们还通过归纳法证明 w 的“如果”部分。假设 w 满足条件。如果 w = λ，则 w ∈ B。否则 w 必须以括号开始，并且必须是一个左括号，否则长度为1的前缀会给出 N()) = -1。现在有两种情况：w = ab，其中 N(a) = N(b) = 0 且 a ≠ λ ≠ b，或者不是这样。如果是这样，则 a 和 b 是平衡字符串。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "≥",
            "∈"
        ]
    },
    "5 Supplementary Exercises 65": {
        "question": "给出一个求所有包含 n 个或更少符号的平衡的括号串的递归算法。",
        "answer": "过程 generate(n: 非负整数) 如果 n 是奇数，则 S := S(n - 1) {由 generate(n - 1) 构建的 S} T := T(n - 1) {由 generate(n - 1) 构建的 T} 否则如果 n = 0，则 S := ∅ T := {λ} 否则 S' := S(n - 2) {由 generate(n - 2) 构建的 S} T' := T(n - 2) {由 generate(n - 2) 构建的 T} T := T' ∪ {(x) | x ∈ T' ∪ S' 且 length(x) = n - 2} S := S' ∪ {xy | x ∈ T' 且 y ∈ T' ∪ S' 且 length(xy) = n} {T ∪ S 是长度不超过 n 的平衡字符串的集合}",
        "answer_symbols": [
            "{",
            "}",
            ":",
            "∪",
            "∈",
            "∧",
            "(",
            ")",
            "λ",
            "∅"
        ]
    },
    "5 Supplementary Exercises 67": {
        "question": "验证程序段 if x > y then x := y 相对于初始断言 T 和终结断言 x ≤ y 是正确的。",
        "answer": "如果 x ≤ y 初始时成立，则 x := y 不会执行，因此 x ≤ y 是一个真实的最终断言。如果 x > y 初始时成立，则 x := y 会被执行，因此 x ≤ y 再次成为一个真实的最终断言",
        "answer_symbols": [
            "≤",
            ">",
            ":="
        ]
    },
    "5 Supplementary Exercises 69": {
        "question": "设计求整数表中整数 0 出现次数的递归算法。",
        "answer": "过程 zerocount(a₁, a₂, ..., aₙ: 整数列表) 如果 n = 1，则 如果 a₁ = 0 则返回 1 否则返回 0 否则如果 aₙ = 0 则返回 zerocount(a₁, a₂, ..., aₙ₋₁) + 1 否则返回 zerocount(a₁, a₂, ..., aₙ₋₁)",
        "answer_symbols": [
            "{",
            "}",
            ":",
            "=",
            "+"
        ]
    },
    "5 Supplementary Exercises 71": {
        "question": "证明：这个序列是良定义的。即证明对所有非负整数 n 来说，a(n) 是唯一定义的。",
        "answer": "我们将证明 a(n) 是自然数且 a(n) ≤ n。对于基例 n = 0，a(0) = 0 成立。现在假设 a(n-1) 是自然数且 a(n-1) ≤ n-1。那么 a(a(n-1)) 是应用于小于或等于 n - 1 的自然数的 a。因此，a(a(n-1)) 也是一个小于或等于 n - 1 的自然数。因此，n - a(a(n-1)) 是 n 减去一个小于或等于 n - 1 的自然数，即一个小于或等于 n 的自然数",
        "answer_symbols": [
            "-",
            "≤",
            "−",
            "("
        ]
    },
    "5 Supplementary Exercises 74 a)": {
        "question": "求出下面每个自生成序列的前 10 项。对 n ≥ 1 来说，a(n) = n - a(a(a(n - 1)))，且 a(0) = 0。",
        "answer": "a(0) = 0\na(1) = 1 - a(a(a(0))) = 1 - a(a(0)) = 1 - a(0) = 1 - 0 = 1\na(2) = 2 - a(a(a(1))) = 2 - a(a(1)) = 2 - a(1) = 2 - 1 = 1\na(3) = 3 - a(a(a(2))) = 3 - a(a(1)) = 3 - a(1) = 3 - 1 = 2\na(4) = 4 - a(a(a(3))) = 4 - a(a(2)) = 4 - a(1) = 4 - 1 = 3\na(5) = 5 - a(a(a(4))) = 5 - a(a(3)) = 5 - a(2) = 5 - 1 = 4\na(6) = 6 - a(a(a(5))) = 6 - a(a(4)) = 6 - a(3) = 6 - 2 = 4\na(7) = 7 - a(a(a(6))) = 7 - a(a(4)) = 7 - a(3) = 7 - 2 = 5\na(8) = 8 - a(a(a(7))) = 8 - a(a(5)) = 8 - a(4) = 8 - 3 = 5\na(9) = 9 - a(a(a(8))) = 9 - a(a(5)) = 9 - a(4) = 9 - 3 = 6",
        "answer_symbols": [
            "=",
            "-",
            "(",
            ")",
            "+"
        ]
    },
    "5 Supplementary Exercises 74 b)": {
        "question": "求出下面每个自生成序列的前 10 项。对 n ≥ 1 来说，a(n) = n - a(a(a(a(n - 1))))，且 a(0) = 0。",
        "answer": "a(0) = 0\na(1) = 1 - a(a(a(a(0)))) = 1 - a(a(a(0))) = 1 - a(a(0)) = 1 - a(0) = 1 - 0 = 1\na(2) = 2 - a(a(a(a(1)))) = 2 - a(a(a(1))) = 2 - a(a(1)) = 2 - a(1) = 2 - 1 = 1\na(3) = 3 - a(a(a(a(2)))) = 3 - a(a(a(1))) = 3 - a(a(1)) = 3 - a(1) = 3 - 1 = 2\na(4) = 4 - a(a(a(a(3)))) = 4 - a(a(a(2))) = 4 - a(a(1)) = 4 - a(1) = 4 - 1 = 3\na(5) = 5 - a(a(a(a(4)))) = 5 - a(a(a(3))) = 5 - a(a(2)) = 5 - a(1) = 5 - 1 = 4\na(6) = 6 - a(a(a(a(5)))) = 6 - a(a(a(4))) = 6 - a(a(3)) = 6 - a(2) = 6 - 1 = 5\na(7) = 7 - a(a(a(a(6)))) = 7 - a(a(a(5))) = 7 - a(a(4)) = 7 - a(3) = 7 - 2 = 5\na(8) = 8 - a(a(a(a(7)))) = 8 - a(a(a(5))) = 8 - a(a(4)) = 8 - a(3) = 8 - 2 = 6\na(9) = 9 - a(a(a(a(8)))) = 9 - a(a(a(6))) = 9 - a(a(5)) = 9 - a(4) = 9 - 3 = 6",
        "answer_symbols": [
            "=",
            "-",
            "(",
            ")",
            "+"
        ]
    },
    "5 Supplementary Exercises 74 c)": {
        "question": "求出下面每个自生成序列的前 10 项。对 n ≥ 3 来说，a(n) = a(n - a(n - 1)) + a(n - a(n - 2))，且 a(1) = 1 和 a(2) = 1。",
        "answer": "We apply the definition:\na(1) = 1\na(2) = 1\na(3) = a(3 − a(2)) + a(3 − a(1)) = a(3 − 1) + a(3 − 1) = a(2) + a(2) = 1 + 1 = 2\na(4) = a(4 − a(3)) + a(4 − a(2)) = a(4 − 2) + a(4 − 1) = a(2) + a(3) = 1 + 2 = 3\na(5) = a(5 − a(4)) + a(5 − a(3)) = a(5 − 3) + a(5 − 2) = a(2) + a(3) = 1 + 2 = 3\na(6) = a(6 − a(5)) + a(6 − a(4)) = a(6 − 3) + a(6 − 3) = a(3) + a(3) = 2 + 2 = 4\na(7) = a(7 − a(6)) + a(7 − a(5)) = a(7 − 4) + a(7 − 3) = a(3) + a(4) = 2 + 3 = 5\na(8) = a(8 − a(7)) + a(8 − a(6)) = a(8 − 5) + a(8 − 4) = a(3) + a(4) = 2 + 3 = 5\na(9) = a(9 − a(8)) + a(9 − a(7)) = a(9 − 5) + a(9 − 5) = a(4) + a(4) = 3 + 3 = 6\na(10) = a(10 − a(9)) + a(10 − a(8)) = a(10 − 6) + a(10 − 5) = a(4) + a(5) = 3 + 3 = 6",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "(",
            ")",
            "a"
        ]
    },
    "5 Supplementary Exercises 76": {
        "question": "求出哥伦布的自生成序列的前 20 项。",
        "answer": "The first term a1 tells how many 1’s there are. If a1 ≥ 2, then the sequence would not be nondecreasing, since a 1 would follow this 2. Therefore a1 = 1. This tells us that there is one 1, so the next term must be at least 2. By the same reasoning as before, a2 can’t be 3 or larger, so a2 = 2. This tells us that there are two 2’s, and they must all come together since the sequence is nondecreasing. So a3 = 2 as well. But now we know that there are two 3’s, and of course they must come next. We continue in this way and obtain the first 20 terms: 1, 2, 2, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8",
        "answer_symbols": [
            "=",
            ",",
            "≥"
        ]
    },
    "6.1 2": {
        "question": "一个办公大楼有 27 层，每层有 37 个办公室，那么在这个大楼里有多少个办公室？",
        "answer": "According to the multiplication rule, there are 27 × 37 = 999 offices.",
        "answer_symbols": [
            "×",
            "="
        ]
    },
    "6.1 4": {
        "question": "某种商标的衬衫有 12 种颜色，有男式和女式 2 种样式，每种样式有 3 种大小型号。这些衬衫有多少种不同的类型？",
        "answer": "According to the multiplication rule, there are 12 × 2 × 3 = 72 different types of shirts.",
        "answer_symbols": [
            "×",
            "="
        ]
    },
    "6.1 6": {
        "question": "从波士顿到底特律有 4 条汽车主干线，而从底特律到洛杉矶有 6 条。那么从波士顿经底特律到洛杉矶的汽车主干线有多少条？",
        "answer": "According to the multiplication rule, there are 4 × 6 = 24 routes.",
        "answer_symbols": [
            "×",
            "="
        ]
    },
    "6.1 8": {
        "question": "如果这 3 个字母不允许重复，人们可以有多少种不同的选择？",
        "answer": "The first letter has 26 choices, the second letter has 25 choices (no repetition), and the third letter has 24 choices. Therefore, according to the multiplication rule, the answer is 26 × 25 × 24 = 15,600.",
        "answer_symbols": [
            "×",
            "="
        ]
    },
    "6.1 10": {
        "question": "8 位位串有多少个？",
        "answer": "Each binary digit has two choices, so there are 2^8 = 256 binary strings.",
        "answer_symbols": [
            "^",
            "="
        ]
    },
    "6.1 12": {
        "question": "位数不超过 6 的位串有多少个？",
        "answer": "We use the addition rule, adding the number of binary strings of each length up to 6. If we include the empty string, we get 2^0 + 2^1 + 2^2 + 2^3 + 2^4 + 2^5 + 2^6 = 2^7 - 1 = 127 (using the sum formula for geometric series—see Theorem 1 in Section 2.4).",
        "answer_symbols": [
            "^",
            "+",
            "-",
            "="
        ]
    },
    "6.1 14": {
        "question": "首、尾都是 1 的 n 位位串有多少个？这里的 n 是正整数。",
        "answer": "If n = 0, then the empty string (vacuously) satisfies the condition (or not, depending on interpretation). If n = 1, then there is only one, which is the string 1. If n ≥ 2, then such strings are determined by the n - 2 positions between the first and last digits, so there are 2^(n-2) such strings.",
        "answer_symbols": [
            "=",
            "≥",
            "^",
            "-"
        ]
    },
    "6.1 16": {
        "question": "由 4 个小写字母构成且含有字母 x 的串有多少个？",
        "answer": "We can subtract the number of 4-character lowercase letter strings without x from the total number of 4-character lowercase letter strings. Therefore, the answer is 26^4 - 25^4 = 66,351.",
        "answer_symbols": [
            "^",
            "-",
            "="
        ]
    },
    "6.1 18 a)": {
        "question": "有多少 5 元素 DNA 序列由 A 结束？",
        "answer": "If the sequence must end with A, then only four positions are available, so the answer is 4^4 = 256.",
        "answer_symbols": [
            "^",
            "="
        ]
    },
    "6.1 18 b)": {
        "question": "有多少 5 元素 DNA 序列开始于 T 并结束于 G？",
        "answer": "If the sequence must start with T and end with G, then only three positions are available, so the answer is 4^3 = 64.",
        "answer_symbols": [
            "^",
            "="
        ]
    },
    "6.1 18 c)": {
        "question": "有多少 5 元素 DNA 序列只包含 A 和 T？",
        "answer": "If only two letters instead of four can be used, the number of choices is 2^5 = 32.",
        "answer_symbols": [
            "^",
            "="
        ]
    },
    "6.1 18 d)": {
        "question": "有多少 5 元素 DNA 序列不包含 C？",
        "answer": "Similarly to part (c), there are 3^5 = 243 sequences that do not contain C.",
        "answer_symbols": [
            "^",
            "="
        ]
    },
    "6.1 20 a)": {
        "question": "在 5 到 31 之间有多少个正整数能被 3 整除？这些整数是什么？",
        "answer": "There are ⌊31/3⌋ = 10 integers less than 31 and divisible by 3, of which ⌊5/3⌋ = 1 is less than 5. This leaves 10 - 1 = 9 integers between 5 and 31 that are divisible by 3. They are 6, 9, 12, 15, 18, 21, 24, 27, and 30.",
        "answer_symbols": [
            "⌋",
            ",",
            "=",
            "⌊",
            "/",
            "-"
        ]
    },
    "6.1 20 b)": {
        "question": "在 5 到 31 之间有多少个正整数能被 4 整除？这些整数是什么？",
        "answer": "There are ⌊31/4⌋ = 7 integers less than 31 that are divisible by 4, and ⌊5/4⌋ = 1 of them is less than 5 as well. This leaves 7 − 1 = 6 numbers between 5 and 31 that are divisible by 4. They are 8, 12, 16, 20, 24, and 28.",
        "answer_symbols": [
            "⌊",
            "⌋",
            "/",
            "=",
            "-",
            ","
        ]
    },
    "6.1 20 c)": {
        "question": "在 5 到 31 之间有多少个正整数能被 3 和 4 同时整除？这些整数是什么？",
        "answer": "A number is divisible by both 3 and 4 if and only if it is divisible by their least common multiple, which is 12. Obviously there are two such numbers between 5 and 31, namely 12 and 24. We could also work this out as we did in the previous parts: ⌊31/12⌋ − ⌊5/12⌋ = 2 − 0 = 2. Note also that the intersection of the sets we found in the previous two parts is precisely what we are looking for here.",
        "answer_symbols": [
            "⌊",
            "⌋",
            "/",
            "-",
            "=",
            ","
        ]
    },
    "6.1 22 a)": {
        "question": "有多少个小于 1000 的正整数被 7 整除？",
        "answer": "Every seventh number is divisible by 7. Therefore there are ⌊999/7⌋ = 142 such numbers. Note that we use the floor function, because the kth multiple of 7 does not occur until the number 7k has been reached.",
        "answer_symbols": [
            "⌊",
            "⌋",
            "/",
            "=",
            "k"
        ]
    },
    "6.1 22 b)": {
        "question": "有多少个小于 1000 的正整数被 7 整除但不被 11 整除？",
        "answer": "For solving this part and the next four parts, we need to use the principle of inclusion–exclusion. Just as in part (a), there are ⌊999/11⌋ = 90 numbers in our range divisible by 11, and there are ⌊999/77⌋ = 12 numbers in our range divisible by both 7 and 11 (the multiples of 77 are the numbers we seek). If we take these 12 numbers away from the 142 numbers divisible by 7, we see that there are 130 numbers in our range divisible by 7 but not 11.",
        "answer_symbols": [
            "⌊",
            "⌋",
            "/",
            "=",
            "-",
            "("
        ]
    },
    "6.1 22 c)": {
        "question": "有多少个小于 1000 的正整数同时被 7 和 11 整除？",
        "answer": "As explained in part (b), the answer is 12.",
        "answer_symbols": []
    },
    "6.1 22 d)": {
        "question": "有多少个小于 1000 的正整数被 7 或 11 整除？",
        "answer": "By the principle of inclusion–exclusion, the answer, using the data from part (b), is 142 + 90 − 12 = 220.",
        "answer_symbols": [
            "+",
            "-",
            "="
        ]
    },
    "6.1 22 e)": {
        "question": "有多少个小于 1000 的正整数恰好被 7 或 11 中的一个数整除？",
        "answer": "If we subtract from the answer to part (d) the number of numbers divisible by both 7 and 11, we will have the number of numbers divisible by neither of them; so the answer is 220 − 12 = 208.",
        "answer_symbols": [
            "−",
            "="
        ]
    },
    "6.1 22 f)": {
        "question": "有多少个小于 1000 的正整数既不被 7 整除，也不被 11 整除？",
        "answer": "If we subtract the answer to part (d) from the total number of positive integers less than 1000, we will have the number of numbers divisible by exactly one of them; so the answer is 999 − 220 = 779.",
        "answer_symbols": [
            "−",
            "="
        ]
    },
    "6.1 22 g)": {
        "question": "有多少个小于 1000 的正整数含有不同的数字？",
        "answer": "If we assume that numbers are written without leading 0’s, then we should break the problem down into three cases—one-digit numbers, two-digit numbers, and three-digit numbers. Clearly there are 9 one-digit numbers, and each of them has distinct digits. There are 90 two-digit numbers (10 through 99), and all but 9 of them have distinct digits, so there are 81 two-digit numbers with distinct digits. An alternative way to compute this is to note that the first digit must be 1 through 9 (9 choices), and the second digit must be something different from the first digit (9 choices out of the 10 possible digits), so by the product rule, we get 9 · 9 = 81 choices in all. This approach also tells us that there are 9 · 9 · 8 = 648 three-digit numbers with distinct digits (again, work from left to right—in the ones place, only 8 digits are left to choose from). So the final answer is 9 + 81 + 648 = 738.",
        "answer_symbols": [
            "·",
            "+",
            "=",
            "(",
            ")"
        ]
    },
    "6.1 22 h)": {
        "question": "有多少个小于 1000 的正整数含有不同的数字且是偶数？",
        "answer": "It turns out to be easier to count the odd numbers with distinct digits and subtract from our answer to part (g), so let us proceed that way. There are 5 odd one-digit numbers. For two-digit numbers, first choose the ones digit (5 choices), then choose the tens digit (8 choices), since neither the ones digit value nor 0 is available; therefore there are 40 such two-digit numbers. (Note that this is not exactly half of 81.) For the three-digit numbers, first choose the ones digit (5 choices), then the hundreds digit (8 choices), then the tens digit (8 choices), giving us 320 in all. So there are 5 + 40 + 320 = 365 odd numbers with distinct digits. Thus the final answer is 738 − 365 = 373.",
        "answer_symbols": [
            "·",
            "+",
            "=",
            "(",
            ")"
        ]
    },
    "6.1 24 a)": {
        "question": "在 1000 到 9999 之间包含多少个正整数被 9 整除？",
        "answer": "Every ninth number is divisible by 9, so the answer is one ninth of 9000 or 1000.",
        "answer_symbols": [
            "/"
        ]
    },
    "6.1 24 b)": {
        "question": "在 1000 到 9999 之间包含多少个正整数是偶数？",
        "answer": "Every other number is even, so the answer is one half of 9000 or 4500.",
        "answer_symbols": [
            "/"
        ]
    },
    "6.1 24 c)": {
        "question": "在 1000 到 9999 之间包含多少个正整数有不同的十进制数字？",
        "answer": "We can reason from left to right. There are 9 choices for the first (left-most) digit (since it cannot be a 0), then 9 choices for the second digit (since it cannot equal the first digit), then, in a similar way, 8 choices for the third digit, and 7 choices for the right-most digit. Therefore there are 9 · 9 · 8 · 7 = 4536 ways to specify such a number. In other words, there are 4536 such numbers. Note that this coincidentally turns out to be almost exactly half of the numbers in the range.",
        "answer_symbols": [
            "·",
            "=",
            "(",
            ")"
        ]
    },
    "6.1 24 d)": {
        "question": "在 1000 到 9999 之间包含多少个正整数不被 3 整除？",
        "answer": "Every third number is divisible by 3, so one third of 9000 or 3000 numbers in this range are divisible by 3. The remaining 6000 are not.",
        "answer_symbols": [
            "/"
        ]
    },
    "6.1 24 e)": {
        "question": "在 1000 到 9999 之间包含多少个正整数被 5 或 7 整除?",
        "answer": "For this part and the next three parts, we first need to notice that, in this range of numbers, one fifth or 1800 can be divided by 5, and one seventh or 1286 can be divided by 7. We also need to know how many of these numbers can be divided by both 5 and 7, which means they can be divided by 35. By similar reasoning, the answer is 257, from 29 * 35 = 1015 to 285 * 35 = 9975. Now to the problem at hand. The number of numbers that can be divided by 5 or 7 is the sum of the number of numbers that can be divided by 5 and the number of numbers that can be divided by 7, minus (because of double counting) the number of numbers that can be divided by both 5 and 7. Therefore, our answer is 1800 + 1286 - 257 = 2829.",
        "answer_symbols": [
            "+",
            "-",
            "*",
            "="
        ]
    },
    "6.1 24 f)": {
        "question": "在 1000 到 9999 之间包含多少个正整数不被 5 也不被 7 整除?",
        "answer": "Because we just found that 2829 numbers can be divided by 5 or 7, the remaining 9000 - 2829 = 6171 numbers cannot be divided by 5 or 7.",
        "answer_symbols": [
            "-",
            "="
        ]
    },
    "6.1 24 g)": {
        "question": "在 1000 到 9999 之间包含多少个正整数被 5 整除但不被 7 整除?",
        "answer": "We mentioned in solving part (e) that 1800 numbers can be divided by 5, of which 257 can also be divided by 7. Therefore, in our range, there are 1800 - 257 = 1543 numbers that can be divided by 5 but not by 7.",
        "answer_symbols": [
            "-",
            "="
        ]
    },
    "6.1 24 h)": {
        "question": "在 1000 到 9999 之间包含多少个正整数被 5 和 7 整除?",
        "answer": "We already found this answer in part (e), which is 257.",
        "answer_symbols": []
    },
    "6.1 26 a)": {
        "question": "有多少个串含有 4 个十进制数字且同一数字不出现两次?",
        "answer": "There are 10 ways to choose the first digit, 9 ways to choose the second digit, and so on; therefore, the answer is 10 * 9 * 8 * 7 = 5040.",
        "answer_symbols": [
            "*",
            "="
        ]
    },
    "6.1 26 b)": {
        "question": "有多少个串含有 4 个十进制数字且以偶数字结束?",
        "answer": "There are 10 ways to choose each of the first three digits and 5 ways to choose the last digit; therefore, the answer is 10^3 * 5 = 5000.",
        "answer_symbols": [
            "^",
            "*",
            "="
        ]
    },
    "6.1 26 c)": {
        "question": "有多少个串含有 4 个十进制数字且恰有 3 个数字是 9?",
        "answer": "There are four positions and four letters, each used exactly once. There are 4 choices for the first position, then 3 for the second, 2 for the third, and 1 for the fourth. Therefore the answer is 4 * 3 * 2 * 1 = 24.",
        "answer_symbols": [
            "=",
            "*"
        ]
    },
    "6.1 28": {
        "question": "用 3 个数字后跟 3 个字母或者 3 个字母后跟 3 个数字可构成多少种车牌?",
        "answer": "10^3263 + 263103 = 35,152,000",
        "answer_symbols": [
            "^",
            "+",
            "="
        ]
    },
    "6.1 30": {
        "question": "用 3 个字母后跟 3 个数字或者 4 个字母后跟 2 个数字可构成多少种车牌?",
        "answer": "263103 + 264102 = 63,273,600",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "6.1 32 a)": {
        "question": "由 8 个英语字母可构成多少个串? 如果字母可以重复",
        "answer": "According to the multiplication rule, the answer is 26^8 = 208,827,064,576.",
        "answer_symbols": [
            "^",
            "="
        ]
    },
    "6.1 32 b)": {
        "question": "由 8 个英语字母可构成多少个串? 如果字母不能重复",
        "answer": "According to the multiplication rule, the answer is 26 * 25 * 24 * 23 * 22 * 21 * 20 * 19 = 62,990,928,000.",
        "answer_symbols": [
            "*",
            "="
        ]
    },
    "6.1 32 c)": {
        "question": "由 8 个英语字母可构成多少个串? 如果字母可以重复且以 X 开始",
        "answer": "This is the same as part (a), except that only seven positions need to be filled, so the answer is 26^7 = 8,031,810,176.",
        "answer_symbols": [
            "^",
            "="
        ]
    },
    "6.1 32 d)": {
        "question": "由 8 个英语字母可构成多少个串? 如果字母不能重复且以 X 开始",
        "answer": "This is similar to part (b), except that the first position has only one choice instead of 26, so the answer is 1 * 25 * 24 * 23 * 22 * 21 * 20 * 19 = 2,422,728,000.",
        "answer_symbols": [
            "*",
            "="
        ]
    },
    "6.1 32 e)": {
        "question": "由 8 个英语字母可构成多少个串? 如果字母可以重复且以 X 开始和结束",
        "answer": "This is the same as part (c), except that only six positions need to be filled, so the answer is 26^6 = 308,915,776.",
        "answer_symbols": [
            "^",
            "="
        ]
    },
    "6.1 32 f)": {
        "question": "由 8 个英语字母可构成多少个串? 如果字母可以重复且以 BO(按此顺序) 开始",
        "answer": "This is the same as part (e); again, only six positions need to be filled, so the answer is 26^6 = 308,915,776.",
        "answer_symbols": [
            "^",
            "="
        ]
    },
    "6.1 32 g)": {
        "question": "由 8 个英语字母可构成多少个串? 如果字母可以重复且以 BO(按此顺序) 开始和结束",
        "answer": "This is the same as part (f), except that only four positions need to be filled, so the answer is 26^4 = 456,976.",
        "answer_symbols": [
            "^",
            "="
        ]
    },
    "6.1 32 h)": {
        "question": "由 8 个英语字母可构成多少个串? 如果字母可以重复且以 BO(按此顺序) 开始或结束",
        "answer": "According to part (f), there are 26^6 strings starting with BO. Similarly, there are 26^6 strings ending this way. According to part (g), there are 26^4 strings that start and end this way. Therefore, according to the inclusion-exclusion principle, the answer is 26^6 + 26^6 - 26^4 = 617,374,576.",
        "answer_symbols": [
            "^",
            "+",
            "-",
            "="
        ]
    },
    "6.1 34 a)": {
        "question": "从 10 元素集合到含有下述元素数的集合有多少个不同的函数? 2",
        "answer": "2^10 = 1024",
        "answer_symbols": [
            "^",
            "="
        ]
    },
    "6.1 34 b)": {
        "question": "从 10 元素集合到含有下述元素数的集合有多少个不同的函数? 3",
        "answer": "3^10 = 59,049",
        "answer_symbols": [
            "^",
            "="
        ]
    },
    "6.1 34 c)": {
        "question": "从 10 元素集合到含有下述元素数的集合有多少个不同的函数? 4",
        "answer": "4^10 = 1,048,576",
        "answer_symbols": [
            "^",
            "="
        ]
    },
    "6.1 34 d)": {
        "question": "从 10 元素集合到含有下述元素数的集合有多少个不同的函数? 5",
        "answer": "5^10 = 9,765,625",
        "answer_symbols": [
            "=",
            "^"
        ]
    },
    "6.1 36": {
        "question": "从集合 {1, 2, …, n} 到集合 {0, 1} 有多少个函数? 这里的 n 是正整数。",
        "answer": "There are 2^n such functions, since there is a choice of 2 function values for each element of the domain.",
        "answer_symbols": [
            "^"
        ]
    },
    "6.1 38 a)": {
        "question": "从 5 元素集合到含有下述元素数的集合有多少个部分函数? 1",
        "answer": "2^5 = 32",
        "answer_symbols": [
            "^"
        ]
    },
    "6.1 38 b)": {
        "question": "从 5 元素集合到含有下述元素数的集合有多少个部分函数? 2",
        "answer": "3^5 = 243",
        "answer_symbols": [
            "^"
        ]
    },
    "6.1 38 c)": {
        "question": "从 5 元素集合到含有下述元素数的集合有多少个部分函数? 5",
        "answer": "6^5 = 7776",
        "answer_symbols": [
            "^"
        ]
    },
    "6.1 38 d)": {
        "question": "从 5 元素集合到含有下述元素数的集合有多少个部分函数? 9",
        "answer": "10^5 = 100,000",
        "answer_symbols": [
            "^"
        ]
    },
    "6.1 40": {
        "question": "100 个元素的集合有多少个子集的元素数多于 1?",
        "answer": "We know that there are 2^100 subsets in all. Clearly 101 of them do not have more than one element, namely the empty set and the 100 sets consisting of 1 element. Therefore the answer is 2^100 − 101 ≈ 1.3 × 10^30.",
        "answer_symbols": [
            "^",
            "−",
            "×"
        ]
    },
    "6.1 42 a)": {
        "question": "有多少 4 元素 DNA 序列不包含碱基 T?",
        "answer": "If the letter T cannot be used, then the number of choices is 3^4 = 81.",
        "answer_symbols": [
            "^"
        ]
    },
    "6.1 42 b)": {
        "question": "有多少 4 元素 DNA 序列包含序列 ACG?",
        "answer": "The sequence must be either ACGx or xACG, where x is one of the four letters. These two cases do not overlap, so the answer is 4 + 4 = 8.",
        "answer_symbols": [
            "+"
        ]
    },
    "6.1 42 c)": {
        "question": "有多少 4 元素 DNA 序列包含所有 4 种碱基 A、T、C 和 G?",
        "answer": "There are four positions and four letters, each used exactly once. There are 4 choices for the first position, then 3 for the second, 2 for the third, and 1 for the fourth. Therefore the answer is 4 * 3 * 2 * 1 = 24.",
        "answer_symbols": [
            "+"
        ]
    },
    "6.1 42 d)": {
        "question": "有多少 4 元素 DNA 序列只包含 4 种碱基 A、T、C 和 G 中的 3 种碱基?",
        "answer": "There are four ways to choose which letter is to be occur twice and three ways to decide which of the other letters to leave out, so there are 4 * 3 = 12 choices of the letters for the sequence. There are 4 positions the first (alphabetically) of the single-use letters can occupy, and then 3 positions for the second single-use letter, a total of 4 * 3 = 12 different sequences once we have determined the letters and their frequencies. Therefore the answer is 12 * 12 = 144.",
        "answer_symbols": [
            "*",
            "="
        ]
    },
    "6.1 44": {
        "question": "一组 10 个人选取 4 人坐在 4 人的圆桌旁边，一共有多少种坐法? 当每个人左右邻座都相同时算为同一种坐法。",
        "answer": "If we ignore the fact that the table is round and just count ordered arrangements of length 4 from the 10 people, then we get 10 * 9 * 8 * 7 = 5040 arrangements. However, we can rotate the people around the table in 4 ways and get the same seating arrangement, so this overcounts by a factor of 4. (For example, the sequence Mary–Debra–Cristina–Julie gives the same circular seating as the sequence Julie–Mary–Debra–Cristina.) Therefore the answer is 5040 / 4 = 1260.",
        "answer_symbols": [
            "*",
            "=",
            "/"
        ]
    },
    "6.2 1": {
        "question": "证明：在任意 5 个整数中（不一定是连续的）有 2 个整数被 4 除的余数相等。",
        "answer": "因为有六节课，但只有五个工作日，鸽巢原理表明至少有两节课必须在同一天进行。",
        "answer_symbols": []
    },
    "6.2 2": {
        "question": "设 d 是正整数，证明：在任意一组 d + 1 个整数中（不一定是连续的）有 2 个整数被 d 除的余数相等。",
        "answer": "这是抽屉原理的应用，k = 26。",
        "answer_symbols": []
    },
    "6.2 3 a)": {
        "question": "抽屉里有一打棕色的短袜和一打黑色的短袜，全都没有配好对。一个人在黑暗中随机取出一些袜子。a) 必须取多少只袜子才能保证至少有 2 只袜子是同色的？",
        "answer": "3",
        "answer_symbols": []
    },
    "6.2 3 b)": {
        "question": "抽屉里有一打棕色的短袜和一打黑色的短袜，全都没有配好对。一个人在黑暗中随机取出一些袜子。b) 必须取多少只袜子才能保证至少有 2 只袜子是黑色的？",
        "answer": "14",
        "answer_symbols": []
    },
    "6.2 4 a)": {
        "question": "一个碗里有 10 个红球和 10 个蓝球。一个女士不看着球而随机地选取。a) 她必须选多少个球才能保证至少有 3 个球是同色的？",
        "answer": "有两种颜色：这些是抽屉。我们想知道确保至少有一个抽屉里有三个球所需的最少数量。根据广义抽屉原理，答案是 5。如果选择了五个球，则至少 5/2 向上取整 = 3 必须具有相同的颜色。另一方面，四个球是不够的，因为两个可能是红色，两个可能是蓝色。请注意，球的数量是无关紧要的（假设至少为 5）。",
        "answer_symbols": [
            "/",
            "=",
            ">"
        ]
    },
    "6.2 4 b)": {
        "question": "一个碗里有 10 个红球和 10 个蓝球。一个女士不看着球而随机地选取。b) 她必须选多少个球才能保证至少有 3 个球是蓝色的？",
        "answer": "她需要选择 13 个球以确保至少有三个蓝色的。如果她这样做，那么最多 10 个是红色的，所以至少有三个是蓝色的。另一方面，如果她选择 12 个或更少的球，那么 10 个可能是红色的，她可能得不到她的三个蓝色球。这次球的数量确实很重要。",
        "answer_symbols": [
            "<",
            ">"
        ]
    },
    "6.2 5": {
        "question": "在一个大学里每个学生来自 50 个州中的一个州，那么必须有多少个学生注册才能保证至少有 100 个学生来自同一个州？",
        "answer": "因为当整数被 4 除时有四种可能的余数，鸽巢原理表明给定五个整数，至少有两个具有相同的余数。",
        "answer_symbols": [
            "÷"
        ]
    },
    "6.2 6": {
        "question": "设 (x_i, y_i) (i = 1, 2, 3, 4, 5) 是 xy 平面上一组具有整数坐标的 5 个不同的点。证明：至少有一对点的连线中点的坐标是整数。",
        "answer": "当一个整数除以 d 时，只有 d 种可能的余数，即 0, 1, ..., d - 1。根据抽屉原理，如果我们有 d + 1 个余数，那么至少有两个必须相同。",
        "answer_symbols": [
            "+",
            "-",
            "="
        ]
    },
    "6.2 7": {
        "question": "设 (x_i, y_i, z_i) (i = 1, 2, 3, 4, 5, 6, 7, 8, 9) 是 xyz 空间中一组具有整数坐标的 9 个不同的点。证明：至少有一对点的连线中点的坐标是整数。",
        "answer": "令 a, a + 1, ..., a + n - 1 是序列中的整数。整数 (a + i) 模 n，i = 0, 1, 2, ..., n - 1，是不同的，因为 0 < (a + j) - (a + k) < n 无论何时 0 ≤ k < j ≤ n - 1。因为 (a + i) 模 n 有 n 种可能的值，而集合中有 n 个不同的整数，所以每个值恰好出现一次。因此，序列中恰好有一个整数能被 n 整除。",
        "answer_symbols": [
            "+",
            "-",
            "<",
            "≤",
            ">",
            "÷"
        ]
    },
    "6.2 8": {
        "question": "至少需要多少个有序对 (a, b) 才能保证存在两个有序对 (a₁, b₁) 和 (a₂, b₂)，使得 a₁ mod 5 = a₂ mod 5 并且 b₁ mod 5 = b₂ mod 5 。",
        "answer": "这只是抽屉原理的另一种表述，k = |T|。",
        "answer_symbols": [
            "|"
        ]
    },
    "6.2 9": {
        "question": "在一个大学里每个学生来自 50 个州中的一个州，那么必须有多少个学生注册才能保证至少有 100 个学生来自同一个州？",
        "answer": "4951",
        "answer_symbols": []
    },
    "6.2 10": {
        "question": "设 (x_i, y_i) (i = 1, 2, 3, 4, 5) 是 xy 平面上一组具有整数坐标的 5 个不同的点。证明：至少有一对点的连线中点的坐标是整数。",
        "answer": "线段端点为 (a, b) 和 (c, d) 的中点是 ((a + c) / 2, (b + d) / 2)。我们只关心原始坐标的整数值。显然，当且仅当 a 和 c 具有相同的奇偶性（都是奇数或都是偶数），并且 b 和 d 具有相同的奇偶性时，这些分数的坐标才会是整数。因此，在这个问题中重要的是坐标的奇偶性。有四种可能的奇偶性对：(奇数, 奇数)，(奇数, 偶数)，(偶数, 奇数)，和 (偶数, 偶数)。因为我们给出了五个点，抽屉原理保证至少有两个点具有相同的奇偶性对。连接这两个点的线段的中点因此将具有整数坐标。",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "/",
            ","
        ]
    },
    "6.2 11": {
        "question": "从集合 {1, 2, 3, 4, 5, 6} 中必须选多少个数才能保证其中至少有一对数之和等于 7？",
        "answer": "连接点 (a, b, c) 和 (d, e, f) 的线段的中点是 ((a + d) / 2, (b + e) / 2, (c + f) / 2)。它具有整数坐标当且仅当 a 和 d 具有相同的奇偶性，b 和 e 具有相同的奇偶性，c 和 f 具有相同的奇偶性。因为有八种可能的奇偶性组合（例如（偶数，奇数，偶数）），根据鸽巢原理，九个点中至少有两个具有相同的奇偶性组合。连接这样两个点的线段的中点具有整数坐标。",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "/",
            "≤",
            "≥"
        ]
    },
    "6.2 13 a)": {
        "question": "如果从前 8 个正整数中选 5 个整数一定存在一对整数其和等于 9。",
        "answer": "将前八个正整数分为四个子集，每个子集包含两个整数，使得每个子集中的整数相加等于 9：{1, 8}, {2, 7}, {3, 6}, 和 {4, 5}。如果从前八个正整数中选择五个整数，根据鸽巢原理，至少有两个来自同一个子集。这样的两个整数之和为 9，如预期。",
        "answer_symbols": [
            "{",
            "}",
            ",",
            "+",
            "="
        ]
    },
    "6.2 13 b)": {
        "question": "如果不是选 5 个而是选 4 个整数，a) 的结论还为真吗？",
        "answer": "不行。取 {1, 2, 3, 4} 为例。",
        "answer_symbols": [
            "{",
            "}"
        ]
    },
    "6.2 14 a)": {
        "question": "设一个小学班的离散数学班有 9 个学生，证明：这个班一定至少有 5 个男生，或者至少有 5 个女生。",
        "answer": "如果不是这样，那么将有 4 个或更少的男生和 4 个或更少的女生，因此总共有 4 + 4 = 8 个或更少的学生，这与班级中有 9 名学生的假设矛盾。",
        "answer_symbols": [
            "+",
            "<=",
            "="
        ]
    },
    "6.2 14 b)": {
        "question": "设一个小学班的离散数学班有 9 个学生，证明：这个班一定至少有 3 个男生，或者至少有 7 个女生。",
        "answer": "如果不是这样，那么将有 2 个或更少的男生和 6 个或更少的女生，因此总共有 2 + 6 = 8 个或更少的学生，这与班级中有 9 名学生的假设矛盾。",
        "answer_symbols": [
            "+",
            "<=",
            "="
        ]
    },
    "6.2 15": {
        "question": "从集合 {1, 2, 3, 4, 5, 6} 中必须选多少个数才能保证其中至少有一对数之和等于 7？",
        "answer": "4",
        "answer_symbols": []
    },
    "6.2 16": {
        "question": "在序列 22, 5, 7, 2, 23, 10, 15, 21, 3, 17 中找出一个最长的递增子序列和一个最长的递减子序列。",
        "answer": "我们可以通过巧妙地将数字分组成对（子集），使每对的和为 16，即 {1, 15}，{3, 13}，{5, 11}，和 {7, 9}。如果我们从集合 {1, 3, 5, 7, 9, 11, 13, 15} 中选择五个数，那么至少有两个数必须属于同一子集，因为只有四个子集。同一子集中的两个数就是所求的和为 16 的一对。我们还需要指出，选择四个数是不够的，因为我们可以选择 {1, 3, 5, 7}，其中没有一对数的和超过 12。",
        "answer_symbols": [
            "{",
            "}",
            "+",
            ","
        ]
    },
    "6.2 17": {
        "question": "构造 16 个正整数的序列，使得它没有 5 项的递增或递减子序列。",
        "answer": "21,251",
        "answer_symbols": []
    },
    "6.2 18 a)": {
        "question": "设一个小学班的离散数学班有 9 个学生，a) 证明：这个班一定至少有 5 个男生，或者至少有 5 个女生。",
        "answer": "如果不是这样，那么将有 4 个或更少的男生和 4 个或更少的女生，因此总共有 4 + 4 = 8 个或更少的学生，这与班级中有 9 名学生的假设矛盾。",
        "answer_symbols": []
    },
    "6.2 18 b)": {
        "question": "设一个小学班的离散数学班有 9 个学生，b) 证明：这个班一定至少有 3 个男生，或者至少有 7 个女生。",
        "answer": "如果不是这样，那么将有 2 个或更少的男生和 6 个或更少的女生，因此总共有 2 + 6 = 8 个或更少的学生，这与班级中有 9 名学生的假设矛盾。",
        "answer_symbols": []
    },
    "6.2 19 a)": {
        "question": "在 25 个学生的离散数学班中，学生有一年级的、二年级的或者三年级的。a) 证明：这个班至少有 9 个是一年级的，或至少有 9 个是二年级的，或至少有 9 个是三年级的。",
        "answer": "如果班上少于 9 名大一学生、少于 9 名大二学生和少于 9 名大三学生，则每种年级的学生人数都不会超过 8 人，总共最多 24 名学生，这与班上有 25 名学生的事实矛盾。",
        "answer_symbols": [
            "<",
            ">"
        ]
    },
    "6.2 19 b)": {
        "question": "在 25 个学生的离散数学班中，学生有一年级的、二年级的或者三年级的。b) 证明：这个班至少有 3 个是一年级的，或至少有 19 个是二年级的，或至少有 5 个是三年级的。",
        "answer": "如果班上少于 3 名大一学生、少于 19 名大二学生和少于 5 名大三学生，则最多 2 名大一学生、最多 18 名大二学生和最多 4 名大三学生，总共最多 24 名学生。这与班上有 25 名学生的事实矛盾。",
        "answer_symbols": [
            "<",
            ">"
        ]
    },
    "6.2 21": {
        "question": "用伪码描述一个算法产生一个不同整数序列的最大递增或递减子序列。",
        "answer": "4, 3, 2, 1, 8, 7, 6, 5, 12, 11, 10, 9, 16, 15, 14, 13",
        "answer_symbols": [
            ","
        ]
    },
    "6.2 23": {
        "question": "证明：在任一组 10 个人中（其中任两个人或者是朋友或者是敌人）存在 3 个人彼此都是朋友，或存在 4 个人彼此都是敌人；并且存在 3 个人彼此都是敌人，或存在 4 个人彼此都是朋友。",
        "answer": "对桌子周围的座位从 1 到 50 编号，并认为座位 50 与座位 1 相邻。有 25 个奇数编号的座位和 25 个偶数编号的座位。如果不超过 12 个男孩占据奇数编号的座位，则至少有 13 个男孩占据偶数编号的座位，反之亦然。不失一般性，假设至少有 13 个男孩占据 25 个奇数编号的座位。那么至少有两个男孩必须坐在连续的奇数编号的座位上，坐在他们之间的人将有两个男孩作为邻居。",
        "answer_symbols": [
            "=",
            "<",
            ">"
        ]
    },
    "6.2 25": {
        "question": "证明：如果 n 是正整数， n ≥ 2 ，那么拉姆齐数 R(2, n) 等于 n 。",
        "answer": "过程 long(a₁, ..., aₙ: 正整数) {首先找到最长的递增子序列} max := 0; set := 00... 00 {n 位} for i := 1 to 2^ⁿ last := 0; count := 0, OK := true for j := 1 to n if set(j) = 1 then if aⱼ > last then last := aⱼ count := count + 1 else OK := false if count > max then max := count best := set set := set + 1 {二进制加法} {max 是长度，best 表示序列} {对递减子序列重复，唯一的改变是用 aⱼ < last 代替 aⱼ > last 并且用 last := ∞ 代替 last := 0}",
        "answer_symbols": [
            "{",
            "}",
            ":",
            "=",
            ">",
            "<",
            "+",
            "∞"
        ]
    },
    "6.2 27": {
        "question": "证明：在加利福尼亚州（人口 3600 万）至少有 6 个人姓名的 3 个缩写字母相同并且他们生在一年的同一天（但不一定是同一年）。",
        "answer": "通过对称性，我们只需要证明第一个陈述。设 A 是其中一个人。要么 A 至少有四个朋友，要么 A 至少有六个敌人（因为 3 + 5 < 9）。假设在第一种情况下，B, C, D, 和 E 都是 A 的朋友。如果这些朋友中有任何两个是朋友，那么我们就找到了三个互为朋友的人。否则 {B, C, D, E} 是四个互为敌人的集合。在第二种情况下，设 {B, C, D, E, F, G} 是 A 的敌人集合。根据例 11，在 B, C, D, E, F, 和 G 中，要么有三个互为朋友的人，要么有三个互为敌人的人，他们与 A 形成四个互为敌人的集合。",
        "answer_symbols": [
            "{",
            "}",
            "+",
            "<"
        ]
    },
    "6.2 29": {
        "question": "在 17 世纪，巴黎人口超过 800 000。那时，认为人的头发不会超过 200 000 根。设这些数据都是正确的，而且每一个人头上至少有一根头发（没有人完全没有头发）。使用鸽巢原理证明，如法国作家皮埃尔尼科尔所做的，有两个巴黎人有相同数量的头发。使用广义鸽巢原理证明至少有 5 个巴黎人有相同数量的头发。",
        "answer": "我们需要证明两件事：如果有一组 n 个人，那么在他们中我们必须找到一对朋友或一组 n 个人，他们都是彼此的敌人；并且存在一组 n - 1 个人，这不可能。对于第一个陈述，如果有任何一对朋友，那么条件就满足了，如果没有，那么每对人都互相是敌人，所以第二个条件也满足。对于第二个陈述，如果我们有一组 n - 1 个人，他们都是彼此的敌人，那么既没有一对朋友，也没有一组 n 个人都是彼此的敌人。",
        "answer_symbols": [
            "−"
        ]
    },
    "6.2 31": {
        "question": "一个大学有 38 个不同的时间段来安排课程，如果有 677 门不同的课程，那么需要多少个不同的教室？",
        "answer": "有 6,432,816 种可能的三个首字母和生日的组合。因此，根据广义鸽巢原理，至少有 37,000,000 / 6,432,816 = 6 人共享相同的首字母和生日。",
        "answer_symbols": [
            "/"
        ]
    },
    "6.2 33": {
        "question": "一个计算机网络由 6 台计算机组成。每台计算机直接连接到零台或者更多台其他计算机。证明：网络中至少有两台计算机直接连接相同数目的其他计算机。",
        "answer": "因为 800,001 > 200,000，鸽巢原理保证至少有两个巴黎人头上的头发数量相同。广义鸽巢原理保证至少有 800,001 / 200,000 = 5 个巴黎人头上的头发数量相同。",
        "answer_symbols": [
            ">",
            "/",
            "="
        ]
    },
    "6.2 37": {
        "question": "一个摔跤选手是 75 小时之内的冠军。该选手一小时至少赛一场，但总共不超过 125 场。证明：存在着连续的若干个小时使得该选手恰好进行了 24 场比赛。",
        "answer": "如果某台计算机没有连接到其他任何计算机，则没有计算机连接到所有五个其他计算机；如果某台计算机连接到所有五个其他计算机，则没有计算机没有连接到其他任何计算机。因此，根据抽屉原理，因为在六台计算机中每台计算机连接的计算机数量最多有五种可能性，所以至少有两台计算机连接到相同数量的其他计算机。",
        "answer_symbols": []
    },
    "6.2 39": {
        "question": "如果 f 是从 S 到 T 的函数，其中 S 和 T 是有穷集，并且 m = |S| / |T| ，那么证明至少存在 S 的 m 个元素映射到 T 的同一个值。即存在 S 中的元素 s₁, s₂, ⋯, sₘ 使得 f(s₁) = f(s₂) = ⋯ = f(sₘ) 。",
        "answer": "将计算机标记为C1至C100，将打印机标记为P1至P20。如果我们连接Ck到Pk（k = 1, 2, ..., 20）并且连接每台从C21到C100的计算机到所有打印机，那么我们总共使用了20 + 80 * 20 = 1620条电缆。显然这是足够的，因为如果计算机C1到C20需要打印机，那么它们可以使用具有相同下标的打印机，如果任何具有更高下标的计算机需要打印机而不是这些中的一个或多个，那么它们可以使用未被使用的打印机，因为它们连接到了所有的打印机。现在我们必须证明1619条电缆是不够的。因为有1619条电缆和20台打印机，每台打印机平均连接的计算机数量为1619 / 20，这少于81。因此，有些打印机必须连接到少于81台计算机。这意味着它连接到80台或更少的计算机，所以有20台计算机没有连接到它。如果这20台计算机同时需要打印机，那么它们就倒霉了，因为它们最多只能连接到其他19台打印机。",
        "answer_symbols": [
            "+",
            "*",
            "/",
            "<"
        ]
    },
    "6.2 40": {
        "question": "一条街道上有 51 所房子，每所房子的地址在 1000 到 1099 之间（包括 1000 与 1099）。证明：至少有 2 所房子的地址是连续的。",
        "answer": "设K(x)为聚会中认识x的人数。K(x)的可能值为0, 1,..., n - 1，其中n >= 2是聚会上的人数。我们不能直接应用鸽巢原理，因为有n个鸽子和n个鸽巢。然而，0和n - 1不可能同时出现在K的范围内，因为如果一个人认识所有其他人，那么没有人可以不认识任何人（假设“认识”是对称的）。因此，K的范围最多有n - 1个元素，而域有n个元素，所以K不是一对一的，这正是我们想要证明的。",
        "answer_symbols": [
            "=",
            "<=",
            ">",
            "-",
            "(",
            ")",
            "∈"
        ]
    },
    "6.2 41": {
        "question": "设 x 是无理数。证明：对于某个不超过 n 的正整数 j ，在 jx 与 jx 最近的整数之间的差的绝对值小于 1/n 。",
        "answer": "让a_i表示第i小时完成的比赛场次。则1 ≤ a_1 < a_2 < ... < a_75 ≤ 125。同样25 ≤ a_1 + 24 < a_2 + 24 < ... < a_75 + 24 ≤ 149。有150个数字a_1, ..., a_75, a_1 + 24, ..., a_75 + 24。根据抽屉原理，至少有两个数字相等。因为所有的a_i都是不同的，所有的(a_i + 24)也都是不同的，所以存在某个i > j使得a_i = a_j + 24。因此，在第(j + 1)到第i小时期间，恰好有24场比赛。",
        "answer_symbols": [
            "≤",
            "<",
            "+",
            "="
        ]
    },
    "6.3 1": {
        "question": "列出 (a, b, c) 的所有排列。",
        "answer": "abc, acb, bac, bca, cab, cba",
        "answer_symbols": []
    },
    "6.3 2": {
        "question": "集合 (a, b, c, d, e, f, g) 有多少个排列？",
        "answer": "P(7, 7) = 7! = 5040",
        "answer_symbols": [
            "!",
            "="
        ]
    },
    "6.3 3": {
        "question": "集合 (a, b, c, d, e, f, g) 有多少个排列以 a 结尾？",
        "answer": "720",
        "answer_symbols": []
    },
    "6.3 6 a)": {
        "question": "求出 C(5, 1)。",
        "answer": "C(5, 1) = 5",
        "answer_symbols": [
            "="
        ]
    },
    "6.3 6 b)": {
        "question": "求出 C(5, 3)。",
        "answer": "C(5, 3) = C(5, 2) = 5 · 4 / 2 = 10",
        "answer_symbols": [
            "=",
            "·",
            "/"
        ]
    },
    "6.3 6 c)": {
        "question": "求出 C(8, 4)。",
        "answer": "C(8, 4) = 8 · 7 · 6 · 5 / (4 · 3 · 2) = 70",
        "answer_symbols": [
            "=",
            "·",
            "/"
        ]
    },
    "6.3 6 d)": {
        "question": "求出 C(8, 8)。",
        "answer": "C(8, 8) = 1",
        "answer_symbols": [
            "="
        ]
    },
    "6.3 6 e)": {
        "question": "求出 C(8, 0)。",
        "answer": "C(8, 0) = 1",
        "answer_symbols": [
            "="
        ]
    },
    "6.3 6 f)": {
        "question": "求出 C(12, 6)。",
        "answer": "C(12, 6) = 12 · 11 · 10 · 9 · 8 · 7 / (6 · 5 · 4 · 3 · 2) = 924",
        "answer_symbols": [
            "=",
            "·",
            "/"
        ]
    },
    "6.3 7": {
        "question": "求出 9 元素集合的 5 排列数。",
        "answer": "15,120",
        "answer_symbols": []
    },
    "6.3 8": {
        "question": "如果不允许并列名次，在结束比赛时 5 个赛跑运动员有多少种不同的排名次序？",
        "answer": "P(5, 5) = 5! = 120",
        "answer_symbols": [
            "!",
            "="
        ]
    },
    "6.3 9": {
        "question": "在一场 12 匹马的赛马中，如果所有的比赛结果都是可能的，对于第一名、第二名和第三名有多少种可能性？",
        "answer": "1320",
        "answer_symbols": []
    },
    "6.3 10": {
        "question": "有 6 个不同的人竞选州长。有多少种不同的次序在选票上打印竞选者的名字？",
        "answer": "P(6, 6) = 6! = 720",
        "answer_symbols": [
            "!",
            "="
        ]
    },
    "6.3 12 a)": {
        "question": "多少个 12 位串包含恰好 3 个 1？",
        "answer": "要指定一个长度为12且恰好包含三个1的位字符串，我们只需要选择包含1的位置。有C(12, 3) = 220种方法。",
        "answer_symbols": [
            "="
        ]
    },
    "6.3 12 b)": {
        "question": "多少个 12 位串包含至多 3 个 1？",
        "answer": "包含最多三个1意味着包含三个1、两个1、一个1或没有1。根据部分(a)的推理，我们看到有C(12, 3) + C(12, 2) + C(12, 1) + C(12, 0) = 220 + 66 + 12 + 1 = 299个这样的字符串。",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "6.3 12 c)": {
        "question": "多少个 12 位串包含至少 3 个 1？",
        "answer": "包含至少三个1意味着包含三个1、四个1、五个1、六个1、七个1、八个1、九个1、十个1、十一个1或十二个1。我们可以像部分(b)那样推理，但会有太多的数字相加。一种更简单的方法是计算不包含至少三个1（即包含两个1、一个1或没有1）的方法数，然后从2^12（长度为12的所有位字符串的总数）中减去这个数。这样我们得到4096 - (66 + 12 + 1) = 4017。",
        "answer_symbols": [
            "+",
            "-",
            "^"
        ]
    },
    "6.3 12 d)": {
        "question": "多少个 12 位串包含 0 的个数和 1 的个数相等？",
        "answer": "在这种情况下，包含相同数量的0和1意味着包含六个1。因此答案是C(12, 6) = 924。",
        "answer_symbols": [
            "="
        ]
    },
    "6.3 13": {
        "question": "一个组有 n 个男士和 n 个女士。如果把他们男女相间地排成一排，有多少种方式？",
        "answer": "2(n!)^²",
        "answer_symbols": [
            "!",
            "^"
        ]
    },
    "6.3 14": {
        "question": "有多少种不同的方式选择两个小于 100 的正整数？",
        "answer": "C(99, 2) = 99 · 98 / 2 = 4851",
        "answer_symbols": [
            "=",
            "·",
            "/"
        ]
    },
    "6.3 15": {
        "question": "有多少种不同的方式从英语字母表中选择 5 个字母？",
        "answer": "65,780",
        "answer_symbols": []
    },
    "6.3 16": {
        "question": "一个 10 元素集合有多少个子集含有奇数个元素？",
        "answer": "我们需要计算C(10, 1) + C(10, 3) + C(10, 5) + C(10, 7) + C(10, 9) = 10 + 120 + 252 + 120 + 10 = 512。 （在下一节中我们将看到，奇数元素的子集数量与偶数元素的子集数量相同（第6.4节练习31）。由于总共有2^10 = 1024个子集，答案是1024 / 2 = 512，与我们的计算结果一致。）",
        "answer_symbols": [
            "+",
            "=",
            "^",
            "/"
        ]
    },
    "6.3 17": {
        "question": "一个 100 元素的集合有多少个子集含有的元素多于 2 个？",
        "answer": "2100 - 5051",
        "answer_symbols": [
            "-"
        ]
    },
    "6.3 18 a)": {
        "question": "一个硬币被掷 8 次，每次可能出现头像或者非头像。有多少种可能的结果包含各种不同的情况？",
        "answer": "每次翻转可以是正面或反面，所以有2^8 = 256种可能的结果。",
        "answer_symbols": [
            "^",
            "="
        ]
    },
    "6.3 18 b)": {
        "question": "一个硬币被掷 8 次，每次可能出现头像或者非头像。有多少种可能的结果包含恰好 3 个头像？",
        "answer": "要指定一个恰好包含三个正面的结果，我们只需要选择三次翻出正面的次数。有C(8, 3) = 56种这样的结果。",
        "answer_symbols": [
            "="
        ]
    },
    "6.3 18 c)": {
        "question": "一个硬币被掷 8 次，每次可能出现头像或者非头像。有多少种可能的结果包含至少 3 个头像？",
        "answer": "包含至少三个正面意味着包含三个正面、四个正面、五个正面、六个正面、七个正面或八个正面。根据部分(b)的推理，我们看到有C(8, 3) + C(8, 4) + C(8, 5) + C(8, 6) + C(8, 7) + C(8, 8) = 56 + 70 + 56 + 28 + 8 + 1 = 219种这样的结果。我们也可以从256中减去两次或更少正面的数量，即28 + 8 + 1 = 37。因为256 - 37 = 219，使用这种方法我们也得到了相同的答案。",
        "answer_symbols": [
            "+",
            "-",
            "="
        ]
    },
    "6.3 18 d)": {
        "question": "一个硬币被掷 8 次，每次可能出现头像或者非头像。有多少种可能的结果头像和非头像的数目相等？",
        "answer": "在这种情况下，包含相同数量的正面和反面意味着包含四个正面。因此答案是C(8, 4) = 70。",
        "answer_symbols": [
            "="
        ]
    },
    "6.3 20 a)": {
        "question": "多少个 10 位串恰好有 3 个 0？",
        "answer": "选择0的位置有C(10, 3)种方式，这是唯一的选择，所以答案是C(10, 3) = 120。",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "6.3 20 b)": {
        "question": "多少个 10 位串 0 比 1 多？",
        "answer": "如果1的数量少于五个，则0的数量多于1的数量。使用与部分(a)相同的推理，加上总和规则，我们得到答案C(10, 0) + C(10, 1) + C(10, 2) + C(10, 3) + C(10, 4) = 1 + 10 + 45 + 120 + 210 = 386。或者，通过对称性，所有不包含五个0的情况中有一半具有更多的0而不是1；因此答案是 (1024 - C(10, 5))/2 = (1024 - 252)/2 = 386。",
        "answer_symbols": [
            "(",
            ")",
            "+",
            ",",
            "-",
            "/"
        ]
    },
    "6.3 20 c)": {
        "question": "多少个 10 位串至少有 7 个 1？",
        "answer": "我们想要计算具有7、8、9或10个1的位串的数量。通过上述相同的推理，存在C(10, 7) + C(10, 8) + C(10, 9) + C(10, 10) = 120 + 45 + 10 + 1 = 176这样的字符串。",
        "answer_symbols": [
            "(",
            ")",
            "+",
            ","
        ]
    },
    "6.3 20 d)": {
        "question": "多少个 10 位串至少有 3 个 1？",
        "answer": "如果一个字符串没有至少三个1，那么它有0、1或2个1。存在C(10, 0) + C(10, 1) + C(10, 2) = 1 + 10 + 45 = 56这样的字符串。总共有2^10 = 1024个字符串。因此，有1024 - 56 = 968个字符串具有至少三个1。",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "^",
            "-",
            ","
        ]
    },
    "6.3 22 a)": {
        "question": "字母 ABCDEFGH 有多少个排列包含串 ED？",
        "answer": "如果ED是一个子串，那么我们可以将这一组字母视为一个超级字母，问题是计算七个项目的排列——字母A、B、C、F、G和H，以及超级字母ED。因此答案是P(7, 7) = 7! = 5040。",
        "answer_symbols": [
            "(",
            ")",
            "!",
            ","
        ]
    },
    "6.3 22 b)": {
        "question": "字母 ABCDEFGH 有多少个排列包含串 CDE？",
        "answer": "通过与部分(a)相同的推理，我们看到答案是P(6, 6) = 6! = 720。",
        "answer_symbols": [
            "(",
            ")",
            "!",
            ","
        ]
    },
    "6.3 22 c)": {
        "question": "字母 ABCDEFGH 有多少个排列包含串 BA 和 FGH？",
        "answer": "与部分(a)一样，我们将BA粘合成一个项目，将FGH粘合成一个项目。因此我们需要排列五个项目，有P(5, 5) = 5! = 120种方法。",
        "answer_symbols": [
            "(",
            ")",
            "!",
            ","
        ]
    },
    "6.3 22 d)": {
        "question": "字母 ABCDEFGH 有多少个排列包含串 AB、DE 和 GH？",
        "answer": "这类似于部分(c)。将AB粘合成一个项目，将DE粘合成一个项目，将GH粘合成一个项目，产生五个项目，所以答案是P(5, 5) = 5! = 120。",
        "answer_symbols": [
            "(",
            ")",
            "!",
            ","
        ]
    },
    "6.3 22 e)": {
        "question": "字母 ABCDEFGH 有多少个排列包含串 CAB 和 BED？",
        "answer": "如果CAB和BED都是子串，那么CABED必须是一个子串。所以我们实际上是在排列四个项目：CABED、F、G和H。因此答案是P(4, 4) = 4! = 24。",
        "answer_symbols": [
            "(",
            ")",
            "!",
            ","
        ]
    },
    "6.3 22 f)": {
        "question": "字母 ABCDEFGH 有多少个排列包含串 BCA 和 ABF？",
        "answer": "由于B不能同时跟在C和F之后，所以不存在同时包含这两个子串的排列。",
        "answer_symbols": []
    },
    "6.3 23": {
        "question": "有多少种方式使得 8 个男士和 5 个女士站成一排并且没有两个女士彼此相邻？[提示：先排男士，然后考虑女士可能的位置。]",
        "answer": "609,638,400",
        "answer_symbols": []
    },
    "6.3 24": {
        "question": "有多少种方式使得 10 个女士和 6 个男士站成一排并且没有两个男士彼此相邻？[提示：先排女士，然后考虑男士可能的位置。]",
        "answer": "首先确定女性之间的相对位置。由于有10名女性，有P(10, 10)种方法来完成这项任务。这会创建11个槽位，其中可以站一名男性（但每个槽位不超过一名男性）：在第一名女性前面、在第一和第二名女性之间、...、在第九和第十名女性之间，以及在最后一名女性后面。我们需要选择六个这样的位置，按顺序为第一名到第六名男性占据（顺序很重要，因为男性是不同的人）。这可以通过P(11, 6)种方法完成。因此答案是P(10, 10) * P(11, 6) = 10! * 11!/5! = 1,207,084,032,000。",
        "answer_symbols": [
            "(",
            ")",
            "*",
            "!",
            ","
        ]
    },
    "6.3 26 a)": {
        "question": "一个垒球队的 13 个人出席一场比赛。有多少种方式选 10 个选手上场？",
        "answer": "这只是从13人中选择10名球员的问题，因为我们被告知不必担心他们所担任的职位；因此答案是C(13, 10) = 286。",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "6.3 26 b)": {
        "question": "一个垒球队的 13 个人出席一场比赛。有多少种方式从 13 个在场的人中分配 10 个选手的位置？",
        "answer": "这与部分(a)相同，但需要考虑选择的顺序，因为有10个不同的职位要填补。因此答案是P(13, 10) = 13!/3! = 1,037,836,800。",
        "answer_symbols": [
            "(",
            ")",
            "!",
            ","
        ]
    },
    "6.3 26 c)": {
        "question": "一个垒球队的 13 个人出席一场比赛。13 个出席的人中有 3 个女士。如果上场的选手中要求至少有一个女士，那么有多少种方式选择 10 个选手？",
        "answer": "没有选择女性的方法只有一种，因为恰好有10名男性。因此（使用部分(a)），如果至少必须选择一名女性，则有286 - 1 = 285种选择球员的方法。",
        "answer_symbols": [
            "-",
            ","
        ]
    },
    "6.3 28": {
        "question": "一个教授写了 40 道离散数学的真假判定题。在这些题中有 17 个语句为真。如果可以按照任意次序排列这些题，可能有多少种不同的答案？",
        "answer": "我们只是被要求计算长度为40且恰好有17个T的T和F字符串的数量。唯一的选择是哪17个位置有T，所以答案是C(40, 17) ≈ 8.9 × 10^10。",
        "answer_symbols": [
            "(",
            ")",
            "×",
            "^",
            ","
        ]
    },
    "6.3 30 a)": {
        "question": "一所学校的数学系有 7 名女教师和 9 名男教师。有多少种方式从中选出 5 人的委员会并使其中包含至少 1 名女教师？",
        "answer": "如果没有限制条件，选择委员会的方法有C(16, 5)种。仅从9名男性中选择委员会的方法有C(9, 5)种。因此有C(16, 5) - C(9, 5) = 4368 - 126 = 4242个委员会至少有一名女性。",
        "answer_symbols": [
            ",",
            "=",
            ")",
            "(",
            "-"
        ]
    },
    "6.3 30 b)": {
        "question": "一所学校的数学系有 7 名女教师和 9 名男教师。有多少种方式从中选出 5 人的委员会并使其中包含至少 1 名女教师和至少 1 名男教师？",
        "answer": "如果没有限制条件，选择委员会的方法有C(16, 5)种。仅从9名男性中选择委员会的方法有C(9, 5)种。仅从7名男性中选择委员会的方法有C(7, 5)种。这些当两种可能性不重叠时，因为没有方法选择一个既不含男性也不含女性的委员会。因此，有 C(16, 5) - C(9, 5) - C(7, 5) = 4368 - 126 - 21 = 4221 个委员会至少包含一名女性和一名男性。",
        "answer_symbols": [
            ",",
            "=",
            ")",
            "(",
            "-"
        ]
    },
    "6.3 32 a)": {
        "question": "由英语字母表中的 6 个小写字母可构成多少字符串使得它们包含字母 a?",
        "answer": "唯一合理的方法是从无限制的字符串数量中减去不包含字母a的字符串数量。答案是 26^6 - 25^6 = 308915776 - 244140625 = 64,775,151。",
        "answer_symbols": [
            "^",
            "-",
            "=",
            ","
        ]
    },
    "6.3 32 b)": {
        "question": "由英语字母表中的 6 个小写字母可构成多少字符串使得它们包含字母 a 和 b?",
        "answer": "如果我们的字符串需要同时包含这两个字母，那么我们需要从总字符串数量中减去未能包含这些字母之一（或两者）的字符串数量。像a部分一样，25^6 个字符串不包含a；同样地，25^6 不包含b。然而，这是过度计数，因为 24^6 个字符串不包含这两个字母。因此，有 25^6 + 25^6 - 24^6 个字符串未能包含至少其中一个字母。因此，答案是 26^6 - (25^6 + 25^6 - 24^6) = 308915776 - (244140625 + 244140625 - 191102976) = 11,737,502。",
        "answer_symbols": [
            "^",
            "+",
            "-",
            "(",
            ")",
            "=",
            ","
        ]
    },
    "6.3 32 c)": {
        "question": "由英语字母表中的 6 个小写字母可构成多少字符串使得它们包含字母 a 和 b，其中 a 在 b 前边的邻接位置，同时所有的字母都不相同？",
        "answer": "首先选择a的位置；这可以以5种方式完成，因为b必须跟在它后面。剩下四个位置，这些位置可以用 P(24, 4) 种方式填充，因为剩下24个字母（不允许重复）。因此，答案是 5P(24, 4) = 1,275,120。",
        "answer_symbols": [
            "(",
            ")",
            ",",
            "P",
            "=",
            ","
        ]
    },
    "6.3 32 d)": {
        "question": "由英语字母表中的 6 个小写字母可构成多少字符串使得它们包含字母 a 和 b，其中 a 在 b 左边的某个位置，同时所有的字母都不相同？",
        "answer": "首先选择a和b的位置；这可以以 C(6, 2) 种方式完成，因为我们一旦选择了两个位置，就在最左边放置a，在另一个位置放置b。剩下四个位置，这些位置可以用 P(24, 4) 种方式填充，因为剩下24个字母（不允许重复）。因此，答案是 C(6, 2)P(24, 4) = 3,825,360。",
        "answer_symbols": [
            "(",
            ")",
            ",",
            "C",
            "P",
            "=",
            ","
        ]
    },
    "6.3 33": {
        "question": "假定某个系包含 10 名男士和 15 名女士。有多少种方式组成一个 6 人委员会且使得它含有相同数量的男士和女士？",
        "answer": "54,600",
        "answer_symbols": []
    },
    "6.3 34": {
        "question": "假定某个系包含 10 名男士和 15 名女士。有多少种方式组成一个 6 人委员会且使得它含有的女士比男士多？",
        "answer": "最好的方法可能是按性别将其分为三种情况。只有女性组成的委员会有 C(15, 6) 种选择方式，如果委员会由五名女性和一名男性组成，则有 C(15, 5)C(10, 1) 种选择方式，如果委员会由四名女性和两名男性组成，则有 C(15, 4)C(10, 2) 种选择方式。因此，答案是 C(15, 6) + C(15, 5)C(10, 1) + C(15, 4)C(10, 2) = 5005 + 30030 + 61425 = 96,460。",
        "answer_symbols": [
            "(",
            ")",
            ",",
            "C",
            "+",
            "=",
            ","
        ]
    },
    "6.3 35": {
        "question": "有多少个位串恰好包含 8 个 0 和 10 个 1，如果每个 0 后面紧跟着 1 个 1?",
        "answer": "45",
        "answer_symbols": []
    },
    "6.3 36": {
        "question": "有多少个位串恰好包含 5 个 0 和 14 个 1，如果每个 0 后面紧跟着 2 个 1?",
        "answer": "将每个0右侧粘贴两个1，这样我们得到一个由九个元素组成的集合：五个011和四个1。问题是这些元素组成的字符串的数量。所涉及的只是在字符串中的九个位置中选择1的位置，所以答案是 C(9, 4) = 126。",
        "answer_symbols": [
            "(",
            ")",
            ",",
            "C",
            "=",
            ","
        ]
    },
    "6.3 37": {
        "question": "有多少个 10 位位串包含至少 3 个 1 和至少 3 个 0?",
        "answer": "912",
        "answer_symbols": []
    },
    "6.3 38": {
        "question": "有多少种方式从联合国中选择 12 个国家成为理事国且使得 3 个选自 45 个国家的一组，4 个选自 57 个国家的一组，其他的选自剩下的 69 个国家？",
        "answer": "C(45, 3) * C(57, 4) * C(69, 5) = 14190 * 395010 * 11238513 ≈ 6.3 × 10^16。",
        "answer_symbols": [
            "(",
            ")",
            ",",
            "C",
            "*",
            "≈",
            "^",
            "×"
        ]
    },
    "6.3 39": {
        "question": "有多少种方式用 3 个字母后跟 3 个数字组成汽车牌照且没有字母和数字出现 2 次？",
        "answer": "11,232,000",
        "answer_symbols": []
    },
    "6.3 40": {
        "question": "计算5个人的3圆排列。",
        "answer": "根据练习41给出的推理，答案是 5! / (3 * (5 - 3)!) = 20。",
        "answer_symbols": [
            "!",
            "/",
            "(",
            ")",
            "*",
            "-",
            "=",
            ","
        ]
    },
    "6.3 41": {
        "question": "找到n个人的r圆排列公式。",
        "answer": "n! / (r(n - r)!)",
        "answer_symbols": [
            "!",
            "/",
            "(",
            ")",
            "-"
        ]
    },
    "6.3 42": {
        "question": "找到n个人取r人围坐圆桌的安排方式，当每个人有相同邻座不考虑左右时只算一种方式。",
        "answer": "这个问题与练习41解决的问题唯一的不同是一个2的因子。根据这里的规则，每种坐法对应于原始规则下的两种坐法，因为我们可以改变桌子周围人的顺序，从顺时针变为逆时针。因此，我们需要将那里的公式除以2，得到 n! / (2r(n - r)!)。这假设 r ≥ 3。如果 r = 1，则问题很简单（在两套规则下都有n种选择）。如果 r = 2，我们不会引入额外的2的因子，因为顺时针顺序和逆时针顺序是相同的。在这种情况下，两个答案都是 n! / (2(n - 2)!)，即 C(n, 2)，正如预期的那样。",
        "answer_symbols": [
            "!",
            "/",
            "(",
            ")",
            "*",
            "≥",
            "=",
            ","
        ]
    },
    "6.3 43": {
        "question": "如果允许出现并列名次，3匹马参加马赛有多少种结果？注意：可以2匹或3匹马并列。",
        "answer": "13",
        "answer_symbols": []
    },
    "6.3 44": {
        "question": "如果允许并列名次，4匹马参加马赛有多少种结果？注意：由于允许并列名次，4匹马中多少匹并列都是可能的。",
        "answer": "我们可以通过根据平局数量的不同来分解这个问题。有五种情况。(1) 如果没有平局，那么显然有 P(4, 4) = 24 种可能的比赛结果。(2) 假设有两匹马并列，但其他马有不同的名次。有 C(4, 2) = 6 种方式选择并列的马；然后有 P(3, 3) = 6 种方式确定三组（一对和两匹单独的马）的名次。因此，这种情况有 6 * 6 = 36 种可能。(3) 可能有两组两匹马并列。有 C(4, 2) = 6 种方式选择获胜者（另外两匹马是失败者）。(4) 可能有三匹马并列。有 C(4, 3) = 4 种方式。",
        "answer_symbols": [
            "(",
            ")",
            ",",
            "P",
            "C",
            "=",
            "*",
            "+",
            "-",
            "=",
            ","
        ]
    },
    "6.3 45": {
        "question": "有6名运动员参加百米赛跑。如果允许并列名次，有多少种方式授予3块奖牌？（跑得最快的运动员得金牌，恰好只被一个运动员超过的运动员得银牌，恰好被2个运动员超过的运动员得铜牌。）",
        "answer": "873",
        "answer_symbols": []
    },
    "6.3 46 a)": {
        "question": "如果比赛进行第一轮的10个罚球，并且这轮比赛结束时一个队不可能与另一个队得分相等，那么有多少种不同的得分场面？",
        "answer": "The complicating factor here is the rule that the penalty kick round (or \"group\") is over once one team has clinched a victory. For example, if the first team to shoot has missed all of its first four shots and the other team has made two of its first three shots, then the round is over after only seven kicks. There are 2^10 = 1024 possible scenarios without this rule (and without worrying yet about whether the score is tied at the end of this round), but it seems rather tedious and dangerous (in the sense of you being likely to make a mistake and leave something out) to try to analyze the more complicated situation by writing out all the possibilities by hand. (This is not impossible, though, and the author has obtained the correct answer in this way.) Rather than do this, one can write a computer program to simulate the situation and do the counting. The result is that there are 672 possible scoring scenarios for a round of penalty kicks, including the possibility that the score is still tied at the end of that round. Next, we need to count the number of ways for the score to end up tied at the end of the round. For this to happen, both teams must score p points, where p is some integer between 0 and 5, inclusive. The scoring scenario is determined by the positions of the kickers who did the scoring. There are C(5, p) ways to choose these positions for each team, or C(5, p)^2 ways in all. We need to sum this over the values of p from 0 to 5. The sum is 252. So there are 252 ways for the score to end up tied. We already noted in the paragraph above that there are 672 different scoring scenarios, so there are 672 - 252 = 420 scenarios in which the score is not tied. This answers the question for this part of the exercise.",
        "answer_symbols": [
            "^",
            "C",
            "=",
            "-",
            "+",
            "<=",
            ">="
        ]
    },
    "6.3 46 b)": {
        "question": "如果比赛进行第二轮的10个罚球，对第一和第二轮罚球可能有多少种不同的得分场面？",
        "answer": "This is easy after what we’ve found above. There are 252 ways for the score to be tied at the end of the first group of penalty kicks, and there are 420 ways for the game to be settled in the second group. So there are 252 · 420 = 105,840 ways for the game to end during the second round.",
        "answer_symbols": [
            "·",
            "="
        ]
    },
    "6.3 46 c)": {
        "question": "如果比赛在两轮每队罚5个球的加赛以后最多再射门10次，那么整个加赛过程可能有多少种得分场面？",
        "answer": "We have already seen that there are 420 ways for the game to end in the first round, and 105,840 more ways for it to end in the second round. In order for it to go into a sudden death period, the first two rounds must have ended tied, which can happen in 420 · 420 = 176,400 ways. Thereafter, the game can end after two more kicks in 2 ways (either team can make their kick and have the other team miss theirs), after four more kicks in 2 · 2 = 4 ways (the first pair of kicks must have the same result, either both made or both missed, and then either team can win), after six more kicks in 2^² · 2 = 8 ways (the first two pairs of kicks must have the same results, and then either team can win), after eight more kicks in 16 ways, and after ten more kicks in 32 ways. Thus there are 2 + 4 + 8 + 16 + 32 = 62 ways for the sudden death round to end within ten kicks. This needs to be multiplied by the 176,400 ways we can reach sudden death, for a total of 10,936,800 scoring scenarios. So the answer to this last question is 420 + 105,840 + 10,936,800 = 11,043,060.",
        "answer_symbols": [
            "·",
            "=",
            "^",
            "+",
            "-"
        ]
    },
    "6.4 2 a)": {
        "question": "求 (x+y)^5 的展开式。使用组合理由，如例 1 所示。",
        "answer": "When (x + y)^5 = (x + y)(x + y)(x + y)(x + y)(x + y) is expanded, all products of a term in the first sum, a term in the second sum, a term in the third sum, a term in the fourth sum, and a term in the fifth sum are added. Terms of the form x^5, x^4y, x^3y^2, x^2y^3, xy^4, and y^5 arise. To obtain a term of the form x^5, an x must be chosen in each of the sums, and this can be done in only one way. Thus, the x^5 term in the product has a coefficient of 1. (We can think of this coefficient as (5 choose 5).) To obtain a term of the form x^4y, an x must be chosen in four of the five sums (and consequently a y in the other sum). Hence, the number of such terms is the number of 4-combinations of five objects, namely (5 choose 4) = 5. Similarly, the number of terms of the form x^3y^2 is the number of ways to pick three of the five sums to obtain x’s (and consequently take a y from each of the other two factors). This can be done in (5 choose 3) = 10 ways. By the same reasoning, there are (5 choose 2) = 10 ways.To obtain the x^²y^³ terms, (5 choose 1) = 5 ways to obtain the xy^⁴ terms, and only one way (which we can think of as (5 choose 0)) to obtain a y^⁵ term. Consequently, the product is x^⁵ + 5x^⁴y + 10x^³y^² + 10x^²y^³ + 5xy^⁴ + y^⁵.\n",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "=",
            "^",
            "choose"
        ]
    },
    "6.4 2 b)": {
        "question": "求 (x+y)^5 的展开式。使用二项式定理。",
        "answer": "This is explained in Example 2. The expansion is (5 choose 0)x^⁵ + (5 choose 1)x^⁴y + (5 choose 2)x^³y^² + (5 choose 3)x^²y^³ + (5 choose 4)xy^⁴ + (5 choose 5)y^⁵ = x^⁵ + 5x^⁴y + 10x^³y^² + 10x^²y^³ + 5xy^⁴ + y^⁵. Note that it does not matter whether we think of the bottom of the binomial coefficient expression as corresponding to the exponent on x, as we did in part (a), or the exponent on y, as we do here.\n",
        "answer_symbols": [
            "!",
            "/",
            "·",
            "(",
            ")",
            "-",
            "="
        ]
    },
    "6.4 3": {
        "question": "求 (x + y)^8 的展开式。",
        "answer": "x^⁶ + 6x^⁵y + 15x^⁴y^² + 20x^³y^³ + 15x^² y^⁴ + 6xy^⁵ + y^⁶",
        "answer_symbols": [
            "+",
            "x",
            "y",
            "^"
        ]
    },
    "6.4 5": {
        "question": "在 (x + y)^100 的展开式中有多少项？",
        "answer": "10",
        "answer_symbols": []
    },
    "6.4 7": {
        "question": "在 (2 - x)^19 中 x^8 的系数是什么？",
        "answer": "-210(199) = -94,595,072",
        "answer_symbols": [
            "-",
            "(",
            ")",
            "="
        ]
    },
    "6.4 9": {
        "question": "在 (2x - 3y)^200 中 x^101 y^99 的系数是什么？",
        "answer": "-2101399(200 99)",
        "answer_symbols": [
            "-",
            "(",
            ")",
            "*"
        ]
    },
    "6.4 11": {
        "question": "给出一个关于 (x^2 - 1/x)^100 的展开式中 x^k 系数的公式，其中 k 是整数。",
        "answer": "(-1)^(200-k)/3 * (100 (200-k)/3) 如果k ≡ 2 (mod 3)且-100 ≤ k ≤ 200；否则为0",
        "answer_symbols": [
            "-",
            "^",
            "/",
            "*",
            "(",
            ")",
            "≤",
            "≥",
            "≡",
            "mod"
        ]
    },
    "6.4 13": {
        "question": "帕斯卡三角形中包含二项式系数 (9 k) (0 ⩽ k ⩽ 9) 的行是什么？",
        "answer": "1 9 36 84 126 126 84 36 9 1",
        "answer_symbols": []
    },
    "6.4 15": {
        "question": "证明：对一切正整数 n 和 k (0 ⩽ k ⩽ n)，(n k) ⩽ 2^n。",
        "answer": "所有正数(n k)的总和，当k从0到n时，是2^ⁿ，因此它们中的每一个都不超过这个总和。",
        "answer_symbols": [
            "(",
            ")",
            "∑",
            "≤",
            "^"
        ]
    },
    "6.4 17": {
        "question": "证明：如果 n 和 k 是整数，其中 1 ⩽ k ⩽ n，那么 (n k) ⩽ n^k/2^(k-1)。",
        "answer": "(n k) = n(n-1)(n-2)...(n-k+1) / k(k-1)(k-2)...2 ≤ n·n...n / 2·2...2 = nᵏ / 2^(k-1)",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "≤",
            "·",
            "^",
            "/"
        ]
    },
    "6.4 19": {
        "question": "使用关于 (n r) 的公式证明帕斯卡恒等式。",
        "answer": "(n k-1) + (n k) = n! / ((k-1)!(n-k+1)!) + n! / (k!(n-k)!) = n! / (k!(n-k+1)!) * [k + (n-k+1)] = (n+1)! / (k!(n+1-k)!) = (n+1 k)",
        "answer_symbols": [
            "+",
            "=",
            "!",
            "(",
            ")",
            "/",
            "[",
            "]"
        ]
    },
    "6.4 22 a)": {
        "question": "证明恒等式 (n r) (r k) = (n k) (n-k r-k)，其中 n, r 和 k 是非负整数且 r ⩽ n, k ⩽ r。使用组合证明。",
        "answer": "Suppose that we have a set with n elements, and we wish to choose a subset A with k elements and another, disjoint, subset with r - k elements. The left-hand side gives us the number of ways to do this, namely the product of the number of ways to choose the r elements that are to go into one or the other of the subsets and the number of ways to choose which of these elements are to go into the first of the subsets.\n",
        "answer_symbols": [
            "!",
            "/",
            "(",
            ")",
            "*",
            "-",
            "=",
            ","
        ]
    },
    "6.4 22 b)": {
        "question": "证明恒等式 (n r) (r k) = (n k) (n-k r-k)，其中 n, r 和 k 是非负整数且 r ⩽ n, k ⩽ r。使用以 n 元素集合的 r 组合数公式为基础的论证。",
        "answer": "b) 一方面，**\n(n r) * (r k) = n! / [r! * (n - r)!] * r! / [k! * (r - k)!] = n! / [k! * (n - r)! * (r - k)!]\n**另一方面，**\n(n k) * (n - k r - k) = n! / [k! * (n - k)!] * (n - k)! / [(r - k)! * (n - r)!] = n! / [k! * (n - r)! * (r - k)!]",
        "answer_symbols": [
            "!",
            "/",
            "(",
            ")",
            "*",
            "-",
            "=",
            ","
        ]
    },
    "6.4 23": {
        "question": "证明：如果 n 和 k 是正整数，那么 (n+1 k) = (n+1 k-1) + (n k) 使用这个恒等式构造一个二项式系数的归纳定义。",
        "answer": "(n+1 k) = (n+1)! / (k!(n+1-k)!) = (n+1) * n! / (k-1)![n-(k-1)]! = (n+1)(n k-1)",
        "answer_symbols": [
            "=",
            "!",
            "(",
            ")",
            "*",
            "-",
            "+"
        ]
    },
    "6.4 24": {
        "question": "证明：如果 p 是素数， k 是满足 1 ≤ k ≤ p - 1 的整数，那么 p 整除 (p k) .",
        "answer": "我们知道 binom{p}{k} = p! / (k! · (p - k)!) 显然，p 可以整除分子。另一方面，由于这些阶乘的质因数分解只包含小于 p 的数，因此 p 不能整除分母。因此，当这个分数化简为最简形式（即一个整数）时，因子 p 不会被约去，所以 p 整除 binom{p}{k}",
        "answer_symbols": [
            "!",
            "/",
            "·",
            "(",
            ")",
            "-",
            "="
        ]
    },
    "6.4 25": {
        "question": "设 n 是正整数，证明 [ (2n n+1) + (2n n) = (2n+2 n+1) ]",
        "answer": "(2n n+1) + (2n n) = (2n+1 n+1) = 1/2 * [(2n+1 n+1) + (2n+1 n+1)] = 1/2 * [(2n+1 n+1) + (2n+1 n)] = 1/2 * (2n+2 n+1)",
        "answer_symbols": [
            "+",
            "=",
            "!",
            "(",
            ")",
            "*",
            "/",
            "[",
            "]"
        ]
    },
    "6.4 26": {
        "question": "设 n 和 k 是整数， 1 ≤ k ≤ n ，证明 [ ∑_(i=1)^n (n k) (n k-1) = (2n+2 n+1) - (2n n) ]",
        "answer": "首先，使用练习 25 将此恒等式的右侧重写为 binom{2n}{n + 1}. 我们给出一个组合证明，表明两边都计算了从 n 个男人和 n 个女人的集合中选择一个子集的方法数，该子集中的男人比女人多一个。对于左侧，我们注意到这个子集必须有 k 个男人和 k - 1 个女人，其中 k 在 1 到 n 之间（包括 1 和 n）。对于（修改后的）右侧，从这 n 个男人和 n 个女人的集合中选择任何 n + 1 个人；所需的子集是被选中的男人和未被选中的女人。",
        "answer_symbols": [
            "+",
            "(",
            ")",
            "-"
        ]
    },
    "6.4 28 a)": {
        "question": "使用组合论证",
        "answer": "从 n 个男人和 n 个女人的集合中选择 2 个人，我们可以选择 2 个男人（有 binom{n}{2} 种方法），或 2 个女人（有 binom{n}{2} 种方法），或一个男人和一个女人（有 n * n 种方法）。因此，右侧计算了这样做（通过加法规则）的方法数。左侧也计算了同样的事情，因为我们只是从 2n 个人中选择 2 个人。",
        "answer_symbols": [
            "!",
            "/",
            "·",
            "(",
            ")",
            "+",
            "*"
        ]
    },
    "6.4 28 b)": {
        "question": "通过代数推导",
        "answer": "2 binom{n}{2} + n^2 = n(n - 1) + n^2 = 2n^2 - n = n(2n - 1) = 2n(2n - 1) / 2 = binom{2n}{2}",
        "answer_symbols": [
            "!",
            "/",
            "·",
            "(",
            ")",
            "+",
            "^",
            "*",
            "-"
        ]
    },
    "6.4 29": {
        "question": "给出关于 ∑_(i=1)^n k (n k) = n 2^(n-1) 的组合证明。[提示：以两种方法计数选择一个委员会，然后选择这个委员会领导的方式数。]",
        "answer": "We can choose the leader first in n different ways. We can then choose the rest of the committee in 2^(n-1) ways. Hence, there are n · 2^(n-1) ways to choose the committee and its leader. Meanwhile, the number of ways to select a committee with k people is (n choose k). Once we have chosen a committee with k people, there are k ways to choose its leader. Hence, there are ∑ from k=1 to n of [k · (n choose k)] ways to choose the committee and its leader. Hence, ∑ from k=1 to n of [k · (n choose k)] = n · 2^(n-1).",
        "answer_symbols": [
            "·",
            "^",
            "(",
            ")",
            "∑",
            "choose"
        ]
    },
    "6.4 30": {
        "question": "给出关于 ∑_(i=1)^n k (n k)^² = n (2n-1 n-1) 的组合证明。[提示：用两种方法计数选择一个委员会的方式数，如果这个委员会有 n 个成员，要求这些成员选自 n 个数学教授和 n 个计算机科学教授，并使得委员会的主席是数学教授。]",
        "answer": "我们遵循提示。选择这个委员会的方法数是从 n 个数学家中选择主席的方法数（n 种方法）乘以从其他 2n - 1 个教授中选择委员会其他 n - 1 名成员的方法数。这给出了 n binom{2n - 1}{n - 1}，即右侧的表达式。另一方面，对于每个 k 从 1 到 n，我们的委员会可以由 k 个数学家和 n - k 个计算机科学家组成。选择数学家的方法有 binom{n}{k} 种，从这些数学家中选择主席的方法有 k 种，选择计算机科学家的方法有 binom{n}{n - k} 种。由于这个最后的数量等于 binom{n}{k}，我们得到了恒等式左侧的表达式。",
        "answer_symbols": [
            "!",
            "/",
            "·",
            "(",
            ")",
            "+",
            "-",
            "="
        ]
    },
    "6.4 31": {
        "question": "证明：一个非空集合具有奇数个元素的子集数与具有偶数个元素的子集数相等。",
        "answer": "Let the set have n elements. From Corollary 2 we have (n choose 0) - (n choose 1) + (n choose 2) - ... + (-1)^n · (n choose n) = 0. It follows that (n choose 0) + (n choose 2) + (n choose 4) + ... = (n choose 1) + (n choose 3) + (n choose 5) + .... The left-hand side gives the number of subsets with an even number of elements, and the right-hand side gives the number of subsets with an odd number of elements.",
        "answer_symbols": [
            "-",
            "+",
            "^",
            "·",
            "choose"
        ]
    },
    "6.4 32": {
        "question": "使用数学归纳法证明二项式定理。",
        "answer": "对于 n = 0，我们希望 (x + y)^0 = ∑(从 j=0 到 0) binom{0}{j} x^(0-j) y^j = binom{0}{0} x^0 y^0，这是正确的，因为 1 = 1。假设归纳假设成立。那么我们有 (x + y)^(n+1) = (x + y) * (∑(从 j=0 到 n) binom{n}{j} x^(n-j) y^j) = ∑(从 j=0 到 n) binom{n}{j} x^(n+1-j) y^j + ∑(从 j=0 到 n) binom{n}{j} x^(n-j) y^(j+1)(x + y)^0 = ∑(从 j=0 到 0) \\binom{0}{j} x^(0-j) y^j = \\binom{0}{0} x^0 y^0，这是正确的，因为 1 = 1。假设归纳假设成立。那么我们有 (x + y)^(n+1) = (x + y) * (∑(从 j=0 到 n) \\binom{n}{j} x^(n-j) y^j) = ∑(从 j=0 到 n) \\binom{n}{j} x^(n+1-j) y^j + ∑(从 j=0 到 n) \\binom{n}{j} x^(n-j) y^(j+1)",
        "answer_symbols": [
            "!",
            "/",
            "·",
            "(",
            ")",
            "+",
            "^",
            "=",
            "*",
            "∑"
        ]
    },
    "6.4 34": {
        "question": "用练习 33 证明 (n k) = (n n-k) ，其中 k 是整数，满足 0 ≤ k ≤ n 。[提示：考虑在练习 33 中所述的从 (0, 0) 到 (n-k, k) 和从 (0, 0) 到 (k, n-k) 的路径数。]",
        "answer": "由练习 33，从 (0, 0) 到 (n - k, k) 有 \\binom{n-k+k}{k} = \\binom{n}{k} 条路径，从 (0, 0) 到 (k, n - k) 有 \\binom{k + n - k}{n - k} = \\binom{n}{n - k} 条路径。由于对称性，这两个数量必须相同（围绕 45° 线翻转图片）。",
        "answer_symbols": [
            "\\binom",
            "=",
            "(",
            ")",
            "-"
        ]
    },
    "6.4 35": {
        "question": "使用练习 33 证明定理 4。[提示：计数练习 33 所描述的那种 n 步路径数。每条路径必须在一个 (n-k, k) 点结束，其中 k = 0, 1, 2, ⋯, n 。]",
        "answer": "By Exercise 33 the number of paths of length n of the type described in that exercise equals 2^n, the number of bit strings of length n. On the other hand, a path of length n of the type described in Exercise 33 must end at a point that has n as the sum of its coordinates, say (n - k, k) for some k between 0 and n, inclusive. By Exercise 33, the number of such paths ending at (n - k, k) equals (n - k + k choose k) = (n choose k). Hence, ∑ from k=0 to n of (n choose k) = 2^n.",
        "answer_symbols": [
            "+",
            "^",
            "choose",
            "∑"
        ]
    },
    "6.4 36": {
        "question": "使用练习 33 证明帕斯卡恒等式。[提示：显示一条在练习 33 所描述的那种从 (0, 0) 到 (n+1-k, k) 并通过 (n+1-k, k-1) 点或 (n-k, k) 点但不同时通过这两点的路径。]",
        "answer": "一条最终到达 (n + 1 - k, k) 的路径必须是向上或向右的最后一步。如果最后一步是向上，则来自 (n + 1 - k, k - 1)；如果是向右，则来自 (n - k, k)。路径不能同时经过这两个点。因此，到 (n + 1 - k, k) 的路径数是从 (n + 1 - k, k - 1) 和 (n - k, k) 的路径数之和。由练习 33，这告诉我们 \\binom{n + 1 - k + k}{k} = \\binom{n + 1 - k + k - 1}{k} + \\binom{n - k + k}{k}，简化为 \\binom{n + 1}{k} = \\binom{n}{k - 1} + \\binom{n}{k}，即帕斯卡恒等式。",
        "answer_symbols": [
            "\\binom",
            "=",
            "+",
            "(",
            ")",
            "-",
            "^"
        ]
    },
    "6.4 33": {
        "question": "在这个练习里，我们将要计数 xy 平面上在原点和 (m, n) 点之间的路径数。这些路径由一系列步构成，其中每一步是向右或者向上移动一个单位（不允许向左或向下移动）。下图给出了两条这种从 (0, 0) 到 (5, 3) 的路径（用粗线标识）。",
        "answer": "a) A path of the desired type consists of m moves to the right and n moves up. Each such path can be represented by a bit string of length m + n with m 0s and n 1s, where a 0 represents a move to the right and a 1 a move up. b) The number of bit strings of length m + n containing exactly n 1s equals (m + n choose n) = (m + n choose m) because such a string is determined by specifying the positions of the n 1s or by specifying the positions of the m 0s.",
        "answer_symbols": [
            "+",
            "choose"
        ]
    },
    "6.4 37": {
        "question": "使用练习 33 证明练习 27 中的恒等式。[提示：首先注意从(0, 0)到(n+1, r)的路径数等于 (n+1+r r) 。其次，按照开始向上恰好走 k 个单位分别计数每一类路径，其中 k=0, 1, 2, …, r，然后对结果求和。]",
        "answer": "By Exercise 33 the number of paths from (0, 0) to (n + 1, r) of the type described in that exercise equals (n + r + 1 choose r). But such a path starts by going j steps vertically for some j with 0 ≤ j ≤ r. The number of these paths beginning with j vertical steps equals the number of paths of the type described in Exercise 33 that go from (1, j) to (n + 1, r). This is the same as the number of such paths that go from (0, 0) to (n, r - j), which by Exercise 33 equals (n + r - j choose r - j). Because ∑ from j=0 to r of (n + r - j choose r - j) = ∑ from k=0 to r of (n + k choose k), it follows that ∑ from k=1 to r of (n + k choose k) = (n + r - 1 choose r).",
        "answer_symbols": [
            "+",
            "-",
            "choose",
            "∑"
        ]
    },
    "6.4 38": {
        "question": "如果 n 是正整数，则 ∑_(k=0)^n k^² (n k) = n(n+1)2^(n-2) ，给出组合证明。[提示：证明等式两边计数了从一个 n 元素集合中选一个子集，再从子集中选 2 个元素的方法，其中这 2 个元素可以相同。而且，等式右边也可以表示成 n(n-1)2^(n-2) + n2^(n-1) 。]",
        "answer": "根据提示，首先注意到可以从 k = 1 开始求和，因为 k = 0 的项为 0。左侧按子集中的元素数将其分解来计算选择一个子集的方法数；注意，如果子集大小为 k，则有 k 种方法选择每个区分的元素。对于右侧，首先注意 n(n + 1)2^(n-2) = n(n - 1 + 2)2^(n-2) = n(n - 1)2^(n-2) + n2^(n-1)。第一项计算两个区分的元素不同（选择它们，然后选择剩余元素的任何子集作为其余部分）的方法数。第二项计算两个区分的元素相同（选择它，然后选择剩余元素的任何子集作为其余部分）的方法数。注意，即使 n = 1 也适用。",
        "answer_symbols": [
            "=",
            "+",
            "(",
            ")",
            "-",
            "^"
        ]
    },
    "6.4 39": {
        "question": "如果一个序列的前若干项如下列出，对于它的第 n 项确定一个与二项式系数有关的公式。[提示：对帕斯卡三角形的观察有助于问题的求解。虽然以这一组给定的项作为开始的序列有无数多个，但下面列出的每个序列都是所求的那种序列的开始。]",
        "answer": "a) (n + 1 choose 2) b) (n + 2 choose 3) c) (2n - 2 choose n - 1) d) (n - 1 choose (n - 1)/2) e) Largest odd entry in nth row of Pascal’s triangle f) (3n - 3 choose n - 1)",
        "answer_symbols": [
            "+",
            "-",
            "/",
            "choose"
        ]
    },
    "6.5 1": {
        "question": "从一个3元素集合中允许重复地有序选取5个元素有多少种不同的方式？",
        "answer": "243",
        "answer_symbols": []
    },
    "6.5 2": {
        "question": "从一个5元素集合中允许重复地有序选取5个元素有多少种不同的方式？",
        "answer": "有 5 次每次 5 个选择，所以答案是 5^5 = 3125。",
        "answer_symbols": [
            "^"
        ]
    },
    "6.5 3": {
        "question": "6个字母的字符串有多少个？",
        "answer": "266",
        "answer_symbols": []
    },
    "6.5 4": {
        "question": "每天一个学生从一堆包好的三明治中随机选1块三明治作为午饭。如果有6种三明治并且选择三明治的次序无关，在一周的7天里这个学生选择三明治有多少种不同的方式？",
        "answer": "有 7 次每次 6 个选择，所以答案是 6^7 = 279,936。",
        "answer_symbols": [
            "^"
        ]
    },
    "6.5 5": {
        "question": "分配3种工作给5个雇员，如果每个雇员可以得到1种以上的工作，那么有多少种不同的分配方式？",
        "answer": "125",
        "answer_symbols": []
    },
    "6.5 6": {
        "question": "从一个3元素集合中允许重复地无序选取5个元素有多少种不同的方式？",
        "answer": "由定理 2，答案是 C(3 + 5 - 1, 5) = C(7, 5) = C(7, 2) = 21。",
        "answer_symbols": [
            "C",
            "(",
            ")",
            "+",
            "-",
            "="
        ]
    },
    "6.5 7": {
        "question": "从一个5元素集合中允许重复地无序选取3个元素有多少种不同的方式？",
        "answer": "35",
        "answer_symbols": []
    },
    "6.5 8": {
        "question": "从一个商店的21种多纳圈中选择12个多纳圈有多少种不同的方式？",
        "answer": "由定理 2，答案是 C(21 + 12 - 1, 12) = C(32, 12) = 225,792,840",
        "answer_symbols": [
            "C",
            ",",
            "=",
            ")",
            "(",
            "+",
            "-"
        ]
    },
    "6.5 9": {
        "question": "一个百吉饼店有洋葱百吉饼、罂粟籽百吉饼、鸡蛋百吉饼、咸味百吉饼、粗制裸麦百吉饼、芝麻百吉饼、葡萄干百吉饼和普通百吉饼，有多少种方式选择",
        "answer": "a) 1716 b) 50,388 c) 2,629,575 d) 330",
        "answer_symbols": []
    },
    "6.5 10 a)": {
        "question": "一个新月形面包店有普通新月形面包、樱桃新月形面包、巧克力新月形面包、杏仁新月形面包、苹果新月形面包和椰菜新月形面包。有多少种方式选择12个新月形面包？",
        "answer": "C(6 + 12 - 1, 12) = C(17, 12) = 6188",
        "answer_symbols": [
            "+",
            "-",
            "(",
            ")",
            ","
        ]
    },
    "6.5 10 b)": {
        "question": "一个新月形面包店有普通新月形面包、樱桃新月形面包、巧克力新月形面包、杏仁新月形面包、苹果新月形面包和椰菜新月形面包。有多少种方式选择36个新月形面包？",
        "answer": "C(6 + 36 - 1, 36) = C(41, 36) = 749,398",
        "answer_symbols": [
            "+",
            "-",
            "(",
            ")",
            ","
        ]
    },
    "6.5 10 c)": {
        "question": "一个新月形面包店有普通新月形面包、樱桃新月形面包、巧克力新月形面包、杏仁新月形面包、苹果新月形面包和椰菜新月形面包。有多少种方式选择24个新月形面包，并且至少每类有2个？",
        "answer": "如果我们先选择每种类型的两个，那么我们已经选择了 2 * 6 = 12 个羊角面包。这剩下了一打可以自由选择，因此答案与 (a) 部分相同，即 C(6 + 12 - 1, 12) = C(17, 12) = 6188",
        "answer_symbols": [
            "*",
            "+",
            "-",
            "(",
            ")",
            ","
        ]
    },
    "6.5 10 d)": {
        "question": "一个新月形面包店有普通新月形面包、樱桃新月形面包、巧克力新月形面包、杏仁新月形面包、苹果新月形面包和椰菜新月形面包。有多少种方式选择24个新月形面包，并且不超过2个椰菜的？",
        "answer": "我们首先计算违反限制的方式数量，即选择至少三个西兰花羊角面包。这可以通过 C(6 + 21 - 1, 21) = C(26, 21) = 65780 种方式完成，因为一旦我们选择了三个西兰花羊角面包，就剩下 21 个可以自由选择。由于在没有任何限制的情况下选择 24 个羊角面包有 C(6 + 24 - 1, 24) = C(29, 24) = 118755 种方式，因此必须有 118755 - 65780 = 52,975 种方式选择两打羊角面包且不超过两个西兰花",
        "answer_symbols": [
            "+",
            "-",
            "(",
            ")",
            ","
        ]
    },
    "6.5 10 e)": {
        "question": "一个新月形面包店有普通新月形面包、樱桃新月形面包、巧克力新月形面包、杏仁新月形面包、苹果新月形面包和椰菜新月形面包。有多少种方式选择24个新月形面包，并且至少5个巧克力的且至少3个杏仁的？",
        "answer": "八个羊角面包已经指定，所以这个问题等同于在没有限制的情况下选择 24 - 8 = 16 个羊角面包，这可以通过 C(6 + 16 - 1, 16) = C(21, 16) = 20,349 种方式完成",
        "answer_symbols": [
            "-",
            "+",
            "-",
            "(",
            ")",
            ","
        ]
    },
    "6.5 10 f)": {
        "question": "一个新月形面包店有普通新月形面包、樱桃新月形面包、巧克力新月形面包、杏仁新月形面包、苹果新月形面包和椰菜新月形面包。有多少种方式选择24个新月形面包，并且至少1个普通的，至少2个樱桃的，至少3个巧克力的，至少1个杏仁的，至少2个苹果的和不超过3个椰菜的？",
        "answer": "首先让我们包括所有下限限制。如果我们选择了所需的 9 个羊角面包，那么剩下 24 - 9 = 15 个需要选择，如果没有对西兰花羊角面包的限制，则有 C(6 + 15 - 1, 15) = C(20, 15) = 15504 种选择方式。如果另外我们违反了西兰花限制，选择了至少四个西兰花羊角面包，将有 C(6 + 11 - 1, 11) = C(16, 11) = 4368 种选择。因此，在不违反限制的情况下进行选择的方式数量为 15504 - 4368 = 11,136",
        "answer_symbols": [
            "-",
            "+",
            "-",
            "(",
            ")",
            ","
        ]
    },
    "6.5 11": {
        "question": "一个小猪储钱罐包含100个相同的1美分和80个相同的5美分硬币，从中选8个硬币有多少种方式？",
        "answer": "9",
        "answer_symbols": []
    },
    "6.5 12": {
        "question": "如果一个小猪储钱罐中有1美分、5美分、10美分、25美分、50美分等硬币，那么20个硬币有多少种不同的组合？",
        "answer": "有 5 个项目可以选择，允许重复，我们需要选择 20 个项目，顺序不重要。因此根据定理 2，答案是 C(5 + 20 - 1, 20) = C(24, 20) = C(24, 4) = 10,626",
        "answer_symbols": [
            "+",
            "-",
            "(",
            ")",
            ","
        ]
    },
    "6.5 13": {
        "question": "一个出版商有3000本离散数学书，如果这些书是没有区别的，那么将这些书存储在3个库房有多少种方式？",
        "answer": "4,504,501",
        "answer_symbols": []
    },
    "6.5 14": {
        "question": "设x1, x2, x3和x4是非负整数，方程x1 + x2 + x3 + x4 = 17有多少个解？",
        "answer": "根据定理 2，答案是 C(4 + 17 - 1, 17) = C(20, 17) = C(20, 3) = 1140",
        "answer_symbols": [
            "+",
            "-",
            "(",
            ")",
            ","
        ]
    },
    "6.5 16 a)": {
        "question": "方程 x1 + x2 + x3 + x4 + x5 + x6 = 29 有多少个解？其中 x1, x2, x3, x4, x5, x6 是非负整数，并且使得 xi > 1, i = 1, 2, 3, 4, 5, 6",
        "answer": "要求每个 x_i ≥ 2。这使用了 12 个总数中的 29 个，因此问题等同于找到方程 x'1 + x'2 + x'3 + x'4 + x'5 + x'6 = 17 的解，其中每个 x'i 是非负整数。解的数量因此为 C(6 + 17 - 1, 17) = C(22, 17) = 26,334",
        "answer_symbols": [
            "≥",
            "+",
            "-",
            "(",
            ")",
            ","
        ]
    },
    "6.5 16 b)": {
        "question": "方程 x1 + x2 + x3 + x4 + x5 + x6 = 29 有多少个解？其中 x1, x2, x3, x4, x5, x6 是非负整数，并且使得 x1 ≥ 1, x2 ≥ 2, x3 ≥ 3, x4 ≥ 4, x5 ≥ 5, x6 ≥ 6",
        "answer": "限制条件使用了总数中的 22 个，剩下 7 个可以自由分配。因此答案是 C(6 + 7 - 1, 7) = C(12, 7) = 792",
        "answer_symbols": [
            "-",
            "+",
            "-",
            "(",
            ")",
            ","
        ]
    },
    "6.5 16 c)": {
        "question": "方程 x1 + x2 + x3 + x4 + x5 + x6 = 29 有多少个解？其中 x1, x2, x3, x4, x5, x6 是非负整数，并且使得 xi ≤ 5",
        "answer": "没有限制的解的数量为 C(6 + 29 - 1, 29) = C(34, 29) = 278256。违反 x1 ≥ 6 限制的解的数量为 C(6 + 23 - 1, 23) = C(28, 23) = 98280。因此答案是 278256 - 98280 = 179,976",
        "answer_symbols": [
            "+",
            "-",
            "(",
            ")",
            ","
        ]
    },
    "6.5 17": {
        "question": "有多少10位三进制数字(0、1 或 2)串恰含有2个0、3个1和5个2？",
        "answer": "2,520",
        "answer_symbols": []
    },
    "6.5 18": {
        "question": "有多少20位十进制数字串含有2个0、4个1、3个2、1个3、2个4、3个5、2个7和3个9？",
        "answer": "直接从定理 3 可知答案为 20! / (2! * 4! * 3! * 1! * 2! * 3! * 2! * 3!) ≈ 5.9 × 10^13",
        "answer_symbols": [
            "!",
            "/",
            "*",
            "^"
        ]
    },
    "6.5 19": {
        "question": "假设一个大家庭有14个孩子，包括2组三胞胎、3组双胞胎以及2个单胞胎。这些孩子坐在一排椅子上，如果相同的三胞胎或双胞胎不能互相区分，那么有多少种方式？",
        "answer": "302,702,400",
        "answer_symbols": []
    },
    "6.5 20": {
        "question": "不等式 x1 + x2 + x3 ≤ 11 有多少个解？其中 x1, x2 和 x3 是非负整数。[提示：引入辅助变量 x4 使得 x1 + x2 + x3 + x4 = 11.]",
        "answer": "引入非负松弛变量 x4，我们的问题等同于计算方程 x1 + x2 + x3 + x4 = 11 的非负整数解的数量。根据定理 2，答案是 C(4 + 11 - 1, 11) = C(14, 11) = C(14, 3) = 364",
        "answer_symbols": [
            "+",
            "-",
            "(",
            ")",
            ","
        ]
    },
    "6.5 21": {
        "question": "把6个相同的球放到9个不同的箱子中有多少种方法？",
        "answer": "3003",
        "answer_symbols": []
    },
    "6.5 22": {
        "question": "把12个相同的球放到6个不同的箱子中有多少种方法？",
        "answer": "如果我们将球视为选择者，那么这是在给定的六个箱子中选择 12 个箱子的问题，允许重复。（每个箱子被选择的次数是该箱子里的球的数量。）根据定理 2，n = 6 和 r = 12，这种选择可以以 C(6 + 12 - 1, 12) = C(17, 12) = 6188 种方式完成",
        "answer_symbols": [
            "+",
            "-",
            "(",
            ")",
            ","
        ]
    },
    "6.5 23": {
        "question": "把12个不同的物体放到6个不同的盒子中并且每个盒子有2个物体，有多少种方法？",
        "answer": "7,484,400",
        "answer_symbols": []
    },
    "6.5 25": {
        "question": "有多少个小于1 000 000的正整数其数字之和等于19？",
        "answer": "30,492",
        "answer_symbols": []
    },
    "6.5 27": {
        "question": "一次离散数学的期终考试有10道题。如果总分数是100且每道题至少5分，那么有多少种方式来分配这些题的分数？",
        "answer": "C(59, 50)",
        "answer_symbols": [
            "("
        ]
    },
    "6.5 29": {
        "question": "如果传送的位串必须以1开始，必须有另外3位1(使得传送的1共有4位)，必须包含总共12位0，必须每个1后面至少跟随2个0，那么有多少个不同的位串？",
        "answer": "35",
        "answer_symbols": []
    },
    "6.5 31": {
        "question": "使用 ABRACADABRA 中的所有字母可以构造多少个不同的串？",
        "answer": "83,160",
        "answer_symbols": []
    },
    "6.5 33": {
        "question": "使用 OROINO 中的某些或全部字母可以构造多少个不同的串？",
        "answer": "63",
        "answer_symbols": []
    },
    "6.5 35": {
        "question": "用 EVERGREEN 中的字母可以构造多少个至少含 7 个字符的串？",
        "answer": "19,635",
        "answer_symbols": []
    },
    "6.5 37": {
        "question": "一个学生有 3 个芒果、2 个番木瓜和 2 个猕猴桃。如果这个学生每天吃 1 个水果，并且只考虑水果的类型，那么有多少种不同的方式吃完这些水果？",
        "answer": "210",
        "answer_symbols": []
    },
    "6.5 39": {
        "question": "有多少种不同的方式在 xyz 空间上从原点 (0, 0, 0) 到达点 (4, 3, 5)？这个旅行的每一步是在 x 正方向移动一个单位，y 正方向移动一个单位，或者 z 正方向移动一个单位。（x、y、z 负方向的移动是禁止的，即不允许回头。）",
        "answer": "27,720",
        "answer_symbols": []
    },
    "6.5 41": {
        "question": "把一副标准的 52 张扑克牌发给 5 个人，每个人得到 7 张牌，有多少种方式？",
        "answer": "52! / (7! * 517!)",
        "answer_symbols": [
            "!",
            "*",
            "/"
        ]
    },
    "6.5 42": {
        "question": "在打桥牌时，把一副标准的 52 张牌发给 4 个人，有多少种不同发牌的方式？",
        "answer": "定理4指出答案是 52!/13!^4 ≈ 5.4 × 10^28，因为每个玩家得到13张牌。",
        "answer_symbols": [
            "!",
            "^",
            "×"
        ]
    },
    "6.5 43": {
        "question": "当把一副标准的 52 张牌发给 4 个人时，若使得每个人有一手包含 1 张 A 的牌，这种概率是多少？",
        "answer": "Approximately 6.5 × 10^32",
        "answer_symbols": [
            "×",
            "^"
        ]
    },
    "6.5 44 a)": {
        "question": "12 本书放在 4 个不同的书架上有多少种方式？如果这些书是同一种书。",
        "answer": "唯一重要的是每个书架上的书籍数量，所以答案就是方程 x1 + x2 + x3 + x4 = 12 的解的数量，其中 xi 被视为书架 i 上的书籍数量。因此，答案是 C(4 + 12 - 1, 12) = C(15, 12) = 455。",
        "answer_symbols": [
            "+",
            "=",
            "C",
            "(",
            ")",
            ","
        ]
    },
    "6.5 44 b)": {
        "question": "12 本书放在 4 个不同的书架上有多少种方式？如果所有的书都不同，并且考虑这些书在书架上的位置。",
        "answer": "如果我们对书籍编号为 b1, b2, ..., b12，并考虑依次放置 b1, b2 等等，则不失一般性。显然有4种方法放置 b1，因为我们可以在任何书架上将其作为第一本书（暂时）。在放置 b1 后，有5种方法放置 b2，因为它可以放在 b1 的右侧或成为任何书架上的第一本书。我们继续这样操作：有6种方法放置 b3（在 b1 右侧、b2 右侧或作为任何书架上的第一本书），7种方法放置 b4，...，15种方法放置 b12。因此，答案是这些数字的乘积 4 × 5 × ... × 15 = 217,945,728,000。",
        "answer_symbols": [
            "×"
        ]
    },
    "6.5 46": {
        "question": "12 本书在一个书架上排成一排。从中选 5 本书并且使得没有 2 本书相邻有多少种方式？",
        "answer": "我们遵循提示。有5个竖线（选中的书籍），因此有6个位置可以放置7个星号（未选中的书籍）（在第一个竖线之前、第一个和第二个竖线之间、...、第五个竖线之后）。从第二个到第五个槽位中，每个槽位必须至少有一个星号，以确保相邻的书籍不被选中。一旦放置了这4个星号，剩下3个星号需要放置在6个槽位中。因此，这样做有 C(6 + 3 - 1, 3) = C(8, 3) = 56 种方法。",
        "answer_symbols": [
            "+",
            "=",
            "C",
            "(",
            ")",
            ","
        ]
    },
    "6.5 50": {
        "question": "有多少种方式把 5 个不同的物体放到 3 个相同的盒子中？",
        "answer": "这实际上是一个关于集合划分的问题。设 5 个对象的集合为 {a, b, c, d, e}。我们希望将这个集合划分为三个两两不相交的子集（某些可能是空集）。我们以一种相当随意的方式计数。首先，我们可以将所有五个对象放入一个子集中（即所有五个对象进入一个盒子，另外两个盒子为空）。其次，我们可以将四个对象放入一个子集，另一个放入另一个子集，例如 {a, b, c, d} 与 {e}。有5种方法这样做，因为五个对象中的每一个都可以是单元素集。第三，我们可以将三个对象放入一个集合（盒子），另外两个放入另一个；有 C(5, 2) = 10 种方法这样做，因为有这么多种方法选择哪些对象是双元素集。同样，有10种方法将元素分布为三个集合，其中一个包含三个元素，另外两个各包含一个元素（例如 {a, b, c}, {d}, 和 {e}）。最后，我们可以将两个项目放入一个集合，另外两个放入另一个集合，最后一个放入第三个集合（例如 {a, b}, {c, d}, 和 {e}）。这里我们需要选择单元素集（5种方式），然后我们需要选择3种方式之一来将剩余的四个元素分成对；这总共给出了15个划分。总计有41种不同的划分。这也可以通过使用文本中讨论的第二类斯特林数的公式解决（这是例10之后的内容）：S(5, 1) = 1 / 1! * (1) = 1，S(5, 2) = 1 / 2! * (2^5 - 2) = 15，S(5, 3) = 1 / 3! * (3^5 - 3 * 2^5 + 3) = 25。",
        "answer_symbols": [
            "{",
            "}",
            ",",
            "!",
            "*",
            "(",
            ")",
            "^",
            "-",
            "+",
            "/"
        ]
    },
    "6.5 51": {
        "question": "有多少种不同的方式将 6 个可辨别的物体放入 4 个不可辨别的盒子，使得每个盒子里至少有 1 个物体？",
        "answer": "65",
        "answer_symbols": []
    },
    "6.5 52": {
        "question": "有多少种不同的方式将 5 个临时雇员安排到 4 个相同的办公室？",
        "answer": "这个类似于练习 50，将 3 替换为 4。我们使用公式计算：S(5, 1) = 1 1!(( 1 1!(1) = 1；S(5, 2) = 1 2!(( 2 2!(32 - 2) = 15；S(5, 3) = 1 3!(( 3 3!(243 - 96 + 3) = 25；S(5, 4) = 1 4!(( 4 4!(1024 - 972 + 192 - 4) = 10",
        "answer_symbols": [
            "!",
            "(",
            ")",
            "-",
            "+",
            "="
        ]
    },
    "6.5 53": {
        "question": "有多少种不同的方式将 6 个临时雇员安排到 4 个相同的办公室，使得每个办公室中至少有 1 个临时雇员？",
        "answer": "65",
        "answer_symbols": []
    },
    "6.5 54": {
        "question": "有多少种不同的方式将 5 个不可辨别的物体放入 3 个不可辨别的盒子？",
        "answer": "我们要求的是将 5 分成最多 3 部分的划分；请注意，我们不需要使用所有三个盒子。我们可以很容易地明确列出这些划分：5 = 5，5 = 4 + 1，5 = 3 + 2，5 = 3 + 1 + 1，和 5 = 2 + 2 + 1。",
        "answer_symbols": [
            "=",
            "+"
        ]
    },
    "6.5 55": {
        "question": "有多少种不同的方式将 6 个不可辨别的物体放入 4 个不可辨别的盒子，使得每个盒子里至少有 1 个物体？",
        "answer": "2",
        "answer_symbols": []
    },
    "6.5 56": {
        "question": "有多少种不同的方式将 8 张相同的 DVD 放入 5 个不可辨别的盒子，使得每个盒子里至少有 1 张 DVD？",
        "answer": "这个类似于练习 55。由于每个盒子必须至少包含一个对象，我们可以先在每个盒子里放一个对象。这剩下三个对象，只有三种选择：我们可以把它们都放在同一个盒子里（这样最终的划分是 8 = 4 + 1 + 1 + 1 + 1），或者我们可以把它们放在三个不同的盒子里（这样最终的划分是 8 = 2 + 2 + 2 + 1 + 1），或者我们可以把两个放在一个盒子里，最后一个放在另一个盒子里（这样最终的划分是 8 = 3 + 2 + 1 + 1 + 1）。",
        "answer_symbols": [
            "=",
            "+"
        ]
    },
    "6.5 57": {
        "question": "有多少种不同的方式将 9 张相同的 DVD 放入 3 个不可辨别的盒子，使得每个盒子里至少有 2 张 DVD？",
        "answer": "3",
        "answer_symbols": []
    },
    "6.5 58 a)": {
        "question": "有多少种不同的方式将 5 个球放到 7 个盒子里，要求每个盒子里最多有 1 个球，如果球与盒都是有标号的？",
        "answer": "这是一个简单的乘法规则应用：第一个球有 7 种选择，第二个球有 6 种选择，以此类推，答案是 7 * 6 * 5 * 4 * 3 = 2520。",
        "answer_symbols": [
            "*",
            "="
        ]
    },
    "6.5 58 b)": {
        "question": "有多少种不同的方式将 5 个球放到 7 个盒子里，要求每个盒子里最多有 1 个球，如果球是有标号的，但盒子是没有标号的？",
        "answer": "由于每个球必须放在不同的盒子里且盒子没有标签，只有一种方法可以做到这一点。",
        "answer_symbols": []
    },
    "6.5 58 c)": {
        "question": "有多少种不同的方式将 5 个球放到 7 个盒子里，要求每个盒子里最多有 1 个球，如果球是没有标号的，但盒子是有标号的？",
        "answer": "这只是选择将球放入哪五个盒子的问题，所以答案是 C(7, 5) = 21。",
        "answer_symbols": [
            "C",
            "=",
            "("
        ]
    },
    "6.5 58 d)": {
        "question": "有多少种不同的方式将 5 个球放到 7 个盒子里，要求每个盒子里最多有 1 个球，如果球与盒都是没有标号的？",
        "answer": "如 b 部分所述，只有一种方法可以做到这一点。",
        "answer_symbols": []
    },
    "6.5 60": {
        "question": "假如一个足球协会中有 32 支球队，将该协会分成两个分会，每个分会都有 16 支球队。将每个分会再分成三个小组。假如中北小组有 5 支球队，该小组的每支球队相互之间要踢四场比赛，每支球队要和该分会其他小组的 11 支球队踢三场比赛，还要和另一个分会的 16 支球队踢两场比赛。要安排中北小组中的一支球队进行比赛，共有多少种不同的方式？",
        "answer": "有 31 支其他队伍要比赛，我们可以用符号 x1, x2, ..., x31 来表示这些队伍。我们被要求列出 4 * 4 + 11 * 3 + 16 * 2 = 81 个这些符号，其中 x1 到 x4 每个恰好出现 4 次，x5 到 x15 每个恰好出现 3 次，x16 到 x31 每个恰好出现 2 次。定理 3 告诉我们可能的列表数量是 81! / (4!^4 * 3!^11 * 2!^16) ≈ 7.35 × 10^101。",
        "answer_symbols": [
            "!",
            "*",
            "+",
            "(",
            ")",
            "^",
            "≈",
            "×"
        ]
    },
    "6.5 61": {
        "question": "假如一个武器巡视员必须对 5 个不同场所中的每个场所巡视两次，每天巡视一个场所。巡视员可以自由选择巡视场所的次序，但他不能连着两天都巡视 X 场所，因为 X 场所是最可疑的场所。那么，该巡视员有多少种不同的方式来巡视这些场所？",
        "answer": "90,720",
        "answer_symbols": []
    },
    "6.5 62": {
        "question": "在 (x_1 + x_2 + ⋯ + x_n)^n 的展开式中，把所有的同类项合并以后有多少个不同的项？",
        "answer": "每个项必须是 Cx1^n1 x2^n2 ... xm^nm 的形式，其中 ni 是非负整数，其总和为 n。那么指定一个项的方法数就是 n1 + n2 + ... + nm = n 的非负整数解的数量，根据定理 2 是 C(m + n - 1, n)。注意，这些项的系数 C 可以使用定理 3 计算——见练习 63。",
        "answer_symbols": [
            "C",
            "^",
            "(",
            ")",
            "+",
            "-",
            "=",
            "…"
        ]
    },
    "6.5 64": {
        "question": "求 (x + y + z)^4 的展开式。",
        "answer": "从习题62中，我们知道有C(3+ 4 - 1, 4) = C(6, 4) = 15项，并且系数来自于习题63。答案是x^4 + y^4 + z^4 + 4x^3y + 4xy^3 + 4x^3z + 4xz^3 + 4y^3z + 4yz^3 + 6x^2y^2 + 6x^2z^2 + 6y^2z^2 + 12x^2yz + 12xy^2z + 12xyz^2。",
        "answer_symbols": [
            "+",
            "^",
            "=",
            "C"
        ]
    },
    "6.5 65": {
        "question": "求 (x + y + z)^10 中的 x^3 y^2 z^5 的系数。",
        "answer": "2520",
        "answer_symbols": []
    },
    "6.5 66": {
        "question": "在 (x + y + z)^100 的展开式中有多少个项？",
        "answer": "根据习题62，答案是C(3+ 100 - 1, 100) = C(102, 100) = C(102, 2) = 5151。",
        "answer_symbols": [
            "+",
            "=",
            "C"
        ]
    },
    "6.6 1": {
        "question": "按照字典顺序排列下列 {1, 2, 3, 4, 5} 的排列： 43521, 15432, 45321, 23451, 23514, 14532, 21345, 45213, 31452, 31542。",
        "answer": "14532, 15432, 21345, 23451, 23514, 31452, 31542, 43521, 45213, 45321",
        "answer_symbols": []
    },
    "6.6 2": {
        "question": "按照字典顺序排列下列 {1, 2, 3, 4, 5, 6} 的排列： 234561, 231456, 165432, 156423, 543216, 541236, 231465, 314562, 432561, 654321, 654312, 453612。",
        "answer": "156423, 165432, 231456, 231465, 234561, 314562, 432561, 435612, 541236, 543216, 654312, 654321",
        "answer_symbols": []
    },
    "6.6 3": {
        "question": "一个计算机目录中文件名字包括 3 个大写字母，接着 1 个数字，其中字母是 A、B 或 C，数字是 1 或 2。以字典顺序列出这些文件名。字母顺序为正常的字母表顺序。",
        "answer": "AAA1, AAA2, AAB1, AAB2, AAC1, AAC2, ABA1, ABA2, ABB1, ABB2, ABC1, ABC2, ACA1, ACA2, ACB1, ACB2, ACC1, ACC2, BAA1, BAA2, BAB1, BAB2, BAC1, BAC2, BBA1, BBA2, BBB1, BBB2, BBC1, BBC2, BCA1, BCA2, BCB1, BCB2, BCC1, BCC2, CAA1, CAA2, CAB1, CAB2, CAC1, CAC2, CBA1, CBA2, CBB1, CBB2, CBC1, CBC2, CCA1, CCA2, CCB1, CCB2, CCC1, CCC2",
        "answer_symbols": []
    },
    "6.6 4": {
        "question": "设一个计算机目录中文件名字包括 3 个数字，接着 2 个小写字母，其中数字是 0、1 或 2，字母是 a 或 b。以字典顺序列出这些文件名。字母顺序为正常的字母表顺序。",
        "answer": "我们的列表将有33 * 22 = 108个项目。这是按字典顺序排列的：000aa, 000ab, 000ba, 000bb, 001aa, 001ab, 001ba, 001bb, 002aa, 002ab, 002ba, 002bb, 010aa, 010ab, 010ba, 010bb, 011aa, 011ab, 011ba, 011bb, 012aa, 012ab, 012ba, 012bb, 020aa, 020ab, 020ba, 020bb, 021aa, 021ab, 021ba, 021bb, 022aa, 022ab, 022ba, 022bb, 100aa, 100ab, 100ba, 100bb, 101aa, 101ab, 101ba, 101bb, 102aa, 102ab, 102ba, 102bb, 110aa, 110ab, 110ba, 110bb, 111aa, 111ab, 111ba, 111bb, 112aa, 112ab, 112ba, 112bb, 120aa, 120ab, 120ba, 120bb, 121aa, 121ab, 121ba, 121bb, 122aa, 122ab, 122ba, 122bb, 200aa, 200ab, 200ba, 200bb, 201aa, 201ab, 201ba, 201bb, 202aa, 202ab, 202ba, 202bb, 210aa, 210ab, 210ba, 210bb, 211aa, 211ab, 211ba, 211bb, 212aa, 212ab, 212ba, 212bb, 220aa, 220ab, 220ba, 220bb, 221aa, 221ab, 221ba, 221bb, 222aa, 222ab, 222ba, 222bb。",
        "answer_symbols": [
            "*",
            "="
        ]
    },
    "6.6 6 a)": {
        "question": "找出按照字典顺序跟在下面每一个排列后面的下一个最大的排列。 a) 1342",
        "answer": "最后一个整数对aj和aj+1（其中aj < aj+1）是a2 = 3和a3 = 4。3右侧大于3的最小整数是4。因此4被放在第二位。然后将整数2和3按顺序放在最后两个位置，给出排列1423。",
        "answer_symbols": [
            "<"
        ]
    },
    "6.6 6 b)": {
        "question": "找出按照字典顺序跟在下面每一个排列后面的下一个最大的排列。 b) 45321",
        "answer": "51234",
        "answer_symbols": []
    },
    "6.6 6 c)": {
        "question": "找出按照字典顺序跟在下面每一个排列后面的下一个最大的排列。 c) 13245",
        "answer": "13254",
        "answer_symbols": []
    },
    "6.6 6 d)": {
        "question": "找出按照字典顺序跟在下面每一个排列后面的下一个最大的排列。 d) 612345",
        "answer": "612354",
        "answer_symbols": []
    },
    "6.6 6 e)": {
        "question": "找出按照字典顺序跟在下面每一个排列后面的下一个最大的排列。 e) 1623547",
        "answer": "1623574",
        "answer_symbols": []
    },
    "6.6 6 f)": {
        "question": "找出按照字典顺序跟在下面每一个排列后面的下一个最大的排列。 f) 23587416",
        "answer": "23587461",
        "answer_symbols": []
    },
    "6.6 7": {
        "question": "使用算法 1 按照字典顺序生成前 4 个正整数的 24 个排列。",
        "answer": "1234, 1243, 1324, 1342, 1423, 1432, 2134, 2143, 2314, 2341, 2413, 2431, 3124, 3142, 3214, 3241, 3412, 3421, 4123, 4132, 4213, 4231, 4312, 4321",
        "answer_symbols": []
    },
    "6.6 8": {
        "question": "使用算法 2 列出集合 {1, 2, 3, 4} 的所有子集。",
        "answer": "第一个子集对应于位串0000，即空集。下一个子集对应于位串0001，即集合{4}。下一个位串是0010，对应于集合{3}，然后是0011，对应于集合{3, 4}。我们继续以这种方式进行，给出剩余的集合：{2}，{2, 4}，{2, 3}，{2, 3, 4}，{1}，{1, 4}，{1, 3}，{1, 3, 4}，{1, 2}，{1, 2, 4}，{1, 2, 3}，{1, 2, 3, 4}。",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "6.6 9": {
        "question": "使用算法 3 列出集合 {1, 2, 3, 4, 5} 的所有的 3 组合。",
        "answer": "{1, 2, 3}, {1, 2, 4}, {1, 2, 5}, {1, 3, 4}, {1, 3, 5}, {1, 4, 5}, {2, 3, 4}, {2, 3, 5}, {2, 4, 5}, {3, 4, 5}",
        "answer_symbols": []
    },
    "6.6 10": {
        "question": "证明：算法 1 按字典顺序生成下一个最大的排列。",
        "answer": "由于新排列在1到j-1的位置上与旧排列相同，并且新排列在j位置上有ak，而旧排列在j位置上有aj，且ak > aj，因此新排列在字典顺序中位于旧排列之后。此外，新排列是在字典顺序中第一个具有a1, a2, ..., aj-1, ak在1到j位置上的排列，而旧排列是最后一个具有a1, a2, ..., aj-1, aj在这些位置上的排列。因为ak是从aj+1, aj+2, ..., an中选择的大于aj的最小数字，所以在这两个排列之间没有其他排列。",
        "answer_symbols": [
            ">",
            ","
        ]
    },
    "6.6 11": {
        "question": "证明：算法 3 按字典顺序生成给定 r 组合后面的下一个最大的 r 组合。",
        "answer": "The bit string representing the next larger r-combination must differ from the bit string representing the original one in position i because positions i + 1, ..., r are occupied by the largest possible numbers. Also ai + 1 is the smallest possible number we can put in position i if we want a combination greater than the original one. Then ai + 2, ..., ai + r - i + 1 are the smallest allowable numbers for positions i + 1 to r. Thus, we have produced the next r-combination.",
        "answer_symbols": [
            "-",
            "+",
            ">",
            "<"
        ]
    },
    "6.6 12": {
        "question": "建立一个算法来生成 n 元素集合的 r 排列。",
        "answer": "一种算法将结合算法3和算法1。使用算法3，我们生成n个元素集合的所有r-组合。在每个阶段，找到每个r-组合后，我们使用算法1（n = r，以及要排列的不同集合而不是{1, 2, ..., n}），生成此组合中元素的所有排列。参见习题13的解答以获取示例。",
        "answer_symbols": [
            "=",
            "{",
            "}",
            ","
        ]
    },
    "6.6 14 a)": {
        "question": "找出对应于下列排列的整数。 a) 246531",
        "answer": "我们发现a1 = 1, a2 = 1, a3 = 2, a4 = 2, a5 = 3。因此这个数是1 * 1! + 1 * 2! + 2 * 3! + 2 * 4! + 3 * 5! = 1 + 2 + 12 + 48 + 360 = 423。",
        "answer_symbols": [
            "=",
            "*",
            "+",
            "!"
        ]
    },
    "6.6 14 b)": {
        "question": "找出对应于下列排列的整数。 b) 12345",
        "answer": "每个ak = 0，所以这个数是0。",
        "answer_symbols": [
            "="
        ]
    },
    "6.6 14 c)": {
        "question": "找出对应于下列排列的整数。 c) 654321",
        "answer": "我们发现a1 = 1, a2 = 2, a3 = 3, a4 = 4, a5 = 5。因此这个数是1 * 1! + 2 * 2! + 3 * 3! + 4 * 4! + 5 * 5! = 1 + 4 + 18 + 96 + 600 = 719 = 6! - 1，正如预期的那样，因为这是最后一个排列。",
        "answer_symbols": [
            "=",
            "*",
            "+",
            "-",
            "!"
        ]
    },
    "6.6 15": {
        "question": "证明：这里描述的对应是 (1, 2, 3, …, n) 的排列的集合与小于 n! 的非负整数之间的双射。",
        "answer": "我们将通过显示它有一个逆来证明它是一个双射。给定一个小于 n! 的正整数，令 a1, a2,..., an−1 为它的康托尔数字。将 n 放在位置 n − an−1；然后显然，an−1 是在排列中跟随 n 的小于 n 的整数的数量。然后将 n − 1 放在自由位置 (n − 1) − an−2，其中我们已经编号了自由位置 1, 2,..., n − 1（排除 n 已经在的位置）。继续直到 1 被放在唯一的空闲位置上。因为我们构造了一个逆，所以这个对应关系是一个双射。",
        "answer_symbols": [
            "!",
            "-",
            "<"
        ]
    },
    "6.6 16 a)": {
        "question": "按照康托尔展开式与练习 12 前面所描述的排列之间的对应找出与下面的整数相对应的 (1, 2, 3, 4, 5) 的排列。 a) 3",
        "answer": "我们找到 3 的康托展开为 1 · 1! + 1 · 2!。因此我们知道 a4 = 0, a3 = 0, a2 = 1, 和 a1 = 1。按照第 15 题解中给出的算法，我们将 5 放在位置 5 - 0 = 5，将 4 放在位置 4 - 0 = 4，将 3 放在位置 3 - 1 = 2，并将 2 放在从右边算起第 1 个可用的位置，即位置 1。因此答案是 23145。",
        "answer_symbols": [
            "·",
            "!",
            "+",
            "=",
            "-",
            "从"
        ]
    },
    "6.6 16 b)": {
        "question": "按照康托尔展开式与练习 12 前面所描述的排列之间的对应找出与下面的整数相对应的 (1, 2, 3, 4, 5) 的排列。 b) 89",
        "answer": "我们发现 89 = 1 · 1! + 2 · 2! + 2 · 3! + 3 · 4!。因此我们按顺序插入 5、4、3 和 2，分别跳过 3、2、2 和 1 个从右向左数的可用位置，得到 35421。",
        "answer_symbols": [
            "=",
            "·",
            "!",
            "+",
            "从"
        ]
    },
    "6.6 16 c)": {
        "question": "按照康托尔展开式与练习 12 前面所描述的排列之间的对应找出与下面的整数相对应的 (1, 2, 3, 4, 5) 的排列。 c) 111",
        "answer": "我们发现 111 = 1 · 1! + 1 · 2! + 2 · 3! + 4 · 4!。因此我们按顺序插入 5、4、3 和 2，分别跳过 4、2、1 和 1 个从右向左数的可用位置，得到 52431。",
        "answer_symbols": [
            "=",
            "·",
            "!",
            "+",
            "从"
        ]
    },
    "6.6 17": {
        "question": "开发一个以练习 14 描述的对应为基础的算法来生成 n 元素集合所有的排列。",
        "answer": "过程 Cantor 排列 (n, i: 整数，且 n ≥ 1 和 0 ≤ i < n!) x := n 对于 j := 1 到 n pj := 0 对于 k := 1 到 n − 1 c := x / (n − k)! x := x − c * (n − k)! h := n 当 ph = 0 h := h − 1 对于 j := 1 到 c h := h − 1 当 ph = 0 h := h − 1 ph := n − k + 1 h := 1 当 ph = 0 h := h + 1 ph := 1 {p1p2... pn 是与 i 对应的排列}",
        "answer_symbols": [
            ":=",
            "+",
            "-",
            "*",
            "/",
            "!"
        ]
    },
    "6 Supplementary Exercises 11": {
        "question": "一个幸运饼干公司制作 213 种不同的幸运饼干。一个学生在一个使用这家饼干公司的饼干的餐馆用餐。这个餐馆在用餐最后为每一个客户提供一块幸运饼干。这个学生在这家餐馆用餐次数最多能是多少以保证不会吃到同一种饼干 4 次？",
        "answer": "639",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 16": {
        "question": "证明：在任何 n+1 个不超过 2n 的正整数中必存在 2 个数互素。",
        "answer": "Partition the set of numbers from 1 to 2n into the n pigeonholes {1, 2}, {3, 4}, ..., {2n − 1, 2n}. If we have n + 1 numbers from this set (the pigeons), then two of them must be in the same hole. This means that among our collection are two consecutive numbers. Clearly, consecutive numbers are relatively prime (since every common divisor must divide their difference, 1).",
        "answer_symbols": [
            "{",
            "}",
            ",",
            "-",
            "+",
            "∈"
        ]
    },
    "6 Supplementary Exercises 18": {
        "question": "证明：如果放 5 个点在边长为 2 的正方形中，那么其中至少有 2 个点的距离不超过根号 2。",
        "answer": "Divide the interior of the square, with lines joining the midpoints of opposite sides, into four 1 × 1 squares. By the pigeonhole principle, at least two of the five points must be in the same small square. The furthest apart two points in a square could be is the length of the diagonal, which is √2 for a square 1 unit on a side.",
        "answer_symbols": [
            "×",
            "√",
            "="
        ]
    },
    "6 Supplementary Exercises 1 a)": {
        "question": "证明：对于给定的 k 存在 k^² 个这样的三元组，因此有 ∑ k^² 个这样的三元组。",
        "answer": "151,200",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 1 b)": {
        "question": "证明：具有 0 ≤ i < j < k 的三元组个数和 0 ≤ j < i < k 的三元组个数都等于 C(n+1, 3)。",
        "answer": "1,000,000",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 1 c)": {
        "question": "证明：具有 0 ≤ i = j < k 的三元组个数等于 C(n+1, 2)。",
        "answer": "210",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 1 d)": {
        "question": "把 a)、b) 和 c) 组合起来得出 ∑ k^² = 2C(n+1, 3) + C(n+1, 2) = n(n+1)(2n+1)/6。",
        "answer": "5005",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 2 a)": {
        "question": "从 6 个不同的项中选 10 项有多少种方式？若这些项是有序选择的并且不允许重复。",
        "answer": "没有办法做到这一点，因为没有足够的项目。",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 2 b)": {
        "question": "从 6 个不同的项中选 10 项有多少种方式？若这些项是有序选择的并且允许重复。",
        "answer": "610 = 60,466,176",
        "answer_symbols": [
            "="
        ]
    },
    "6 Supplementary Exercises 2 c)": {
        "question": "从 6 个不同的项中选 10 项有多少种方式？若这些项是无序选择的并且不允许重复。",
        "answer": "没有办法做到这一点，因为没有足够的项目。",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 2 d)": {
        "question": "从 6 个不同的项中选 10 项有多少种方式？若这些项是无序选择的并且允许重复。",
        "answer": "C(6 + 10 - 1, 10) = C(15, 10) = C(15, 5) = 3003",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "-",
            ",",
            "=",
            "C"
        ]
    },
    "6 Supplementary Exercises 3": {
        "question": "一个考试包含 100 道真假判断题。如果答案可以空缺，一个学生回答这些考题可能有多少种不同的方式？",
        "answer": "3^100",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 4": {
        "question": "有多少个 10 位位串以 000 开始或以 111 结束？",
        "answer": "有 27 个长度为 10 的位串以 000 开头，因为最后 7 位中的每一位都可以选择两种方式之一。同样，有 26 个长度为 10 的位串以 1111 结尾，有 23 个长度为 10 的位串既以 000 开头又以 1111 结尾（因为只有中间的 3 位可以自由选择）。因此根据包含-排除原理，答案是 27 + 26 - 23 = 184。",
        "answer_symbols": [
            "+",
            "-",
            "="
        ]
    },
    "6 Supplementary Exercises 5": {
        "question": "字母表 {a, b, c} 上有多少个 10 位字符串恰有 3 个 a 或恰有 4 个 b？",
        "answer": "24,600",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 6": {
        "question": "一个校园电话系统的内部电话号码由 5 个数字组成，且第一个数字不等于 0。在这个系统中可以分配多少个不同的电话号码？",
        "answer": "9 · 10 · 10 · 10 · 10 = 90,000",
        "answer_symbols": [
            "·",
            "="
        ]
    },
    "6 Supplementary Exercises 7 a)": {
        "question": "一个冰淇淋店有 28 种不同味道的冰淇淋、8 种不同的果汁和 12 种配料。如果每种味道的可以不止 1 份，并且不考虑次序，那么取 3 份冰淇淋放在一个盘中有多少种不同的方式？",
        "answer": "4060",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 7 b)": {
        "question": "一个冰淇淋店有 28 种不同味道的冰淇淋、8 种不同的果汁和 12 种配料。如果一个小圣代包含 1 份冰淇淋、1 种果汁和 1 种配料，那么有多少种不同的小圣代？",
        "answer": "2688",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 7 c)": {
        "question": "一个冰淇淋店有 28 种不同味道的冰淇淋、8 种不同的果汁和 12 种配料。如果一个大圣代包含 3 份冰淇淋、2 种果汁和 3 种配料。其中每种味道的冰淇淋可以不止 1 个并且不考虑次序，每种果汁只能用 1 次且不考虑次序，同时每种配料也只能用 1 次并且不考虑次序。那么有多少种不同的大圣代？",
        "answer": "25,009,600",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 8 a)": {
        "question": "有多少个小于 1000 的正整数？恰有 3 个十进制数字？",
        "answer": "从 100 到 999 的所有整数都有三个十进制数字，共有 999 - 100 + 1 = 900 个这样的数字。",
        "answer_symbols": [
            "-",
            "+",
            "="
        ]
    },
    "6 Supplementary Exercises 8 b)": {
        "question": "有多少个小于 1000 的正整数？有奇数个十进制数字？",
        "answer": "除了 900 个三位数外，还有 9 个一位正整数，总共 909 个。",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "6 Supplementary Exercises 8 c)": {
        "question": "有多少个小于 1000 的正整数？至少有 1 个十进制数字等于 9？",
        "answer": "有一个一位数包含 9。在两位数中，有 10 个从 90 到 99 的数字，加上 19, 29, ..., 89 这 8 个数字，总共 18 个。在三位数中，有 100 个从 900 到 999 的数字；并且在每个世纪（从 100 到 800）中，再次有 1 + 18 = 19 个至少包含一个 9 的数字；这给出总计 100 + 8 · 19 = 252。因此我们的最终答案是 1 + 18 + 252 = 271。",
        "answer_symbols": [
            "+",
            "=",
            "·"
        ]
    },
    "6 Supplementary Exercises 8 d)": {
        "question": "有多少个小于 1000 的正整数？没有奇数个十进制数字？",
        "answer": "由于我们只能使用偶数数字，因此有 53 = 125 种方法来指定一个三位数，允许前导 0。然而，由于数字 0 = 000 不在我们的集合中，我们需要减去 1，得出答案 124。",
        "answer_symbols": [
            "=",
            "-",
            "="
        ]
    },
    "6 Supplementary Exercises 8 e)": {
        "question": "有多少个小于 1000 的正整数？有两个连续的十进制数字等于 5？",
        "answer": "符合条件的数字要么是 d55 或 55d 形式，其中 d ≠ 5，或者是 555。由于 d 可以是任意九个数字之一，因此有 9 + 9 + 1 = 19 个这样的数字。",
        "answer_symbols": [
            "+",
            "=",
            "≠"
        ]
    },
    "6 Supplementary Exercises 8 f)": {
        "question": "有多少个小于 1000 的正整数？是回文（即正读和倒读是一样的）？",
        "answer": "所有 9 个一位数都是回文数。9 个两位数 11, 22, ..., 99 是回文数。对于三位数，第一位（必须等于第三位）可以是 9 个非零数字中的任意一个，第二位可以是 10 个数字中的任意一个，共有 9 · 10 = 90 种可能性。因此答案是 9 + 9 + 90 = 108。",
        "answer_symbols": [
            "+",
            "=",
            "·"
        ]
    },
    "6 Supplementary Exercises 9 a)": {
        "question": "当用十进制记法写出从 1 到 1000 的数时，有多少个下面的数字被用到？0",
        "answer": "192",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 9 b)": {
        "question": "当用十进制记法写出从 1 到 1000 的数时，有多少个下面的数字被用到？1",
        "answer": "301",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 9 c)": {
        "question": "当用十进制记法写出从 1 到 1000 的数时，有多少个下面的数字被用到？2",
        "answer": "300",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 9 d)": {
        "question": "当用十进制记法写出从 1 到 1000 的数时，有多少个下面的数字被用到？9",
        "answer": "300",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 10": {
        "question": "有黄道十二宫，需要有多少人才能保证其中至少 6 个人在同一宫？",
        "answer": "使用广义鸽巢原理，我们看到需要 5 × 12 + 1 = 61 人。",
        "answer_symbols": [
            "×",
            "+",
            "="
        ]
    },
    "6 Supplementary Exercises 12": {
        "question": "为保证至少 2 个人生在一周的同一天和同一个月（可以不在同一年），那么需要多少人？",
        "answer": "有 7 × 12 = 84 个日-月组合。因此需要 85 人以确保其中两人出生在同一天和同一月份。",
        "answer_symbols": [
            "×",
            "=",
            "+"
        ]
    },
    "6 Supplementary Exercises 13": {
        "question": "证明：在 10 个不超过 50 的正整数集合中至少有 2 个不同的 5 元素子集有同样的和。",
        "answer": "最大可能和是 240，最小可能和是 15。因此可能的和的数量是 226。由于一个 10 元素集合的 5 元素子集有 252 个，根据抽屉原理，至少有两个具有相同的和。",
        "answer_symbols": [
            "+",
            "−"
        ]
    },
    "6 Supplementary Exercises 14": {
        "question": "一包棒球卡有 20 张。如果总共有 550 种不同的卡，那么需要买多少包卡才能保证其中的 2 张卡是一样的。",
        "answer": "至少需要 551 张卡片才能确保至少有两张是相同的。由于卡片是以 20 张为一组包装的，因此需要 551 / 20 = 28 组。",
        "answer_symbols": [
            "/",
            "="
        ]
    },
    "6 Supplementary Exercises 15": {
        "question": "从一副牌中需要选多少张牌才能保证至少选中 2 张 A？",
        "answer": "a) 50 b) 50 c) 14 d) 17",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 17": {
        "question": "证明：在 m 个整数的序列中存在若干个连续的整数其和可被 m 整除。",
        "answer": "设 a₁, a₂,..., aₘ 是整数，令 dᵢ = Σ (从 j=1 到 i) aⱼ。如果对于某个 i 有 dᵢ ≡ 0 (mod m)，则完成。否则 d₁ mod m, d₂ mod m,..., dₘ mod m 是 m 个值在 {1, 2,..., m − 1} 中的整数。根据抽屉原理，存在 1 ≤ k < l ≤ m 使得 dₖ = dₗ。那么 Σ (从 j=k+1 到 l) aⱼ = dₗ − dₖ ≡ 0 (mod m)。",
        "answer_symbols": [
            "≡",
            "Σ",
            "₁",
            "₂",
            "ₘ",
            "ₖ",
            "ₗ",
            "−",
            "≤",
            "<",
            "="
        ]
    },
    "6 Supplementary Exercises 19": {
        "question": "证明：一个有理数的十进制展开式一定从某一点出现重复。",
        "answer": "有理数 a/b 的十进制展开可以通过除法获得，其中 a 写成带小数点并后跟任意长零串的形式。基本步骤是找到商的下一位，即 r/b，其中 r 是余数加上被除数的下一位。当前余数是从前一位余数减去 b 乘以商的前一位得到的。最终被除数只剩下 0。此外，只有 b 种可能的余数。因此，在某一点上，根据抽屉原理，我们将再次遇到相同的情况。从那一点开始，计算必须遵循相同的模式。特别是，商将重复。",
        "answer_symbols": [
            "/",
            "+",
            "−",
            "*"
        ]
    },
    "6 Supplementary Exercises 20": {
        "question": "曾经有一种计算机病毒通过感染的邮件信息感染了一台计算机，该病毒在这台计算机的邮箱中向 100 个邮件地址都发送了自身的副本。那么，当该计算机将感染的邮件信息发送 5 次之后，它所感染的不同计算机的最大数量是多少？",
        "answer": "If the worm never gets sent to the same computer twice, then it will infect 100 computers on the first round of forwarding, 100^2 = 10,000 other computers on the second round of forwarding, and so on. Therefore, the maximum number of different computers this one computer can infect is 100 + 100^2 + 100^3 + 100^4 + 100^5 = 10,101,010,100. This figure of ten billion is probably comparable to the total number of computers in the world.",
        "answer_symbols": [
            "+",
            "^"
        ]
    },
    "6 Supplementary Exercises 22 a)": {
        "question": "求 n，如果 P(n, 2) = 110",
        "answer": "We want to solve n(n − 1) = 110, or n^² − n − 110 = 0. Simple algebra gives n = 11 (we ignore n = −10, since we need a positive integer for our answer).",
        "answer_symbols": [
            "(",
            ")",
            "-",
            "=",
            "²"
        ]
    },
    "6 Supplementary Exercises 22 b)": {
        "question": "求 n，如果 P(n, n) = 5040",
        "answer": "We recall that 7! = 5040, so the answer is 7.",
        "answer_symbols": [
            "!",
            "="
        ]
    },
    "6 Supplementary Exercises 22 c)": {
        "question": "求 n，如果 P(n, 4) = 12P(n, 2)",
        "answer": "We need to solve the equation n(n − 1)(n − 2)(n − 3) = 12n(n − 1). Since we have n ≥ 4 in order for P(n, 4) to be defined, this equation reduces to (n − 2)(n − 3) = 12, or n^² − 5n − 6 = 0. Simple algebra gives n = 6 (we ignore the solution n = −1 since n needs to be a positive integer).",
        "answer_symbols": [
            "(",
            ")",
            "-",
            "=",
            "²",
            "≥"
        ]
    },
    "6 Supplementary Exercises 24": {
        "question": "证明：如果 n 和 r 是非负整数且 n ≥ r，则 P(n+1, r) = P(n, r)(n+1)/(n+1-r)",
        "answer": "An algebraic proof is straightforward. We will give a combinatorial proof of the equivalent identity P(n + 1, r)(n + 1 − r) = (n + 1)P(n, r) (and in fact both of these equal P(n + 1, r + 1)). Consider the problem of writing down a permutation of r + 1 objects from a collection of n + 1 objects. We can first write down a permutation of r of these objects (P(n + 1, r) ways to do so), and then write down one more object (and there are n + 1 − r objects left to choose from), thereby obtaining the left-hand side; or we can first choose an object to write down first (n + 1 to choose from), and then write down a permutation of length r using the n remaining objects (P(n, r) ways to do so), thereby obtaining the right-hand side.",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "-",
            "=",
            "P"
        ]
    },
    "6 Supplementary Exercises 25": {
        "question": "设 S 是 n 元素集合，存在多少个有序对 (A, B) 使得 A 和 B 是 S 的子集且 A ⊆ B？[提示：证明 S 中的每个元素属于 A、B-A 或 S-B。]",
        "answer": "3n^²",
        "answer_symbols": [
            "²"
        ]
    },
    "6 Supplementary Exercises 26": {
        "question": "通过构造在集合的具有偶数个元素的子集与具有奇数个元素的子集之间的对应，给出关于 5.4 节推论 2 的组合证明。[提示：取集合的一个元素 a，如下构造对应：如果 a 不在子集中就把它放到子集中；如果 a 在子集中就把它从子集中取出。]",
        "answer": "First note that Corollary 2 of Section 6.4 is equivalent to the assertion that the sum of the numbers C(n, k) for even k is equal to the sum of the numbers C(n, k) for odd k. Since C(n, k) counts the number of subsets of size k of a set with n elements, we need to show that a set has as many even-sized subsets as it has odd-sized subsets. Define a function f from the set of all subsets of A to itself (where A is a set with n elements, one of which is a), by setting f(B) = B ∪ {a} if a ∉ B, and f(B) = B − {a} if a ∈ B. It is clear that f takes even-sized subsets to odd-sized subsets and vice versa, and that f is one-to-one and onto (indeed, f^⁻¹ = f). Therefore, f restricted to the set of subsets of odd size gives a one-to-one correspondence between that set and the set of subsets of even size.",
        "answer_symbols": [
            "∪",
            "−",
            "∈",
            "∉",
            "⁻¹",
            "="
        ]
    },
    "6 Supplementary Exercises 27": {
        "question": "设 n 和 r 是非负整数且 r < n。证明 C(n, r-1) = C(n+2, r+1) - 2C(n+1, r+1) + C(n, r+1)",
        "answer": "C(n + 2, r + 1) = C(n + 1, r + 1) + C(n + 1, r) = 2C(n + 1, r + 1) − C(n + 1, r + 1) + C(n + 1, r) = 2C(n + 1, r + 1) − (C(n, r + 1) + C(n, r)) + (C(n, r) + C(n, r − 1)) = 2C(n + 1, r + 1) − C(n, r + 1) + C(n, r − 1)",
        "answer_symbols": [
            "=",
            "+",
            "−",
            "(",
            ")",
            "C",
            "₁",
            "₂",
            "ₙ",
            "₊",
            "₋"
        ]
    },
    "6 Supplementary Exercises 28": {
        "question": "使用数学归纳法证明 ∑(j=2)^n C(j, 2) = C(n+1, 3) 其中 n 是大于 1 的整数。",
        "answer": "The base case is n = 2, in which case the identity simply states that 1 = 1. Assume the inductive hypothesis, that ∑_{j=2}^n C(j, 2) = C(n + 1, 3). Then ∑_{j=2}^{n+1} C(j, 2) = (∑_{j=2}^n C(j, 2)) + C(n + 1, 2) = C(n + 1, 3) + C(n + 1, 2) = C((n + 1) + 1, 3), as desired. The last equality made use of Pascal’s identity.",
        "answer_symbols": [
            "∑",
            "C",
            "(",
            ")",
            "+",
            "=",
            "j",
            "n"
        ]
    },
    "6 Supplementary Exercises 29": {
        "question": "证明：如果 n 是整数，则 ∑(k=0)^n 3^k C(n, k) = 4^n",
        "answer": "将 x = 1 和 y = 3 代入二项式定理。",
        "answer_symbols": [
            "=",
            "+",
            "−",
            "*",
            "/"
        ]
    },
    "6 Supplementary Exercises 30": {
        "question": "证明 ∑(i=0)^n ∑(j=i+1)^n 1 = C(n, 2)，n 为大于等于 2 的整数。",
        "answer": "Each pair of values of i and j with 1 ≤ i < j ≤ n contributes a 1 to this sum, so the sum is just the number of such pairs. But this is clearly the number of ways to choose two integers from {1, 2, ..., n}, which is C(n, 2), also known as (n choose 2).",
        "answer_symbols": [
            "≤",
            "<",
            "C",
            "(",
            ")",
            "choose"
        ]
    },
    "6 Supplementary Exercises 31": {
        "question": "证明 ∑(i=0)^n ∑(j=i+1)^n 1 = C(n, 3)，n 为大于等于 3 的整数。",
        "answer": "两边都表示从 {1, 2,..., n} 中选择三个不同的数 {i, j, k} 且 i < j < k 的方法数。",
        "answer_symbols": [
            "<"
        ]
    },
    "6 Supplementary Exercises 32 a)": {
        "question": "在这个练习中我们将推导一个关于 n 个最小正整数的平方和的公式。我们将用两种方式计数三元组 (i, j, k) 的个数，其中 i, j 和 k 是整数且满足 0 ≤ i < k, 0 ≤ j < k, 1 ≤ k ≤ n。证明：对于给定的 k 存在 k^² 个这样的三元组，因此有 ∑ k^² 个这样的三元组。",
        "answer": "对于固定的 k，一个三元组完全由选择 i 和 j 来确定；因为每个都可以以 k 种方式选择（每个可以是 0 到 k-1 中的任意数字），所以有 k^² 种方法来选择这个三元组。将所有可能的 k 值相加就得到了所指示的总和。",
        "answer_symbols": [
            "k",
            "²",
            "∑"
        ]
    },
    "6 Supplementary Exercises 32 b)": {
        "question": "在这个练习中我们将推导一个关于 n 个最小正整数的平方和的公式。我们将用两种方式计数三元组 (i, j, k) 的个数，其中 i, j 和 k 是整数且满足 0 ≤ i < k, 0 ≤ j < k, 1 ≤ k ≤ n。证明：具有 0 ≤ i < j < k 的三元组个数和 0 ≤ j < i < k 的三元组个数都等于 C(n+1, 3)。",
        "answer": "这种类型的三元组完全由知道数字集 {i, j, k} 来确定，因为顺序是固定的。因此，每种类型的三元组的数量就是从集合 {0, 1, 2, ..., n} 中选择 3 个元素的集合的数量，这显然是 C(n + 1, 3).",
        "answer_symbols": [
            "{",
            "}",
            "C",
            "+",
            ","
        ]
    },
    "6 Supplementary Exercises 32 c)": {
        "question": "在这个练习中我们将推导一个关于 n 个最小正整数的平方和的公式。我们将用两种方式计数三元组 (i, j, k) 的个数，其中 i, j 和 k 是整数且满足 0 ≤ i < k, 0 ≤ j < k, 1 ≤ k ≤ n。证明：具有 0 ≤ i = j < k 的三元组个数等于 C(n+1, 2)。",
        "answer": "为了使 i 等于 j（两者都小于 k），我们需要从 {0, 1, 2, ..., n} 中选择两个元素，用较大的那个作为 k，较小的那个作为 i 和 j。因此，这样的选择数量与该集合的 2 元素子集的数量相同，即 C(n + 1, 2).",
        "answer_symbols": [
            "{",
            "}",
            "C",
            "+",
            ","
        ]
    },
    "6 Supplementary Exercises 32 d)": {
        "question": "把这个练习中的 a)、b) 和 c) 组合起来得出 ∑ k^² = 2C(n+1, 3) + C(n+1, 2) = n(n+1)(2n+1)/6",
        "answer": "这部分本身就是证明。最后一个等式是从初等代数得出的。",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 33": {
        "question": "设 n ≥ 4，有多少个 n 位位串恰好 01 在其中出现两次？",
        "answer": "C(n + 1, 5)",
        "answer_symbols": [
            "C",
            "(",
            ")"
        ]
    },
    "6 Supplementary Exercises 34 a)": {
        "question": "证明：具有 2d-1 个元素的集合 S 的所有 d 子集构成的子集簇不是可 2 涂色的。",
        "answer": "如果我们对 S 的 2d - 1 个元素进行二染色，那么必须至少有一种颜色的元素不少于 d 个（如果两种颜色的元素都少于或等于 d-1 个，则只有 2d-2 个元素被染色）；这只是广义鸽巢原理的一个应用。因此存在一个不包含两种颜色的 d 元子集，违反了可二染色的条件。",
        "answer_symbols": [
            "-",
            "<=",
            "=",
            "∑"
        ]
    },
    "6 Supplementary Exercises 34 b)": {
        "question": "证明：m(2) = 3。",
        "answer": "我们必须证明每一个包含少于三个集合且每个集合包含两个元素的集合族都是可二染色的，并且存在一个包含三个集合且每个集合包含两个元素的集合族是不可二染色的。第二个陈述可以从 (a) 部分得出，取 d = 2（这三个集合是 {1, 2}、{1, 3} 和 {2, 3}）。另一方面，如果我们有两个或更少的每个包含两个元素的集合，那么我们可以用不同的颜色给第一个集合的两个元素上色，并且我们不能被阻止正确地上色第二个集合，因为它必须包含不在第一个集合中的一个元素。",
        "answer_symbols": [
            "{",
            "}",
            "="
        ]
    },
    "6 Supplementary Exercises 34 c)": {
        "question": "证明：m(3) = 7。[提示：证明 {1, 3, 5}, {1, 2, 6}, {1, 4, 7}, {2, 3, 4}, {2, 5, 7}, {3, 6, 7}, {4, 5, 6} 不是可 2 涂色的。然后证明所有具有 3 个元素的 6 个集合的集合簇都是可 2 涂色的。]",
        "answer": "首先，我们证明给定的集合族是不可二染色的。不失一般性，假设 1 是红色。如果 2 是红色，那么 6 必须是蓝色（第二个集合）。因此，要么 4 要么 5 必须是红色（第七个集合），这意味着 3 必须是蓝色（第一个或第四个集合）。这将迫使 7 变成红色（第六个集合），这又将迫使 4 和 5 都变成蓝色（第三个和第五个集合），产生矛盾。因此 2 是蓝色。如果 3 是红色，那么我们可以推断出 5 是蓝色，7 是红色，6 是蓝色，4 是蓝色，使得最后一个集合上色不当。因此 3 是蓝色。这表明 4 是红色，因此 7 是蓝色，5 和 6 是红色，又产生矛盾。所以给定的集合族不能被二染色。接下来我们必须证明所有包含六个集合且每个集合包含三个元素的集合族都是可二染色的。由于在 S 中有更多的元素只会使集合族更容易被二染色，我们可以假设 S 只有五个元素；设 S = {a, b, c, d, e}。由于集合族中元素出现的次数为 18 次，某个元素，比如说 a，必须至少出现四次（因为 3 * 5 < 18）。如果 a 出现在六个集合中，那么我们可以将 a 染成红色，其余元素染成蓝色。如果 a 出现在五个集合中，不妨假设 b 和 c 出现在第六个集合中。那么我们可以将 a 和 b 染成红色，其余元素染成蓝色。最后，如果 a 只出现在四个集合中，那么剩下两个集合只有四个元素，因此它们必须共享一对元素，比如说 b 和 c。再次将 a 和 b 染成红色，其余元素染成蓝色，就得到了所需的染色方案。",
        "answer_symbols": [
            "{",
            "}",
            "<",
            "*",
            "="
        ]
    },
    "6 Supplementary Exercises 35": {
        "question": "一个教授为一次离散数学考试出了 20 道多选题，每道题可能的答案为 a、b、c 或 d。如果具有答案 a、b、c 和 d 的试题数分别为 8、3、4 和 5，且试题可以用任意的顺序安排，那么可能有多少种不同的答案。",
        "answer": "3,491,888,400",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 36": {
        "question": "8 个人围圆桌就座有多少种不同的安排？其中如果一种安排通过旋转能从另一种安排得到，那么就认为这两种安排是一样的。",
        "answer": "我们不妨假设第一个人坐在最北边的座位上。然后剩下的 7 个人有 P(7, 7) 种坐法，因为他们形成了一个从第一个人开始顺时针排列的排列。因此答案是 7! = 5040。",
        "answer_symbols": [
            "P",
            "!",
            "="
        ]
    },
    "6 Supplementary Exercises 37": {
        "question": "把 24 个学生分给 5 个指导教师有多少种方式？",
        "answer": "5243939",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 38": {
        "question": "一蒲式耳包含 20 个不可辨别的 Delicious 苹果、20 个不可辨别的 Macintosh 苹果和 20 个不可辨别的 Granny Smith 苹果，从其中选 12 个苹果，如果每类至少选 3 个，有多少种方式？",
        "answer": "我们需要知道方程 d + m + g = 12 的解的个数，其中 d, m, 和 g 是大于或等于 3 的整数。这等价于求方程 d' + m' + g' = 3 的非负整数解的个数，其中 d' = d - 3, m' = m - 3, 和 g' = g - 3。根据第 6.5 节的定理 2，答案是 C(3 + 3 - 1, 3) = C(5, 3) = 10。",
        "answer_symbols": [
            "+",
            "=",
            "-",
            "C",
            ","
        ]
    },
    "6 Supplementary Exercises 40 a)": {
        "question": "可以构成多少个不同的字符串？",
        "answer": "根据第 6.5 节的定理 3，答案是 10! / (3! 2! 2!) = 151,200。",
        "answer_symbols": [
            "!",
            "/",
            "(",
            ")",
            ","
        ]
    },
    "6 Supplementary Exercises 40 b)": {
        "question": "其中有多少字符串以 P 开始和结束？",
        "answer": "如果我们固定开头和结尾，那么问题只涉及 8 个字母，答案是 8! / (2! 2!) = 10,080。",
        "answer_symbols": [
            "!",
            "/",
            "(",
            ")",
            ","
        ]
    },
    "6 Supplementary Exercises 40 c)": {
        "question": "在多少个字符串中有 3 个连续的 P？",
        "answer": "如果我们固定开头和结尾，那么问题只涉及 8 个字母，答案是 8! / (2! 2!) = 10,080。",
        "answer_symbols": [
            "!",
            "/"
        ]
    },
    "6 Supplementary Exercises 42": {
        "question": "一个交通逃逸事故的证人告诉警察，肇事汽车的车牌包含 3 个字母后面跟着 3 个数字，以字母 AS 开始且包含数字 1 和 2。有多少不同的车牌符合这个描述？",
        "answer": "There are 26 choices for the third letter. If the digit part of the plate consists of the digits 1, 2, and d, where d is different from 1 or 2, then there are 8 choices for d and 3! = 6 choices for a permutation of these digits. If d = 1 or 2, then there are 2 choices for d and 3 choices for a permutation. Therefore the answer is 26 * (8 * 6 + 2 * 3) = 1404.",
        "answer_symbols": [
            "!",
            "*",
            "+",
            "=",
            "(",
            ")"
        ]
    },
    "6 Supplementary Exercises 43": {
        "question": "有多少种方式把 n 个相同的物体放入 m 个不同的容器而使得没有一个容器是空的？",
        "answer": "如果 n < m，则为 0；如果 n ≥ m，则为 C(n − 1, n − m)",
        "answer_symbols": [
            "<",
            "≥",
            "C",
            "(",
            ")",
            "−"
        ]
    },
    "6 Supplementary Exercises 44": {
        "question": "6 个男孩和 8 个女孩坐在一排椅子上，如果没有两个男孩相邻，有多少种方式？",
        "answer": "Let us look at the girls first. There are P(8, 8) = 8! = 40320 ways to order them relative to each other. This much work produces 9 gaps between girls (including the ends), in each of which at most one boy may sit. We need to choose, in order without repetition, 6 of these gaps, and this can be done in P(9, 6) = 60480 ways. Therefore the answer is, by the product rule, 40320 * 60480 = 2,438,553,600.",
        "answer_symbols": [
            "!",
            "*",
            "=",
            "(",
            ")",
            ","
        ]
    },
    "6 Supplementary Exercises 46 a)": {
        "question": "物体与盒子都是有标号的？",
        "answer": "This is a straightforward application of the product rule; there are 6^5 = 7776 ways to do this, because there are 6 choices for each of the 5 objects.",
        "answer_symbols": [
            "^",
            "="
        ]
    },
    "6 Supplementary Exercises 46 b)": {
        "question": "物体是有标号的，但盒子是没有标号的？",
        "answer": "This is similar to Exercise 50 in Section 6.5. We compute this using the formulae: S(5, 1) = 1 * 1! * (1) = 1, S(5, 2) = 1 * 2! * (32 - 2) = 15, S(5, 3) = 1 * 3! * (243 - 96 + 3) = 25, S(5, 4) = 1 * 4! * (1024 - 972 + 192 - 4) = 10, S(5, 5) = 1 * 5! * (3125 - 5120 + 2430 - 320 + 5) = 1. 5 ∑ j=1 S(5, j) = 1 + 15 + 25 + 10 + 1 = 52",
        "answer_symbols": [
            "!",
            "*",
            "-",
            "+",
            "=",
            "(",
            ")",
            "∑",
            "^"
        ]
    },
    "6 Supplementary Exercises 46 c)": {
        "question": "物体是没有标号的，但盒子是有标号的？",
        "answer": "This is asking for the number of solutions to x1 + x2 + x3 + x4 + x5 + x6 = 5 in nonnegative integers. By Theorem 2 (see also Example 5) in Section 6.5, the answer is C(6 + 5 - 1, 5) = C(10, 5) = 252.",
        "answer_symbols": [
            "+",
            "-",
            "=",
            "(",
            ")",
            ","
        ]
    },
    "6 Supplementary Exercises 46 d)": {
        "question": "物体与盒子都是没有标号的？",
        "answer": "This is asking for the number of partitions of 5 (into at most six parts, but that is moot). We list them: 5 = 5, 5 = 4 + 1, 5 = 3 + 2, 5 = 3 + 1 + 1, 5 = 2 + 2 + 1, 5 = 2 + 1 + 1 + 1, 5 = 1 + 1 + 1 + 1 + 1. Therefore the answer is 7.",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "6 Supplementary Exercises 39": {
        "question": "方程 x₁ + x₂ + x₃ = 17 有多少个非负整数解？",
        "answer": "a) 45 b) 57 c) 12",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 41": {
        "question": "10 元素集合有多少个子集？",
        "answer": "a) 386 b) 564",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 45": {
        "question": "将 6 个物体放入 5 个盒子中有多少种方式，如果",
        "answer": "a) 15,625 b) 202 c) 210 d) 10",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 47": {
        "question": "计算下列第一类斯特林数。",
        "answer": "a) 3 b) 11 c) 6 d) 10",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 48": {
        "question": "证明如果 n 为正整数，则 ∑ c(n, j) = n!",
        "answer": "One way to look at this involves what is called the cycle structure of a permutation. Think of the people as the numbers from 1 to n. Given a permutation π of {1, 2, ..., n}, we can write down the cycles the result from applying this permutation. Each cycle can be viewed as a list of the people sitting at a circular table, in clockwise order. The first cycle contains 1, π(1), π(π(1)), ..., until we eventually return to 1 (which must happen because permutations are one-to-one functions). If k is the first number not in the first cycle, then the second cycle consists of k, π(k), π(π(k)), ..., and so on. For example, the permutation that sends x to x + 3 on a 12-hour clock has cycle structure (1, 4, 7, 10), (2, 5, 8, 11), (3, 6, 9, 12). Thus each of the n! permutations gives rise to a seating of n people around j circular tables for some j between 1 and n inclusive. Conversely, such a seating gives us a permutation—π(x) is the number clockwise from x at whatever table x is at (which could be x itself). The identity follows from this discussion.",
        "answer_symbols": [
            "→",
            "π",
            "(",
            ")",
            "+",
            ",",
            "!"
        ]
    },
    "6 Supplementary Exercises 49": {
        "question": "证明如果 n 为正整数，n ≥ 3，则 c(n, n-2) = (3n-1)C(n, 3)/4",
        "answer": "有两种可能性：三个人坐在一张桌子旁，其他人都单独坐，这可以以 2C(n, 3) 种方式完成（选择三个人并将他们安排在两种安排之一中），或者两个人一组地坐在两张桌子旁，其他人都单独坐，这可以以 3C(n, 4) 种方式完成（选择四个人，然后选择三种配对方式之一）。2C(n, 3) + 3C(n, 4) 和 (3n − 1)C(n, 3)/4 都等于 n^⁴/8 − 5n^³/12 + 3n^²/8 − n/12。",
        "answer_symbols": [
            "C",
            "(",
            ")",
            "+",
            "*",
            "/",
            "−",
            "²",
            "³",
            "⁴"
        ]
    },
    "6 Supplementary Exercises 50": {
        "question": "证明 k 和 n 都为整数，1 ≤ k < n，则 c(n+1, k) = c(n, k-1) + nc(n, k)",
        "answer": "我们可以给出一个很好的组合证明。如果我们希望编号为 1 到 n+1 的人坐在 k 个圆桌旁，有两种选择。我们可以让 n+1 单独坐一张桌子，然后将剩下的 n 个人安排在 k-1 个圆桌旁（这个恒等式的右边第一项），或者我们先将前 n 个人安排在 k 张桌子上，然后让 n+1 坐在其中一个人的右边（有 n 种选择，这给出了右边的第二项）。",
        "answer_symbols": [
            "-",
            "+"
        ]
    },
    "6 Supplementary Exercises 51": {
        "question": "给出一个组合证明当 n 为正偶数时，2^n 能整除 n!。[提示：使用 6.5 节中的定理 3 计算 2n 个对象的排列数，其中一共 n 种不同类型，每类型有 2 个相同的对象。]",
        "answer": "2n 个不同类型的对象（每种类型两个）的排列数是 (2n)!/2^ⁿ。因为这必须是一个整数，所以分母必须能整除分子。",
        "answer_symbols": [
            "!",
            "(",
            ")",
            "−",
            "²",
            "ⁿ",
            "/"
        ]
    },
    "6 Supplementary Exercises 52": {
        "question": "有多少种长度为 11 的 RNA 序列，其中有 4 个 A、3 个 C、2 个 U 和 2 个 G，并以 CAA 结尾？",
        "answer": "除了最后三个符号外，我们需要对 2 个 A、2 个 C、2 个 U 和 2 个 G 进行排列。根据第 6.5 节中的定理 3，答案是 8! / (2!^4) = 2520。",
        "answer_symbols": [
            "!",
            "/",
            "^"
        ]
    },
    "6 Supplementary Exercises 53": {
        "question": "设在每个 G 链接后打断 RNA 链的酶用于长为 12 的链接链。片段得到了 G、CCG、AAAG 和 UCCG，当采用每个 C 或 U 处打断 RNA 链的酶时，片段得到了 C、C、C、C、GGU 和 GAAAG。你能从这些片段确定这条长度为 12 的 RNA 链？如果可以，这条链是怎样的？",
        "answer": "CCGGUCCGAAAG",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 54": {
        "question": "设在每个 G 链接后打断 RNA 链的酶用于长为 12 的链接链。片段得到了 AC、UG 和 ACG，当采用每个 C 或 U 处打断 RNA 链的酶时，片段得到了 U、GAC 和 GAC。你能从这些片段确定这条 12 长度的 RNA 链？如果可以，这条链是怎样的？",
        "answer": "根据第一条信息，我们知道链以 AC 结束，在此之前是 UG 和 ACG 链的某种顺序。所以只有两种选择：UGACGAC 或 ACGUGAC。很容易看出，如果在第一个选择中每次在 U 或 C 后面断开，会产生句子后半部分所述的片段，而第二个选择同样断开会生成其他东西（AC, GU, GAC）。因此原始链是 UGACGAC。",
        "answer_symbols": []
    },
    "6 Supplementary Exercises 55": {
        "question": "设计一个算法生成一个有穷集的所有允许重复的 r 排列。",
        "answer": "过程 next 排列 (n: 正整数, a₁, a₂,..., aᵣ: 不超过 n 的正整数，且 a₁a₂... aᵣ = nn... n) i := r 当 aᵢ = n 时 aᵢ := 1 i := i − 1 aᵢ := aᵢ + 1 {a₁a₂... aᵣ 是字典顺序下的下一个排列}",
        "answer_symbols": [
            "=",
            "−",
            "₁",
            "₂",
            "ₕ",
            "ⱼ",
            "ₙ",
            "ₖ",
            "ₙ₋₁",
            "ₙ₋₂"
        ]
    },
    "6 Supplementary Exercises 56": {
        "question": "设计一个算法生成一个有穷集的所有允许重复的 r 组合。",
        "answer": "不失一般性地假设我们希望从集合 {1, 2, ..., n} 中形成 r 组合。我们修改第 6.6 节中用于生成字典序下一个 r 组合的算法，允许重复。然后通过从 11...1 开始并调用此修改后的算法 C(n+r-1, r)-1 次（这将使最后一个为 nn...n）来生成所有这样的组合。过程 next r-combination(a1, a2, ..., ar: 整数) {我们假设 1 ≤ a1 ≤ a2 ≤ ... ≤ ar ≤ n，且 a1 ≠ n} i := r 当 ai = n i := i - 1 ai := ai + 1 对于 j := i + 1 到 r aj := ai",
        "answer_symbols": [
            "{",
            "}",
            "≤",
            "≠",
            ":",
            "=",
            "-",
            "+",
            "≥"
        ]
    },
    "6 Supplementary Exercises 57": {
        "question": "证明：如果 m、n 为整数，m ≥ 3，n ≥ 3，那么 R(m, n) ≤ R(m, n-1) + R(m-1, n)",
        "answer": "必须证明如果有 R(m, n−1) + R(m−1, n) 人在派对上，那么至少有 m 个共同的朋友或 n 个共同的敌人。考虑一个人，称他为杰里。那么派对上有 R(m−1, n) + R(m, n−1) − 1 其他人，根据抽屉原理，杰里的朋友中至少有 R(m−1, n) 人或杰里的敌人中至少有 R(m, n−1) 人。首先假设杰里有 R(m−1, n) 个朋友。根据 R 的定义，在这些人中我们保证能找到 m − 1 个共同的朋友或 n 个共同的敌人。在前一种情况下，这 m−1 个共同的朋友加上杰里是一组 m 个共同的朋友；而在后一种情况下，我们找到了所需的 n 个共同的敌人。另一种情况类似：假设杰里有 R(m, n−1) 个敌人；我们保证在他们中找到 m 个共同的朋友或 n − 1 个共同的敌人。在前一种情况下，我们找到了所需的 m 个共同的朋友；在后一种情况下，这 n−1 个共同的敌人加上杰里是一组 n 个共同的敌人。",
        "answer_symbols": [
            "+",
            "−",
            "(",
            ")",
            "R",
            "m",
            "n",
            "≤",
            "≥"
        ]
    },
    "6 Supplementary Exercises 58": {
        "question": "在一组 6 个人中，每两个人是朋友或者是敌人，证明在这组人中不存在 3 个人两两是朋友，也不存在 4 个人两两是敌人。从而证明了 R(3, 4) ≥ 7",
        "answer": "需要足够尝试才能最终发现满足条件的情况。这里有一种方法。假设这个群体由三名男性和三名女性组成，并假设同性别的人总是敌人，异性总是朋友。那么显然不可能有一组四个互为敌人的成员，因为任何四个人的集合必须至少包括一名男性和一名女性（因为整个群体中每个性别只有三人）。也不可能有一组三个互为朋友的成员，因为任何三个人的集合必须至少包括两个同性别的人（因为只有两种性别）。",
        "answer_symbols": []
    },
    "7.1 1": {
        "question": "从一副牌中选出1张A的概率是多少？",
        "answer": "1/13",
        "answer_symbols": [
            "/"
        ]
    },
    "7.1 2": {
        "question": "掷骰子时出现6点的概率是多少？",
        "answer": "概率为 1/6 ≈ 0.17，因为有六种等可能的结果。",
        "answer_symbols": [
            "/",
            "≈"
        ]
    },
    "7.1 3": {
        "question": "从前100个正整数中随机选出1个奇数的概率是多少？",
        "answer": "1/2",
        "answer_symbols": [
            "/"
        ]
    },
    "7.1 4": {
        "question": "从一年（365天）中随机选出1天在4月的概率是多少？",
        "answer": "因为四月有30天，所以答案是 30/366 = 5/61 ≈ 0.082。",
        "answer_symbols": [
            "/",
            "=",
            "≈"
        ]
    },
    "7.1 5": {
        "question": "当掷2个骰子时，其点数之和是偶数的概率是多少？",
        "answer": "1/2",
        "answer_symbols": [
            "/"
        ]
    },
    "7.1 6": {
        "question": "从一副牌中选出1张是A或者红心的概率是多少？",
        "answer": "有16张牌符合条件，即A或红心，因此答案是 16/52 = 4/13 ≈ 0.31。我们也可以通过定理2来计算这个结果，即 4/52 + 13/52 - 1/52。",
        "answer_symbols": [
            "/",
            "=",
            "≈",
            "+",
            "-"
        ]
    },
    "7.1 7": {
        "question": "掷6次硬币，全部头像向上的概率是多少？",
        "answer": "1/64",
        "answer_symbols": [
            "/"
        ]
    },
    "7.1 8": {
        "question": "一手扑克牌有5张，其中包含红心A的概率是多少？",
        "answer": "我们在第6.3节的例子11中看到，有 C(52, 5) 种可能的扑克手牌，并且我们假设它们都是等可能的。为了回答这个问题，我们需要计算包含红心A的扑克手牌数量。选择红心A没有选择余地。为了组成其余的手牌，我们需要从剩余的51张牌中选择4张，因此有 C(51, 4) 手牌包含红心A。因此，问题的答案是比值 C(51, 4) / C(52, 5) = 5/52 ≈ 9.6%。这个问题也可以通过从1中减去练习9的答案来解决，因为一手牌包含红心A当且仅当它不包含红心A的情况不存在。",
        "answer_symbols": [
            "(",
            ")",
            "/",
            "=",
            "≈",
            "-",
            "+"
        ]
    },
    "7.1 9": {
        "question": "一手扑克牌有5张，其中不包含红心Q的概率是多少？",
        "answer": "47/52",
        "answer_symbols": [
            "/"
        ]
    },
    "7.1 10": {
        "question": "一手扑克牌有5张，其中包含方块2和黑桃3的概率是多少？",
        "answer": "这类似于练习8。我们需要计算包含方块二和黑桃三的扑克手牌数量。选择这两张牌没有选择余地。为了组成其余的手牌，我们需要从剩余的50张牌中选择3张，因此有 C(50, 3) 手牌包含这两张特定的牌。因此，问题的答案是比值 C(50, 3) / C(52, 5) = 5/663 ≈ 0.0075。",
        "answer_symbols": [
            "(",
            ")",
            "/",
            "=",
            "≈"
        ]
    },
    "7.1 11": {
        "question": "一手扑克牌有5张，其中包含方块2、黑桃3、红心6、梅花10和红心K的概率是多少？",
        "answer": "1/ C(52, 5)",
        "answer_symbols": [
            "/",
            "(",
            ")"
        ]
    },
    "7.1 12": {
        "question": "一手扑克牌有5张，其中恰好包含1张A的概率是多少？",
        "answer": "有4种方法可以指定A。一旦选择了手牌中的A，就有 C(48, 4) 种方法来选择剩余四张非A的牌。因此，有 4 * C(48, 4) 手牌恰好包含一个A。由于有 C(52, 5) 种等可能的手牌，答案是比值 4 * C(48, 4) / C(52, 5) ≈ 0.30。",
        "answer_symbols": [
            "*",
            "(",
            ")",
            "/",
            "≈"
        ]
    },
    "7.1 13": {
        "question": "一手扑克牌有5张，其中至少包含1张A的概率是多少？",
        "answer": "1 - [C(48, 5)/ C(52, 5)]",
        "answer_symbols": [
            "-",
            "[",
            "]",
            "/",
            "(",
            ")"
        ]
    },
    "7.1 14": {
        "question": "一手扑克牌有5张，其中包含5类不同牌的概率是多少？",
        "answer": "我们在第6.3节的例子11中看到，有 C(52, 5) = 2,598,960 种不同的手牌，并且我们假设它们都是等可能的。我们需要计算有5种不同种类（面值）的手牌数量。有 C(13, 5) 种方法来选择种类。对于每张牌，有4种方法来选择花色。因此，有 C(13, 5) * 4^5 = 1,317,888 种方法来选择手牌。因此，概率为 1317888 / 2598960 = 2112 / 4165 ≈ 0.51。",
        "answer_symbols": [
            "=",
            "*",
            "^",
            "/",
            "≈"
        ]
    },
    "7.1 15": {
        "question": "一手扑克牌有5张，其中包含2个对子（两张牌花色不同但点相同）的概率是多少？",
        "answer": "C(13, 2)C(4, 2)C(4, 2) C(44, 1)/ C(52, 5)",
        "answer_symbols": [
            "C",
            "(",
            ")",
            "*",
            "/"
        ]
    },
    "7.1 16": {
        "question": "一手扑克牌有5张，其中包含一手同花，即5张牌的花色相同的概率是多少？",
        "answer": "Of the C(52, 5) = 2,598,960 hands, 4 · C(13, 5) = 5148 are flushes, since we can specify a flush by choosing a suit and then choosing 5 cards from that suit. Therefore the answer is 5148 / 2,598,960 = 33 / 16,660 ≈ 0.0020.",
        "answer_symbols": [
            "C",
            "(",
            ")",
            "=",
            "·",
            "/",
            "≈"
        ]
    },
    "7.1 17": {
        "question": "一手扑克牌有5张，其中包含一个顺子，即5张牌的点是连续的概率是多少？[注意，A-2-3-4-5和10-J-Q-K-A都可以看成是顺子。]",
        "answer": "10,240/ C(52, 5)",
        "answer_symbols": [
            "/",
            "C",
            "(",
            ")"
        ]
    },
    "7.1 18": {
        "question": "一手扑克牌有5张，其中包含一个同花顺子，即5张牌的点连续且是同一花色的概率是多少？",
        "answer": "There are clearly only 10 · 4 = 40 straight flushes, since all we get to specify for a straight flush is the starting (lowest) kind in the straight (anything from ace up to ten) and the suit. Therefore the answer is 40 / C(52, 5) = 40 / 2,598,960 = 1 / 64,974.",
        "answer_symbols": [
            "·",
            "C",
            "(",
            ")",
            "=",
            "/",
            "≈"
        ]
    },
    "7.1 19": {
        "question": "一手扑克牌有5张，其中包含5张不同类的牌且不包含一个同花或一个顺子的概率是多少？",
        "answer": "1,302,540/ C(52, 5)",
        "answer_symbols": [
            "/",
            "C",
            "(",
            ")"
        ]
    },
    "7.1 20": {
        "question": "一手扑克牌有5张，其中包含同一花色的10、J、Q、K和A的概率是多少？",
        "answer": "There are 4 royal flushes, one in each suit. Therefore the answer is 4 / C(52, 5) = 4 / 2,598,960 = 1 / 649,740.",
        "answer_symbols": [
            "C",
            "(",
            ")",
            "=",
            "/",
            "≈"
        ]
    },
    "7.1 21": {
        "question": "一个骰子掷6次都不出现偶数点的概率是多少？",
        "answer": "1/64",
        "answer_symbols": [
            "/"
        ]
    },
    "7.1 22": {
        "question": "随机选取一个不超过100的正整数，能够被3整除的概率是多少？",
        "answer": "There are 100 / 3 = 33 multiples of 3 among the integers from 1 to 100 (inclusive), so the answer is 33 / 100 = 0.33.",
        "answer_symbols": [
            "/",
            "=",
            "≈"
        ]
    },
    "7.1 23": {
        "question": "随机选取一个不超过100的正整数，能够被5或7整除的概率是多少？",
        "answer": "8/25",
        "answer_symbols": [
            "/"
        ]
    },
    "7.1 24": {
        "question": "求从不超过下述整数的正整数中选出6个整数来赢彩票的概率，这里不考虑选择整数的顺序。 a) 30 b) 36 c) 42 d) 48",
        "answer": "In each case, if the numbers are chosen from the integers from 1 to n, then there are C(n, 6) possible entries, only one of which is the winning one, so the answer is 1 / C(n, 6).",
        "answer_symbols": [
            "C",
            "(",
            ")",
            "=",
            "/"
        ]
    },
    "7.1 26": {
        "question": "求从不超过下述整数的正整数中选6个整数都不中的概率，这里不考虑选择整数的顺序。 a) 40 b) 48 c) 56 d) 64",
        "answer": "In each case, if the numbers are chosen from the integers from 1 to n, then there are C(n, 6) possible entries. If we wish to avoid all the winning numbers, then we must make our choice from the n - 6 nonwinning numbers, and this can be done in C(n - 6, 6) ways. Therefore, since the winning numbers are picked at random, the probability is C(n - 6, 6) / C(n, 6).",
        "answer_symbols": [
            "C",
            "(",
            ")",
            "-",
            "=",
            "/"
        ]
    },
    "7.1 24 a)": {
        "question": "求从不超过30的正整数中选出6个整数来赢彩票的概率，这里不考虑选择整数的顺序。",
        "answer": "1 / C(30, 6) = 1 / 593,775 ≈ 1.7 × 10^-6",
        "answer_symbols": [
            "C",
            "(",
            ")",
            "=",
            "/",
            "×",
            "^",
            "≈"
        ]
    },
    "7.1 24 b)": {
        "question": "求从不超过36的正整数中选出6个整数来赢彩票的概率，这里不考虑选择整数的顺序。",
        "answer": "1 / C(36, 6) = 1 / 1,947,792 ≈ 5.1 × 10^-7",
        "answer_symbols": [
            "C",
            "(",
            ")",
            "=",
            "/",
            "×",
            "^",
            "≈"
        ]
    },
    "7.1 24 c)": {
        "question": "求从不超过42的正整数中选出6个整数来赢彩票的概率，这里不考虑选择整数的顺序。",
        "answer": "1 / C(42, 6) = 1 / 5,245,786 ≈ 1.9 × 10^-7",
        "answer_symbols": [
            "C",
            "(",
            ")",
            "=",
            "/",
            "×",
            "^",
            "≈"
        ]
    },
    "7.1 24 d)": {
        "question": "求从不超过48的正整数中选出6个整数来赢彩票的概率，这里不考虑选择整数的顺序。",
        "answer": "1 / C(48, 6) = 1 / 12,271,512 ≈ 8.1 × 10^-8",
        "answer_symbols": [
            "C",
            "(",
            ")",
            "=",
            "/",
            "×",
            "^",
            "≈"
        ]
    },
    "7.1 25 a)": {
        "question": "求从不超过50的正整数中选出6个整数来赢彩票的概率，这里不考虑选择整数的顺序。",
        "answer": "1/ C(50, 6)",
        "answer_symbols": [
            "/",
            "C",
            "(",
            ")"
        ]
    },
    "7.1 25 b)": {
        "question": "求从不超过52的正整数中选出6个整数来赢彩票的概率，这里不考虑选择整数的顺序。",
        "answer": "1/ C(52, 6)",
        "answer_symbols": [
            "/",
            "C",
            "(",
            ")"
        ]
    },
    "7.1 25 c)": {
        "question": "求从不超过56的正整数中选出6个整数来赢彩票的概率，这里不考虑选择整数的顺序。",
        "answer": "1/ C(56, 6)",
        "answer_symbols": [
            "/",
            "C",
            "(",
            ")"
        ]
    },
    "7.1 25 d)": {
        "question": "求从不超过60的正整数中选出6个整数来赢彩票的概率，这里不考虑选择整数的顺序。",
        "answer": "1/ C(60, 6)",
        "answer_symbols": [
            "/",
            "C",
            "(",
            ")"
        ]
    },
    "7.1 26 a)": {
        "question": "求从不超过40的正整数中选6个整数都不中的概率，这里不考虑选择整数的顺序。",
        "answer": "C(34, 6) / C(40, 6) = 1,344,904 / 3,838,380 ≈ 0.35",
        "answer_symbols": [
            "C",
            "(",
            ")",
            "=",
            "/",
            "≈"
        ]
    },
    "7.1 26 b)": {
        "question": "求从不超过48的正整数中选6个整数都不中的概率，这里不考虑选择整数的顺序。",
        "answer": "C(42, 6) / C(48, 6) = 5,245,786 / 12,271,512 ≈ 0.43",
        "answer_symbols": [
            "C",
            "(",
            ")",
            "=",
            "/",
            "≈"
        ]
    },
    "7.1 26 c)": {
        "question": "求从不超过56的正整数中选6个整数都不中的概率，这里不考虑选择整数的顺序。",
        "answer": "C(50, 6) / C(56, 6) = 15,890,700 / 32,468,436 ≈ 0.49",
        "answer_symbols": [
            "C",
            "(",
            ")",
            "=",
            "/",
            "≈"
        ]
    },
    "7.1 26 d)": {
        "question": "求从不超过64的正整数中选6个整数都不中的概率，这里不考虑选择整数的顺序。",
        "answer": "C(58, 6) / C(64, 6) = 40,475,358 / 74,974,368 ≈ 0.54",
        "answer_symbols": [
            "C",
            "(",
            ")",
            "=",
            "/",
            "≈"
        ]
    },
    "7.1 27 a)": {
        "question": "求从不超过40的正整数中选6个整数，并且恰好选中1个的概率，这里不考虑选择整数的顺序。",
        "answer": "139,128/319,865",
        "answer_symbols": [
            "/"
        ]
    },
    "7.1 27 b)": {
        "question": "求从不超过48的正整数中选6个整数，并且恰好选中1个的概率，这里不考虑选择整数的顺序。",
        "answer": "212,667/511,313",
        "answer_symbols": [
            "/"
        ]
    },
    "7.1 27 c)": {
        "question": "求从不超过56的正整数中选6个整数，并且恰好选中1个的概率，这里不考虑选择整数的顺序。",
        "answer": "151,340/386,529",
        "answer_symbols": [
            "/"
        ]
    },
    "7.1 27 d)": {
        "question": "求从不超过64的正整数中选6个整数，并且恰好选中1个的概率，这里不考虑选择整数的顺序。",
        "answer": "163,647/446,276",
        "answer_symbols": [
            "/"
        ]
    },
    "7.1 28": {
        "question": "美国宾夕法尼亚超级彩票的玩法是，买彩票的人要从前80个正整数中选出7个数。如果这7个数是在由宾夕法尼亚彩票委员会选出的11个数中的6就能赢大奖，那么一个人赢大奖的概率是多少？",
        "answer": "We need to find the number of ways for the computer to select its 11 numbers, and we need to find the number of ways for it to select its 11 numbers so as to contain the 7 numbers that we chose. For the former, the number is clearly C(80, 11). For the latter, the computer must select four more numbers besides the ones we chose, from the 80 - 7 = 73 other numbers, so there are C(73, 4) ways to do this. Therefore the probability that we win is the ratio C(73, 4) / C(80, 11), which works out to 3 / 28,879,240, or about one chance in ten million (1.04 × 10^-7). The same answer can be obtained by counting things in the other direction: the number of ways for us to choose 7 of the computer’s predestined 11 numbers divided by the number of ways for us to pick 7 numbers. This gives C(11, 7) / C(80, 7), which has the same value as before.",
        "answer_symbols": [
            "C",
            "(",
            ")",
            "-",
            "=",
            "/",
            "×",
            "^",
            "≈"
        ]
    },
    "7.1 29": {
        "question": "在一种超级彩票中，如果买彩票的人选中的8个数正是计算机从不超过100的正整数中选出的数就能中彩。请问中彩的概率是多少？",
        "answer": "1/ C(100, 8)",
        "answer_symbols": [
            "/",
            "C",
            "(",
            ")"
        ]
    },
    "7.1 30": {
        "question": "由计算机从1到40之间（包括1和40在内）选出6个数，如果某人选中了其中的5个（但不是6个）数就能获奖，那么获奖的概率是多少？",
        "answer": "In order to specify a winning ticket, we must choose five of the six numbers to match (C(6, 5) = 6 ways to do so) and one number from among the remaining 34 numbers not to match (C(34, 1) = 34 ways to do so). Therefore there are 6 · 34 = 204 winning tickets. Since there are C(40, 6) = 3,838,380 tickets in all, the answer is 204 / 3,838,380 = 17 / 319,865 ≈ 5.3 × 10^-5, or about 1 chance in 19,000.",
        "answer_symbols": [
            "C",
            "(",
            ")",
            "=",
            "·",
            "/",
            "×",
            "^",
            "≈"
        ]
    },
    "7.1 31": {
        "question": "假设100个人进入决赛并且随机选择不同的人作为一等奖、二等奖和三等奖的获奖者。如果米切尔是进入决赛的人之一，她中奖的概率是多大？",
        "answer": "3/100",
        "answer_symbols": [
            "/"
        ]
    },
    "7.1 32": {
        "question": "假设100个人进入决赛并且随机选择不同的人作为一等奖、二等奖和三等奖的获奖者。如果库玛、加奈斯、彼得罗是进入决赛的人，他们每个人都赢得一个奖项的概率是多少？",
        "answer": "The number of ways for the drawing to turn out is 100 · 99 · 98. The number of ways for the drawing to cause Kumar, Janice, and Pedro each to win a prize is 3 · 2 · 1 (three ways for one of these to be picked to win first prize, two ways for one of the others to win second prize, one way for the third to win third prize). Therefore the probability we seek is (3 · 2 · 1) / (100 · 99 · 98) = 1 / 161,700.",
        "answer_symbols": [
            "·",
            "(",
            ")",
            "/",
            "="
        ]
    },
    "7.1 33 a)": {
        "question": "在一次绘画比赛中，200个人进入决赛，在下述条件下，艾比、巴里、西尔维亚分别赢得一等奖、二等奖、三等奖的概率是多少？如果每个人至多得一个奖。",
        "answer": "1/7,880,400",
        "answer_symbols": [
            "/"
        ]
    },
    "7.1 33 b)": {
        "question": "在一次绘画比赛中，200个人进入决赛，在下述条件下，艾比、巴里、西尔维亚分别赢得一等奖、二等奖、三等奖的概率是多少？如果允许一个人得多个奖。",
        "answer": "1/8,000,000",
        "answer_symbols": [
            "/"
        ]
    },
    "7.1 34 a)": {
        "question": "在一次绘画比赛中，50个人进入决赛，在下述条件下，勃、考林、杰夫、罗海尼分别赢得一等奖、二等奖、三等奖和四等奖的概率是多少？如果每个人至多得一个奖。",
        "answer": "There are 50 · 49 · 48 · 47 equally likely outcomes of the drawings. In only one of these do Bo, Colleen, Jeff, and Rohini win the first, second, third, and fourth prizes, respectively. Therefore the probability is 1 / (50 · 49 · 48 · 47) = 1 / 5,527,200.",
        "answer_symbols": [
            "·",
            "(",
            ")",
            "/",
            "="
        ]
    },
    "7.1 34 b)": {
        "question": "在一次绘画比赛中，50个人进入决赛，在下述条件下，勃、考林、杰夫、罗海尼分别赢得一等奖、二等奖、三等奖和四等奖的概率是多少？如果允许一个人得多个奖。",
        "answer": "There are 50 · 50 · 50 · 50 equally likely outcomes of the drawings. In only one of these do Bo, Colleen, Jeff, and Rohini win the first, second, third, and fourth prizes, respectively. Therefore the probability is 1 / 50^4 = 1 / 6,250,000.",
        "answer_symbols": [
            "=",
            "·",
            "(",
            "^",
            ")",
            "/"
        ]
    },
    "7.1 35 a)": {
        "question": "在轮盘赌中，旋转一个有38个数的轮盘，其中18个数是红的，18个数是黑的，另外两个既不红也不黑的数是0和00。当轮盘转动时，它到达任何特定数字的概率是1/38。轮盘落到1个红数的概率是多少？",
        "answer": "9/19",
        "answer_symbols": [
            "/"
        ]
    },
    "7.1 35 b)": {
        "question": "在轮盘赌中，旋转一个有38个数的轮盘，其中18个数是红的，18个数是黑的，另外两个既不红也不黑的数是0和00。当轮盘转动时，它到达任何特定数字的概率是1/38。轮盘两次落到某列上的同一个黑数的概率是多少？",
        "answer": "81/361",
        "answer_symbols": [
            "/"
        ]
    },
    "7.1 35 c)": {
        "question": "在轮盘赌中，旋转一个有38个数的轮盘，其中18个数是红的，18个数是黑的，另外两个既不红也不黑的数是0和00。当轮盘转动时，它到达任何特定数字的概率是1/38。轮盘落到0或00的概率是多少？",
        "answer": "1/19",
        "answer_symbols": [
            "/"
        ]
    },
    "7.1 35 d)": {
        "question": "在轮盘赌中，旋转一个有38个数的轮盘，其中18个数是红的，18个数是黑的，另外两个既不红也不黑的数是0和00。当轮盘转动时，它到达任何特定数字的概率是1/38。轮盘旋转5次，5次都不落到0或00的概率是多少？",
        "answer": "1,889,568/2,476,099",
        "answer_symbols": [
            "/"
        ]
    },
    "7.1 35 e)": {
        "question": "在轮盘赌中，旋转一个有38个数的轮盘，其中18个数是红的，18个数是黑的，另外两个既不红也不黑的数是0和00。当轮盘转动时，它到达任何特定数字的概率是1/38。某次转动轮盘，落到1～6之间（包含1和6在内）的某个数字，但下次转动轮盘却不落到这些数字之间的概率是多少？",
        "answer": "48/361",
        "answer_symbols": [
            "/"
        ]
    },
    "7.1 36": {
        "question": "掷2个骰子总点数为8或掷3个骰子总点数为8，哪种可能性更大？",
        "answer": "通过例2中的推理，我们可以看到当两个骰子掷出时，有5种方法可以得到总数为8：(6, 2)，(5, 3)，(4, 4)，(3, 5) 和 (2, 6)。掷两个骰子的所有可能结果有6^2 = 36种，且这些结果是等可能的，因此掷两个骰子得到总数为8的概率是5/36 ≈ 0.139。对于三个骰子，所有可能的结果有6^3 = 216种，我们可以用有序三元组(a, b, c)表示这些结果。我们需要枚举给出总数为8的可能性。虽然在第6.5节中以更系统的方式完成这项工作，但这里我们通过暴力法来实现。第一个骰子可能是6，产生1个三元组(6, 1, 1)。第一个骰子可能是5，产生2个三元组(5, 2, 1) 和 (5, 1, 2)。继续这种方式，我们可以看到当第一个骰子显示4时，有3个三元组给出总数为8；当它显示3时，有4个三元组；当它显示2时，有5个三元组；当它显示1时，有6个三元组（即(1, 6, 1)，(1, 5, 2)，(1, 4, 3)，(1, 3, 4)，(1, 2, 5) 和 (1, 1, 6)）。因此，总共有1 + 2 + 3 + 4 + 5 + 6 = 21种可能的结果给出总数为8。这告诉我们掷三个骰子得到总数为8的概率是21/216 ≈ 0.097，小于使用两个骰子时对应的值。因此，使用两个骰子比使用三个骰子更容易得到总数为8。",
        "answer_symbols": [
            "^",
            "=",
            "+",
            "≈"
        ]
    },
    "7.1 37": {
        "question": "掷2个骰子总点数为9或掷3个骰子总点数为9，哪种可能性更大？",
        "answer": "三个骰子",
        "answer_symbols": []
    },
    "7.1 38 a)": {
        "question": "设E1和E2是两个事件，如果P(E1 ∩ E2) = P(E1)P(E2)，就称E1和E2是独立的。如果把一枚硬币抛掷3次时所有可能的结果构成一个集合，把这个集合的子集看做事件，确定下面的每一对事件是否是独立的。E1：第一次硬币头像向下；E2：第二次硬币头像向上。",
        "answer": "直觉上，这些应该是独立的，因为第一个事件似乎对第二个事件没有影响。实际上，我们可以通过以下方式计算。首先，p(E1) = 1/2 和 p(E2) = 1/2，这是由抛硬币的对称性决定的。此外，E1 ∩ E2 是前两枚硬币分别出现反面和正面的事件。由于前两枚硬币有四种等可能的结果（HH、HT、TH 和 TT），p(E1 ∩ E2) = 1/4。因此，p(E1 ∩ E2) = 1/4 = (1/2) * (1/2) = p(E1)p(E2)，所以这些事件确实是独立的。",
        "answer_symbols": [
            "=",
            "∩",
            "*",
            "≈"
        ]
    },
    "7.1 38 b)": {
        "question": "设E1和E2是两个事件，如果P(E1 ∩ E2) = P(E1)P(E2)，就称E1和E2是独立的。如果把一枚硬币抛掷3次时所有可能的结果构成一个集合，把这个集合的子集看做事件，确定下面的每一对事件是否是独立的。E1：第一次硬币头像向下；E2：在连续3次中有2次但不是3次头像向上。",
        "answer": "同样，p(E1) = 1/2。对于E2，注意三枚硬币有8种等可能的结果，其中2种情况E2发生（即HHT 和 THH）；因此 p(E2) = 2/8 = 1/4。因此，p(E1)p(E2) = (1/2) * (1/4) = 1/8。现在 E1 ∩ E2 是第一枚硬币出现反面，且连续出现两次但不是三次正面的事件。这恰好发生在结果为THT时，所以概率为1/8。这与 p(E1)p(E2) 相同，所以这些事件是独立的。",
        "answer_symbols": [
            "=",
            "∩",
            "*",
            "≈"
        ]
    },
    "7.1 38 c)": {
        "question": "设E1和E2是两个事件，如果P(E1 ∩ E2) = P(E1)P(E2)，就称E1和E2是独立的。如果把一枚硬币抛掷3次时所有可能的结果构成一个集合，把这个集合的子集看做事件，确定下面的每一对事件是否是独立的。E1：第二次硬币头像向下；E2：在连续3次中有2次但不是3次头像向上。",
        "answer": "如同部分(b)所述，p(E1) = 1/2 和 p(E2) = 1/4。这次 p(E1 ∩ E2) = 0，因为在第二枚硬币出现反面的情况下不可能连续出现两次正面。由于 p(E1)p(E2) ≠ p(E1 ∩ E2)，这些事件不是独立的。",
        "answer_symbols": [
            "=",
            "∩",
            "≠",
            "*"
        ]
    },
    "7.1 39": {
        "question": "解释下面的陈述错在什么地方。在蒙地厅大厦三门难题里，因为剩下两个门，所以你选的第一个门后面是大奖的概率与另一个没打开的门后面是大奖的概率都是1/2。",
        "answer": "参赛者选择的门是随机选择的，不知道奖品在哪里，但主持人选择的门不是随机的，因为他总是避免打开有奖品的门。这使得任何基于对称性的论点无效。",
        "answer_symbols": []
    },
    "7.1 41 a)": {
        "question": "这个问题由薛瓦利埃·德梅雷提出，并由布莱斯·帕斯卡和皮埃尔·德·费马解决。求一个骰子掷4次时掷出一个6点的概率。",
        "answer": "671/1296",
        "answer_symbols": [
            "/"
        ]
    },
    "7.1 41 b)": {
        "question": "这个问题由薛瓦利埃·德梅雷提出，并由布莱斯·帕斯卡和皮埃尔·德·费马解决。求一对骰子掷24次时掷出两个6点的概率。这个问题是薛瓦利埃·德梅雷问帕斯卡的，他问这个概率是否大于1/2。请解答这个问题。",
        "answer": "1 - 3524/3624；不",
        "answer_symbols": [
            "-",
            "/",
            ";"
        ]
    },
    "7.1 41 c)": {
        "question": "这个问题由薛瓦利埃·德梅雷提出，并由布莱斯·帕斯卡和皮埃尔·德·费马解决。一个骰子掷4次时掷出一个6点或一对骰子掷24次时掷出两个6点，哪种情况更可能发生？",
        "answer": "前者",
        "answer_symbols": []
    },
    "7.2 1": {
        "question": "当掷一个不均匀的硬币时，如果出现头像是不出现头像的可能性的 3 倍，那么出现头像的概率应该是多少？不出现头像的概率应该是多少？",
        "answer": "p(T) = 1/4, p(H) = 3/4",
        "answer_symbols": [
            "=",
            "/",
            ","
        ]
    },
    "7.2 2": {
        "question": "当掷一个被填充的骰子时，如果骰子出现 3 点这一面的可能性是其他五个面的 2 倍，求每种结果的概率。",
        "answer": "我们被告知 p(3) = 2p(x) 对于每个 x ≠ 3，但暗示 p(1) = p(2) = p(4) = p(5) = p(6)。我们还知道这六个数字的总和必须是1。通过简单的代数运算可以得出 p(3) = 2/7 和 p(x) = 1/7（x = 1, 2, 4, 5, 6）。",
        "answer_symbols": [
            "=",
            "≠",
            "∑"
        ]
    },
    "7.2 3": {
        "question": "当掷一个不均匀的骰子时，如果骰子出现 2 点或 4 点这一面的可能性是出现其他四个面的 3 倍，并且掷出一个 2 点或者一个 4 点是等可能的，求每种结果的概率。",
        "answer": "p(1) = p(3) = p(5) = p(6) = 1/16; p(2) = p(4) = 3/8",
        "answer_symbols": [
            "=",
            "/",
            ";",
            ","
        ]
    },
    "7.2 4": {
        "question": "当结果是等可能的时候，证明在拉普拉斯的概率定义下条件(i)和(ii)是满足的。",
        "answer": "如果结果是等可能的，那么每个结果的概率是1/n，其中n是结果的数量。显然，这个数量在0和1之间（包括0和1），因此满足(i)。此外，有n个结果，每个结果的概率是1/n，所以(ii)所示的总和必须等于 n * (1/n) = 1。",
        "answer_symbols": [
            "∑",
            "=",
            "n",
            "(",
            ")",
            "*",
            "/",
            "1/n"
        ]
    },
    "7.2 5": {
        "question": "一对骰子被灌铅特殊处理。第一个骰子出现4点的概率是2/7，第二个骰子出现3点的概率是2/7，且每个骰子出现其他点数的概率是1/7。当掷出2个骰子时，点数之和为7的概率是多少？",
        "answer": "9/49",
        "answer_symbols": [
            "/"
        ]
    },
    "7.2 6 a)": {
        "question": "当我们随机选择{1, 2, 3}的一个排列时，这些事件的概率是什么？（a）1在3前面。",
        "answer": "由于1要么在3之前，要么在3之后，而且没有理由认为其中一种情况比另一种更有可能，因此我们立即看到答案是1/2。我们也可以简单地列出所有6个排列，并计算出有3个排列中的1在3之前，即123、132和213。",
        "answer_symbols": [
            "1/2"
        ]
    },
    "7.2 6 b)": {
        "question": "当我们随机选择{1, 2, 3}的一个排列时，这些事件的概率是什么？（b）3在1前面。",
        "answer": "与部分(a)相同的推理，答案再次为1/2。",
        "answer_symbols": [
            "1/2"
        ]
    },
    "7.2 6 c)": {
        "question": "当我们随机选择{1, 2, 3}的一个排列时，这些事件的概率是什么？（c）3在1前面且3在2前面。",
        "answer": "所述条件迫使3首先出现，因此只有312和321是允许的。因此答案是2/6 = 1/3。",
        "answer_symbols": [
            "2/6",
            "=",
            "1/3"
        ]
    },
    "7.2 7 a)": {
        "question": "当我们随机选择{1, 2, 3, 4}的一个排列时，这些事件的概率是什么？（a）1在4前面。",
        "answer": "1/2",
        "answer_symbols": [
            "/"
        ]
    },
    "7.2 7 b)": {
        "question": "当我们随机选择{1, 2, 3, 4}的一个排列时，这些事件的概率是什么？（b）4在1前面。",
        "answer": "1/2",
        "answer_symbols": [
            "/"
        ]
    },
    "7.2 7 c)": {
        "question": "当我们随机选择{1, 2, 3, 4}的一个排列时，这些事件的概率是什么？（c）4在1前面且4在2前面。",
        "answer": "1/3",
        "answer_symbols": [
            "/"
        ]
    },
    "7.2 7 d)": {
        "question": "当我们随机选择{1, 2, 3, 4}的一个排列时，这些事件的概率是什么？（d）4在1前面，4在2前面，且4在3前面。",
        "answer": "1/4",
        "answer_symbols": [
            "/"
        ]
    },
    "7.2 7 e)": {
        "question": "当我们随机选择{1, 2, 3, 4}的一个排列时，这些事件的概率是什么？（e）4在3前面且2在1前面。",
        "answer": "1/4",
        "answer_symbols": [
            "/"
        ]
    },
    "7.2 8 a)": {
        "question": "当我们随机选择{1, 2, …, n}的一个排列时，其中n≥4，这些事件的概率是什么？（a）1在2前面。",
        "answer": "由于1要么在2之前，要么在2之后，而且没有理由认为其中一种情况比另一种更有可能，因此我们立即看到答案是1/2。",
        "answer_symbols": [
            "1/2"
        ]
    },
    "7.2 8 b)": {
        "question": "当我们随机选择{1, 2, …, n}的一个排列时，其中n≥4，这些事件的概率是什么？（b）2在1前面。",
        "answer": "与部分(a)相同的推理，答案再次为1/2。",
        "answer_symbols": [
            "1/2"
        ]
    },
    "7.2 8 c)": {
        "question": "当我们随机选择{1, 2, …, n}的一个排列时，其中n≥4，这些事件的概率是什么？（c）1紧挨着2前面。",
        "answer": "对于1紧接在2之前的情况，我们可以将这两个数字视为粘在一起形成排列。然后我们实际上是在排列n - 1个数字——从3到n的单个数字和一个粘合的对象12。有(n - 1)!种方法可以做到这一点。由于总共有n!种排列，随机选择其中一个的概率是(n - 1)!/n! = 1/n。",
        "answer_symbols": [
            "!",
            "n - 1",
            "n",
            "/",
            "(",
            ")",
            "="
        ]
    },
    "7.2 8 d)": {
        "question": "当我们随机选择{1, 2, …, n}的一个排列时，其中n≥4，这些事件的概率是什么？（d）n在1前面且n-1在2前面。",
        "answer": "一半的排列中n在1之前。在这些排列中，有一半的排列中n - 1在2之前。因此，满足这些条件的排列占四分之一，所以概率是1/4。",
        "answer_symbols": [
            "1/4"
        ]
    },
    "7.2 8 e)": {
        "question": "当我们随机选择{1, 2, …, n}的一个排列时，其中n≥4，这些事件的概率是什么？（e）n在1前面且n在2前面。",
        "answer": "查看1、2和n的相对位置，我们看到三分之一的时间，n会排在最前面。因此答案是1/3。",
        "answer_symbols": [
            "1/3"
        ]
    },
    "7.2 9 a)": {
        "question": "当我们随机选择26个英语小写字母的一个排列时，这些事件的概率是什么？（a）排列由按字母表相反顺序的字母组成。",
        "answer": "1/26!",
        "answer_symbols": [
            "/",
            "!"
        ]
    },
    "7.2 9 b)": {
        "question": "当我们随机选择26个英语小写字母的一个排列时，这些事件的概率是什么？（b）z是排列的第一个字母。",
        "answer": "1/26",
        "answer_symbols": [
            "/"
        ]
    },
    "7.2 9 c)": {
        "question": "当我们随机选择26个英语小写字母的一个排列时，这些事件的概率是什么？（c）排列中z在a前面。",
        "answer": "1/2",
        "answer_symbols": [
            "/"
        ]
    },
    "7.2 9 d)": {
        "question": "当我们随机选择26个英语小写字母的一个排列时，这些事件的概率是什么？（d）排列中a紧挨在z的前面。",
        "answer": "1/26",
        "answer_symbols": [
            "/"
        ]
    },
    "7.2 9 e)": {
        "question": "当我们随机选择26个英语小写字母的一个排列时，这些事件的概率是什么？（e）排列中a紧挨在m的前面，m紧挨在z的前面。",
        "answer": "1/650",
        "answer_symbols": [
            "/"
        ]
    },
    "7.2 9 f)": {
        "question": "当我们随机选择26个英语小写字母的一个排列时，这些事件的概率是什么？（f）排列中m, n, o在字母表中的原来位置。",
        "answer": "1/15,600",
        "answer_symbols": [
            "/"
        ]
    },
    "7.2 10 a)": {
        "question": "当我们随机选择26个英语小写字母的一个排列时，这些事件的概率是什么？（a）排列中的前13个字母按照字母表的顺序。",
        "answer": "前13个字母的排列有13!种可能，其中只有一种是按字母顺序排列的。因此答案是1/13!。",
        "answer_symbols": [
            "13!",
            "1/13!"
        ]
    },
    "7.2 10 b)": {
        "question": "当我们随机选择26个英语小写字母的一个排列时，这些事件的概率是什么？（b）a是排列的第一个字母且z是排列的最后一个字母。",
        "answer": "一旦这两个条件满足，剩余的字母有24!种方式排列在第2到第25位。因此答案是24!/26! = 1/650。",
        "answer_symbols": [
            "24!",
            "26!",
            "1/650"
        ]
    },
    "7.2 10 c)": {
        "question": "当我们随机选择26个英语小写字母的一个排列时，这些事件的概率是什么？（c）a和z在排列中彼此相邻。",
        "answer": "实际上，我们正在形成25个项目的排列——字母b到y和双字母组合az或za。有25!种方式排列这些项目，对于每种排列，a和z谁先出现有两种选择。因此有2 * 25!种方式形成这样的排列，因此答案是2 * 25!/26! = 1/13。",
        "answer_symbols": [
            "25!",
            "2 * 25!",
            "26!",
            "1/13"
        ]
    },
    "7.2 10 d)": {
        "question": "当我们随机选择26个英语小写字母的一个排列时，这些事件的概率是什么？（d）a和b在排列中彼此不相邻。",
        "answer": "根据部分(c)，a和b相邻的概率是1/13。因此a和b不相邻的概率是12/13。",
        "answer_symbols": [
            "1/13",
            "12/13"
        ]
    },
    "7.2 10 e)": {
        "question": "当我们随机选择26个英语小写字母的一个排列时，这些事件的概率是什么？（e）排列中a和z被至少23个字母分开。",
        "answer": "这种情况有六种可能：ax24z、zx24a、xax23z、xzx23a、ax23zx和zx23ax，其中x代表除a和z以外的任何字母（但当然每个排列中的所有x都是不同的）。在每种情况下，除了a和z之外的字母有24!种排列方式，因此每种类型的排列有24!种。这给出了总共6 * 24!种满足条件的排列，因此答案是(6 * 24!)/26! = 3/325。",
        "answer_symbols": [
            "24!",
            "6 * 24!",
            "26!",
            "3/325"
        ]
    },
    "7.2 10 f)": {
        "question": "当我们随机选择26个英语小写字母的一个排列时，这些事件的概率是什么？（f）排列中z在a和b两者的前面。",
        "answer": "查看z、a和b的相对位置，我们看到三分之一的时间，z会排在最前面。因此答案是1/3。",
        "answer_symbols": [
            "1/3"
        ]
    },
    "7.2 11": {
        "question": "假设E和F是事件，满足p(E)=0.7且p(F)=0.5。证明p(E∪F)≥0.7和p(E∩F)≥0.2。",
        "answer": "显然，p(E ∪ F) ≥ p(E) = 0.7。同时，p(E ∪ F) ≤ 1。如果我们应用第7.1节中的定理2，可以将此重写为 p(E) + p(F) - p(E ∩ F) ≤ 1，即 0.7 + 0.5 - p(E ∩ F) ≤ 1。解 p(E ∩ F) 得 p(E ∩ F) ≥ 0.2。",
        "answer_symbols": [
            "∪",
            "∩",
            "≥",
            "≤",
            "+",
            "-",
            "="
        ]
    },
    "7.2 12": {
        "question": "假设E和F是事件，满足p(E)=0.8且p(F)=0.6。证明p(E∪F)≥0.8和p(E∩F)≥0.4。",
        "answer": "显然p(E ∪ F) ≥ p(E) = 0.8。同时，p(E ∪ F) ≤ 1。如果我们应用第7.1节的定理2，可以重写为p(E) + p(F) - p(E ∩ F) ≤ 1，即0.8 + 0.6 - p(E ∩ F) ≤ 1。解p(E ∩ F)得到p(E ∩ F) ≥ 0.4。",
        "answer_symbols": [
            "∪",
            "≥",
            "≤",
            "+",
            "-",
            "∩"
        ]
    },
    "7.2 13": {
        "question": "证明如果E和F是事件，那么p(E∩F)≥p(E)+p(F)-1。这就是邦弗罗尼(Bonferroni)不等式。",
        "answer": "因为 p(E ∪ F) = p(E) + p(F) - p(E ∩ F) 且 p(E ∪ F) ≤ 1，所以 1 ≥ p(E) + p(F) - p(E ∩ F)。从这个不等式中我们得出结论：p(E) + p(F) ≤ 1 + p(E ∩ F)。",
        "answer_symbols": [
            "∪",
            "∩",
            "≥",
            "≤",
            "+",
            "-",
            "="
        ]
    },
    "7.2 14": {
        "question": "使用数学归纳法证明下述一般的邦弗罗尼不等式：p(E1∩E2∩…∩En)≥p(E1)+p(E2)+…+p(En)-(n-1)，其中E1, E2, …, En是n个事件。",
        "answer": "基础步骤n = 1是平凡的陈述p(E₁) ≥ p(E₁)，n = 2的情况在练习13中完成。假设归纳假设：p(E₁ ∩ E₂ ∩ ... ∩ Eₙ) ≥ p(E₁) + p(E₂) + ... + p(Eₙ) - (n - 1)",
        "answer_symbols": [
            "(",
            "-",
            ")",
            "+",
            "≥",
            "∩"
        ]
    },
    "7.2 15": {
        "question": "证明如果E1, E2, …, En是一个有限样本空间的事件，那么p(E1∪E2∪…∪En)≤p(E1)+p(E2)+…+p(En)。这就是布尔不等式。",
        "answer": "我们将使用数学归纳法证明不等式对于 n ≥ 2 成立。设 P(n) 是陈述 p(∪(n)j=1 E_j) ≤ ∑(n)j=1 p(E_j)。基础步骤：P(2) 为真，因为 p(E_1 ∪ E_2) = p(E_1) + p(E_2) - p(E_1 ∩ E_2) ≤ p(E_1) + p(E_2)。归纳步骤：假设 P(k) 为真。使用基础情况和归纳假设，得出 p(∪(k+1)j=1 E_j) ≤ p(∪(k)j=1 E_j) + p(E_(k+1)) ≤ ∑(k+1)j=1 p(E_j)。这表明 P(k+1) 为真，完成了通过数学归纳法的证明。",
        "answer_symbols": [
            "∪",
            "∩",
            "∑",
            "≤",
            "+",
            "-"
        ]
    },
    "7.2 16": {
        "question": "证明如果E和F是独立的事件，那么E和F也是独立的事件。",
        "answer": "按定义，说E和F是独立的是指p(E ∩ F) = p(E) * p(F)。根据德摩根定律，E ∩ F = E ∪ F。因此 p(E ∩ F) = p(E ∪ F) = 1 - p(E ∪ F) = 1 - (p(E) + p(F) - p(E ∩ F)) = 1 - p(E) - p(F) + p(E ∩ F) = 1 - p(E) - p(F) + p(E) * p(F) = (1 - p(E)) * (1 - p(F)) = p(E) * p(F)。（我们使用了事件组合子部分中介绍的两个事实。）",
        "answer_symbols": [
            "∩",
            "∪",
            "=",
            "*",
            "+",
            "-",
            "(",
            ")"
        ]
    },
    "7.2 17": {
        "question": "如果E和F是独立的事件，证明或反驳E和F也必须是独立的事件。",
        "answer": "因为 E ∪ E 是整个样本空间 S，事件 F 可以分为两个互斥的事件：F = S ∩ F = (E ∪ E) ∩ F = (E ∩ F) ∪ (E ∩ F)，使用分配律。因此，p(F) = p((E ∩ F) ∪ (E ∩ F)) = p(E ∩ F) + p(E ∩ F)，因为这两个事件是互斥的。从两边减去 p(E ∩ F)，利用 p(E ∩ F) = p(E) · p(F)（假设 E 和 F 是独立的），并因式分解，得到 p(F)[1 - p(E)] = p(E ∩ F)。因为 1 - p(E) = p(E)，这表示 p(E ∩ F) = p(E) · p(F)，如所愿。",
        "answer_symbols": [
            "∪",
            "∩",
            "S",
            "(",
            ")",
            "=",
            "+",
            "-",
            "·",
            "[",
            "]"
        ]
    },
    "7.2 18 a)": {
        "question": "两个人出生在一周的同一天的概率是多少？",
        "answer": "第二个人与第一个人（无论是什么）出生在同一天的概率是1/7。",
        "answer_symbols": [
            "/"
        ]
    },
    "7.2 18 b)": {
        "question": "一组n个人里，至少2个人出生在一周的同一天的概率是什么？",
        "answer": "所有出生日期都不同的概率为 pₙ = 6/7 * 5/7 * ... * (8 - n)/7 因为第一个人之后的每个人必须与之前的所有人有不同的出生日期。注意，如果n ≥ 8，则 pₙ = 0，因为第七个分数为0（这也遵循鸽巢原理）。因此，至少有两个人出生在同一天的概率为 1 - pₙ。",
        "answer_symbols": [
            "=",
            "*",
            "/",
            "+",
            "-",
            "≥",
            "(",
            ")"
        ]
    },
    "7.2 18 c)": {
        "question": "要使得至少2个人出生在一周的同一天的概率大于1/2，需要多少个人？",
        "answer": "我们计算1 - pₙ，当n = 2, 3, ... 时，发现这个值首次超过1/2是在n = 4时，这就是我们的答案。四个人中至少有两人共享出生日的概率为223/343，约为65%。",
        "answer_symbols": [
            "-",
            "/",
            "%"
        ]
    },
    "7.2 19 a)": {
        "question": "2个人出生在一年的同一个月的概率是多少？",
        "answer": "1/12",
        "answer_symbols": [
            "/"
        ]
    },
    "7.2 19 b)": {
        "question": "一组n个人里，至少2个人出生在一年的同一个月的概率是什么？",
        "answer": "1 - 1121 · 1102 · ··· · 13-n 12",
        "answer_symbols": [
            "-",
            "·",
            "…"
        ]
    },
    "7.2 20": {
        "question": "要使得某个人的生日就在当天的概率大于1/2，求房间里最少的人数（假设生于每一天是等可能的并且这一年有366天）。",
        "answer": "如果随机选择n个人（我们假设366个等可能且独立的生日），那么没有人今天过生日的概率为(365/366)^ⁿ。题目要求的是使这个量小于1/2的最小n。我们可以通过试错法或使用对数解方程(365/366)^ⁿ = 1/2来确定。无论是哪种方法，我们发现当n ≤ 253时，(365/366)^ⁿ > 1/2，但 (365/366)^²^⁵^⁴ ≈ 0.4991。因此，答案是254。",
        "answer_symbols": [
            "(",
            ")",
            "/",
            "^",
            "<",
            ">",
            "≈"
        ]
    },
    "7.2 21": {
        "question": "要使得房间里的两个人都生在4月1日的概率大于1/2，求房间里最少的人数（假设生于每一天是等可能的并且这一年有366天）。",
        "answer": "6142323",
        "answer_symbols": []
    },
    "7.2 22 a)": {
        "question": "应该用哪种关于生日的概率分布来反映 2 月 29 日出现次数的多少？",
        "answer": "鉴于我们现在不再接近1900年，那一年不是闰年，让我们假设每四年出现一次2月29日，而其他每个日期每四年出现四次。一个四年的周期包含4 * 365 + 1 = 1461天。因此，随机选择的一天是2月29日的概率为1/1461，随机选择的一天是其他365个日期中的任何一个的概率为4/1461。",
        "answer_symbols": [
            "*",
            "+",
            "=",
            "/",
            "(",
            ")"
        ]
    },
    "7.2 22 b)": {
        "question": "利用 a) 的概率分布，一组 n 个人中至少两个人有相同生日的概率是什么？",
        "answer": "我们需要计算在一个n人的群体中，所有人都有不同的生日的概率。而不是在每个阶段计算概率，让我们计算从四年的周期中选择生日的方法数量，以便n个人都有不同的生日。有两种情况需要考虑，取决于群体中是否包含一个2月29日出生的人。假设群体中确实有一个闰日出生的人；有n种方法可以指定这个人是谁。然后有1460天可供第二个人选择。这总共给出了 n * 1460 * 1456 * ... * (1468 - 4n) 种方式。另一种情况是没有闰日生日。那么第一个人有1460个可能的生日，第二个人有1456个，依此类推，直到第n个人有1464 - 4n个。因此，不包括2月29日选择生日的总方法数为 1460 * 1456 * ... * (1464 - 4n)。这两个数字的和是所有生日都不同的概率的分子。分母是1461^n，因为每个人在四年内可以有任意一个生日。综合以上，我们看到至少有两个人生日相同的概率为 1 - [n * 1460 * 1456 * ... * (1468 - 4n) + 1460 * 1456 * ... * (1464 - 4n)] / 1461^n。",
        "answer_symbols": [
            "-",
            "^",
            "+",
            "]",
            "*",
            "/",
            "["
        ]
    },
    "7.2 23": {
        "question": "给定掷硬币第一次的头像在上，当一个均匀的硬币被掷 5 次时恰好 4 次头像在上的条件概率是多少？",
        "answer": "1/4",
        "answer_symbols": [
            "/"
        ]
    },
    "7.2 24": {
        "question": "给定掷硬币第一次的头像在下，当一个均匀的硬币被掷 5 次时恰好 4 次头像在上的条件概率是多少？",
        "answer": "抛一枚公平硬币五次，第一次出现反面的结果共有16种等可能的情况（其他每次抛掷可以是正面或反面）。其中只有一种结果会出现四个正面，即 T HHHH。因此答案是 1/16。",
        "answer_symbols": [
            "/"
        ]
    },
    "7.2 25": {
        "question": "给定第一位是 1，随机产生 4 位二进制串并使得它至少包含 2 个连续的 0 的条件概率是多少？（假设是 1 和是 0 的概率相同。）",
        "answer": "3/8",
        "answer_symbols": [
            "/"
        ]
    },
    "7.2 26": {
        "question": "随机产生 3 位二进制串，设 E 是这个串含有奇数个 1 的事件，F 是这个串以 1 开始的事件。E 和 F 是独立的吗？",
        "answer": "直觉上答案应该是肯定的，因为1的数量的奇偶性是一个五十对五十的概率，完全由任意一次抛掷决定（例如，最后一次抛掷）。其他抛掷的结果实际上并不重要。让我们更严格地证明这一点。长度为3的二进制字符串有8个，其中4个包含奇数个1（即 001, 010, 100, 和 111）。因此 p(E) = 4/8 = 1/2。由于4个长度为3的二进制字符串以1开头（即 100, 101, 110, 和 111），我们看到 p(F) = 4/8 = 1/2。此外，由于有两个字符串以1开头且包含奇数个1（即 100 和 111），我们看到 p(E ∩ F) = 2/8 = 1/4。然后，由于 p(E) * p(F) = (1/2) * (1/2) = 1/4 = p(E ∩ F)，我们从定义得出E和F是独立的。",
        "answer_symbols": [
            "=",
            "*",
            "∩"
        ]
    },
    "7.2 27 a)": {
        "question": "设 E 和 F 分别表示有 n 个孩子的家庭同时有男孩和女孩以及至多有 1 个男孩的事件。在 n=2 的条件下 E 和 F 是独立的吗？",
        "answer": "不独立",
        "answer_symbols": []
    },
    "7.2 27 b)": {
        "question": "设 E 和 F 分别表示有 n 个孩子的家庭同时有男孩和女孩以及至多有 1 个男孩的事件。在 n=4 的条件下 E 和 F 是独立的吗？",
        "answer": "不独立",
        "answer_symbols": []
    },
    "7.2 27 c)": {
        "question": "设 E 和 F 分别表示有 n 个孩子的家庭同时有男孩和女孩以及至多有 1 个男孩的事件。在 n=5 的条件下 E 和 F 是独立的吗？",
        "answer": "不独立",
        "answer_symbols": []
    },
    "7.2 28 a)": {
        "question": "假定一个孩子是男孩的概率是 0.51，且生在一个家庭的孩子的性别是独立的。一个家庭有 5 个孩子，那么恰有 3 个男孩的概率是什么？",
        "answer": "我们被要求求 k = 3 的概率。根据定理2，答案是 C(5, 3) * 0.51^3 * 0.49^2 ≈ 0.32。",
        "answer_symbols": [
            "(",
            ")",
            ",",
            "*",
            "^",
            "≈"
        ]
    },
    "7.2 28 b)": {
        "question": "假定一个孩子是男孩的概率是 0.51，且生在一个家庭的孩子的性别是独立的。一个家庭有 5 个孩子，那么至少有 1 个男孩的概率是什么？",
        "answer": "至少有一个男孩意味着没有全是女孩。女孩全出现的概率是 0.49^5，所以答案是 1 - 0.49^5 ≈ 0.972。",
        "answer_symbols": [
            "-",
            "^",
            "≈"
        ]
    },
    "7.2 28 c)": {
        "question": "假定一个孩子是男孩的概率是 0.51，且生在一个家庭的孩子的性别是独立的。一个家庭有 5 个孩子，那么至少有 1 个女孩的概率是什么？",
        "answer": "这类似于部分(b)：全是男孩的概率是 0.51^5，所以答案是 1 - 0.51^5 ≈ 0.965。",
        "answer_symbols": [
            "-",
            "^",
            "≈"
        ]
    },
    "7.2 28 d)": {
        "question": "假定一个孩子是男孩的概率是 0.51，且生在一个家庭的孩子的性别是独立的。一个家庭有 5 个孩子，那么所有的孩子性别都相同的概率是什么？",
        "answer": "有两种情况可以发生。答案显然是 0.51^5 + 0.49^5 ≈ 0.063。",
        "answer_symbols": [
            "+",
            "^",
            "≈"
        ]
    },
    "7.2 29": {
        "question": "一组 6 个人玩“单人出局”的游戏来确定谁买茶点。每个人掷一个均匀的硬币，如果一个人掷出的结果不和组中其他任何人相同，这个人就必须买茶点。在掷过一次硬币以后出现这种单人出局的概率是多少？",
        "answer": "3/16",
        "answer_symbols": [
            "/"
        ]
    },
    "7.2 30 a)": {
        "question": "10 位的二进制串，如果每位的产生是独立的，求出下列每种情况下随机产生不包含 0 的位串的概率。一位为 0 和为 1 是等可能的。",
        "answer": "所有位都是1的概率是 (1/2)^10 = 1/1024。这就是所要求的。",
        "answer_symbols": [
            "(",
            ")",
            "/",
            "^",
            "="
        ]
    },
    "7.2 30 b)": {
        "question": "10 位的二进制串，如果每位的产生是独立的，求出下列每种情况下随机产生不包含 0 的位串的概率。一位为 1 的概率是 0.6。",
        "answer": "这与部分(a)相同，但1位的概率是0.6而不是1/2。因此答案是 0.6^10 ≈ 0.0060。",
        "answer_symbols": [
            "^",
            "≈"
        ]
    },
    "7.2 30 c)": {
        "question": "10 位的二进制串，如果每位的产生是独立的，求出下列每种情况下随机产生不包含 0 的位串的概率。第 i 位为 1 的概率是 1/2，i=1, 2, 3, …, 10。",
        "answer": "我们需要乘以每个位为1的概率，所以答案是 1/2^² * 1/2^³ * ... * 1/2¹^⁰ = 1/2^(1+2+...+10) = 1/2^⁵^⁵ ≈ 2.8 × 10^⁻¹^⁷。注意，这几乎是0。",
        "answer_symbols": [
            "=",
            "-",
            "≈",
            "^",
            "+",
            "*",
            "×"
        ]
    },
    "7.2 31 a)": {
        "question": "求有 5 个孩子的家庭没有男孩的概率，如果孩子的性别是独立的，且是男孩和是女孩是等可能的。",
        "answer": "1/32 = 0.03125",
        "answer_symbols": [
            "/",
            "="
        ]
    },
    "7.2 31 b)": {
        "question": "求有 5 个孩子的家庭没有男孩的概率，如果孩子的性别是独立的，且是男孩的概率是 0.51。",
        "answer": "0.495 ≈ 0.02825",
        "answer_symbols": [
            "≈",
            "="
        ]
    },
    "7.2 31 c)": {
        "question": "求有 5 个孩子的家庭没有男孩的概率，如果孩子的性别是独立的，且第 i 个孩子是男孩的概率是 0.51-(i/100)。",
        "answer": "0.0379501",
        "answer_symbols": [
            "="
        ]
    },
    "7.2 32 a)": {
        "question": "10 位二进制串，如果每位的产生是独立的，分别求在 30a) 条件下随机产生一个以 1 开始或以 00 结尾的位串的概率。",
        "answer": "我们有 p(E) = 1/2 和 p(F) = (1/2) * (1/2) = 1/4。因此答案是 1/2 + 1/4 - 1/4 = 5/8。",
        "answer_symbols": [
            "=",
            "*",
            "+",
            "-",
            "/"
        ]
    },
    "7.2 32 b)": {
        "question": "10 位二进制串，如果每位的产生是独立的，分别求在 30b) 条件下随机产生一个以 1 开始或以 00 结尾的位串的概率。",
        "answer": "我们有 p(E) = 0.6 和 p(F) = (0.4) * (0.4) = 0.16。因此答案是 0.6 + 0.16 - 0.6 * 0.16 = 0.664。",
        "answer_symbols": [
            "=",
            "*",
            "+",
            "-"
        ]
    },
    "7.2 32 c)": {
        "question": "10 位二进制串，如果每位的产生是独立的，分别求在 30c) 条件下随机产生一个以 1 开始或以 00 结尾的位串的概率。",
        "answer": "我们有 p(E) = 1/2 和 p(F) = (1 - 1/2^⁹) * (1 - 1/2¹^⁰) = 1 - 1/2^⁹ - 1/2¹^⁰ + 1/2¹^⁹。因此答案是 1/2 + 1 - 1/2^⁹ - 1/2¹^⁰ + 1/2¹^⁹ - 1/2 * (1 - 1/2^⁹ - 1/2¹^⁰ + 1/2¹^⁹) = 1 - 1/2^⁹ - 1/2¹^⁰ + 1/2¹^⁹ - 1/2 + 1/2¹^⁰ + 1/2¹¹ + 1/2¹^⁹ - 1/2^²^⁰。",
        "answer_symbols": [
            "=",
            "*",
            "+",
            "-",
            "/",
            "^"
        ]
    },
    "7.2 33 a)": {
        "question": "按照练习 31a) 的条件，分别求出有 5 个孩子的家庭中第 1 个孩子是男孩或者最后 2 个孩子是女孩的概率。",
        "answer": "5/8",
        "answer_symbols": [
            "/"
        ]
    },
    "7.2 33 b)": {
        "question": "按照练习 31b) 的条件，分别求出有 5 个孩子的家庭中第 1 个孩子是男孩或者最后 2 个孩子是女孩的概率。",
        "answer": "0.627649",
        "answer_symbols": [
            "="
        ]
    },
    "7.2 33 c)": {
        "question": "按照练习 31c) 的条件，分别求出有 5 个孩子的家庭中第 1 个孩子是男孩或者最后 2 个孩子是女孩的概率。",
        "answer": "0.643135",
        "answer_symbols": [
            "="
        ]
    },
    "7.2 34 a)": {
        "question": "执行 n 次独立的伯努利试验，其中每次试验的成功概率为 p，求下述每种情况的概率。没有 1 次成功的概率。",
        "answer": "这里 k = 0，因为我们希望所有试验都失败。代入并计算，我们有 b(0; n, p) = 1 * p^⁰ * (1 - p)^ⁿ = (1 - p)^ⁿ。",
        "answer_symbols": [
            "=",
            "*",
            "+",
            "-",
            "^"
        ]
    },
    "7.2 34 b)": {
        "question": "执行 n 次独立的伯努利试验，其中每次试验的成功概率为 p，求下述每种情况的概率。至少 1 次成功的概率。",
        "answer": "至少有一次成功当且仅当没有一次成功的概率不为零。因此，我们通过从 1 中减去第 (a) 部分的概率来获得答案，即 1 - (1 - p)^ⁿ。",
        "answer_symbols": [
            "=",
            "-",
            "^"
        ]
    },
    "7.2 34 c)": {
        "question": "执行 n 次独立的伯努利试验，其中每次试验的成功概率为 p，求下述每种情况的概率。至多 1 次成功的概率。",
        "answer": "最多有一次成功有两种情况：没有成功或一次成功。我们已经计算出没有成功的概率为 (1 - p)^ⁿ。代入 k = 1，我们计算出恰好一次成功的概率为 b(1; n, p) = n * p¹ * (1 - p)^(n-1)。因此答案是 (1 - p)^ⁿ + n * p * (1 - p)^(n-1)。当然，这个公式只有在 n > 0 时才有意义；如果 n = 0，则答案显然是 1。",
        "answer_symbols": [
            "=",
            "*",
            "+",
            "-",
            "^"
        ]
    },
    "7.2 34 d)": {
        "question": "执行 n 次独立的伯努利试验，其中每次试验的成功概率为 p，求下述每种情况的概率。至少 2 次成功的概率。",
        "answer": "由于此事件只是第 (c) 部分事件的对立事件，答案是 1 - [(1 - p)^ⁿ + n * p * (1 - p)^(n-1)]。同样，这是针对 n > 0 的情况；如果 n = 0，则概率显然为 0。",
        "answer_symbols": [
            "=",
            "*",
            "+",
            "-",
            "[",
            "]",
            "^"
        ]
    },
    "7.2 35 a)": {
        "question": "求在下述每种情况下执行 n 次独立的伯努利试验时的概率，其中每次试验的成功概率为 p。没有 1 次失败的概率。",
        "answer": "p^n",
        "answer_symbols": [
            "^"
        ]
    },
    "7.2 35 b)": {
        "question": "求在下述每种情况下执行 n 次独立的伯努利试验时的概率，其中每次试验的成功概率为 p。至少 1 次失败的概率。",
        "answer": "1 - p^n",
        "answer_symbols": [
            "-",
            "^"
        ]
    },
    "7.2 35 c)": {
        "question": "求在下述每种情况下执行 n 次独立的伯努利试验时的概率，其中每次试验的成功概率为 p。至多 1 次失败的概率。",
        "answer": "p^n + n · p^(n-1) · (1 - p)",
        "answer_symbols": [
            "+",
            "-",
            "·",
            "^",
            "(",
            ")"
        ]
    },
    "7.2 35 d)": {
        "question": "求在下述每种情况下执行 n 次独立的伯努利试验时的概率，其中每次试验的成功概率为 p。至少 2 次失败的概率。",
        "answer": "1 - [p^n + n · p^(n-1) · (1 - p)]",
        "answer_symbols": [
            "-",
            "[",
            "]",
            "+",
            "·",
            "^",
            "(",
            ")"
        ]
    },
    "7.2 36": {
        "question": "使用数学归纳法证明如果 E1, E2, …, En 是样本空间 S 中的 n 个两两不相交的事件的序列，其中 n 是正整数，那么 p(∪i=1n Ei) = ∑i=1n p(Ei)。",
        "answer": "基础情况可以取 n = 2，在这种情况下我们有 p(E1 ∪ E2) = p(E1) + p(E2)。左侧是所有 x ∈ E1 ∪ E2 的 p(x) 之和。由于 E1 和 E2 不相交，这是所有 x ∈ E1 的 p(x) 之和加上所有 x ∈ E2 的 p(x) 之和，即右侧。假设对 n ≤ k 强归纳假设成立，考虑 n = k + 1 的情况，即 p(∪_(i=1)^(k+1) Ei) = ∑_(i=1)^(k+1) p(Ei)。令 F = (∪_(i=1)^k Ei)。则我们可以将左侧重写为 p(F ∪ Ek+1)。根据 n = 2 的归纳假设（因为 F ∩ Ek+1 = Ø），这等于 p(F) + p(Ek+1)。然后根据 n = k 的归纳假设（因为 Ei 两两不相交），这等于 ∑_(i=1)^k p(Ei) + p(Ek+1) = ∑_(i=1)^(k+1) p(Ei)，如所需。",
        "answer_symbols": [
            "=",
            "+",
            "∪",
            "∑",
            "∈",
            "∩",
            "Ø"
        ]
    },
    "7.2 37": {
        "question": "(要求微积分) 证明如果 E1, E2, … 是样本空间 S 中的两两不相交的事件的无限序列，那么 p(∪i=1∞ Ei) = ∑i=1∞ p(Ei)。[提示：利用练习 36 并且取极限。]",
        "answer": "p(∪∞ i=1 E_i) 是每个结果 s 在 ∪∞ i=1 E_i 中的概率 p(s) 的总和。因为 E_i 是两两互斥的，这是在任何 E_i 中的所有结果的概率之和，即 ∑∞ i=1 p(E_i)。（我们可以重新排列求和项，仍然得到相同的结果，因为这个级数绝对收敛。）",
        "answer_symbols": [
            "∪",
            "∞",
            "∑",
            "(",
            ")",
            "+"
        ]
    },
    "7.2 38 a)": {
        "question": "在异地掷一对骰子，一个诚实的旁观者通知我们至少有一个骰子掷出 6 点。以诚实的观察者提供的信息为条件，两个骰子掷出的点数之和等于 7 的概率是多少？",
        "answer": "我们假设观察者事先被告知要告诉我们是否至少有一个骰子出现 6 并且不提供更多信息。如果不做这样的假设，以下分析将无效。我们用 (i, j) 表示第一个骰子出现 i，第二个骰子出现 j。注意，有 36 种等可能的结果。设 S 是事件至少有一个骰子出现 6，T 是事件骰子总和为 7。我们想要 p(T | S)。根据定义 3，这等于 p(S ∩ T) / p(S)。S ∩ T 的结果是 (1, 6) 和 (6, 1)，所以 p(S ∩ T) = 2/36。S 中有 5^² = 25 种结果（每个骰子有五种选择），所以 p(S) = (36 - 25) / 36 = 11/36。因此答案是 (2/36) / (11/36) = 2/11。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "*",
            "/",
            "∩"
        ]
    },
    "7.2 38 b)": {
        "question": "假设诚实的观察者告诉我们至少一个骰子是 5 点。以此为给定条件，两个骰子的点数之和等于 7 的概率是多少？",
        "answer": "分析与第 (a) 部分完全相同，因此答案同样是 2/11。",
        "answer_symbols": [
            "/"
        ]
    },
    "7.2 39 a)": {
        "question": "这个练习利用概率方法证明一个关于循环赛的结果。在一个具有 m 个游戏者的循环赛中，每两个人玩一个游戏，其中一个赢，另一个输。我们想要寻找一个关于正整数 m 和 k 的条件 (k < m)，以使得这个循环赛的结果有下述性质的可能：对每 k 个游戏者的集合，存在 1 个游戏者赢了这个集合的每个成员。假设当 2 个游戏者竞争时每个游戏者赢得这个游戏是等可能的，并且假设不同游戏的结果是独立的，这使得我们可以使用概率推理得出关于循环赛的结论。设 k 是小于 m 的正整数，E 是对每个具有 k 个游戏者的集合 S，存在 1 个游戏者赢了 S 中所有 k 个人的事件。证明 p(¯E) ≤ ∑j=1m p(Fj)，这里 Fj 是一个事件，表示在 (m k) 个 k 人的集合构成的表中，没有 1 个游戏者赢了第 j 个集合的所有 k 个人。",
        "answer": "E = ∪(m k) j=1 F_j，所以给定的不等式现在从布尔不等式（练习 15）得出。",
        "answer_symbols": [
            "∪",
            "(",
            ")",
            "="
        ]
    },
    "7.2 39 b)": {
        "question": "证明 Fj 的概率是 (1-2^-k)^(m-k)。",
        "answer": "特定玩家未在第 j 组中的概率为 (1/2)^k = 2^-k。因此，该玩家不能做到这一点的概率为 1 - 2^-k，所以所有 m - k 个不在第 j 组中的玩家无法吹嘘对第 j 组中的每个人都有完美记录的概率为 (1 - 2^-k)^(m-k)。这就是 p(F_j)。",
        "answer_symbols": [
            "^",
            "=",
            "-",
            "(",
            ")"
        ]
    },
    "7.2 39 c)": {
        "question": "从 a) 和 b) 证明 p(¯E) ≤ (m k) (1-2^-k)^(m-k)，因此得知，如果 (m k) (1-2^-k)^(m-k) < 1，一定存在一个竞赛具有所描述的性质。",
        "answer": "第一个不等式立即成立，因为所有加项都相同，并且有 (m k) 个。如果这个概率小于 1，则必须有可能 E 失败，即 E 发生。只要第二个不等式成立，就存在满足问题条件的比赛。",
        "answer_symbols": [
            "(",
            ")",
            "<",
            "≥"
        ]
    },
    "7.2 39 d)": {
        "question": "使用 c) 找出 m 的值，使得在 m 个游戏者的循环赛中对每 2 个游戏者的集合 S，都存在 1 个游戏者，赢了 S 中的 2 个人。对 3 个游戏者的集合重复这个问题。",
        "answer": "对于 k = 2，m ≥ 21；对于 k = 3，m ≥ 91",
        "answer_symbols": [
            "=",
            "≥"
        ]
    },
    "7.2 40": {
        "question": "设计一个蒙特卡罗算法以确定一个整数 1 到 n 的排列是已经被排序的 (即按照递增顺序排列) 还是随机的排列。如果确定这个序列没有被排序，算法的某一步应该回答“真”，否则回答“不知道”。在 k 步以后，如果每步回答都是“不知道”，则算法判定这些整数是排好序的。证明随着步数的增加，算法产生一个错误结果的概率会极小。[提示：对每一步，测试某些元素是否在正确的顺序上。保证这些测试是独立的。]",
        "answer": "We assume that n is much greater than k, since otherwise, we could simply compare each element with its successor in the list and know for sure whether or not the list is sorted. We choose two distinct random integers i and j from 1 to n, and we compare the ith and jth elements of the given list; if they are in correct order relative to each other, then we answer “unknown” at this step and proceed. If not, then we answer “true” (i.e., the list is not sorted) and halt. We repeat this for k steps (or until we have found elements out of order), choosing new random indices each time. If we have not found any elements out of order after k steps, we halt and answer “false” (i.e., the original list is probably sorted). Since in a random list the probability that two randomly chosen elements are in correct order relative to each other is 1/2, the probability that we wrongly answer “false” will be about 1/2^k if the list is a random permutation. If k is large, this will be very small; for example, if k = 100, then this will be less than one chance in 10^30.",
        "answer_symbols": [
            "/",
            "^"
        ]
    },
    "7.2 41": {
        "question": "使用伪码写出在例 16 中描述的素数的概率测试算法。",
        "answer": "过程 p robabilistic p rime(n, k)复合数 := 假i := 0当复合数 = 假 且 i < ki := i + 1随机选择 b 使得 1 < b < n对基数 b 应用米勒测试如果 n 未能通过测试复合数 := 真如果复合数 = 真打印(\"复合数\")否则打印(\"可能是质数\")",
        "answer_symbols": [
            "<",
            ":=",
            ">",
            "+",
            "="
        ]
    },
    "7.3 1": {
        "question": "设 E 和 F 是样本空间中的事件，且 p(E) = 1/3，p(F) = 1/2，p(E | F) = 2/5。求 p(F | E)。",
        "answer": "3/5",
        "answer_symbols": [
            "/"
        ]
    },
    "7.3 2": {
        "question": "设 E 和 F 是样本空间中的事件，且 p(E) = 2/3，p(F) = 3/4，p(F | E) = 5/8。求 p(E | F)。",
        "answer": "We know that p(E | F) = p(E ∩ F) / p(F), so we need to find those two quantities. We are given p(F) = 3/4. To compute p(E ∩ F), we can use the fact that p(E ∩ F) = p(E) p(F | E). We are given that p(E) = 2/3 and that p(F | E) = 5/8; therefore p(F ∩ E) = (2/3)(5/8) = 5/12. Putting this together, we have p(E | F) = (5/12) / (3/4) = 5/9.",
        "answer_symbols": [
            "|",
            "∩",
            "/",
            "(",
            ")",
            "="
        ]
    },
    "7.3 3": {
        "question": "假如弗雷德随机从两个箱子中的一个箱子里选取了一个球，然后又从这个箱子里随机选取了一个球。第一个箱子里有 2 个白球和 3 个蓝球，第二个箱子里有 4 个白球和 1 个蓝球。如果弗雷德选出了 1 个蓝球，那么该球来自第一个箱子的概率是多少?",
        "answer": "3/4",
        "answer_symbols": [
            "/"
        ]
    },
    "7.3 4": {
        "question": "假如安随机从两个箱子中的一个箱子里选取了一个球，然后又从这个箱子里随机选取了一个球。第一个箱子里有 3 个橙色球和 4 个黑球，第二个箱子里有 5 个橙色球和 6 个黑球。如果安选出了一个橙色的球，那么该球来自第二个箱子的概率是多少?",
        "answer": "Let F be the event that Ann picks the second box. Thus we know that p(F) = p(F) = 1/2. Let B be the event that Frida picks an orange ball. Because of the contents of the boxes, we know that p(B | F) = 5/11 (five of the eleven balls in the second box are orange) and p(B | F) = 3/7. We are asked for p(F | B). We use Bayes’ theorem: p(F | B) = p(B | F) p(F) / [p(B | F) p(F) + p(B | F) p(F)] = (5/11)(1/2) / [(5/11)(1/2) + (3/7)(1/2)] = 35 / 68",
        "answer_symbols": [
            "|",
            "=",
            "/",
            "[",
            "]",
            "(",
            ")",
            "+",
            "F",
            "B"
        ]
    },
    "7.3 5": {
        "question": "假如所有自行车赛手中有 8% 的选手使用兴奋剂，使用兴奋剂的选手中有 96% 的人兴奋剂检测呈阳性，不使用兴奋剂的选手中有 9% 的人兴奋剂检测呈阳性。如果随机选择的一个选手其兴奋剂检测呈阳性，那么该选手使用了兴奋剂的概率是多少？",
        "answer": "0.481",
        "answer_symbols": [
            "."
        ]
    },
    "7.3 6": {
        "question": "在对足球选手做兴奋剂检测时，使用兴奋剂的选手中有 98% 的人兴奋剂检测呈阳性，不使用兴奋剂的选手中有 12% 的人兴奋剂检测呈阳性。假如有 5% 的足球选手使用了兴奋剂，那么一个选手兴奋剂检测呈阳性时，该选手使用了兴奋剂的概率是多少？",
        "answer": "Let S be the event that a randomly chosen soccer player uses steroids. We know that p(S) = 0.05 and therefore p(S) = 0.95. Let P be the event that a randomly chosen person tests positive for steroid use. We are told that p(P | S) = 0.98 and p(P | S) = 0.12 (this is a “false positive” test result). We are asked for p(S | P). We use Bayes’ theorem: p(S | P) = p(P | S) p(S) / [p(P | S) p(S) + p(P | S) p(S)] = (0.98)(0.05) / [(0.98)(0.05) + (0.12)(0.95)] ≈ 0.301",
        "answer_symbols": [
            "|",
            "=",
            "/",
            "[",
            "]",
            "(",
            ")",
            "+",
            "S",
            "P"
        ]
    },
    "7.3 7 a)": {
        "question": "假如吸鸦片的检测中有 2% 的阳性错误率和 5% 的阴性错误率，即有 2% 的人没有吸鸦片但鸦片检测呈阳性，有 5% 的人吸了鸦片但鸦片检测呈阴性。此外，假定有 1% 的人吸鸦片。求某人没有吸鸦片且鸦片检测呈阴性的概率。",
        "answer": "0.999",
        "answer_symbols": [
            "."
        ]
    },
    "7.3 7 b)": {
        "question": "假如吸鸦片的检测中有 2% 的阳性错误率和 5% 的阴性错误率，即有 2% 的人没有吸鸦片但鸦片检测呈阳性，有 5% 的人吸了鸦片但鸦片检测呈阴性。此外，假定有 1% 的人吸鸦片。求某人吸了鸦片且鸦片检测呈阳性的概率。",
        "answer": "0.324",
        "answer_symbols": [
            "."
        ]
    },
    "7.3 8 a)": {
        "question": "假如 10 000 个人中有一个人会得少见的遗传病。有一种对该疾病非常准确的检测：得此病的人中 99.9% 的人检测呈阳性，没得此病的人中只有 0.02% 的人检测呈阳性。求某人得了遗传病且检测呈阳性的概率。",
        "answer": "We are asked for p(D | P). We use Bayes’ theorem: p(D | P) = p(P | D) p(D) / [p(P | D) p(D) + p(P | D) p(D)] = (0.9998)(0.9999) / [(0.9998)(0.9999) + (0.001)(0.0001)] ≈ 1.000 (This last answer is exactly 49985001/49985006 ≈ 0.99999989997.)",
        "answer_symbols": [
            "|",
            "=",
            "/",
            "[",
            "]",
            "(",
            ")",
            "+",
            "D",
            "P"
        ]
    },
    "7.3 8 b)": {
        "question": "假如 10 000 个人中有一个人会得少见的遗传病。有一种对该疾病非常准确的检测：得此病的人中 99.9% 的人检测呈阳性，没得此病的人中只有 0.02% 的人检测呈阳性。求某人没得遗传病且检测呈阴性的概率。",
        "answer": "p(D | P) = p(P | D) p(D) / [p(P | D) p(D) + p(P | D) p(D)] = (0.9998)(0.9999) / [(0.9998)(0.9999) + (0.001)(0.0001)] ≈ 1.000 (This last answer is exactly 49985001/49985006 ≈ 0.99999989997.)",
        "answer_symbols": [
            "|",
            "/",
            "[",
            "]",
            "≈",
            "="
        ]
    },
    "7.3 10 a)": {
        "question": "假如某诊所对病人的检测中有 4% 的人感染了禽流感病毒，此外，假定对给定的禽流感血液检测，感染了禽流感的人中有 97% 的人 HIV 检测呈阳性，没感染禽流感的人中有 2% 的人禽流感检测呈阳性。求禽流感检测呈阳性的人真的感染了禽流感病毒的概率。",
        "answer": "p(A | P) = (p(P | A) p(A)) / (p(P | A) p(A) + p(P | A) p(A)) = (0.97)(0.04) / (0.97)(0.04) + (0.02)(0.96) ≈ 0.669",
        "answer_symbols": [
            "|",
            "/",
            "(",
            ")",
            "≈",
            "="
        ]
    },
    "7.3 10 b)": {
        "question": "假如某诊所对病人的检测中有 4% 的人感染了禽流感病毒，此外，假定对给定的禽流感血液检测，感染了禽流感的人中有 97% 的人 HIV 检测呈阳性，没感染禽流感的人中有 2% 的人禽流感检测呈阳性。求禽流感检测呈阳性的人没有感染禽流感病毒的概率。",
        "answer": "p(A | P) = 1 - p(A | P) ≈ 1 - 0.669 = 0.331",
        "answer_symbols": [
            "|",
            "-",
            "≈",
            "="
        ]
    },
    "7.3 10 c)": {
        "question": "假如某诊所对病人的检测中有 4% 的人感染了禽流感病毒，此外，假定对给定的禽流感血液检测，感染了禽流感的人中有 97% 的人 HIV 检测呈阳性，没感染禽流感的人中有 2% 的人禽流感检测呈阳性。求禽流感检测呈阴性的人感染了禽流感病毒的概率。",
        "answer": "p(A | P) = (p(P | A) p(A)) / (p(P | A) p(A) + p(P | A) p(A)) = (0.03)(0.04) / (0.03)(0.04) + (0.98)(0.96) ≈ 0.001",
        "answer_symbols": [
            "|",
            "/",
            "(",
            ")",
            "≈",
            "="
        ]
    },
    "7.3 10 d)": {
        "question": "假如某诊所对病人的检测中有 4% 的人感染了禽流感病毒，此外，假定对给定的禽流感血液检测，感染了禽流感的人中有 97% 的人 HIV 检测呈阳性，没感染禽流感的人中有 2% 的人禽流感检测呈阳性。求禽流感检测呈阴性的人没有感染禽流感病毒的概率。",
        "answer": "p(A | P) = 1 - p(A | P) ≈ 1 - 0.001 = 0.999",
        "answer_symbols": [
            "|",
            "-",
            "≈",
            "="
        ]
    },
    "7.3 11": {
        "question": "某电子公司计划引入一种新的照相手机。公司对每种新产品都制定了一个市场报告来预测产品的成功与失败。此外，在他们预测成功的产品中有 70% 的产品都成功了，而在他们预测成功的产品中有 40% 的产品都没成功。如果预测新的照相手机会成功，那么该产品成功的概率是多少？",
        "answer": "0.724",
        "answer_symbols": [
            "."
        ]
    },
    "7.3 12 a)": {
        "question": "某 Neptune 附近的空中探测器用位串与地球通信。假如传送中它用 1/3 的时间发送的是 1，2/3 的时间发送的是 0。当发送的是 0 时，收到 0 的概率是 0.9，收到 1 的概率是 0.1。当发送的是 1 时，收到 1 的概率是 0.8，收到 0 的概率是 0.2。求收到 0 的概率。",
        "answer": "p(E) = p(E | F1) p(F1) + p(E | F2) p(F2) = 0.9 * (2/3) + 0.2 * (1/3) = 2/3",
        "answer_symbols": [
            "|",
            "+",
            "*",
            "=",
            "/"
        ]
    },
    "7.3 12 b)": {
        "question": "某 Neptune 附近的空中探测器用位串与地球通信。假如传送中它用 1/3 的时间发送的是 1，2/3 的时间发送的是 0。当发送的是 0 时，收到 0 的概率是 0.9，收到 1 的概率是 0.1。当发送的是 1 时，收到 1 的概率是 0.8，收到 0 的概率是 0.2。利用贝叶斯定理求：在收到 0 的条件下，发送的是 0 的概率。",
        "answer": "p(F1 | E) = (p(E | F1) p(F1)) / (p(E | F1) p(F1) + p(E | F2) p(F2)) = (0.9 * (2/3)) / (0.9 * (2/3) + 0.2 * (1/3)) = 0.6 / (2/3) = 0.9",
        "answer_symbols": [
            "|",
            "/",
            "+",
            "*",
            "=",
            "(",
            ")"
        ]
    },
    "7.3 13": {
        "question": "设 E, F1, F2 和 F3 是样本空间 S 中的事件，F1, F2 和 F3 互不相交，且它们的并为 S。如果 p(E|F1) = 1/8, p(E|F2) = 1/4, p(E|F3) = 1/6, p(F1) = 1/4, p(F2) = 1/4, p(F3) = 1/2，求 p(F1|E)。",
        "answer": "3/17",
        "answer_symbols": [
            "/"
        ]
    },
    "7.3 14": {
        "question": "设 E, F1, F2 和 F3 是样本空间 S 中的事件，F1, F2 和 F3 互不相交，且它们的并为 S。如果 p(E|F1) = 2/7, p(E|F2) = 3/8, p(E|F3) = 1/2, p(F1) = 1/6, p(F2) = 1/2, p(F3) = 1/3，求 p(F2|E)。",
        "answer": "p(F2 | E) = (p(E | F2) p(F2)) / (p(E | F1) p(F1) + p(E | F2) p(F2) + p(E | F3) p(F3)) = (3/8)(1/2) / ((2/7)(1/6) + (3/8)(1/2) + (1/2)(1/3)) = 7",
        "answer_symbols": [
            "|",
            "/",
            "+",
            "*",
            "=",
            "(",
            ")"
        ]
    },
    "7.3 15 a)": {
        "question": "本题利用贝叶斯定理求解蒙地厅大厦难题。在这个难题中，要求我们选择打开 3 扇门中的一扇门。其中的一扇门后面有一个大奖，另外两扇门后面没有奖。当你选择了一扇门后，蒙地厅大厦打开你没有选择的两扇门中的一扇门，他知道那扇门后面没有奖，如果这两扇门后面都是没有奖的，他就随机打开其中的一扇门。蒙地厅问你是否愿意选定那扇门。假设难题中的 3 扇门分别标有 1、2、3 号。设 W 是随机变量，其值是获奖门的号码。假定对 k = 1, 2, 3, p(W = k) = 1/3。设 M 是随机变量，其值是蒙地厅打开的那扇门的门号。假如你选择的门号为 i。如果在蒙地厅问你是否改变门号之前游戏结束，你获奖的概率是多少？",
        "answer": "1/3",
        "answer_symbols": [
            "/"
        ]
    },
    "7.3 15 b)": {
        "question": "本题利用贝叶斯定理求解蒙地厅大厦难题。在这个难题中，要求我们选择打开 3 扇门中的一扇门。其中的一扇门后面有一个大奖，另外两扇门后面没有奖。当你选择了一扇门后，蒙地厅大厦打开你没有选择的两扇门中的一扇门，他知道那扇门后面没有奖，如果这两扇门后面都是没有奖的，他就随机打开其中的一扇门。蒙地厅问你是否愿意选定那扇门。假设难题中的 3 扇门分别标有 1、2、3 号。设 W 是随机变量，其值是获奖门的号码。假定对 k = 1, 2, 3, p(W = k) = 1/3。设 M 是随机变量，其值是蒙地厅打开的那扇门的门号。假如你选择的门号为 i。对 j = 1, 2, 3 和 k = 1, 2, 3，求 p(M = j|W = k)。",
        "answer": "如果 i、j 和 k 各不相同，则 p(M = j | W = k) = 1；如果 j = k 或 j = i，则 p(M = j | W = k) = 0；如果 i = k 且 j ≠ i，则 p(M = j | W = k) = 1/2",
        "answer_symbols": [
            "|",
            "=",
            "≠",
            ";"
        ]
    },
    "7.3 15 c)": {
        "question": "本题利用贝叶斯定理求解蒙地厅大厦难题。在这个难题中，要求我们选择打开 3 扇门中的一扇门。其中的一扇门后面有一个大奖，另外两扇门后面没有奖。当你选择了一扇门后，蒙地厅大厦打开你没有选择的两扇门中的一扇门，他知道那扇门后面没有奖，如果这两扇门后面都是没有奖的，他就随机打开其中的一扇门。蒙地厅问你是否愿意选定那扇门。假设难题中的 3 扇门分别标有 1、2、3 号。设 W 是随机变量，其值是获奖门的号码。假定对 k = 1, 2, 3, p(W = k) = 1/3。设 M 是随机变量，其值是蒙地厅打开的那扇门的门号。假如你选择的门号为 i。利用贝叶斯定理求 p(W=j|M=k)，其中 j 和 k 的值不同。",
        "answer": "2/3",
        "answer_symbols": [
            "/"
        ]
    },
    "7.3 15 d)": {
        "question": "本题利用贝叶斯定理求解蒙地厅大厦难题。在这个难题中，要求我们选择打开 3 扇门中的一扇门。其中的一扇门后面有一个大奖，另外两扇门后面没有奖。当你选择了一扇门后，蒙地厅大厦打开你没有选择的两扇门中的一扇门，他知道那扇门后面没有奖，如果这两扇门后面都是没有奖的，他就随机打开其中的一扇门。蒙地厅问你是否愿意选定那扇门。假设难题中的 3 扇门分别标有 1、2、3 号。设 W 是随机变量，其值是获奖门的号码。假定对 k = 1, 2, 3, p(W = k) = 1/3。设 M 是随机变量，其值是蒙地厅打开的那扇门的门号。假如你选择的门号为 i。解释为什么 c) 的答案告诉了你：当蒙地厅给你改变门号的机会时，你是否应该改变。",
        "answer": "你应该换门，因为你现在有 2/3 的机会通过换门获胜。",
        "answer_symbols": [
            "/"
        ]
    },
    "7.3 16 a)": {
        "question": "Remesh 可以通过 3 种不同的方式去工作：骑自行车、开车或坐公共汽车。由于上班族引起的交通繁忙，他若开车上班，则有 50% 的可能迟到。他若坐公共汽车上班，公共汽车可以走一条专门为公共汽车行驶的路线，那他有 20% 的可能迟到。他骑车上班只有 5% 的可能迟到。Remesh 有一天迟到了。他的老板想估计他那天开车上班的概率。假定老板假设 Remesh 以 1/3 的可能采用 3 种方法中的任何一种方法来上班。在此假设下，根据贝叶斯定理，Remesh 开车来上班的概率估计是多少？",
        "answer": "p(C | L) = (p(L | C) p(C)) / (p(L | B) p(B) + p(L | C) p(C) + p(L | O) p(O)) = (0.50)(1/3) / (0.05)(1/3) + (0.50)(1/3) + (0.20)(1/3) = 2/3",
        "answer_symbols": [
            "|",
            "/",
            "+",
            "*",
            "=",
            "(",
            ")"
        ]
    },
    "7.3 16 b)": {
        "question": "Remesh 可以通过 3 种不同的方式去工作：骑自行车、开车或坐公共汽车。由于上班族引起的交通繁忙，他若开车上班，则有 50% 的可能迟到。他若坐公共汽车上班，公共汽车可以走一条专门为公共汽车行驶的路线，那他有 20% 的可能迟到。他骑车上班只有 5% 的可能迟到。Remesh 有一天迟到了。他的老板想估计他那天开车上班的概率。假定老板知道 Remesh 开车的可能性有 30%，坐公共汽车的可能性有 10%，骑自行车的可能性有 60%。利用这些信息，根据贝叶斯定理，Remesh 开车来上班的概率估计是多少？",
        "answer": "p(C | L) = (p(L | C) p(C)) / (p(L | B) p(B) + p(L | C) p(C) + p(L | O) p(O)) = (0.50)(0.30) / (0.05)(0.60) + (0.50)(0.30) + (0.20)(0.10) = 3/4",
        "answer_symbols": [
            "|",
            "/",
            "+",
            "*",
            "=",
            "(",
            ")"
        ]
    },
    "7.3 17": {
        "question": "证明扩展的贝叶斯定理。即，设 E 是取自样本空间 S 的事件，F1, F2, …, Fn 是互斥事件，且 ∪Fi=S，假定 p(E)≠0，p(Fi)≠0(i=1, 2, …, n)，则 p(Fi|E) = p(E|Fi)p(Fi) / ∑ p(E|Fi)p(Fi) [提示：利用事实 E=∪(E∩Fi)]",
        "answer": "条件概率的定义告诉我们 p(F_j | E) = p(E ∩ F_j)/p(E)。对于分子，再次使用条件概率的定义，我们有 p(E ∩ F_j) = p(E | F_j)p(F_j)，如所愿。对于分母，我们证明 p(E) = ∑n i=1 p(E | F_i)p(F_i)。事件 E ∩ F_i 划分了事件 E；即，当 i1 ≠ i2 时 (E ∩ F_i1) ∩ (E ∩ F_i2) = ∅（因为 F_i 互斥），并且 ∪n i=1 (E ∩ F_i) = E（因为 ∪n i=1 F_i = S）。因此，p(E) = ∑n i=1 p(E ∩ F_i) = ∑n i=1 p(E | F_i)p(F_i)。",
        "answer_symbols": [
            "|",
            "∩",
            "∪",
            "∑",
            "(",
            ")",
            "=",
            "≠",
            "∅"
        ]
    },
    "7.3 18": {
        "question": "假设一个贝叶斯垃圾邮件过滤器在一个有 500 个垃圾邮件信息和 200 个非垃圾邮件信息的集合上训练。字“exciting”出现在了 40 个垃圾邮件信息和 25 个非垃圾邮件信息中。如果一条信息中含有字“exciting”，且拒绝垃圾邮件的阈值是 0.9，那么这条信息会被拒绝吗？",
        "answer": "We first compute that p(exciting) = 40/500 = 0.08 and q(exciting) = 25/200 = 0.125. Then we compute that r(exciting) = p(exciting) / (p(exciting) + q(exciting)) = 0.08 / (0.08 + 0.125) ≈ 0.390. Because r(exciting) is less than the threshold 0.9, an incoming message containing \"exciting\" would not be rejected.",
        "answer_symbols": [
            "=",
            "/",
            "+",
            "(",
            ")",
            "<"
        ]
    },
    "7.3 20 a)": {
        "question": "我们会把例 4 中的信息看成垃圾邮件而拒绝它吗？只利用字“undervalued”出现在信息中这一事实。",
        "answer": "In Example 4 we found p(undervalued) = 0.1 and q(undervalued) = 0.025. So we compute that r(undervalued) = p(undervalued) / (p(undervalued) + q(undervalued)) = 0.01 / (0.01 + 0.025) ≈ 0.286. Because r(undervalued) is less than the threshold 0.9, an incoming message containing \"undervalued\" would not be rejected.",
        "answer_symbols": [
            "=",
            "/",
            "+",
            "(",
            ")",
            "<"
        ]
    },
    "7.3 20 b)": {
        "question": "我们会把例 4 中的信息看成垃圾邮件而拒绝它吗？只利用字“stock”出现在信息中这一事实。",
        "answer": "This is similar to part(a), where p(stock) = 0.2 and q(stock) = 0.06. Then we compute that r(stock) = p(stock) / (p(stock) + q(stock)) = 0.2 / (0.2 + 0.06) ≈ 0.769. Because r(stock) is less than the threshold 0.9, an incoming message containing \"stock\" would not be rejected. Notice that each event alone was not enough to cause rejection, but both events together were enough (see Example 4).",
        "answer_symbols": [
            "=",
            "/",
            "+",
            "(",
            ")",
            "<"
        ]
    },
    "7.3 22 a)": {
        "question": "如果我们有关于一条随机信息是不是垃圾邮件的先验知识。特别地，假定经过一段时期，我们发现收到了 s 条垃圾邮件信息和 n 条非垃圾邮件信息。利用这一信息估计所收到的信息是垃圾邮件的概率 p(S) 和所收到的信息不是垃圾邮件的概率 p(¬S)。",
        "answer": "Out of a total of s + h messages, s are spam, so p(S) = s / (s + h). Similarly, p(S) = h / (s + h).",
        "answer_symbols": [
            "=",
            "/",
            "+",
            "(",
            ")"
        ]
    },
    "7.3 22 b)": {
        "question": "如果我们有关于一条随机信息是不是垃圾邮件的先验知识。特别地，假定经过一段时期，我们发现收到了 s 条垃圾邮件信息和 n 条非垃圾邮件信息。利用贝叶斯定理和 a) 估计收到的含有字 w 的信息是垃圾邮件的概率，其中 p(w) 是 w 出现在垃圾邮件信息中的概率，q(w) 是 w 出现在非垃圾邮件信息中的概率。",
        "answer": "Let W be the event that an incoming message contains the word w. We are told that p(W | S) = p(w) and p(W | S) = q(w). We want to find p(S | W). We use Bayes' theorem: p(S | W) = (p(W | S) * p(S)) / (p(W | S) * p(S) + p(W | S) * p(S)) = (p(w) * s / (s + h)) / (p(w) * s / (s + h) + q(w) * h / (s + h)) = (p(w) * s) / (p(w) * s + q(w) * h) The assumption made in this section was that s = h, so those factors cancel out of this answer to give the formula for r(w) obtained in the text.",
        "answer_symbols": [
            "|",
            "=",
            "/",
            "+",
            "*",
            "(",
            ")",
            "p",
            "q",
            "s",
            "h",
            "w",
            "S",
            "W"
        ]
    },
    "7.4 2": {
        "question": "当一个均匀的硬币被掷 10 次时，头像在上的预期次数是多少？",
        "answer": "By Theorem 2 the expected number of successes for n Bernoulli trials is np. In the present problem we have n = 10 and p = 1/2. Therefore the expected number of successes (i.e., appearances of a head) is 10 * (1/2) = 5.",
        "answer_symbols": [
            "=",
            "*",
            "n",
            "p"
        ]
    },
    "7.4 4": {
        "question": "一个硬币是不均匀的，使得掷出头像的概率是 0.6。当掷 10 次时，头像在上的预期次数是多少？",
        "answer": "This is identical to Exercise 2, except that p = 0.6. Thus the expected number of heads is 10 * 0.6 = 6.",
        "answer_symbols": [
            "=",
            "*",
            "p"
        ]
    },
    "7.4 6": {
        "question": "如果彩票包含了从集合 {1, 2, 3, …, 50} 选出的 6 个中奖数字就赢奖 1000 万美元，否则不中奖，那么买 1 美元彩票中奖的期望值是多少？",
        "answer": "There are C(50, 6) equally likely possible outcomes when the state picks its winning numbers. The probability of winning $10 million is therefore 1 / C(50, 6), and the probability of winning $0 is 1 - (1 / C(50, 6)). By definition, the expectation is therefore $10,000,000 * 1 / C(50, 6) + 0 = $10,000,000 / 15,890,700 ≈ $0.63.",
        "answer_symbols": [
            "C",
            "=",
            "-",
            "+",
            "(",
            ")",
            "/"
        ]
    },
    "7.4 8": {
        "question": "当掷 3 个均匀的骰子时预期出现的数字和是多少？",
        "answer": "By Theorem 3 we know that the expectation of a sum is the sum of the expectations. In the current exercise we can let X be the random variable giving the value on the first die, let Y be the random variable giving the value on the second die, and let Z be the random variable giving the value on the third die. In order to compute the expectation of X, of Y, and of Z, we can ignore what happens on the dice not under consideration. Looking just at the first die, then, we compute that the expectation of X is 1 * 1/6 + 2 * 1/6 + 3 * 1/6 + 4 * 1/6 + 5 * 1/6 + 6 * 1/6 = 3.5. Similarly, E(Y) = 3.5 and E(Z) = 3.5. Therefore E(X + Y + Z) = 3 * 3.5 = 10.5.",
        "answer_symbols": [
            "=",
            "+",
            "*",
            "(",
            ")",
            "E",
            "X",
            "Y",
            "Z"
        ]
    },
    "7.4 26": {
        "question": "设X(s)是随机变量，对所有s∈S，X(s)是非负整数，且A是满足X(s)≥k的事件。证明E(X)=∑p(A)",
        "answer": "E(X) = ∑ k · p(X= k). 让我们写出并重新分组（即使总和是无限的，这种重新分组也是有效的，因为所有项都是正的）： E(X) = p(X= 1) + (p(X= 2) + p(X= 2)) + (p(X= 3) + p(X= 3) + p(X= 3)) + · · · = (p(X= 1) + p(X= 2) + p(X= 3) + · · ·) + (p(X= 2) + p(X= 3) + · · ·) + (p(X= 3) + · · ·) + · · ·。但这正是 p(A1) + p(A2) + p(A3) + · · ·，正如所愿。",
        "answer_symbols": [
            "=",
            "∑",
            "+",
            "·",
            "(",
            ")",
            "∞"
        ]
    },
    "7.4 28": {
        "question": "当一个均匀的骰子被掷10次时，出现6点的次数的方差是什么？",
        "answer": "在例 18 中我们看到，n 次伯努利试验中成功次数的方差为 npq。这里 n= 10 且 p= 1/6 和 q= 5/6。因此方差为 25/18。",
        "answer_symbols": [
            "=",
            "n",
            "p",
            "q",
            "+",
            "1",
            "/",
            "6",
            "5",
            "25",
            "18"
        ]
    },
    "7.4 30": {
        "question": "证明如果X和Y是独立随机变量，则V(XY)=E(X)^2V(Y)+E(Y)^2V(X)+V(X)V(Y)",
        "answer": "这是一个代数练习，使用本节的定义和定理。根据定理 6，左边是 E(X^²Y^²) - E(XY)^²，这等于 E(X^²)E(Y^²) - E(X)^²E(Y)^²，因为 X 和 Y 是独立的。 右边是 E(X)^²V(Y) + V(X)V(Y) + E(Y)^²V(X) = V(Y)(E(X)^² + V(X)) + E(Y)^²V(X) = (E(Y^²) - E(Y)^²)(E(X)^² + V(X)) + E(Y)^²V(X) = E(Y^²)E(X)^² + E(Y^²)V(X) - E(Y)^²E(X)^² = E(Y^²)E(X)^² + E(Y^²)(E(X^²) - E(X)^²) - E(Y)^²E(X)^² = E(Y^²)E(X^²) - E(Y)^²E(X)^²，这是相同的结果。",
        "answer_symbols": [
            "=",
            "-",
            "+",
            "E",
            "X",
            "Y",
            "V",
            "²",
            "(",
            ")",
            "·"
        ]
    },
    "7.4 32": {
        "question": "提供一个例子说明当两个随机变量不独立时，它们的和的方差不一定等于它们的方差之和",
        "answer": "一个戏剧性的例子是取 Y= -X。那么两个随机变量之和恒为 0，所以方差当然为 0；但方差之和为 2V(X)，因为 Y 与 X 有相同的方差。另一个（更具体的）例子，我们可以取 X 为抛硬币时出现正面的次数，Y 为出现反面的次数。那么根据例 14，V(X) = V(Y) = 1/4；但显然 X + Y = 1，所以 V(X + Y) = 0。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "V",
            "X",
            "Y",
            "0",
            "1",
            "2",
            "4"
        ]
    },
    "7.4 34": {
        "question": "证明定理7的一般情况。即证明：如果X1、X2、…、Xn是样本空间S上两两独立的随机变量，其中n是正整数，那么V(X1+X2+…+Xn)=V(X1)+V(X2)+…+V(Xn)。[提示：对定理7中两个随机变量的情况进行推广。注意：利用数学归纳法的证明是无效的，见练习33]",
        "answer": "我们真正需要做的就是复制定理 7 的证明，将两个事件的和替换为 n 个事件的和。代数稍微复杂一点。我们将使用求和符号。注意，根据分配律我们有 ( ∑ ai)^² = ∑ a^²i + 2∑ aiaj。从定理 6 我们有 V( ∑ Xi) = E(( ∑ Xi)^²) - (E( ∑ Xi))^²。根据代数和期望的线性性质可以得出 V( ∑ Xi) = E( ∑ Xi^² + 2∑ XiXj) - (∑ E(Xi))^² = ∑ E(Xi^²) + 2∑ E(XiXj) - ∑ E(Xi)^² - 2∑ E(Xi)E(Xj)。由于事件是两两互斥的，根据定理 5 我们有 E(XiXj) = E(Xi)E(Xj)。因此 V( ∑ Xi) = ∑ (E(Xi^²) - E(Xi)^²) = ∑ V(Xi)。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "V",
            "E",
            "X",
            "Y",
            "∑",
            "²",
            "(",
            ")",
            "·"
        ]
    },
    "7.4 42 d)": {
        "question": "证明p(第j个最小元素和第k个最小元素被比较过的概率)等于2/(k-j+1)，其中k > j",
        "answer": "我们用强归纳法证明这一点。当n = 2时，这是正确的，因为在这种情况下两个元素确实被比较了一次，而2/(k-j+1) = 2/(2-1+1) = 1。假设归纳假设成立，考虑快速排序的第一轮。假设第一位置的元素（本轮要比较的元素）是第i小的元素。如果j < i < k，那么第j小的元素被放入第一个子列表。In a random permutation, if the j-th smallest element and the k-th smallest element are placed into different sublists, they will never be compared. This happens with probability (k - j - 1)/n. If i = j or i = k, then the j-th smallest element and the k-th smallest element will be compared this round. This happens with probability 2/n. If i < j, then both the j-th smallest element and the k-th smallest element get put into the second sublist, and by induction, the probability that they will be compared later on will be 2/(k - j + 1). Similarly, if i > k. The probability that i < j is (j - 1)/n, and the probability that i > k is (n - k)/n. Putting this all together, the probability of the desired comparison is: 0 · (k - j - 1)/n + 1 · 2/n + 2 · 2/(k - j + 1) · ((j - 1)/n + (n - k)/n) This simplifies to 2/(k - j + 1), as desired.",
        "answer_symbols": [
            "-",
            "+",
            "/",
            "·",
            "<",
            ">"
        ]
    },
    "7.4 42 e)": {
        "question": "使用c)和d)证明E(X) = 2(n+1) ( ∑i=1^n 1/i ) - 2(n-1)",
        "answer": "From the previous two parts, we need to prove that: ∑_(k=2)^(n) ∑_(j=1)^(k-1) 2/(k - j + 1) = 2(n + 1) ∑_(i=2)^(n) 1/i - 2(n - 1) This can be done, painfully, by induction.",
        "answer_symbols": [
            "∑",
            "(",
            ")",
            "-",
            "+",
            "=",
            "/",
            "·"
        ]
    },
    "7.4 42 f)": {
        "question": "从e)和∑i=1^n 1/i ≈ ln n + γ的事实证明快速排序算法的平均比较次数是Θ(n log n)。这里的γ = 0.577是欧拉常数",
        "answer": "This follows immediately from the previous two parts.",
        "answer_symbols": []
    },
    "7.4 44": {
        "question": "证明Cov(X, Y) = E(XY) - E(X)E(Y)，并使用这一结果证明，如果X和Y是独立的随机变量则Cov(X, Y) = 0",
        "answer": "We can prove this by doing some algebra on the definition, using the facts (Theorem 3) that the expectation of a sum (or difference) is the sum (or difference) of the expectations and that the expectation of a constant times a random variable equals that constant times the expectation of the random variable: Cov(X, Y) = E((X - E(X)) · (Y - E(Y))) = E(XY - Y · E(X) - X · E(Y) + E(X) · E(Y)) = E(XY) - E(Y) · E(X) - E(X) · E(Y) + E(X) · E(Y) = E(XY) - E(X) · E(Y) If X and Y are independent, then by Theorem 5 these last two terms are the same, so their difference is 0.",
        "answer_symbols": [
            "-",
            "+",
            "·",
            "(",
            ")",
            "="
        ]
    },
    "7.4 46": {
        "question": "如果X和Y是具有X((i, j)) = 2i和Y((i, j)) = i + j的随机变量，其中i和j是掷两个均匀的骰子时出现在第一个和第二个骰子上的点数，求Cov(X+Y)",
        "answer": "We can use the result of Exercise 44. It is easy to see that E(X) = 7 and E(Y) = 7 (see Example 4). To find the expectation of XY, we construct the following table to show the value of 2i(i + j) for the 36 equally-likely outcomes (i is the row label, j the column label): | | 1 | 2 | 3 | 4 | 5 | 6 | |---|----|----|----|----|----|----| | 1 | 4 | 6 | 8 | 10 | 12 | 14 | | 2 | 12 | 16 | 20 | 24 | 28 | 32 | | 3 | 24 | 30 | 36 | 42 | 48 | 54 | | 4 | 40 | 48 | 56 | 64 | 72 | 80 | | 5 | 60 | 70 | 80 | 90 | 100| 110| | 6 | 84 | 96 | 108| 120| 132| 144| The expected value of XY is therefore the sum of these entries divided by 36, namely 1974/36 = 329/6. Therefore, the covariance is: 329/6 - 7 · 7 = 35/6 ≈ 5.8",
        "answer_symbols": [
            "|",
            "−",
            "+",
            "·",
            "=",
            "/",
            "≈"
        ]
    },
    "7.4 48": {
        "question": "m个球被均匀地随机分到n个箱子里，预期落入第一个箱子的球数是多少？",
        "answer": "Let X = X_1 + X_2 + ⋯ + X_m, where X_i = 1 if the i-th ball falls into the first bin and X_i = 0 otherwise. Then X is the number of balls that fall into the first bin, so we are being asked to compute E(X). Clearly E(X_i) = P(X_i = 1) = 1/n. By linearity of expectation (Theorem 3), the expected number of balls that fall into the first bin is therefore m/n.",
        "answer_symbols": [
            "=",
            "+",
            "·",
            "(",
            ")",
            "/"
        ]
    },
    "7 Supplementary Exercises 2 a)": {
        "question": "计算玩家中大奖的概率。",
        "answer": "只有一种方法可以中奖，因此中奖的概率是 1/175,711,536。",
        "answer_symbols": [
            "*",
            "/",
            "≈",
            "^"
        ]
    },
    "7 Supplementary Exercises 2 b)": {
        "question": "当匹配前 5 个数字而与第 6 个数字不匹配时，可赢得 250.00 美元，计算中这个奖的概率。",
        "answer": "在这种情况下，有 45 种方法可以赢（你不能匹配第六个球），所以答案是 45/175,711,536 ≈ 1/3,904,701。",
        "answer_symbols": [
            "*",
            "/",
            "≈",
            "^"
        ]
    },
    "7 Supplementary Exercises 6 a)": {
        "question": "求下述各种情况下的概率。选7张扑克牌包含2类，其中一类4张，第二类3张。",
        "answer": "这样的手牌数量是 13 * 12 * 4，因为有 13 种方法选择四张同花色的牌的种类，然后有 12 种方法选择另一张三张同花色的牌的种类，然后有 C(4, 3) = 4 种方法选择那第二种牌的哪三张。因此概率是 624 / 133,784,560 ≈ 4.7 × 10^-6。",
        "answer_symbols": [
            "*",
            "/",
            "≈",
            "^"
        ]
    },
    "7 Supplementary Exercises 6 b)": {
        "question": "求下述各种情况下的概率。选7张扑克牌包含3类，其中一类3张，另外两类每类各2张。",
        "answer": "这样的手牌数量是 13 * 4 * 66 * 62，因为有 13 种方法选择三张同花色的牌的种类，有 C(4, 3) = 4 种方法选择那种牌的哪三张，然后有 C(12, 2) = 66 种方法选择另外两张对子的种类，然后有 C(4, 2) = 6 种方法选择每种对子的哪两张。因此概率是 123,552 / 133,784,560 ≈ 9.2 × 10^-4。\n",
        "answer_symbols": [
            "*",
            "/",
            "≈",
            "^"
        ]
    },
    "7 Supplementary Exercises 8 a)": {
        "question": "当掷一个均匀的十二面体骰子时，出现数字的期望值是什么？",
        "answer": "结果 1 到 12 每个出现的概率为 1/12，所以期望值是 (1/12)(1 + 2 + 3 + ... + 12) = 13/2。",
        "answer_symbols": [
            "/",
            "+",
            "="
        ]
    },
    "7 Supplementary Exercises 8 b)": {
        "question": "当掷一个均匀的十二面体骰子时，出现数字的方差是什么？",
        "answer": "我们计算 V(X) = E(X^²) - E(X)^² = (1/12)(1^² + 2^² + 3^² + ... + 12^²) - (13/2)^² = (325/6) - (169/4) = 143/12。",
        "answer_symbols": [
            "=",
            "-",
            "+",
            "²",
            "(",
            ")",
            "/"
        ]
    },
    "7 Supplementary Exercises 10 a)": {
        "question": "假设掷一对均匀的十二面体骰子。出现数字之和的期望值是什么？",
        "answer": "由于期望值是线性的，总和的期望值是各个期望值的总和，每个期望值由第 8 题 a 部分得出为 13/2。因此答案是 13。",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "7 Supplementary Exercises 10 b)": {
        "question": "假设掷一对均匀的十二面体骰子。出现数字之和的方差是什么？",
        "answer": "由于方差对于独立随机变量是线性的，并且显然这些变量是独立的，总和的方差是各个方差的总和，每个方差由第 8 题 b 部分得出为 143/12。因此答案是 143/6。",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "7 Supplementary Exercises 12 a)": {
        "question": "假设一个均匀的八面体骰子和一个均匀的十二面体骰子一起掷。出现数字之和的期望值是什么？",
        "answer": "由于期望值是线性的，总和的期望值是各个期望值的总和，分别是 9/2 和 13/2。因此答案是 (9/2) + (13/2) = 11。",
        "answer_symbols": [
            "+",
            "=",
            "/"
        ]
    },
    "7 Supplementary Exercises 12 b)": {
        "question": "假设一个均匀的八面体骰子和一个均匀的十二面体骰子一起掷。出现数字之和的方差是什么？",
        "answer": "由于方差对于独立随机变量是线性的，并且显然这些变量是独立的，总和的方差是各个方差的总和，分别是 21/4 和 143/12。因此答案是 (21/4) + (143/12) = 103/6。",
        "answer_symbols": [
            "+",
            "=",
            "/"
        ]
    },
    "7 Supplementary Exercises 2 c)": {
        "question": "当匹配前 5 个数字中的 3 个而与第 6 个数字不匹配，或者匹配前 5 个数字中的 2 个而与第 6 个数字也匹配时，可赢得 150 美元，计算中这个奖的概率。",
        "answer": "要匹配前五个球中的三个，有 C(5, 3) 种方法选择匹配的号码和 C(51, 2) 种方法选择不匹配的号码；因此这种情况下的分子是 C(5, 3) * C(51, 2)。同样地，匹配前五个球中的四个但不匹配第六个球可以以 C(5, 4) * C(51, 1) * 45 种方法完成。因此答案是 (C(5, 3) * C(51, 2) + C(5, 4) * C(51, 1) * 45) / (C(56, 5) * C(46, 1)) = 24,225 / 175,711,536 ≈ 1/7253。",
        "answer_symbols": [
            "*",
            "/",
            "≈",
            "^"
        ]
    },
    "7 Supplementary Exercises 2 d)": {
        "question": "计算玩家在匹配前 5 个数字或者最后一个数字的 3 个数字则算中奖，计算中这个奖的概率。",
        "answer": "不获奖要求不匹配前五个数字中的零、一或两个，并且不匹配第六个数字。因此答案是 1 - ((C(5, 0) * C(51, 5) + C(5, 1) * C(51, 4) + C(5, 2) * C(51, 3)) * 45) / (C(59, 5) * C(46, 1)) = 34,961 / 1,394,536 ≈ 1/40。\n",
        "answer_symbols": [
            "*",
            "/",
            "≈",
            "^"
        ]
    },
    "7 Supplementary Exercises 4": {
        "question": "确定需要多少人，才能保证其中至少 2 个人的生日在每年的同一天的概率至少是 70%、80%、90%、95%、98% 和 99%。",
        "answer": "有 C(52, 13) 种可能的手牌。没有对子的手牌必须包含每种花色的一张牌。因此，唯一的选择是每个 13 张牌的花色。有 4 种方法指定花色，有 13 项任务需要完成。因此，没有对子的手牌有 4^13 种。因此，抽取这样一手牌的概率是 4^13 / C(52, 13) = 67,108,864 / 635,013,559,600 = 4,194,304 / 39,688,347,475 ≈ 0.000106。",
        "answer_symbols": [
            "*",
            "/",
            "≈",
            "^"
        ]
    },
    "7 Supplementary Exercises 6 c)": {
        "question": "求下述各种情况下的概率。选7张扑克牌包含4类，其中三类每类各2张，第四类1张。",
        "answer": "这样的手牌数量是 286 * 63 * 10 * 4，因为有 C(13, 3) = 286 种方法选择对子的种类，有 C(4, 2) = 6 种方法选择每种对子的哪两张，有 10 种方法选择单张的种类，有 4 种方法选择那种牌的哪一张。因此概率是 2,471,040 / 133,784,560 ≈ 0.018。",
        "answer_symbols": [
            "*",
            "/",
            "≈",
            "^"
        ]
    },
    "7 Supplementary Exercises 6 d)": {
        "question": "求下述各种情况下的概率。选7张扑克牌包含5类，其中两类每类各2张，另三类每类各3张。",
        "answer": "这样的手牌数量是 78 * 62 * 165 * 43，因为有 C(13, 2) = 78 种方法选择对子的种类，有 C(4, 2) = 6 种方法选择每种对子的哪两张，有 C(11, 3) = 165 种方法选择单张的种类，有 4 种方法选择每种单张的哪一张。因此概率是 29,652,480 / 133,784,560 ≈ 0.22。",
        "answer_symbols": [
            "*",
            "/",
            "≈",
            "^"
        ]
    },
    "7 Supplementary Exercises 6 e)": {
        "question": "求下述各种情况下的概率。选7张扑克牌包含7类不同的牌。",
        "answer": "这样的手牌数量是 1716 * 47，因为有 C(13, 7) = 1716 种方法选择种类，有 4 种方法选择每种牌的哪一张。因此概率是 28,114,944 / 133,784,560 ≈ 0.21。\n",
        "answer_symbols": [
            "*",
            "/",
            "≈",
            "^"
        ]
    },
    "7 Supplementary Exercises 6 f)": {
        "question": "求下述各种情况下的概率。选7张扑克牌包含一个7张牌的顺子。",
        "answer": "这样的手牌数量是 4 * 1716，因为有 4 种方法选择同花色的花色，有 C(13, 7) = 1716 种方法选择那种花色的种类。因此概率是 6864 / 133,784,560 ≈ 5.1 × 10^-5。",
        "answer_symbols": [
            "*",
            "/",
            "≈",
            "^"
        ]
    },
    "7 Supplementary Exercises 6 g)": {
        "question": "求下述各种情况下的概率。选7张扑克牌包含一个7张牌的同花顺子。",
        "answer": "这样的手牌数量是 8 * 47，因为有 8 种方法选择顺子的起始种类（A, 2, 3, 4, 5, 6, 7 或 8），有 4 种方法选择每种牌的哪一张。因此概率是 131,072 / 133,784,560 ≈ 9.8 × 10^-4。",
        "answer_symbols": [
            "*",
            "/",
            "≈",
            "^"
        ]
    },
    "7 Supplementary Exercises 14": {
        "question": "设p和q是素数且n=pq。随机选择小于n的正整数不被p或q整除的概率是多少？",
        "answer": "我们需要确定小于 n = pq 的正整数中有多少可以被 p 或 q 整除。当然，数 p, 2p, 3p, ..., (q - 1)p 都可以被 p 整除。这给出了 q - 1 个数。同样，p - 1 个数可以被 q 整除。没有这些数同时被 p 和 q 整除，因为最小公倍数 lcm(p, q) = pq / gcd(p, q) = pq / 1 = pq = n。因此在这个范围内可以被 p 或 q 整除的数有 p + q - 2 个，剩下的 pq - 1 - (p + q - 2) = pq - p - q + 1 = (p - 1)(q - 1) 个不能被 p 或 q 整除。因此在该范围内随机选择一个整数不被 p 或 q 整除的概率为 (p - 1)(q - 1) / (pq - 1)。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "*",
            "/",
            "(",
            ")"
        ]
    },
    "7 Supplementary Exercises 16": {
        "question": "设E1, E2, …, En是n个事件满足p(Ei)>0, i=1, 2, …, n。证明p(E1∩E2∩…∩En)=p(E1)p(E2|E1)p(E3|E1∩E2)…p(En|E1∩E2∩…∩En-1)",
        "answer": "严格来说需要数学归纳法证明，但我们将给出一个稍微不那么正式的版本。我们只是将条件概率的定义应用于右边，并观察几乎所有的项都相互抵消（每个分母与前一项的分子相抵消）：p(E1)p(E2|E1)p(E3|E1 ∩ E2)...p(En|E1 ∩ E2 ∩ ... ∩ En-1) = p(E1) * p(E1 ∩ E2) / p(E1) * p(E1 ∩ E2 ∩ E3) / p(E1 ∩ E2) * ... * p(E1 ∩ E2 ∩ ... ∩ En) / p(E1 ∩ E2 ∩ ... ∩ En-1) = p(E1 ∩ E2 ∩ ... ∩ En)。",
        "answer_symbols": [
            "|",
            "∩",
            "=",
            "*",
            "/",
            "..."
        ]
    },
    "7 Supplementary Exercises 18": {
        "question": "当一个均匀的硬币被掷n次时，头像向上和头像向下出现的次数相等的概率是多少？",
        "answer": "如果 n 是奇数，那么这是不可能的，所以概率为 0。如果 n 是偶数，那么有 C(n, n/2) 种方式可以让正面和反面的数量相等（选择哪些翻转将是正面），总共有 2^n 种结果，所以概率为 C(n, n/2) / 2^n。",
        "answer_symbols": [
            "!",
            "/",
            "^"
        ]
    },
    "7 Supplementary Exercises 20": {
        "question": "一个随机选择的 11 位二进制串出现回文的概率是多少?",
        "answer": "有 2^11 位字符串。有 2^6 个回文位字符串，因为一旦前六个位任意指定，剩下的五个位就被确定了。如果随机选择一个位字符串，那么它是回文的概率为 2^6 / 2^11 = 1/32。",
        "answer_symbols": [
            "^",
            "/"
        ]
    },
    "7 Supplementary Exercises 22 a)": {
        "question": "设将 n 个球抛进 b 个箱子使得每个球等可能地落入任何箱子并且这些抛放是独立的。找出一个特定的球落入一个特定箱子的概率。",
        "answer": "由于有 b 个箱子，每个箱子接收到球的可能性相同，答案是 1/b。",
        "answer_symbols": [
            "/"
        ]
    },
    "7 Supplementary Exercises 22 b)": {
        "question": "设将 n 个球抛进 b 个箱子使得每个球等可能地落入任何箱子并且这些抛放是独立的。落入一个特定箱子的球的预期数目是多少?",
        "answer": "通过期望值的线性性质、n 个球被抛出的事实以及 a 部分的答案，答案是 n/b。",
        "answer_symbols": [
            "/"
        ]
    },
    "7 Supplementary Exercises 22 c)": {
        "question": "设将 n 个球抛进 b 个箱子使得每个球等可能地落入任何箱子并且这些抛放是独立的。直到一个特定的箱子包含一个球为止，预期需要投多少个球?",
        "answer": "为了使这一部分有意义，我们忽略 n，并假设球的供应是无限的，我们一直抛直到箱子里有一个球。抛投次数的期望值为几何分布，p = 1/b 来自 a 部分。因此期望值为 b。",
        "answer_symbols": [
            "=",
            "b",
            "∞",
            "p",
            "1",
            "/"
        ]
    },
    "7 Supplementary Exercises 22 d)": {
        "question": "设将 n 个球抛进 b 个箱子使得每个球等可能地落入任何箱子并且这些抛放是独立的。直到所有的箱子都包含一个球为止，预期需要抛多少个球? [提示：设 X 表示一旦 i-1 个箱子包含一个球，第 i 个箱子落入一个球所需要抛掷的球数。求 E(X) 并且使用期望的线性性质。]",
        "answer": "我们必须再次假设球的供应是无限的，并且我们继续投掷直到每个箱子至少包含一个球。分析与本集中的练习33相同，这里的b扮演了那里的n的角色。根据那里给出的解，答案是 b * (1/1 + 1/2 + 1/3 + ... + 1/b)。",
        "answer_symbols": [
            "*",
            "+",
            "...",
            "1",
            "b"
        ]
    },
    "7 Supplementary Exercises 24 a)": {
        "question": "设 A 和 B 是具有概率 p(A)=2/3, p(B)=1/2 的事件。最大的 p(A∩B) 可能是多少? 它最小可能是多少? 举例说明这两种极端情况对于 p(A∩B) 都是可能的。",
        "answer": "两个集合的交集是每个集合的子集，因此 p(A ∩ B) 最大值会在较小的集合是较大集合的子集时出现。在这种情况下，这意味着我们要让 B 是 A 的子集，即 A ∩ B = B，所以 p(A ∩ B) = p(B) = 1/2。为了构造一个例子，我们找到涉及的分数的公分母，即6，并让样本空间由6个等可能的结果组成，比如说编号为1到6。我们设 B = {1, 2, 3} 和 A = {1, 2, 3, 4}。最小的交集会在 A ∪ B 尽可能大的时候发生，因为 p(A ∪ B) = p(A) + p(B) - p(A ∩ B)。A ∪ B 可能最大的是整个样本空间，其概率为1，在这里当然可能发生。所以我们有 1 = (2/3) + (1/2) - p(A ∩ B)，这给出了 p(A ∩ B) = 1/6。为了构造一个例子，我们再次找到这些分数的公分母，即6，并让样本空间由6个等可能的结果组成，比如说编号为1到6。我们设 A = {1, 2, 3, 4} 和 B = {4, 5, 6}。那么 A ∩ B = {4}，并且 p(A ∩ B) = 1/6。",
        "answer_symbols": [
            "∩",
            "∪",
            "=",
            "+",
            "-",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6"
        ]
    },
    "7 Supplementary Exercises 24 b)": {
        "question": "设 A 和 B 是具有概率 p(A)=2/3, p(B)=1/2 的事件。最大的 p(A∪B) 可能是多少? 它最小可能是多少? 举例说明这两种极端情况对于 p(A∪B) 都是可能的。",
        "answer": "两个集合的并集是每个集合的子集，因此 p(A ∪ B) 最小值会在较小的集合是较大集合的子集时出现。在这种情况下，这意味着我们要让 B 是 A 的子集，即 A ∪ B = A，所以 p(A ∪ B) = p(A) = 2/3。这在上面给出的第一个例子中发生。",
        "answer_symbols": [
            "∪",
            "=",
            "2",
            "3"
        ]
    },
    "7 Supplementary Exercises 26": {
        "question": "设 A 和 B 是样本空间 S 中的事件，且 p(A)≠0, p(B)≠0。证明：如果 p(B|A)<p(B)，则 p(A|B)<p(A)。",
        "answer": "从 p(B | A) < p(B) 可以得出 p(A ∩ B) / p(A) < p(B)，这等价于 p(A ∩ B) < p(A) * p(B)。两边同时除以 p(B) 并使用 p(A | B) = p(A ∩ B) / p(B) 这一事实，可以得到所需的结果。",
        "answer_symbols": [
            "|",
            "∩",
            "/",
            "<",
            "*",
            "="
        ]
    },
    "7 Supplementary Exercises 28": {
        "question": "对于第一种可能性，列出另一个孩子所有性别和出生星期等概率的可能性。这样，首先考虑了大一点的孩子是出生在周二的男孩的情况，然后大一点的孩子出生在周二不是男孩的情况。",
        "answer": "对于第一种解释，有27种可能的情况（在14 * 14 = 196种可能的性别和生日配对中），史密斯先生将有一个星期二出生的儿子——14种情况是较大的孩子是星期二出生的儿子，13种情况是较大的孩子不是星期二出生的儿子但较小的孩子是。在前14种情况中有7种，后13种情况中有6种，史密斯先生有两个儿子。因此答案是 13/27。对于第二种解释，假设史密斯先生随机选择了一个孩子并报告了其性别和生日。那么我们对另一个孩子一无所知，所以它是男孩的概率是1/2（在通常的假设下，即等可能性和独立性，这接近生物学事实）。因此答案是 1/2。",
        "answer_symbols": [
            "*",
            "=",
            "1",
            "2",
            "3",
            "4",
            "6",
            "7",
            "13",
            "14",
            "27",
            "196"
        ]
    },
    "7 Supplementary Exercises 30": {
        "question": "用切比雪夫不等式证明不管多少个人寄存他们的帽子，当帽子寄存人随机返回帽子时有多于10个人取回自己帽子的概率不超过1/100。",
        "answer": "根据第7.4节的例子6，X（取回自己帽子的人数）的期望值是1。根据该部分的练习43，X的方差也是1。如果我们应用切比雪夫不等式（第7.4节的定理8）并取r = 10，我们发现X大于或等于11的概率最多为1/10^² = 1/100。",
        "answer_symbols": [
            "=",
            "1",
            "2",
            "10",
            "100"
        ]
    },
    "7 Supplementary Exercises 32": {
        "question": "证明：如果m是正整数，那么当执行每次成功概率为p的独立伯努利试验时，在第m+n次试验出现第m次成功的概率是(n+m-1)Cnqᵐ p^ⁿ。",
        "answer": "为了使所述结果发生，前m+n次试验必须恰好有m次成功和n次失败，并且第(m+n)次试验必须是成功。有许多方法可以实现这一点；具体来说，有 C(n + m - 1, n) 种方法可以选择前n+m-1次试验中的哪n次是失败。每个特定序列发生的概率为 q^ⁿ * pᵐ，因为成功的概率为p，失败的概率为q。答案由此得出。",
        "answer_symbols": [
            "+",
            "-",
            "(",
            ")",
            "C",
            "n",
            "m",
            "q",
            "p",
            "*"
        ]
    },
    "7 Supplementary Exercises 34 a)": {
        "question": "假设在一个合取范式的复合命题中有n个变量。如果我们通过掷硬币随机对每个变量赋值，若硬币出现头像在上对变量赋真值，若头像在下则赋假值。对n个变量而言，每种可能赋值的概率是什么?",
        "answer": "显然每个分配的概率为1/2^n。",
        "answer_symbols": [
            "/"
        ]
    },
    "7 Supplementary Exercises 34 b)": {
        "question": "假设每个子句是恰好两个不同变量或者它们的非的析取式，给定a)中随机的真值赋值。一个给定子句为真的概率是多少?",
        "answer": "随机分配真值使子句中的第一个文字为假的概率是1/2，第二个也是如此。由于抛硬币是独立的，因此两者都为假的概率为 (1/2) * (1/2) = 1/4，所以析取为真的概率为 1 - (1/4) = 3/4。",
        "answer_symbols": [
            "/"
        ]
    },
    "7 Supplementary Exercises 34 c)": {
        "question": "假设在复合命题中有D个子句。给这些变量随机地进行真值赋值，这些子句中预期为真的个数是多少?",
        "answer": "通过期望的线性性，答案为 (3/4) * D。",
        "answer_symbols": [
            "/"
        ]
    },
    "7 Supplementary Exercises 34 d)": {
        "question": "用c)证明，对每个合取范式的复合命题，存在对变量的一组真值赋值，使得至少3/4的子句为真。",
        "answer": "根据部分（c），在所有可能的硬币翻转结果中平均有 3/4 的子句为真。由于平均值不能大于被平均的所有数值，因此至少有 3/4 的子句对于至少一次硬币投掷的结果为真。",
        "answer_symbols": [
            "/"
        ]
    },
    "7 Supplementary Exercises 36": {
        "question": "下面的方法可用来产生具有n个项的序列的随机排列。首先，将第n项和第r(n)项对换，其中r(n)是满足1≤r(n)≤n的一个随机整数。接下来，将所得序列的第n-1项和第r(n-1)项对换，其中r(n-1)是满足1≤r(n-1)≤n-1的一个随机整数。继续这一过程，直到j=n为止，在第j步，将所得序列的第n-j+1项和第r(n-j+1)项对换，其中r(n-j+1)是满足1≤r(n-j+1)≤n-j+1的一个随机整数。证明：遵循这一方法，序列中各项的n!个不同的排列中的每一个排列都会等可能地产生。",
        "answer": "我们将给出一个直接的论证，而不是遵循提示。这里给出的协议有 n! 种可能的结果，每种结果出现的概率相同，因为有 n 种可能的选择来决定 r(n)，n - 1 种可能的选择来决定 r(n - 1)，等等。因此，如果我们能够论证每个结果都会产生唯一的一个排列，那么每个排列出现的概率将是相同的。但这是显而易见的。假设 (a1, a2, a3, ..., an) 是 (1, 2, 3, ..., n) 的一个排列。为了使这个排列由协议生成，必须满足 r(n) = an，因为在协议的第一轮中只有东西会被移动到第 n 个位置。接下来，r(n - 1) 必须是唯一确定 an-1 放入第 (n - 1) 个位置的值（这不一定是 an-1，因为可能会发生 an-1 = n，而 n 可能在第一轮中被移动到了其他位置）。依此类推。因此，每个排列对应于唯一的一组随机数选择序列。",
        "answer_symbols": [
            "!",
            "=",
            "-",
            "..."
        ]
    },
    "7 Supplementary Exercises 2": {
        "question": "找出在新泽西六合彩中买 1 美元奖票有大于 1 美元的中奖期望值的条件。为了赢奖，不管数的次序，你必须从 1 到 48 的正整数中（含 1 和 48 在内）选出的 6 个数。奖金在中奖的人中平均分配。必须考虑抽奖的奖金总额和买奖票的人数。",
        "answer": "抽奖有 C(56, 5) * C(46, 1) = 175,711,536 种可能的结果，因此所有分数形式的概率分母都是这个数字。你可以通过访问 Mega Millions 的网站来核对这些练习的答案：www.megamillions.com/howto。",
        "answer_symbols": [
            "*",
            "/",
            "≈",
            "^"
        ]
    },
    "7 Supplementary Exercises 6": {
        "question": "给定一组邮件信息，且每组信息是不是垃圾邮件都已经确定，根据这些信息中特定字的出现情况建立一个贝叶斯过滤器。",
        "answer": "每个概率的分母是 7 张牌扑克手牌的数量，即 C(52, 7) = 133,784,560。",
        "answer_symbols": [
            "*",
            "/",
            "≈",
            "^"
        ]
    },
    "8.1 1": {
        "question": "用数学归纳法验证在例 2 导出的求解汉诺塔难题所需移动次数的公式.",
        "answer": "Hₙ = 2^ⁿ−1.",
        "answer_symbols": [
            "=",
            "^",
            "-"
        ]
    },
    "8.1 3 a)": {
        "question": "找出与放 n 美元到这台售货机的方式数有关的递推关系，这里要考虑硬币和纸币放人的次序。",
        "answer": "aₙ = 2aₙ₋₁ + aₙ₋₅ for n ≥ 5",
        "answer_symbols": [
            "=",
            "+",
            "≥",
            "-",
            "ₙ",
            "ₙ₋₁",
            "ₙ₋₅"
        ]
    },
    "8.1 3 b)": {
        "question": "初始条件是什么？",
        "answer": "a₀ = 1, a₁ = 2, a₂ = 4, a₃ = 8, a₄ = 16",
        "answer_symbols": [
            "=",
            "₀",
            "₁",
            "₂",
            "₃",
            "₄"
        ]
    },
    "8.1 3 c)": {
        "question": "一本邮票簿需 10 美元，有多少种方式付款？",
        "answer": "12175. 94947.",
        "answer_symbols": []
    },
    "8.1 4": {
        "question": "一个国家使用的硬币币值为 1 比索、2 比索、5 比索和 10 比索，纸币的币值为 5 比索、10 比索、20 比索、50 比索和 100 比索。如果考虑付硬币和纸币的次序，求一个与付 n 比索账单的方式数有关的递推关系。",
        "answer": "This is similar to Exercise 3 and solved in exactly the same way. The recurrence relation is a_n = a_{n-1} + a_{n-2} + 2a_{n-5} + 2a_{n-10} + a_{n-20} + a_{n-50} + a_{n-100}. It would be quite tedious to write down the 100 initial conditions.",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "8.1 7 a)": {
        "question": "求与包含 2 个连续 0 的 n 位二进制位串的个数有关的递推关系。",
        "answer": "aₙ = aₙ₋₁ + aₙ₋₂ + aₙ₋₃ for n ≥ 3",
        "answer_symbols": [
            "=",
            "+",
            "≥",
            "-",
            "ₙ",
            "ₙ₋₁",
            "ₙ₋₂",
            "ₙ₋₃"
        ]
    },
    "8.1 7 b)": {
        "question": "初始条件是什么？",
        "answer": "a₀ = 1, a₁ = 2, a₂ = 4",
        "answer_symbols": [
            "=",
            "₀",
            "₁",
            "₂"
        ]
    },
    "8.1 7 c)": {
        "question": "包含 2 个连续 0 的 7 位二进制位串有多少个？",
        "answer": "811",
        "answer_symbols": []
    },
    "8.1 8 a)": {
        "question": "求与包含 3 个连续 0 的 n 位二进制位串的个数有关的递推关系。",
        "answer": "a) Let a_n be the number of bit strings of length n containing three consecutive 0’s. In order to construct a bit string of length n containing three consecutive 0’s, we could start with 1 and follow with a string of length n−1 containing three consecutive 0’s, or we could start with a 01 and follow with a string of length n−2 containing three consecutive 0’s, or we could start with a 001 and follow with a string of length n − 3 containing three consecutive 0’s, or we could start with a 000 and follow with any string of length n − 3. These four cases are mutually exclusive and exhaust the possibilities for how the string might start. From this analysis, we can immediately write down the recurrence relation, valid for all n ≥ 3: a_n = a_{n-1} + a_{n-2} + a_{n-3} + 2^ⁿ^⁻^³. ",
        "answer_symbols": []
    },
    "8.1 8 b)": {
        "question": "初始条件是什么？",
        "answer": "b) There are no bit strings of length 0, 1, or 2 containing three consecutive 0’s, so the initial conditions are a_0 = a_1 = a_2 = 0.",
        "answer_symbols": []
    },
    "8.1 9 a)": {
        "question": "求与不包含 3 个连续 0 的 n 位二进制位串的个数有关的递推关系。",
        "answer": "aₙ = aₙ₋₁ + aₙ₋₂ for n ≥ 2",
        "answer_symbols": [
            "=",
            "+",
            "≥",
            "-",
            "ₙ",
            "ₙ₋₁",
            "ₙ₋₂"
        ]
    },
    "8.1 9 b)": {
        "question": "初始条件是什么？",
        "answer": "a₀ = 1, a₁ = 1",
        "answer_symbols": [
            "=",
            "₀",
            "₁"
        ]
    },
    "8.1 9 c)": {
        "question": "不包含 3 个连续 0 的 7 位二进制位串有多少个？",
        "answer": "34",
        "answer_symbols": []
    },
    "8.1 11 a)": {
        "question": "一个人爬阶梯，如果每次可以上 1 或 2 步，求与爬 n 步阶梯的方式数有关的递推关系。",
        "answer": "aₙ = 2aₙ₋₁ + 2aₙ₋₂ for n ≥ 2",
        "answer_symbols": [
            "=",
            "+",
            "≥",
            "-",
            "ₙ",
            "ₙ₋₁",
            "ₙ₋₂",
            "2"
        ]
    },
    "8.1 11 b)": {
        "question": "初始条件是什么？",
        "answer": "a₀ = 1, a₁ = 3",
        "answer_symbols": [
            "=",
            "₀",
            "₁"
        ]
    },
    "8.1 11 c)": {
        "question": "这个人爬 8 步阶梯有多少种方式？",
        "answer": "448",
        "answer_symbols": []
    },
    "8.1 13 a)": {
        "question": "求与不包含 2 个连续 0 的 n 位三进制位串的个数有关的递推关系。",
        "answer": "aₙ = 2aₙ₋₁ + aₙ₋₂ for n ≥ 2",
        "answer_symbols": [
            "=",
            "+",
            "≥",
            "-",
            "ₙ",
            "ₙ₋₁",
            "ₙ₋₂"
        ]
    },
    "8.1 13 b)": {
        "question": "初始条件是什么？",
        "answer": "a₀ = 1, a₁ = 3",
        "answer_symbols": [
            "=",
            "₀",
            "₁"
        ]
    },
    "8.1 13 c)": {
        "question": "不包含 2 个连续 0 的 6 位三进制位串有多少个？",
        "answer": "239",
        "answer_symbols": []
    },
    "8.1 14 a)": {
        "question": "求与包含 2 个连续 0 的 n 位三进制位串的个数有关的递推关系。",
        "answer": "Let an be the number of ternary strings that contain two consecutive 0’s. To construct such a string, we could start with either a 1 or a 2 and follow with a string containing two consecutive 0’s (and this can be done in an−1 ways).假设我们可以通过以下方式构造一个字符串：以2开头，后面跟着一个包含两个连续0的字符串（这可以以2a(n-1)种方式完成），或者我们可以以01或02开头，后面跟着一个包含两个连续0的字符串（这可以以2a(n-2)种方式完成），或者我们可以以00开头，后面跟着任意长度为n-2的三进制字符串（显然有3^(n-2)种）。因此，对于所有n≥2，递推关系式是a(n) = 2a(n-1) + 2a(n-2) + 3^(n-2)。",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "^",
            "="
        ]
    },
    "8.1 14 b)": {
        "question": "初始条件是什么？",
        "answer": "显然a(0) = a(1) = 0。",
        "answer_symbols": [
            "="
        ]
    },
    "8.1 14 c)": {
        "question": "包含 2 个连续 0 的 6 位三进制位串有多少个？",
        "answer": "我们将使用递推关系式计算a(2)到a(6)：a(2) = 2a(1) + 2a(0) + 3^0 = 2 * 0 + 2 * 0 + 1 = 1 a(3) = 2a(2) + 2a(1) + 3^1 = 2 * 1 + 2 * 0 + 3 = 5 a(4) = 2a(3) + 2a(2) + 3^2 = 2 * 5 + 2 * 1 + 9 = 21 a(5) = 2a(4) + 2a(3) + 3^3 = 2 * 21 + 2 * 5 + 27 = 79 a(6) = 2a(5) + 2a(4) + 3^4 = 2 * 79 + 2 * 21 + 81 = 281 因此，长度为6且包含两个连续0的位串有281个。",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "*",
            "^",
            "="
        ]
    },
    "8.1 15 a)": {
        "question": "求与不包含 2 个连续 0 或 2 个连续 1 的 n 位三进制位串的个数有关的递推关系。",
        "answer": "aₙ = 2aₙ₋₁ for n ≥ 2",
        "answer_symbols": [
            "=",
            "≥",
            "-",
            "ₙ",
            "ₙ₋₁"
        ]
    },
    "8.1 15 b)": {
        "question": "初始条件是什么？",
        "answer": "a₁ = 3",
        "answer_symbols": [
            "=",
            "₁"
        ]
    },
    "8.1 15 c)": {
        "question": "不包含 2 个连续 0 或 2 个连续 1 的 6 位三进制位串有多少个？",
        "answer": "96",
        "answer_symbols": []
    },
    "8.1 16 a)": {
        "question": "求与包含 2 个连续 0 或 2 个连续 1 的 n 位三进制位串的个数有关的递推关系。",
        "answer": "假设a(n)是包含两个连续0或两个连续1的三进制字符串的数量。为了构造这样一个字符串，我们可以以2开头，后面跟着一个包含两个连续0或两个连续1的字符串，这可以以a(n-1)种方式完成。然而，还有其他可能性。对于从0到n-2的每个k，字符串可以以n-1-k个交替的0和1开始，然后跟一个2，再跟一个长度为k且包含两个连续0或两个连续1的字符串。这样的字符串数量为2a(k)，因为初始部分有2种交替方式。另一种可能性是字符串根本没有2。那么它必须由n-k-2个交替的0和1组成，后面跟着一对0或1，再跟一个长度为k的任意字符串。这样的字符串有2 * 3^k个。现在当k从0到n-2时，这些数量的总和（因为这是一个几何级数）是3^(n-1) - 1。把这一切放在一起，我们得到以下递推关系式，对于所有n≥2有效：a(n) = a(n-1) + 2a(n-2) + 2a(n-3) + ... + 2a(0) + 3^(n-1) - 1。（通过用n-1替换n从这个递推关系式中减去相同的递推关系式，我们可以得到这个问题的封闭形式递推关系式：a(n) = 2a(n-1) + a(n-2) + 2 * 3^(n-2)。）",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "*",
            "^",
            "=",
            "-"
        ]
    },
    "8.1 16 b)": {
        "question": "初始条件是什么？",
        "answer": "显然a(0) = a(1) = 0。",
        "answer_symbols": [
            "="
        ]
    },
    "8.1 16 c)": {
        "question": "包含 2 个连续 0 或 2 个连续 1 的 6 位三进制位串有多少个？",
        "answer": "我们将使用递推关系式计算a(2)到a(6)：a(2) = a(1) + 2a(0) + 3^1 - 1 = 0 + 2 * 0 + 3 - 1 = 2 a(3) = a(2) + 2a(1) + 2a(0) + 3^2 - 1 = 2 + 2 * 0 + 2 * 0 + 9 - 1 = 10 a(4) = a(3) + 2a(2) + 2a(1) + 2a(0) + 3^3 - 1 = 10 + 2 * 2 + 2 * 0 + 2 * 0 + 27 - 1 = 40 a(5) = a(4) + 2a(3) + 2a(2) + 2a(1) + 2a(0) + 3^4 - 1 = 40 + 2 * 10 + 2 * 2 + 2 * 0 + 2 * 0 + 81 - 1 = 144 a(6) = a(5) + 2a(4) + 2a(3) + 2a(2) + 2a(1) + 2a(0) + 3^5 - 1 = 144 + 2 * 40 + 2 * 10 + 2 * 2 + 2 * 0 + 2 * 0 + 243 - 1 = 490 因此，长度为6且包含两个连续0或两个连续1的三进制字符串有490个。",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "*",
            "^",
            "=",
            "-"
        ]
    },
    "8.1 17 a)": {
        "question": "求与不包含连续的相同符号的 n 位三进制位串的个数有关的递推关系。",
        "answer": "aₙ = aₙ₋₁ + aₙ₋₂ for n ≥ 2",
        "answer_symbols": [
            "=",
            "+",
            "≥",
            "-",
            "ₙ",
            "ₙ₋₁",
            "ₙ₋₂"
        ]
    },
    "8.1 17 b)": {
        "question": "初始条件是什么？",
        "answer": "a₀ = 1, a₁ = 1",
        "answer_symbols": [
            "=",
            "₀",
            "₁"
        ]
    },
    "8.1 17 c)": {
        "question": "不包含连续的相同符号的 6 位三进制位串有多少个？",
        "answer": "89",
        "answer_symbols": []
    },
    "8.1 18 a)": {
        "question": "求包含 2 个连续的相同符号的 n 位三进制位串的个数有关的递推关系。",
        "answer": "假设a(n)是包含两个连续相同符号的三进制字符串的数量。我们将通过利用三个符号之间的对称性来开发一个递推关系式。特别是，必须有a(n)/3个这样的字符串以三个符号中的每一个开头。现在让我们看看如何指定一个满足条件的长度为n的字符串。我们可以在三种方式中选择第一个符号。我们可以跟随一个不同的符号，但其中有一对连续的符号；根据我们刚才所说，有2a(n-1)/3个这样的字符串。或者，我们可以在初始符号后跟另一个相同的符号，然后再跟一个长度为n-2的任意字符串；显然有3^(n-2)个这样的字符串。因此，递推关系式是a(n) = 3 * ((2a(n-1)/3) + 3^(n-2)) = 2a(n-1) + 3^(n-1)。它对于所有n≥2有效。",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "*",
            "/",
            "^",
            "="
        ]
    },
    "8.1 18 b)": {
        "question": "初始条件是什么？",
        "answer": "显然a(0) = a(1) = 0。",
        "answer_symbols": [
            "="
        ]
    },
    "8.1 18 c)": {
        "question": "包含 2 个连续的相同符号的 6 位三进制位串有多少个？",
        "answer": "我们将使用递推关系计算 a2 到 a6：a2= 2a1+ 3¹= 2 · 0+ 3= 3 a3= 2a2+ 3^²= 2 · 3+ 9= 15 a4= 2a3+ 3^³= 2 · 15+ 27= 57 a5= 2a4+ 3^⁴= 2 · 57+ 81= 195 a6= 2a5+ 3^⁵= 2 · 195+ 243= 633 因此有 633 个长度为 6 的位串包含两个连续的 0、1 或 2。",
        "answer_symbols": [
            "=",
            "+",
            "·",
            "^"
        ]
    },
    "8.1 19 a)": {
        "question": "求与在 n 微秒内发送的不同信息数有关的递推关系，其中信息由这两个信号的序列构成，并且信息中的每个信号后面都紧跟着下一个信号。",
        "answer": "Rₙ = n + Rₙ₋₁, R₀ = 1",
        "answer_symbols": [
            "=",
            "+",
            "ₙ",
            "ₙ₋₁",
            "₀"
        ]
    },
    "8.1 19 b)": {
        "question": "初始条件是什么？",
        "answer": "Rₙ = n(n+1)/2 + 1",
        "answer_symbols": [
            "=",
            "+",
            "/",
            "(",
            ")",
            "ₙ"
        ]
    },
    "8.1 20 a)": {
        "question": "求与这个汽车司机付费 n 美分的不同方式数有关的递推关系（考虑使用硬币的次序）。",
        "answer": "这个问题与练习 11 同构，因此答案相同：a_n= a_(n−1)+ a_(n−2)，其中 a_0= a_1= 1。",
        "answer_symbols": [
            "=",
            "+",
            "_",
            "-"
        ]
    },
    "8.1 20 b)": {
        "question": "这个司机付费 45 美分有多少种可能的方式？",
        "answer": "迭代后，我们发现 a_9= 55。",
        "answer_symbols": [
            "=",
            "_"
        ]
    },
    "8.1 21 a)": {
        "question": "如果 Rₙ 是一个平面被 n 条直线划分出的区域个数，其中没有两条直线是平行的，也没有 3 条直线交于一点，找出由 Rₙ 满足的递推关系。",
        "answer": "Sₙ = Sₙ₋₁ + (n^² − n + 2)/2, S₀ = 1",
        "answer_symbols": [
            "=",
            "+",
            "(",
            ")",
            "/",
            "²",
            "-",
            "ₙ",
            "ₙ₋₁",
            "₀"
        ]
    },
    "8.1 21 b)": {
        "question": "使用迭代求出 Rₙ。",
        "answer": "Sₙ = (n^³ + 5n + 6)/6",
        "answer_symbols": [
            "=",
            "+",
            "/",
            "³",
            "(",
            ")",
            "ₙ"
        ]
    },
    "8.1 22 a)": {
        "question": "找出由 Rn 满足的递推关系，其中 Rn 是一个球面被 n 个大圆（球面与通过球心的平面的交线）划分的区域个数，如果没有 3 个大圆交于一点。",
        "answer": "我们先计算前几项以了解发生的情况。显然 R_1= 2，因为赤道将球体分为两个半球。同样，R_2= 4 和 R_3= 8。让我们尝试分析当添加第 n 个大圆时会发生什么。它必须与每个其他圆相交两次（在对径点），并且每次这样的交点都会使一个先前的区域分裂成两个区域，如练习 21 所示。有 n − 1 个先前的大圆，因此有 2(n − 1) 个新区域。因此 R_n= R_(n−1)+ 2(n − 1)。如果我们施加初始条件 R_1= 2，则上面找到的 R_2 和 R_3 值与此递推关系一致。注意 R_4= 14，R_5= 22，等等。",
        "answer_symbols": [
            "=",
            "+",
            "_",
            "-",
            "(",
            ")",
            "·"
        ]
    },
    "8.1 22 b)": {
        "question": "使用迭代求出 Rn。",
        "answer": "我们遵循通常的技术，如第 2.4 节练习 17 中所述。在最后一行中，我们使用了前 n−1 个正整数的和的熟悉公式。请注意该公式与上面计算的值相符。R_n= 2(n − 1)+ R_(n−1) = 2(n − 1)+ 2(n − 2)+ R_(n−2) = 2(n − 1)+ 2(n − 2)+ 2(n − 3)+ R_(n−3)... = 2(n − 1)+ 2(n − 2)+ 2(n − 3)+ 2 · 1+ R_1 = n(n − 1)+ 2= n^² − n+ 2",
        "answer_symbols": [
            "=",
            "+",
            "_",
            "-",
            "(",
            ")",
            "·",
            "^"
        ]
    },
    "8.1 24": {
        "question": "求出与具有偶数个 0 的 n 位二进制位串个数有关的递推关系。",
        "answer": "设 e_n 为长度为 n 的位序列中具有偶数个 0 的位序列的数量。因此有 2^n − e_n 个具有奇数个 0 的位序列。有两种方法可以获得长度为 n 且具有偶数个 0 的位字符串。它可以以 1 开头并后跟一个长度为 n − 1 且具有偶数个 0 的位字符串，这样的位字符串有 e_(n−1) 个；或者它可以以 0 开头并后跟一个长度为 n − 1 且具有奇数个 0 的位字符串，这样的位字符串有 2^(n−1) − e_(n−1) 个。因此 e_n= e_(n−1)+ 2^(n−1) − e_(n−1)，或简单地 e_n= 2^(n−1)。另见第 6.4 节练习 31。",
        "answer_symbols": [
            "=",
            "+",
            "_",
            "-",
            "(",
            ")",
            "^"
        ]
    },
    "8.1 26 a)": {
        "question": "找到与用 1×2 的多米诺牌完全覆盖 2×n 的棋盘的方式数有关的递推关系。[提示：分别考虑对棋盘右上角的位置用一张多米诺牌水平放置和垂直放置的覆盖方式。]",
        "answer": "我们遵循提示。如果最右边的多米诺骨牌垂直放置，则我们有最左边 n−1 列的覆盖，这可以以 a_(n−1) 种方式完成。如果最右边的多米诺骨牌水平放置，则必须在其下方再放置一个多米诺骨牌，这两者一起覆盖最后两列。前 n−2 列将需要由多米诺骨牌覆盖，这可以以 a_(n−2) 种方式完成。因此我们得到斐波那契递推关系 a_n= a_(n−1)+ a_(n−2)。",
        "answer_symbols": [
            "=",
            "+",
            "_",
            "-"
        ]
    },
    "8.1 26 b)": {
        "question": "关于 a) 中递推关系的初始条件是什么？",
        "answer": "显然 a_1= 1 和 a_2= 2。",
        "answer_symbols": [
            "=",
            "_"
        ]
    },
    "8.1 26 c)": {
        "question": "用 1×2 的多米诺牌完全覆盖 2×17 的棋盘有多少种方式？",
        "answer": "我们得到的序列只是斐波那契序列向右移一位。该序列是 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584,...，因此这部分的答案是 2584。",
        "answer_symbols": [
            ",",
            "..."
        ]
    },
    "8.1 28": {
        "question": "证明斐波那契数满足递推关系 fₙ = 5fₙ₋₄ + 3fₙ₋₅，n = 5, 6, 7, …，其中递推关系具有初始条件 f₀ = 0, f₁ = 1, f₂ = 1, f₃ = 2, f₄ = 3。用这个递推关系证明 fₙ 可被 5 整除，n = 1, 2, 3, …。",
        "answer": "初始条件当然是成立的。我们通过归纳法对 n 进行证明，从基本情况 n= 5 和 n= 6 开始，在这两种情况下我们发现 5f₁ + 3f₀ = 5 = f₅ 和 5f₂ + 3f₁ = 8 = f₆。假设归纳假设成立。那么我们有 5fₙ₋₄ + 3fₙ₋₅ = 5(fₙ₋₅ + fₙ₋₆) + 3(fₙ₋₆ + fₙ₋₇) = (5fₙ₋₅ + 3fₙ₋₆) + (5fₙ₋₆ + 3fₙ₋₇) = fₙ₋₁ + fₙ₋₂ = fₙ（这里我们使用了归纳假设和斐波那契数列的递归定义）。最后，我们通过归纳法证明 f₅ₙ 可以被 5 整除。对于 n= 1 是成立的，因为 f₅ = 5 可以被 5 整除。假设它对 f₅ₙ 成立。那么 f₅(n+1) = f₅ₙ₊₅ = 5f₅ₙ₊₁ + 3f₅ₙ 可以被 5 整除，因为这个表达式中的两个加项都可以被 5 整除。",
        "answer_symbols": [
            "=",
            "+",
            "(",
            ")",
            "∈",
            "∑",
            "!",
            "⋅",
            "⋯",
            "⋯"
        ]
    },
    "8.1 30 a)": {
        "question": "写出为确定相乘次序而在乘积 x₀ × x₁ × x₂ × x₃ × x₄ 中加括号的所有方式。",
        "answer": "我们系统地进行这项工作，基于最外层点的位置，从左到右：x₀ ·(x₁ ·(x₂ ·(x₃ · x₄))) x₀ ·(x₁ ·((x₂ · x₃) · x₄)) x₀ ·((x₁ · x₂) ·(x₃ · x₄)) x₀ ·((x₁ ·(x₂ · x₃)) · x₄) x₀ ·(((x₁ · x₂) · x₃) · x₄) (x₀ · x₁) ·(x₂ ·(x₃ · x₄)) (x₀ · x₁) ·((x₂ · x₃) · x₄) (x₀ ·(x₁ · x₂)) ·(x₃ · x₄) ((x₀ · x₁) · x₂) ·(x₃ · x₄) (x₀ ·(x₁ ·(x₂ · x₃))) · x₄ (x₀ ·((x₁ · x₂) · x₃)) · x₄ ((x₀ · x₁) ·(x₂ · x₃)) · x₄ ((x₀ ·(x₁ · x₂)) · x₃) · x₄ (((x₀ · x₁) · x₂) · x₃) · x₄",
        "answer_symbols": [
            "·",
            "(",
            ")",
            "⋯"
        ]
    },
    "8.1 30 b)": {
        "question": "使用在例 5 所建立的递推关系计算 C₄，即为确定相乘的次序在 5 个数的乘积中加括号的方式数。验证 a) 列出的方式数是正确的。",
        "answer": "根据例5，我们知道 C₀ = 1, C₁ = 1, 且 C₃ = 5。也很容易看到 C₂ = 2，因为只有两种方式可以对三个数的乘积进行括号化。因此递归关系告诉我们 C₄ = C₀C₃ + C₁C₂ + C₂C₁ + C₃C₀ = 1 · 5 + 1 · 2 + 2 · 1 + 5 · 1 = 14。我们在上面列出了正确的解的数量。",
        "answer_symbols": [
            "=",
            "+",
            "·",
            "⋯"
        ]
    },
    "8.1 30 c)": {
        "question": "使用在例 5 的解答中所提到的关于 Cₙ 的封闭公式，通过求出 C₄ 检验 b) 得到的结果。",
        "answer": "这里 n= 4，所以公式给出 15 C(8, 4) = 15 · 8 · 7 · 6 · 5/4! = 14。",
        "answer_symbols": [
            "=",
            "·",
            "/",
            "!",
            "⋯"
        ]
    },
    "8.1 31 a)": {
        "question": "使用在例 5 所建立的递推关系确定 C₅，即为确定相乘的次序在 6 个数的乘积中加括号的方式数。",
        "answer": "J(1) = 1, J(2) = 1, J(3) = 3, J(4) = 1, J(5) = 3, J(6) = 5, J(7) = 7, J(8) = 1, J(9) = 3, J(10) = 5, J(11) = 7, J(12) = 9, J(13) = 11, J(14) = 13, J(15) = 15, J(16) = 13",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "J"
        ]
    },
    "8.1 31 b)": {
        "question": "使用在例 5 的解答中所提到的关于 Cₙ 的封闭公式检验 b) 得到的结果。",
        "answer": "First, suppose that the number of people is even, say 2n. After going around the circle once and returning to the first person, because the people at locations with even numbers have been eliminated, there are exactly n people left and the person currently at location i is the person who was originally at location 2i−1. Therefore, the survivor [originally in location J(2n)] is now in location J(n); this was the person who was at location 2J(n) − 1. Hence, J(2n) = 2J(n) − 1. Similarly, when there are an odd number of people, say 2n+1, then after going around the circle once and then eliminating person 1, there are n people left and the person currently at location i is the person who was at location 2i+1. Therefore, the survivor will be the player currently occupying location J(n), namely, the person who was originally at location 2J(n) + 1. Hence, J(2n+1) = 2J(n) + 1. The basis step is J(1) = 1.",
        "answer_symbols": [
            "=",
            "+",
            "−",
            "(",
            ")",
            "J",
            "n",
            "i"
        ]
    },
    "8.1 32 a)": {
        "question": "在汉诺塔难题中，假设我们的目标是把所有的 n 个盘子从柱 1 移到柱 3，但我们不能直接在柱 1 和柱 3 之间移动盘子。每次移动盘子必须通过柱 2，并且我们不能把较大的盘子放在较小的盘子上面。找出与求解这个具有附加限制条件的 n 个盘子的难题所需移动次数有关的递推关系。",
        "answer": "为了将最底下的盘子从柱子1移开，我们必须已经将其他 n−1 个盘子转移到柱子3（因为我们必须将最底下的盘子移到柱子2）；这需要 aₙ₋₁ 步。然后我们可以将最底下的盘子移到柱子2（再加一步）。然而，我们的目标是将其移动到柱子3，所以我们现在必须将其他 n − 1 个盘子从柱子3移回柱子1，同时让最底下的盘子安静地放在柱子2上。根据对称性，这再次需要 aₙ₋₁ 步。再加一步让我们可以将最底下的盘子从柱子2移到柱子3。现在需要 aₙ₋₁ 步将剩余的盘子从柱子1移到柱子3。因此我们的递推关系是 aₙ = 3aₙ₋₁ + 2。初始条件当然是 a₀ = 0。",
        "answer_symbols": [
            "=",
            "+",
            "−",
            "⋯"
        ]
    },
    "8.1 32 b)": {
        "question": "解这个递推关系来确定求解这个 n 个盘子难题所需移动次数的公式。",
        "answer": "计算前几个值，我们发现 a₁ = 2, a₂ = 8, a₃ = 26, 且 a₄ = 80。看起来 aₙ = 3^ⁿ - 1。这很容易通过归纳法验证：基本情况是 a₀ = 3^⁰ - 1 = 1 - 1 = 0，而 3aₙ₋₁ + 2 = 3 ·(3^ⁿ^⁻¹ - 1) + 2 = 3^ⁿ - 3 + 2 = 3^ⁿ - 1 = aₙ。",
        "answer_symbols": [
            "=",
            "+",
            "−",
            "·",
            "⋯"
        ]
    },
    "8.1 32 c)": {
        "question": "有多少种不同的方法把 n 个盘子安排在 3 个柱子上使得没有一个较大的盘子放在较小的盘子上面？",
        "answer": "分配盘子时唯一的选择是每个盘子放在哪个柱子上，因为给定柱子上的盘子顺序是固定的。由于每个盘子有三种选择，所以答案是 3^ⁿ。",
        "answer_symbols": [
            "=",
            "⋯"
        ]
    },
    "8.1 32 d)": {
        "question": "显示在这个变形难题的解中得到的对 n 个盘子的各种可能的安排。",
        "answer": "谜题在解决过程中涉及 1 + aₙ = 3^ⁿ 种盘子排列——初始排列和每次移动后的排列。这些排列中没有一个可以重复之前的排列，If the same arrangement occurred twice, there would have been no point in making the moves between the two occurrences of the same arrangement. Therefore, these 3n arrangements are all distinct. We saw in part (c) that there are exactly 3n arrangements, so every arrangement was used.",
        "answer_symbols": [
            "=",
            "+",
            "⋯"
        ]
    },
    "8.1 33": {
        "question": "对每个正整数 n 的值，1 ≤ n ≤ 16，确定 J(n) 的值。",
        "answer": "These nine moves solve the puzzle: Move disk 1 from peg 1 to peg 2; move disk 2 from peg 1 to peg 3; move disk 1 from peg 2 to peg 3; move disk 3 from peg 1 to peg 2; move disk 4 from peg 1 to peg 4; move disk 3 from peg 2 to peg 4; move disk 1 from peg 3 to peg 2; move disk 2 from peg 3 to peg 4; move disk 1 from peg 2 to peg 4. To see that at least nine moves are required, first note that at least seven moves are required no matter how many pegs are present: three to unstack the disks, one to move the largest disk 4, and three more moves to restack them. At least two other moves are needed, because to move disk 4 from peg 1 to peg 4 the other three disks must be on pegs 2 and 3, so at least one move is needed to restack them and one move to unstack them.",
        "answer_symbols": [
            ";",
            ":",
            "(",
            ")",
            "1",
            "2",
            "3",
            "4"
        ]
    },
    "8.1 34": {
        "question": "使用你在练习 33 找到的值猜想一个关于 J(2^ⁿ) 的公式。[提示：写 n = 2ᵐ + k，其中 m 是非负整数，k 是小于 2ᵐ 的非负整数。]",
        "answer": "If we follow the hint, then it certainly looks as if J(n) = 2k + 1, where k is the amount left over after the largest possible power of 2 has been subtracted from n (i.e., n = 2^m + k and k < 2^m).",
        "answer_symbols": [
            "=",
            "^",
            "<"
        ]
    },
    "8.1 35": {
        "question": "对于 n ≥ 1，证明 J(n) 满足递推关系 J(2^ⁿ) = 2J(n) - 1 和 J(2^ⁿ + 1) = 2J(n) + 1，且 J(1) = 1。",
        "answer": "The base cases are obvious. If n > 1, the algorithm consists of three stages. In the first stage, by the inductive hypothesis, R(n−k) moves are used to transfer the smallest n − k disks to peg 2. Then using the usual three-peg Tower of Hanoi algorithm, it takes 2ᵏ − 1 moves to transfer the rest of the disks (the largest k disks) to peg 4, avoiding peg 2. Then again by the inductive hypothesis, it takes R(n − k) moves to transfer the smallest n − k disks to peg 4; all the pegs are available for this, because the largest disks, now on peg 4, do not interfere. This establishes the recurrence relation.",
        "answer_symbols": [
            "=",
            ">",
            "−",
            "(",
            ")",
            "R",
            "k",
            "n",
            "2",
            "4"
        ]
    },
    "8.1 36": {
        "question": "用练习 35 的递推关系根据数学归纳法证明你在练习 34 所猜想的公式。",
        "answer": "The basis step is trivial, since when n = 1 = 2^0 + 0, the conjecture in Exercise 34 states that J(n) = 2 * 0 + 1 = 1, which is correct. For the inductive step, we look at two cases, depending on whether there are an even or an odd number of players. If there are 2n players, suppose that 2n = 2^m + k, as in the hint for Exercise 34. Then k must be even and we can write n = 2^(m-1) + (k/2), and k/2 < 2^(m-1). By the inductive hypothesis, J(n) = 2(k/2) + 1 = k + 1. Then by the recurrence relation from Exercise 35, J(2n) = 2J(n) - 1 = 2(k + 1) - 1 = 2k + 1, as desired. For the other case, assume that there are 2n + 1 players, and again write 2n + 1 = 2^m + k, as in the hint for Exercise 34. Then k must be odd and we can write n = 2^(m-1) + (k - 1)/2, where (k - 1)/2 < 2^(m-1). By the inductive hypothesis, J(n) = 2((k - 1)/2) + 1 = k. Then by the recurrence relation from Exercise 35, J(2n + 1) = 2J(n) + 1 = 2k + 1, as desired.",
        "answer_symbols": [
            "=",
            "^",
            "+",
            "-",
            "*",
            "/",
            "<",
            ">",
            "(",
            ")"
        ]
    },
    "8.1 37": {
        "question": "根据关于 J(n) 的公式确定 J(100)、J(1000) 和 J(10 000).",
        "answer": "73, 977, 3617",
        "answer_symbols": []
    },
    "8.1 38": {
        "question": "证明：具有 3 个盘子的雷夫难题最少可以使用 5 次移动求解.",
        "answer": "Since we can only move one disk at a time, we need one move to lift the smallest disk off the middle disk, and another to lift the middle disk off the largest. Similarly, we need two moves to rejoin these disks. And of course, we need at least one move to get the largest disk off peg 1. Therefore, we can do no better than five moves. To see that this is possible, we just make the obvious moves (disk 1 is the smallest, and a −→bc means to move disk b from peg a to peg c): 1 −1→2, 1 −2→3, 1 −3→4, 3 −2→4, 2 −1→4.",
        "answer_symbols": [
            "−→",
            "−"
        ]
    },
    "8.1 39": {
        "question": "证明：具有 4 个盘子的雷夫难题最少可以使用 9 次移动求解.",
        "answer": "First note that R(n) = ∑(from j=1 to n) [R(j) − R(j − 1)] [which follows because the sum is telescoping and R(0) = 0]. By Exercise 42, this is the sum of 2ᵏ − 1 for this range of values of j. Therefore, the sum is ∑(from i=1 to k) i2^⁽ⁱ^⁻¹^⁾, except that if n is not a triangular number, then the last few values when i = k are missing, and that is what the final term in the given expression accounts for.",
        "answer_symbols": [
            "=",
            "∑",
            "(",
            ")",
            "−",
            "R",
            "j",
            "k",
            "i",
            "2",
            "⁽",
            "⁾",
            "⁻"
        ]
    },
    "8.1 40 a)": {
        "question": "描述弗雷姆斯图尔特算法所做的移动，并选择 k 使得在 5 个盘子的情况下所需要的移动次数最少.",
        "answer": "According to the algorithm, we take k = 3, since 5 is between the triangular numbers t2 = 3 and t3 = 6. The moves are to first move 5 - 3 = 2 disks from peg 1 to peg 2 (1 −1→3, 1 −2→2, 3 −1→2), then working with pegs 1, 3, and 4 move disks 3, 4, and 5 to peg 4 (1 −3→4, 1 −4→3, 4 −3→3, 1 −5→4, 3 −3→1, 3 −4→4, 1 −3→4), and then move disks 1 and 2 from peg 2 to peg 4 (2 −1→3, 2 −2→4, 3 −1→4). Note that this took 13 moves in all.",
        "answer_symbols": [
            "−→",
            "−"
        ]
    },
    "8.1 40 b)": {
        "question": "描述弗雷姆斯图尔特算法所做的移动，并选择 k 使得在 6 个盘子的情况下所需要的移动次数最少.",
        "answer": "According to the algorithm, we take k = 3, since 6 is between the triangular numbers t2 = 3 and t3 = 6. The moves are to first move 6 - 3 = 3 disks from peg 1 to peg 2 (1 −1→3, 1 −2→4, 1 −3→2, 4 −2→2, 3 −1→2), then working with pegs 1, 3, and 4 move disks 4, 5, and 6 to peg 4 (1 −4→4, 1 −5→3, 4 −4→3, 1 −6→4, 3 −4→1, 3 −5→4, 1 −4→4), and then move disks 1, 2, and 3 from peg 2 to peg 4 (2 −1→3, 2 −2→1, 2 −3→4, 1 −2→4, 3 −1→4). Note that this took 17 moves in all.",
        "answer_symbols": [
            "−→",
            "−"
        ]
    },
    "8.1 40 c)": {
        "question": "描述弗雷姆斯图尔特算法所做的移动，并选择 k 使得在 7 个盘子的情况下所需要的移动次数最少.",
        "answer": "According to the algorithm, we take k = 4, since 7 is between the triangular numbers t3 = 6 and t4 = 10. The moves are to first move 7 - 4 = 3 disks from peg 1 to peg 2 (five moves, as in part (b)), then working with pegs 1, 3, and 4 move disks 4, 5, 6, and 7 to peg 4 (15 moves, using the usual Tower of Hanoi algorithm), and then move disks 1, 2, and 3 from peg 2 to peg 4 (again five moves, as in part (b)). Note that this took 25 moves in all.",
        "answer_symbols": [
            "−→",
            "−"
        ]
    },
    "8.1 40 d)": {
        "question": "描述弗雷姆斯图尔特算法所做的移动，并选择 k 使得在 8 个盘子的情况下所需要的移动次数最少.",
        "answer": "According to the algorithm, we take k = 4, since 8 is between the triangular numbers t3 = 6 and t4 = 10. The moves are to first move 8 - 4 = 4 disks from peg 1 to peg 2 (nine moves, as in Exercise 39, with peg 2 playing the role of peg 4), then working with pegs 1, 3, and 4 move disks 5, 6, 7, and 8 to peg 4 (15 moves, using the usual Tower of Hanoi algorithm), and then move disks 1, 2, 3, and 4 from peg 2 to peg 4 (again nine moves, as above). Note that this took 33 moves in all.",
        "answer_symbols": [
            "−→",
            "−"
        ]
    },
    "8.1 41": {
        "question": "证明：如果 R(n) 是由弗雷姆斯图尔特算法求解具有 n 个盘子的雷夫难题所使用的移动次数，这里选择 k 是满足 n≤k(k+1)/2 的最小的整数，那么 R(n) 满足递推关系 R(n)=2R(n-k)+2^k-1 和 R(0)=0，R(1)=1.",
        "answer": "By Exercise 43, R(n) is no larger than ∑(from i=1 to k) i^²^⁽ⁱ^⁻¹^⁾. It can be shown that this sum equals (k+1)2ᵏ − 2^⁽ᵏ^⁺¹^⁾ + 1, so it is no greater than (k+1)2ᵏ. Because n > k(k−1)/2, the quadratic formula can be used to show that...以下是根据您提供的 PDF 文档提取的内容：---**离散数学及其应用(英文版·第7版) - 奇数题答案-49.pdf**---P1:1. 对于所有 n > 1，有 k < 1 + √(2n)。因此，R(n) 被 (1 + √(2n) + 1)^² / (1 + √(2n)) < 8√(n^²) / (2√(2n)) 限制，对于所有 n > 2。因此，R(n) 是 O(√(n^²) / (2√(2n)))。",
        "answer_symbols": [
            ">",
            "2",
            "∑",
            "⁺",
            ")",
            "⁽",
            "(",
            "⁾",
            "+",
            "/",
            "=",
            "i",
            "O",
            "R",
            "−",
            "k",
            "√",
            "1",
            "<",
            "²"
        ]
    },
    "8.1 42": {
        "question": "证明：如果 k 像练习 41 那样选择，那么 R(n)-R(n-1)=2^k-1.",
        "answer": "To clarify the problem, we note that k is chosen to be the smallest nonnegative integer such that n ≤ k(k + 1)/2. If n - 1 ≠ k(k - 1)/2, then this same value of k applies to n - 1 as well; otherwise, the value for n - 1 is k - 1. If n - 1 ≠ k(k - 1)/2, it also follows by subtracting k from both sides of the inequality that the",
        "answer_symbols": [
            "≤",
            "≠",
            "+",
            "/",
            "−"
        ]
    },
    "8.1 47": {
        "question": "对于在练习 46 中的序列求 ∇^2 a_n.",
        "answer": "a) 0 b) 0 c) 2 d) 2n−1 − 2n−2",
        "answer_symbols": [
            "-",
            "−"
        ]
    },
    "8.1 49": {
        "question": "证明：a_n-2=a_n-2∇a_n+∇^2 a_n.",
        "answer": "a_{n-2} ∇a_n + ∇^²a_n = a_{n-2} (a_n - a_{n-1}) + (∇a_n - ∇a_{n-1}) = -a_n + 2a_{n-1} + [(a_n - a_{n-1}) - (a_{n-1} - a_{n-2})] = -a_n + 2a_{n-1} + (a_n - 2a_{n-1} + a_{n-2}) = a_{n-2}",
        "answer_symbols": [
            "+",
            "-",
            "=",
            "∇",
            "²"
        ]
    },
    "8.1 51": {
        "question": "用 a_n，∇a_n，∇^2 a_n 的项表示递推关系 a_n=a_n-1+a_n-2.",
        "answer": "a_n = a_{n-1} + a_{n-2} = (a_n - ∇a_n) + (a_n - 2∇a_n + ∇^²a_n) = 2a_n - 3∇a_n + ∇^²a_n，或 a_n = 3∇a_n - ∇^²a_n",
        "answer_symbols": [
            "+",
            "-",
            "=",
            "∇",
            "²"
        ]
    },
    "8.1 52": {
        "question": "证明：关于序列 {a_n} 的任何递推关系都可以用 a_n，∇a_n，∇^2 a_n，… 的项表示. 涉及这个序列和它的差分的等式叫做差分方程.",
        "answer": "By Exercise 50, each a_n-i can be so expressed (as a linear function), so the entire recurrence relation a_n = c₁ * a_n-1 + c₂ * a_n-2 + ... + c_k * a_n-k can be written as a_n = c₁ * f₁ + c₂ * f₂ + ... + c_k * f_k, where each f_i is a linear expression involving a_n, ∇a_n, ..., ∇^k a_n. This gives us the desired difference equation.",
        "answer_symbols": [
            "-",
            "+",
            "*",
            "=",
            "∇",
            "^"
        ]
    },
    "8.1 53": {
        "question": "在算法 1 之后，设计一个算法确定哪些讲座应该调度以获得最大的参与者总人数而不只是由算法 1 得到的最大的参与者总人数.",
        "answer": "Insert S(0) := ∅ after T(0) := 0 (where S(j) will record the optimal set of talks among the first j talks), and replace the statement T(j) := max(wj + T(p(j)), T(j − 1)) with the following code:if wj + T(p(j)) > T(j − 1) thenT(j) := wj + T(p(j))S(j) := S(p(j)) ∪ {j}elseT(j) := T(j − 1)S(j) := S(j − 1)",
        "answer_symbols": [
            "∅",
            "∪",
            "−",
            ">",
            ":="
        ]
    },
    "8.1 55 a)": {
        "question": "对于练习 54 中的每一部分，使用 53 题的算法找到优化调度方案以获得最大的参考者人数。（a）20, 10, 50, 30, 15, 25, 40。",
        "answer": "讲座 1、3 和 7",
        "answer_symbols": []
    },
    "8.1 55 b)": {
        "question": "对于练习 54 中的每一部分，使用 53 题的算法找到优化调度方案以获得最大的参考者人数。（b）100, 5, 10, 20, 25, 40, 30。",
        "answer": "讲座 1 和 6 或讲座 1、3 和 7",
        "answer_symbols": []
    },
    "8.1 55 c)": {
        "question": "对于练习 54 中的每一部分，使用 53 题的算法找到优化调度方案以获得最大的参考者人数。（c）2, 3, 8, 5, 4, 7, 10。",
        "answer": "讲座 1、3 和 7",
        "answer_symbols": []
    },
    "8.1 55 d)": {
        "question": "对于练习 54 中的每一部分，使用 53 题的算法找到优化调度方案以获得最大的参考者人数。（d）10, 8, 7, 25, 20, 30, 5。",
        "answer": "讲座 1 和 6",
        "answer_symbols": []
    },
    "8.1 55": {
        "question": "对于练习 54 中的每一部分，使用 53 题的算法找到优化调度方案以获得最大的参考者人数.",
        "answer": "a) Talks 1, 3, and 7 b) Talks 1 and 6, or talks 1, 3, and 7 c) Talks 1, 3, and 7 d) Talks 1 and 6",
        "answer_symbols": [
            "and",
            "or"
        ]
    },
    "8.1 56 a)": {
        "question": "证明序列的所有项都是非负数，这个问题可以变为求所有项的和. 然后，给出一个连续项的最大和不是所有项之和的例子.",
        "answer": "If all the terms are nonnegative, then the more terms we have, the larger the sum. A sequence such as 5, -2 shows that the maximum might not be achieved by taking all the terms if some are negative; in this example, the maximum is achieved by taking just the first term, and taking all the terms gives a smaller sum.",
        "answer_symbols": [
            "-",
            ">"
        ]
    },
    "8.1 56 b)": {
        "question": "设 M(k) 是以 a_k 结尾的连续项的最大和. 即，M(k) = max ∑_i=j^k a_i. 解释 k = 2, …, n 时，递推关系 M(k) = max(M(k-1) + a_k, a_k) 成立.",
        "answer": "If the string of consecutive terms must end at a_k, then either it consists just of a_k or it consists of a string of consecutive terms ending at a_k-1 followed by a_k. If we want the largest such sum in the second case, then we must take the largest sum of consecutive terms ending at a_k-1. Therefore, the given recurrence relation must hold.",
        "answer_symbols": [
            "-",
            "+",
            "="
        ]
    },
    "8.1 56 c)": {
        "question": "使用 b) 设计一个动态规划算法解这个问题.",
        "answer": "We compute and store the values M(k) using the recurrence relation in part (b). We could also store, for each k, the starting point of the string of numbers ending at position k that achieves the maximum sum. This would not only give us the sum but also tell us which terms to add to achieve it. Note also that the max function will choose the first argument if and only if M(k - 1) is positive (or nonnegative).",
        "answer_symbols": [
            "-",
            "+",
            ">",
            "<",
            "="
        ]
    },
    "8.1 56 d)": {
        "question": "用序列 2, -3, 4, 1, -2, 3 解释 c) 的每一步找到的连续的最大和.",
        "answer": "The successive values for M(k) are 2, -1 (because -3 + 2 > -3), 4 (because 4 > -1 + 4), 5 (because 4 + 1 > 1), 3 (because 5 + (-2) > -2), and 6 (because 3 + 3 > 3).",
        "answer_symbols": [
            "-",
            "+",
            ">",
            "<",
            "="
        ]
    },
    "8.1 56 e)": {
        "question": "证明 c) 中算法的加法和比较运算的最坏情况时间复杂度是线性的.",
        "answer": "The algorithm has just the one loop containing a few arithmetic steps, iterated O(n) times.",
        "answer_symbols": [
            "O"
        ]
    },
    "8.1 57 a)": {
        "question": "证明采用蛮力算法确定矩阵链乘法问题整数乘法的最小个数将是指数最坏情况时间复杂度. [首先通过证明矩阵乘法的顺序是由乘积括号指定的，然后使用例 5 和 8.4 节的练习 41 的 c).]",
        "answer": "这直接从第 8.4 节的示例 5 和练习 41c 得出。",
        "answer_symbols": []
    },
    "8.1 57 b)": {
        "question": "用 A_ij 表示 A_i A_i+1 ⋯ A_j 的乘积，M(i, j) 表示计算 A_ij 的最小整数乘法数. 证明如果将 A_i A_i+1 ⋯ A_j 分割为 A_i 与 A_i+1 和 A_i+1 与 A_j 相乘，可以得到计算 A_ij 较少的整数乘法数，那么第一个 k 矩阵项必定括在一起，这样 A_ik 采用 M(i, k) 最优乘法次数；A_k+1, j 必定括在一起，这样 A_k+1, j 采用 M(k+1, j) 最优乘法次数.",
        "answer": "计算 Aij 的最后一步是将 Aik 乘以 Ak+1,j，其中 k 在 i 和 j-1 之间（包括端点），这将需要 m_i m_k+1 m_j+1 次整数乘法，与 Aik 和 Ak+1,j 的计算方式无关。因此，为了最小化总整数乘法次数，这两个因子必须以最有效的方式计算。",
        "answer_symbols": [
            "×",
            "m",
            "(",
            ")",
            "+",
            "∈"
        ]
    },
    "8.1 57 c)": {
        "question": "解释为什么 b) 可以得到如下递推关系：如果 1 ≤ i ≤ k < j ≤ n，M(i, j) = min_i≤k<j (M(i, k) + M(k+1, j) + m_i m_k+1 m_j+1)",
        "answer": "这直接来自部分 (b) 和 M(i, j) 的定义。",
        "answer_symbols": []
    },
    "8.1 57 d)": {
        "question": "使用 c) 中的递推关系设计一个确定 n 矩阵乘的有效算法，算法采用最小整数乘法个数. 当计算出 M(i, j) 时，保存 M(i, j) 部分结果使得算法不会出现指数时间复杂度.",
        "answer": "矩阵排序过程 (m1, ..., m_{n+1}: 正整数) for i := 1 to n M(i, i) := 0 for d := 1 to n - 1 for i := 1 to n - d min := 0 for k := i to i + d new := M(i, k) + M(k + 1, i + d) + m_i * m_{k+1} * m_{i+d+1} if new < min then min := new where(i, i + d) := k M(i, i + d) := min",
        "answer_symbols": [
            ":=",
            "+",
            "*",
            "<",
            "min"
        ]
    },
    "8.1 57 e)": {
        "question": "证明 d) 的算法对于整数乘具有 O(n^3) 的最坏情况时间复杂度.",
        "answer": "该算法有三个嵌套循环，每个循环最多索引 n 个值。",
        "answer_symbols": []
    },
    "8.2 1 a)": {
        "question": "证明 a_n = n2^n 是这个递推关系的一个解。",
        "answer": "度 3",
        "answer_symbols": []
    },
    "8.2 1 b)": {
        "question": "使用定理 5 找出这个递推关系的所有解。",
        "answer": "不",
        "answer_symbols": []
    },
    "8.2 1 c)": {
        "question": "找出具有 a_0 = 2 的解。",
        "answer": "度 4",
        "answer_symbols": []
    },
    "8.2 1 d)": {
        "question": "确定下面哪些是常系数线性齐次递推关系，如果是，求它们的阶。aₙ=aₙ₋₁+2",
        "answer": "不",
        "answer_symbols": []
    },
    "8.2 1 e)": {
        "question": "确定下面哪些是常系数线性齐次递推关系，如果是，求它们的阶。aₙ=aₙ₋₁^²+aₙ₋₂",
        "answer": "不",
        "answer_symbols": []
    },
    "8.2 1 f)": {
        "question": "确定下面哪些是常系数线性齐次递推关系，如果是，求它们的阶。aₙ=aₙ₋₂",
        "answer": "度 2",
        "answer_symbols": []
    },
    "8.2 1 g)": {
        "question": "确定下面哪些是常系数线性齐次递推关系，如果是，求它们的阶。aₙ=aₙ₋₁+n",
        "answer": "不",
        "answer_symbols": []
    },
    "8.2 2 a)": {
        "question": "确定下面哪些是常系数线性齐次递推关系，如果是，求它们的阶。aₙ=3aₙ₋₁",
        "answer": "Linear, homogeneous, with constant coefficients; degree 2",
        "answer_symbols": []
    },
    "8.2 2 b)": {
        "question": "确定下面哪些是常系数线性齐次递推关系，如果是，求它们的阶。aₙ=3",
        "answer": "Linear with constant coefficients but not homogeneous",
        "answer_symbols": []
    },
    "8.2 2 c)": {
        "question": "确定下面哪些是常系数线性齐次递推关系，如果是，求它们的阶。aₙ=aₙ₋₁^²",
        "answer": "Not linear",
        "answer_symbols": []
    },
    "8.2 2 d)": {
        "question": "确定下面哪些是常系数线性齐次递推关系，如果是，求它们的阶。aₙ=aₙ₋₁+2aₙ₋₃",
        "answer": "Linear, homogeneous, with constant coefficients; degree 3",
        "answer_symbols": []
    },
    "8.2 2 e)": {
        "question": "确定下面哪些是常系数线性齐次递推关系，如果是，求它们的阶。aₙ=aₙ₋₁/n",
        "answer": "Linear and homogeneous, but not with constant coefficients",
        "answer_symbols": []
    },
    "8.2 2 f)": {
        "question": "确定下面哪些是常系数线性齐次递推关系，如果是，求它们的阶。aₙ=aₙ₋₁+aₙ₋₂+n+3",
        "answer": "Linear with constant coefficients, but not homogeneous",
        "answer_symbols": []
    },
    "8.2 2 g)": {
        "question": "确定下面哪些是常系数线性齐次递推关系，如果是，求它们的阶。aₙ=4aₙ₋₂+5aₙ₋₄+9aₙ₋₇",
        "answer": "Linear, homogeneous, with constant coefficients; degree 7",
        "answer_symbols": []
    },
    "8.2 3 a)": {
        "question": "求解下列具有给定初始条件的递推关系。aₙ = 2aₙ₋₁，n ≥ 1，a₀ = 3",
        "answer": "an = 3 · 2^n",
        "answer_symbols": [
            "=",
            "·",
            "^"
        ]
    },
    "8.2 3 b)": {
        "question": "求解下列具有给定初始条件的递推关系。aₙ = aₙ₋₁，n ≥ 1，a₀ = 2",
        "answer": "a_n = 2",
        "answer_symbols": [
            "="
        ]
    },
    "8.2 3 c)": {
        "question": "求解下列具有给定初始条件的递推关系。aₙ = 5aₙ₋₁ - 6aₙ₋₂，n ≥ 2，a₀ = 1，a₁ = 0",
        "answer": "a_n = 3 * 2^n - 2 * 3^n",
        "answer_symbols": [
            "=",
            "*",
            "^",
            "-"
        ]
    },
    "8.2 3 d)": {
        "question": "求解下列具有给定初始条件的递推关系。aₙ = 4aₙ₋₁ - 4aₙ₋₂，n ≥ 2，a₀ = 6，a₁ = 8",
        "answer": "a_n = 6 * 2^n - 2 * n^2 * 2^n",
        "answer_symbols": [
            "=",
            "*",
            "^",
            "-"
        ]
    },
    "8.2 3 e)": {
        "question": "求解下列具有给定初始条件的递推关系。aₙ = -4aₙ₋₁ - 4aₙ₋₂，n ≥ 2，a₀ = 0，a₁ = 1",
        "answer": "a_n = n(-2)^(n-1)",
        "answer_symbols": [
            "=",
            "*",
            "^"
        ]
    },
    "8.2 3 f)": {
        "question": "求解下列具有给定初始条件的递推关系。aₙ = 4aₙ₋₂，n ≥ 2，a₀ = 0，a₁ = 4",
        "answer": "a_n = 2^n - (-2)^n",
        "answer_symbols": [
            "=",
            "^",
            "-"
        ]
    },
    "8.2 3 g)": {
        "question": "求解下列具有给定初始条件的递推关系。aₙ = aₙ₋₂/4，n ≥ 2，a₀ = 1，a₁ = 0",
        "answer": "a_n = (1/2)^(n+1) - (-1/2)^(n+1)",
        "answer_symbols": [
            "=",
            "^",
            "-"
        ]
    },
    "8.2 4 a)": {
        "question": "求解下列具有给定初始条件的递推关系。aₙ = aₙ₋₁ + 6aₙ₋₂，n ≥ 2，a₀ = 3，a₁ = 6",
        "answer": "r^² - r - 6 = 0 r = -2, 3 a_n = α₁ * (-2)^ⁿ + α₂ * 3^ⁿ 3 = α₁ + α₂ 6 = -2α₁ + 3α₂ α₁ = 3/5 α₂ = 12/5 a_n = (3/5) * (-2)^ⁿ + (12/5) * 3^ⁿ",
        "answer_symbols": [
            "-",
            "+",
            "*",
            "=",
            "^",
            "(",
            ")"
        ]
    },
    "8.2 4 b)": {
        "question": "求解下列具有给定初始条件的递推关系。aₙ = 7aₙ₋₁ - 10aₙ₋₂，n ≥ 2，a₀ = 2，a₁ = 1",
        "answer": "r^² - 7r + 10 = 0 r = 2, 5 a_n = α1 * 2^n + α2 * 5^n\n2 = α1 + α2\n1 = 2α1 + 5α2\nα1 = 3\nα2 = -1\na_n = 3 * 2^n - 5^n",
        "answer_symbols": [
            "+",
            "*",
            "ⁿ",
            "^",
            "=",
            "²",
            "-"
        ]
    },
    "8.2 4 c)": {
        "question": "求解下列具有给定初始条件的递推关系。aₙ = 6aₙ₋₁ - 8aₙ₋₂，n ≥ 2，a₀ = 4，a₁ = 10",
        "answer": "r^² - 6r + 8 = 0 r = 2, 4 a_n = α₁ * 2^n + α₂ * 4^n 4 = α₁ + α₂ 10 = 2α₁ + 4α₂ α₁ = 3 α₂ = 1 a_n = 3 * 2^n + 4^n",
        "answer_symbols": [
            "²",
            "-",
            "+",
            "=",
            "*",
            "^",
            "n"
        ]
    },
    "8.2 4 d)": {
        "question": "求解下列具有给定初始条件的递推关系。aₙ = 2aₙ₋₁ - aₙ₋₂，n ≥ 2，a₀ = 4，a₁ = 1",
        "answer": "r^² - 2r + 1 = 0 r = 1, 1 a_n = α₁ * 1^n + α₂ * n * 1^n = α₁ + α₂ * n 4 = α₁ 1 = α₁ + α₂ α₁ = 4 α₂ = -3 a_n = 4 - 3n",
        "answer_symbols": [
            "²",
            "-",
            "+",
            "=",
            "*",
            "^",
            "n"
        ]
    },
    "8.2 4 e)": {
        "question": "求解下列具有给定初始条件的递推关系。aₙ = aₙ₋₂，n ≥ 2，a₀ = 5，a₁ = -1",
        "answer": "r^² - 1 = 0 r = -1, 1 a_n = α₁ * (-1)^n + α₂ * 1^n = α₁ * (-1)^n + α₂ 5 = α₁ + α₂ -1 = -α₁ + α₂ α₁ = 3 α₂ = 2 a_n = 3 * (-1)^n + 2",
        "answer_symbols": [
            "²",
            "-",
            "+",
            "=",
            "*",
            "^",
            "n"
        ]
    },
    "8.2 4 f)": {
        "question": "求解下列具有给定初始条件的递推关系。aₙ = -6aₙ₋₁ - 9aₙ₋₂，n ≥ 2，a₀ = 3，a₁ = -3",
        "answer": "r^² + 6r + 9 = 0 r = -3, -3 a_n = α₁ * (-3)^n + α₂ * n * (-3)^n 3 = α₁ -3 = -3α₁ - 3α₂ α₁ = 3 α₂ = -2 a_n = 3 * (-3)^n - 2n * (-3)^n = (3 - 2n) * (-3)^n",
        "answer_symbols": [
            "²",
            "+",
            "=",
            "*",
            "^",
            "n",
            "-"
        ]
    },
    "8.2 4 g)": {
        "question": "求解下列具有给定初始条件的递推关系。aₙ + 2 = -4aₙ₊₁ + 5aₙ，n ≥ 0，a₀ = 2，a₁ = 8",
        "answer": "r^² + 4r - 5 = 0 r = -5, 1 a_n = α₁ * (-5)^n + α₂ * 1^n = α₁ * (-5)^n + α₂ 2 = α₁ + α₂ 8 = -5α₁ + α₂ α₁ = -1 α₂ = 3 a_n = -(-5)^n + 3",
        "answer_symbols": [
            "²",
            "+",
            "-",
            "=",
            "*",
            "^",
            "n"
        ]
    },
    "8.2 5": {
        "question": "使用 8.1 节练习 19 描述的两个信号在 n 微秒内可以传送多少不同的信息？",
        "answer": "a_n = 1/√5 * (1+√5/2)^(n+1) - 1/√5 * (1-√5/2)^(n+1)",
        "answer_symbols": [
            "=",
            "*",
            "^",
            "+",
            "-",
            "√"
        ]
    },
    "8.2 6": {
        "question": "如果传送 1 个信号需要 1 微秒，传送另外 2 个信号中的每一个都需要 2 微秒，且在信号中一个信号紧接着下一个信号，使用这 3 个信号在 n 微秒内可以传送多少个不同的信息？",
        "answer": "模型是递推关系 a_n = a_(n-1) + a_(n-2) + a_(n-2) = a_(n-1) + 2a_(n-2)，初始条件为 a_0 = a_1 = 1（见第8.1节练习19的技术）。为了求解这个递推关系，我们使用特征方程 r^2 - r - 2 = 0，其根为 -1 和 2。因此通解为 a_n = α₁ * (-1)^n + α₂ * 2^n。代入初始条件得到方程 1 = α₁ + α₂ 和 1 = -α₁ + 2α₂，解得 α₁ = 1/3 和 α₂ = 2/3。因此在 n 微秒内可以传输 (1/3) * (-1)^n + (2/3) * 2^n 条消息。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "*",
            "^",
            "n",
            "/"
        ]
    },
    "8.2 7": {
        "question": "使用 1 × 2 和 2 × 2 的块铺满一块 2 × n 的长方形板，有多少种方式？",
        "answer": "[2^n+1 + (−1)^n] / 3",
        "answer_symbols": [
            "=",
            "+",
            "^",
            "−",
            "/"
        ]
    },
    "8.2 8 a)": {
        "question": "一个关于每年捕龙虾数的模型基于如下的假设：1 年捕捞的龙虾数是前 2 年捕捞龙虾数的平均值。a) 找出一个关于 {Lₙ} 的递推关系，其中 Lₙ 是在这个模型的假设下第 n 年捕捞的龙虾数。",
        "answer": "根据平均值的定义，递推关系为 L_n = (1/2) * L_(n-1) + (1/2) * L_(n-2)。",
        "answer_symbols": [
            "=",
            "+",
            "*",
            "n",
            "/"
        ]
    },
    "8.2 8 b)": {
        "question": "一个关于每年捕龙虾数的模型基于如下的假设：1 年捕捞的龙虾数是前 2 年捕捞龙虾数的平均值。b) 如果在第 1 年捕捞了 100 000 只龙虾且第 2 年捕捞了 300 000 只龙虾，求 L₃。",
        "answer": "特征方程为 r^2 - (1/2)r - (1/2) = 0，解得 r = -1/2 和 r = 1。因此通解为 L_n = α₁ * (-1/2)^n + α₂。代入初始条件 L_1 = 100000 和 L_2 = 300000，得到 100000 = (-1/2) * α₁ + α₂ 和 300000 = (1/4) * α₁ + α₂。解这些方程得到 α₁ = 800000/3 和 α₂ = 700000/3。因此答案为 L_n = (800000/3) * (-1/2)^n + (700000/3)。",
        "answer_symbols": [
            "²",
            "-",
            "+",
            "=",
            "*",
            "^",
            "n",
            "/"
        ]
    },
    "8.2 9 a)": {
        "question": "年初把一笔 100 000 美元的钱存入一个投资基金。在每年的最后一天得到两份红利。第一份红利是当年账上钱数的 20%。第二份红利是前一年账上钱数的 45%。a) 如果不允许取钱，找出一个关于 {Pₙ} 的递推关系，其中 Pₙ 是第 n 年末账上的钱数。",
        "answer": "P_n = 1.2P_{n-1} + 0.45P_{n-2}, P_0 = 100,000, P_1 = 120,000",
        "answer_symbols": [
            "=",
            "+"
        ]
    },
    "8.2 9 b)": {
        "question": "年初把一笔 100 000 美元的钱存入一个投资基金。在每年的最后一天得到两份红利。第一份红利是当年账上钱数的 20%。第二份红利是前一年账上钱数的 45%。b) 如果不允许取钱，n 年以后账上有多少钱？",
        "answer": "P_n = (250,000/3) * (3/2)^n + (50,000/3) * (-3/10)^n",
        "answer_symbols": [
            "=",
            "*",
            "^",
            "+"
        ]
    },
    "8.2 11 a)": {
        "question": "卢卡斯数满足递推关系 Lₙ = Lₙ₋₁ + Lₙ₋₂ 和初始条件 L₀ = 2 和 L₁ = 1。a) 证明 Lₙ = fₙ₋₁ + fₙ₊₁，n = 2, 3, ⋯，其中 fₙ 是第 n 个斐波那契数。",
        "answer": "基础步骤：对于 n = 1，我们有 1 = 0 + 1；对于 n = 2，我们有 3 = 1 + 2。归纳步骤：假设对 k ≤ n 成立。那么 L_{n+1} = L_n + L_{n-1} = f_{n-1} + f_{n+1} + f_{n-2} + f_n = (f_{n-1} + f_{n-2}) + (f_{n+1} + f_n) = f_n + f_{n+2}。",
        "answer_symbols": [
            "=",
            "+",
            "≤"
        ]
    },
    "8.2 11 b)": {
        "question": "卢卡斯数满足递推关系 Lₙ = Lₙ₋₁ + Lₙ₋₂ 和初始条件 L₀ = 2 和 L₁ = 1。b) 求出卢卡斯数的显式公式。",
        "answer": "L_n = (1+√5/2)^n + (1-√5/2)^n",
        "answer_symbols": [
            "=",
            "^",
            "+",
            "√"
        ]
    },
    "8.2 13": {
        "question": "求解 aₙ = 7aₙ₋₂ + 6aₙ₋₃，a₀ = 9，a₁ = 10，a₂ = 32。",
        "answer": "a_n = 8(-1)^n - 3(-2)^n + 4 * 3^n",
        "answer_symbols": [
            "=",
            "*",
            "^",
            "+",
            "-"
        ]
    },
    "8.2 15": {
        "question": "求解 aₙ = 2aₙ₋₁ + 5aₙ₋₂ - 6aₙ₋₃，a₀ = 7，a₁ = -4，a₂ = 8。",
        "answer": "a_n = 5 + 3(-2)^n - 3n",
        "answer_symbols": [
            "=",
            "*",
            "^",
            "+",
            "-"
        ]
    },
    "8.2 17": {
        "question": "证明下列涉及斐波那契数和二项式系数的恒等式：fₙ₊₁ = C(n, 0) + C(n-1, 1) + ⋯ + C(n-k, k)，其中 n 是正整数且 k = ⌊n/2⌋。",
        "answer": "令 a_n = C(n, 0) + C(n-1, 1) + ... + C(n-k, k)，其中 k = n/2。首先，假设 n 是偶数，所以 k = n/2，最后一项是 C(k, k)。通过帕斯卡恒等式，我们有 a_n = 1 + C(n-2, 0) + C(n-2, 1) + C(n-3, 1) + C(n-3, 2) + ... + C(n - k, k - 2) + C(n - k, k - 1) + 1 = 1 + C(n-2, 1) + C(n-3, 2) + ... + C(n - k, k - 1) + C(n-2, 0) + C(n-3, 1) + ... + C(n - k, k - 2) + 1 = a_{n-1} + a_{n-2}，因为 (n - 1)/2 = k - 1 = (n - 2)/2。当 n 是奇数时，类似的计算也成立。因此，{a_n} 满足递推关系 a_n = a_{n-1} + a_{n-2} 对于所有正整数 n，n ≥ 2。另外，a_1 = C(1, 0) = 1 且 a_2 = C(2, 0) + C(1, 1) = 2，它们分别是 f_2 和 f_3。由此得出 a_n = f_{n+1} 对于所有正整数 n。",
        "answer_symbols": [
            "=",
            "+",
            "≥",
            "C"
        ]
    },
    "8.2 19": {
        "question": "求解递推关系 aₙ = -3aₙ₋₁ - 3aₙ₋₂ - aₙ₋₃，a₀ = 5，a₁ = -9，a₂ = 15。",
        "answer": "a_n = (n^2 + 3n + 5)(-1)^n",
        "answer_symbols": [
            "=",
            "*",
            "^",
            "+"
        ]
    },
    "8.2 21": {
        "question": "如果线性齐次递推关系的特征方程的根是 1, 1, 1, 1, -2, -2, -2, 3, 3, -4，那么它的解的一般形式是什么？",
        "answer": "(a1,0 + a1,1n + a1,2n^2 + a1,3n^3) + (a2,0 + a2,1n + a2,2n^2)(−2)^n + (a3,0 + a3,1n)3^n + a4,0(−4)^n",
        "answer_symbols": [
            "*",
            "(",
            ",",
            "−",
            "+",
            "=",
            "^",
            ")"
        ]
    },
    "8.2 23 a)": {
        "question": "考虑非齐次线性递推关系 aₙ = 3aₙ₋₁ + 2^ⁿ。a) 证明 aₙ = -2^ⁿ^⁺¹ 是这个递推关系的一个解。",
        "answer": "3a_{n-1} + 2n = 3(-2)^n + 2n = 2n(-3 + 1) = -2^(n+1) = a_n",
        "answer_symbols": [
            "=",
            "*",
            "^",
            "+",
            "-"
        ]
    },
    "8.2 23 b)": {
        "question": "考虑非齐次线性递推关系 aₙ = 3aₙ₋₁ + 2^ⁿ。b) 使用定理 5 找出这个递推关系的所有解。",
        "answer": "a_n = α3^n - 2^(n+1)",
        "answer_symbols": [
            "=",
            "*",
            "^",
            "-"
        ]
    },
    "8.2 23 c)": {
        "question": "考虑非齐次线性递推关系 aₙ = 3aₙ₋₁ + 2^ⁿ。c) 找出具有 a₀ = 1 的解。",
        "answer": "a_n = 3^(n+1) - 2^(n+1)",
        "answer_symbols": [
            "=",
            "^",
            "-"
        ]
    },
    "8.2 25 a)": {
        "question": "确定常数 A 和 B 的值，使得 a_n = An + B 是递推关系 a_n = 2a_{n-1} + n + 5 的一个解。",
        "answer": "A = -1, B = -7",
        "answer_symbols": [
            "=",
            ","
        ]
    },
    "8.2 25 b)": {
        "question": "使用定理 5 找出这个递推关系的所有解。",
        "answer": "a_n = α2^n - n - 7",
        "answer_symbols": [
            "=",
            "*",
            "^",
            "-",
            "+"
        ]
    },
    "8.2 25 c)": {
        "question": "找出这个递推关系具有 a_0 = 4 的解。",
        "answer": "a_n = 11 * 2^n - n - 7",
        "answer_symbols": [
            "=",
            "*",
            "^",
            "-",
            "+"
        ]
    },
    "8.2 27 a)": {
        "question": "什么是线性非齐次递推关系 a_n = 8a_{n-1} - 16a_{n-2} + F(n) 的特解的一般形式？如果 F(n) = n^2",
        "answer": "p3n^3 + p2n^2 + p1n + p0",
        "answer_symbols": [
            "+",
            "*",
            "^"
        ]
    },
    "8.2 27 b)": {
        "question": "什么是线性非齐次递推关系 a_n = 8a_{n-1} - 16a_{n-2} + F(n) 的特解的一般形式？如果 F(n) = (-2)^n",
        "answer": "n^2p0(-2)^n",
        "answer_symbols": [
            "*",
            "(",
            "^"
        ]
    },
    "8.2 27 c)": {
        "question": "什么是线性非齐次递推关系 a_n = 8a_{n-1} - 16a_{n-2} + F(n) 的特解的一般形式？如果 F(n) = n2^n",
        "answer": "n^2(p1n + p0)2^n",
        "answer_symbols": [
            "*",
            "^",
            "+"
        ]
    },
    "8.2 27 d)": {
        "question": "什么是线性非齐次递推关系 a_n = 8a_{n-1} - 16a_{n-2} + F(n) 的特解的一般形式？如果 F(n) = n^2 4^n",
        "answer": "(p2n^2 + p1n + p0)4^n",
        "answer_symbols": [
            "*",
            "^",
            "+"
        ]
    },
    "8.2 27 e)": {
        "question": "什么是线性非齐次递推关系 a_n = 8a_{n-1} - 16a_{n-2} + F(n) 的特解的一般形式？如果 F(n) = (n^2 - 2)(-2)^n",
        "answer": "n^2(p2n^2 + p1n + p0)(-2)^n",
        "answer_symbols": [
            "*",
            "^",
            "+"
        ]
    },
    "8.2 27 f)": {
        "question": "什么是线性非齐次递推关系 a_n = 8a_{n-1} - 16a_{n-2} + F(n) 的特解的一般形式？如果 F(n) = n^2 (-2)^n",
        "answer": "n^2(p4n^4 + p3n^3 + p2n^2 + p1n + p0)2^n",
        "answer_symbols": [
            "*",
            "^",
            "+"
        ]
    },
    "8.2 27 g)": {
        "question": "什么是线性非齐次递推关系 a_n = 8a_{n-1} - 16a_{n-2} + F(n) 的特解的一般形式？如果 F(n) = 2",
        "answer": "p0",
        "answer_symbols": []
    },
    "8.2 29 a)": {
        "question": "找出递推关系 a_n = 2a_{n-1} + 3^n 的所有解。",
        "answer": "a_n = α2^n + 3^(n+1)",
        "answer_symbols": [
            "=",
            "*",
            "^",
            "+"
        ]
    },
    "8.2 29 b)": {
        "question": "找出 a) 中的递推关系具有初始条件 a_1 = 5 的解。",
        "answer": "a_n = -2 * 2^n + 3^(n+1)",
        "answer_symbols": [
            "=",
            "*",
            "^",
            "+",
            "-"
        ]
    },
    "8.2 31": {
        "question": "找出递推关系 a_n = 5a_{n-1} - 6a_{n-2} + 2^n + 3n 的所有解。[提示：找形如 qn2^n + p_1n + p_2 的特解，其中 q, p_1, p_2 是常数。]",
        "answer": "a_n = α2^n + β3^n - n * 2^(n+1) + 3^n / 2 + 21/4",
        "answer_symbols": [
            "=",
            "*",
            "^",
            "+",
            "-",
            "/"
        ]
    },
    "8.2 33": {
        "question": "找出递推关系 a_n = 4a_{n-1} - 4a_{n-2} + (n+1)2^n 的所有解。",
        "answer": "a_n = (α + βn + n^2 + n^3 / 6)2^n",
        "answer_symbols": [
            "=",
            "*",
            "^",
            "+",
            "/"
        ]
    },
    "8.2 35": {
        "question": "找出递推关系 a_n = 4a_{n-1} - 3a_{n-2} + 2^n + n + 3 的解，其中 a_0 = 1, a_1 = 4。",
        "answer": "a_n = -4 * 2^n - n^2 / 4 - 5n / 2 + 1/8 + (39/8)3^n",
        "answer_symbols": [
            "=",
            "*",
            "^",
            "+",
            "-",
            "/"
        ]
    },
    "8.2 36": {
        "question": "设 a_n 是前 n 个完全平方的和，即 a_n = ∑_{k=1}^{n} k^2。证明序列 {a_n} 满足线性非齐次递推关系 a_n = a_{n-1} + n^2 和初始条件 a_1 = 1。使用定理 6 求解这个递推关系以确定关于 a_n 的公式。",
        "answer": "Obviously the n-th term of the sequence comes from the (n-1)-st term by adding n^2; in symbols, a_(n-1) + n^2 = (∑ from k=1 to n-1 k^2) + n^2 = ∑ from k=1 to n k^2 = a_n. Also, the sum of the first square is clearly 1. To solve this recurrence relation, we easily see that the homogeneous solution is a_n = α, so since the nonhomogeneous term is a second degree polynomial, we need a particular solution of the form a_n = c_n^3 + d_n^2 + e_n. Plugging this into the recurrence relation gives c_n^3 + d_n^2 + e_n = c_(n-1)^3 + d_(n-1)^2 + e_(n-1) + n^2. Expanding and collecting terms, we have (3c - 1)n^2 + (-3c + 2d)n + (c - d + e) = 0, whence c = 1/3, d = 1/2, and e = 1/6. Thus a_n^(h) = 1/3 n^3 + 1/2 n^2 + 1/6 n. So the general solution is a_n = α + 1/3 n^3 + 1/2 n^2 + 1/6 n. It is now a simple matter to plug in the initial condition to see that α = 0. Note that we can find a common denominator and write our solution in the familiar form a_n = n(n + 1)(2n + 1)/6.",
        "answer_symbols": [
            "^",
            "+",
            "-",
            "=",
            "∑",
            "(",
            ")",
            "n",
            "α",
            "c",
            "d",
            "e"
        ]
    },
    "8.2 37": {
        "question": "设 a_n 是前 n 个三角形数的和，即 a_n = ∑_{k=1}^{n} t_k，其中 t_k = k(k+1)/2。证明 {a_n} 满足线性非齐次递推关系 a_n = a_{n-1} + n(n+1)/2 和初始条件 a_1 = 1。使用定理 6 求解这个递推关系以确定关于 a_n 的公式。",
        "answer": "a_n = n(n + 1)(n + 2) / 6",
        "answer_symbols": [
            "=",
            "*",
            "+",
            "/"
        ]
    },
    "8.2 38 a)": {
        "question": "求线性齐次递推关系 a_n = 2a_{n-1} - 2a_{n-2} 的特征根。[注意：这些根是复数。]",
        "answer": "The characteristic equation is r^2 - 2r + 2 = 0, whose roots are, by the quadratic formula, 1 ± √(-1), in other words, 1 + i and 1 - i.",
        "answer_symbols": [
            "^",
            "-",
            "=",
            "±",
            "√",
            "i",
            "r"
        ]
    },
    "8.2 38 b)": {
        "question": "求 a) 的递推关系的解，其中 a_0 = 1 和 a_1 = 2。",
        "answer": "The general solution is, by part (a), a_n = α1(1 + i)^n + α2(1 - i)^n. Plugging in the initial conditions gives us 1 = α1 + α2 and 2 = (1 + i)α1 + (1 - i)α2. Solving these linear equations tells us that α1 = 1/2 - 1/2 i and α2 = 1/2 + 1/2 i. Therefore the solution is a_n = (1/2 - 1/2 i)(1 + i)^n + (1/2 + 1/2 i)(1 - i)^n.",
        "answer_symbols": [
            "^",
            "+",
            "-",
            "=",
            "α1",
            "α2",
            "i",
            "n"
        ]
    },
    "8.2 39 a)": {
        "question": "求线性齐次递推关系 a_n = a_{n-1} 的特征根。[注意：这些根包含复数。]",
        "answer": "1, -1, i, -i",
        "answer_symbols": [
            "-",
            "i"
        ]
    },
    "8.2 39 b)": {
        "question": "求 a) 的递推关系的解，其中 a_0 = 1, a_1 = 0, a_2 = -1 和 a_3 = 1。",
        "answer": "a_n = 41 - 41(-1)^n + 2 + 4i^n + 24 - i(-i)^n",
        "answer_symbols": [
            "=",
            "*",
            "^",
            "+",
            "-"
        ]
    },
    "8.2 40": {
        "question": "求解联立递推关系 a_n = 3a_{n-1} + 2b_{n-1} 和 b_n = a_{n-1} + 2b_{n-1}，初始条件 a_0 = 1 和 b_0 = 2。",
        "answer": "First we reduce this system to a recurrence relation and initial conditions involving only a_n. If we subtract the two equations, we obtain a_n - b_n = 2a_(n-1), which gives us b_n = a_n - 2a_(n-1). We plug this back into the first equation to get a_n = 3a_(n-1) + 2(a_(n-1) - 2a_(n-2)) = 5a_(n-1) - 4a_(n-2), our desired recurrence relation in one variable. Note also that the first of the original equations gives us the necessary second initial condition, namely a_1 = 3a_0 + 2b_0 = 7. We now solve this problem for {a_n} in the usual way. The roots of the characteristic equation r^2 - 5r + 4 = 0 are 1 and 4, and the solution, after solving for the arbitrary constants, is a_n = -1 + 2 · 4^n. Finally, we plug this back into the equation b_n = a_n - 2a_(n-1) to find that b_n = 1 + 4^n.",
        "answer_symbols": [
            "^",
            "+",
            "-",
            "=",
            "·",
            "r",
            "a_n",
            "b_n",
            "n"
        ]
    },
    "8.2 41 a)": {
        "question": "用例 4 找到的关于第 n 个斐波那契数 f_n 的公式证明 f_n 是最接近 1/√5 (1+√5/2)^n 的整数。",
        "answer": "使用 f_n 的公式，我们看到 |f_n - 1/2^n| = |1/2^n| < 1/√5 < 1/2。这意味着 f_n 是最接近 1/2^n 的整数。",
        "answer_symbols": [
            "|",
            "-",
            "^",
            "<",
            "="
        ]
    },
    "8.2 41 b)": {
        "question": "确定对哪些 n 有 f_n 大于 1/√5 (1+√5/2)^n 对哪些 n 有 f_n 小于 1/√5 (1+√5/2)^n",
        "answer": "当 n 是偶数时较少；当 n 是奇数时较大",
        "answer_symbols": []
    },
    "8.2 42": {
        "question": "证明：如果 a_n = a_{n-1} + a_{n-2}，a_0 = s 和 a_1 = t，其中 s 和 t 是常数，那么对所有的正整数 n 有 a_n = sf_{n-1} + tf_n。",
        "answer": "We can prove this by induction on n. If n = 1, then the assertion is a_1 = s · f_0 + t · f_1 = s · 0 + t · 1 = t, which is given; and if n = 2, then the assertion is a_2 = s · f_1 + t · f_2 = s · 1 + t · 1 = s + t, which is true, since a_2 = a_1 + a_0 = t + s. Having taken care of the base cases, we assume the inductive hypothesis, that the statement is true for values less than n. Then a_n = a_(n-1) + a_(n-2) = (s · f_(n-2) + t · f_(n-1)) + (s · f_(n-3) + t · f_(n-2)) = s(f_(n-2) + f_(n-3)) + t(f_(n-1) + f_(n-2)) = s · f_(n-1) + t · f_n, as desired.",
        "answer_symbols": [
            "=",
            "+",
            "·",
            "s",
            "t",
            "f",
            "n"
        ]
    },
    "8.2 43": {
        "question": "用斐波那契数的项表示线性非齐次递推关系 a_n = a_{n-1} + a_{n-2} + 1 的解，其中 n ≥ 2，a_0 = 0，a_1 = 1。[提示：令 b_n = a_{n+1} 并对序列 b 应用练习 42。]",
        "answer": "a_n = f_{n-1} + 2f_n - 1",
        "answer_symbols": [
            "=",
            "+",
            "-"
        ]
    },
    "8.2 45 a)": {
        "question": "假设留在岛上的每对遗传工程培育的兔子在一个月大时生出 2 对新兔子，在两个月大和以后的每个月都生出 6 对新兔子。没有兔子死去，也没有兔子从岛上离开。一对新生的兔子留在岛上，求出与 n 个月后岛上兔子对数有关的递推关系。",
        "answer": "a_n = 3a_{n-1} + 4a_{n-2}, a_0 = 2, a_1 = 6",
        "answer_symbols": [
            "=",
            "+"
        ]
    },
    "8.2 45 b)": {
        "question": "通过求解 a) 中的递推关系确定一对新生的兔子留在岛上 n 个月以后岛上的兔子对数。",
        "answer": "a_n = [4^(n+1) + (-1)^n] / 5",
        "answer_symbols": [
            "=",
            "^",
            "+",
            "/"
        ]
    },
    "8.2 46 a)": {
        "question": "假设在一个岛上最初有 2 只山羊。由于自然繁殖，岛上的山羊数每年加倍，并且每年有些山羊被带来或带走。假定每年另有 100 只山羊被放到岛上，构造一个关于第 n 年初岛上山羊数的递推关系。",
        "answer": "初始条件是 a₁ = 2；我们被告知在第一年初有两只山羊。在每个后续年份（第 n 年，n ≥ 2），前一年（第 n-1 年）的山羊数量翻倍，并且额外增加 100 只山羊。所以 a_n = 2a_{n-1} + 100。",
        "answer_symbols": [
            "=",
            "+",
            "≥"
        ]
    },
    "8.2 46 b)": {
        "question": "求解 a) 的递推关系来找出第 n 年初岛上的山羊数。",
        "answer": "相关的齐次递推关系是 a_n = 2a_{n-1}，其解为 a^(h)_n = α * 2^ⁿ。特解是一个 0 次多项式，即常数，a_n = c。将此代入递推关系得 c = 2c + 100，从而 c = -100。所以特解是 a^(p)_n = -100，通解是 a_n = α * 2^ⁿ - 100。代入初始条件并解出 α 得到 2 = 2α - 100，或 α = 51。因此所需的公式是 a_n = 51 * 2^ⁿ - 100。第 n 年初岛上有 51 * 2^ⁿ - 100 只山羊。",
        "answer_symbols": [
            "=",
            "+",
            "*",
            "^",
            "-"
        ]
    },
    "8.2 46 c)": {
        "question": "假定对于每个 n ≥ 3，在第 n 年有 n 只山羊被从岛上带走，构造一个关于第 n 年初岛上山羊数的递推关系。",
        "answer": "我们被告知 a₁ = 2，但这不是相关的初始条件。相反，由于前两年是特殊的（没有山羊被移除），相关的初始条件是 a₂ = 4。在每个后续年份（第 n 年，n ≥ 3），前一年（第 n-1 年）的山羊数量翻倍，并且移除 n 只山羊。所以 a_n = 2a_{n-1} - n。（我们假设移除发生在加倍之后；如果假设移除先发生，则必须写成 a_n = 2(a_{n-1} - n) = 2a_{n-1} - 2n。）",
        "answer_symbols": [
            "=",
            "-",
            "≥",
            "*"
        ]
    },
    "8.2 46 d)": {
        "question": "求解 c) 的关于第 n 年初岛上山羊数的递推关系。",
        "answer": "相关的齐次递推关系是 a_n = 2a_{n-1}，其解为 a^(h)_n = α * 2^ⁿ。特解是一个 1 次多项式，设 a_n = cn + d。将此代入递推关系并合并同类项得 (-c + 1)n + (2c - d) = 0，从而 c = 1 和 d = 2。所以特解是 a^(p)_n = n + 2，通解是 a_n = α * 2^ⁿ + n + 2。代入初始条件 a₂ = 4 并解出 α 得到 4 = 4α + 4，或 α = 0。因此所需的公式是 a_n = n + 2 对所有 n ≥ 2（并且 a₁ = 2）。第 n 年初岛上有 n + 2 只山羊，对所有 n ≥ 2。",
        "answer_symbols": [
            "=",
            "+",
            "*",
            "^",
            "-",
            "≥"
        ]
    },
    "8.2 47 a)": {
        "question": "在一个充满活力的新软件公司，一个新女雇员的初始工资为 50 000 美元，公司允许她每年底她的工资将是她前一年工资的 2 倍，并且她在公司的每年都将额外增加 10 000 美元。构造一个与被雇用的第 n 年她的工资数有关的递推关系。",
        "answer": "a_n = 2a_{n+1} + (n - 1)10,000",
        "answer_symbols": [
            "=",
            "+",
            "*",
            "-"
        ]
    },
    "8.2 47 b)": {
        "question": "求解这个递推关系，找出她被雇用的第 n 年的工资。",
        "answer": "a_n = 70,000 * 2^(n-1) - 10,000n - 10,000",
        "answer_symbols": [
            "=",
            "*",
            "^",
            "+",
            "-"
        ]
    },
    "8.2 48 a)": {
        "question": "证明递推关系 f(n)a_n = g(n)a_{n-1} + h(n) 其中 n ≥ 1，a_0 = C，可以转变成如下形式的递推关系 b_n = b_{n-1} + Q(n)h(n) 其中 b_n = g(n+1)Q(n+1)a_n，满足 Q(n) = (f(1)f(2)⋯f(n-1))/(g(1)g(2)⋯g(n))",
        "answer": "这只是一个跟踪所有符号意义的问题。首先注意 Q(n+1) = Q(n)f(n)/g(n+1)。现在所需等式的左边是 b_n = g(n+1)Q(n+1)a_n = Q(n)f(n)a_n。右边是 b_{n-1} + Q(n)h(n) = g(n)Q(n)a_{n-1} + Q(n)h(n) = Q(n)(g(n)a_{n-1} + h(n))。现在从原始递推关系 f(n)a_n = g(n)a_{n-1} + h(n) 可以看出两边相同。注意：初始条件为 {b_n} 是 b_0 = g(1)Q(1)a_0 = g(1)(1/g(1))a_0 = a_0 = C, 因为通常将空乘积视为数字 1。",
        "answer_symbols": [
            "=",
            "+",
            "/",
            "(",
            ")"
        ]
    },
    "8.2 48 b)": {
        "question": "使用 a) 求解原来的递推关系以得到 a_n = (C + ∑_{i=1}^{n} Q(i)h(i))/(g(n+1)Q(n+1))",
        "answer": "由于 {b_n} 满足部分 (a) 中显示的简单递推关系，我们可以立即看到：b_n = Q(n)h(n) + b_(n-1) = Q(n)h(n) + Q(n - 1)h(n - 1) + b_(n-2) = ... = ∑(from i=1 to n) Q(i)h(i) + b_0 = ∑(from i=1 to n) Q(i)h(i) + C。a_n 的值可以从部分 (a) 中给出的 b_n 的定义得出。",
        "answer_symbols": [
            "=",
            "+",
            "∑",
            "!"
        ]
    },
    "8.2 49": {
        "question": "使用练习 48 求解递推关系 (n+1)a_n = (n+3)a_{n-1} + n，n ≥ 1，a_0 = 1。",
        "answer": "a_n = 5n^2 / 12 + 13n / 12 + 1",
        "answer_symbols": [
            "=",
            "*",
            "+",
            "/",
            "^"
        ]
    },
    "8.2 50 a)": {
        "question": "可以证明当以随机顺序排序 n 个元素时，快速排序算法（在 5.4 节练习 50 中描述）所做的平均比较次数满足递推关系 C_n = n + 1 + (2/n) ∑_{k=0}^{n-1} C_k n = 1, 2, ⋯，且初始条件 C_0 = 0。证明 {C_n} 也满足递推关系 nC_n = (n+1)C_{n-1} + 2n，n = 1, 2, ⋯。",
        "answer": "我们可以通过证明 nC_n - (n + 1)C_(n-1) = 2^n 来证明这一点，所以让我们计算，使用给定的递推关系：nC_n - (n + 1)C_(n-1) = nC_n - (n - 1)C_(n-1) - 2C_(n-1) = n^² + n + 2 ∑(from k=0 to n-1) C_k - (n - 1)(n + 2 ∑(from k=0 to n-2) C_k) - 2C_(n-1) = n^² + n + 2 ∑(from k=0 to n-2) C_k + 2C_(n-1) - n^² + n - 2 ∑(from k=0 to n-2) C_k - 2C_(n-1) = 2^n。",
        "answer_symbols": [
            "=",
            "-",
            "+",
            "∑",
            "^",
            "²"
        ]
    },
    "8.2 50 b)": {
        "question": "使用练习 48 求解 a) 的递推关系以找到关于 C_n 的显示公式。",
        "answer": "我们使用练习 48 中给出的公式。首先注意 f(n) = n, g(n) = n + 1, 和 h(n) = 2^n。因此 Q(n) = (n - 1)! / (n + 1)! = 1 / n(n + 1)。将此代入公式得到：0 + ∑(from i=1 to n) 2^i / [i(i + 1)] * (n + 2) * 1 / [(n + 1)(n + 2)] = 2(n + 1) ∑(from i=1 to n) 1 / (i + 1)。这个和（调和级数）没有好的闭合形式表示，但我们可以检查这个公式和递推关系对于小的 n 值（即 C_1 = 2, C_2 = 5, C_3 = 26/3 等）产生相同的 C_n 值。",
        "answer_symbols": [
            "=",
            "+",
            "∑",
            "/",
            "!",
            "^",
            "²",
            "(",
            ")"
        ]
    },
    "8.2 51": {
        "question": "证明定理 4。",
        "answer": "See Chapter 11, Section 5 in [Ma93].",
        "answer_symbols": []
    },
    "8.2 52": {
        "question": "证明定理 6。",
        "answer": "这个定理的证明可以在诸如 H. E. Mattson, Jr. 的《Discrete Mathematics with Applications》（Wiley, 1993）等教科书中找到，第 11 章。",
        "answer_symbols": []
    },
    "8.2 53": {
        "question": "求解具有初始条件 T(1) = 6 的递推关系 T(n) = nT^2(n/2)。[提示：令 n = 2^k，然后做替换 a_k = log T(2^k) 以便得到一个线性非齐次的递推关系。]",
        "answer": "6^n * 4^(n-1) / n",
        "answer_symbols": [
            "=",
            "*",
            "^",
            "/"
        ]
    },
    "8.3 2": {
        "question": "在 128 个元素的序列中，使用例 2 中的算法查找最大和最小的元素需要多少次比较?",
        "answer": "这里的递推关系是 f(n) = 2f(n/2) + 2，其中 f(1) = 0，因为对一个元素的集合不需要比较。迭代后，我们发现：f(2) = 2 * 0 + 2 = 2, f(4) = 2 * 2 + 2 = 6, f(8) = 2 * 6 + 2 = 14, f(16) = 2 * 14 + 2 = 30, f(32) = 2 * 30 + 2 = 62, f(64) = 2 * 62 + 2 = 126, f(128) = 2 * 126 + 2 = 254。",
        "answer_symbols": [
            "=",
            "+",
            "*",
            "/"
        ]
    },
    "8.3 4": {
        "question": "用伪码表示快速乘法算法。",
        "answer": "在这个算法中，我们假设 a = (a_2n-1 a_2n-2 ... a_1 a_0)_2 和 b = (b_2n-1 b_2n-2 ... b_1 b_0)_2。过程 fast_multiply(a, b: 非负整数) 如果 a ≤ 1 且 b ≤ 1 则 返回 ab 否则 A1 := (a / 2^n) A0 := a - 2^n * A1 B1 := (b / 2^n) B0 := b - 2^n * B1 {假设这四个数字的长度为 n；必要时进行填充} x := fast_multiply(A1, B1) answer := (x 左移 2n 位) + (x 左移 n 位) x := fast_multiply(A0, B0) answer := answer + x + (x 左移 n 位) 如果 A1 ≥ A0 则 A2 := A1 - A0 否则 A2 := A0 - A1 如果 B0 ≥ B1 则 B2 := B0 - B1 否则 B2 := B1 - B0 x := fast_multiply(A2, B2) 左移 n 位 如果 (A1 ≥ A0 且 B0 ≥ B1) 或 (A1 < A0 且 B0 < B1) 则 answer := answer + x 否则 answer := answer - x 返回 answer",
        "answer_symbols": [
            "≤",
            ":",
            "→",
            "÷",
            "-",
            "+",
            "*",
            "=",
            "≥",
            "<",
            "∨",
            "∧"
        ]
    },
    "8.3 6": {
        "question": "用例 4 引人的算法做两个 32×32 矩阵相乘需要多少次运算?",
        "answer": "递推关系是 f(n) = 7f(n/2) + 15n^²/4，初始条件 f(1) = 1。因此我们有： f(2) = 7 * 1 + 15 * 2^²/4 = 22 f(4) = 7 * 22 + 15 * 4^²/4 = 214 f(8) = 7 * 214 + 15 * 8^²/4 = 1738 f(16) = 7 * 1738 + 15 * 16^²/4 = 13126 f(32) = 7 * 13126 + 15 * 32^²/4 = 95,722",
        "answer_symbols": [
            "=",
            "*",
            "+",
            "²",
            "/"
        ]
    },
    "8.3 10": {
        "question": "当 n=2^k 时求 f(n)，其中 f 满足递推关系 f(n)=f(n/2)+1，f(1)=1。",
        "answer": "由于 f 每个因子 2 增加 1，显然 f(2^k) = k + 1。",
        "answer_symbols": [
            "+",
            "^"
        ]
    },
    "8.3 12": {
        "question": "当 n=3^k 时求 f(n)，其中 f 满足递推关系 f(n)=2f(n/3)+4，f(1)=1。",
        "answer": "定理 1 的证明给出了一个精确公式，即 f(n) = [f(1) + c / (a - 1)] * n^(log_b a) - c / (a - 1)，其中 a = 2, b = 3, 和 c = 4。因此答案是 f(n) = 5 * n^(log_3 2) - 4。",
        "answer_symbols": [
            "=",
            "+",
            "/",
            "*",
            "-",
            "(",
            ")",
            "^",
            "log"
        ]
    },
    "8.3 14": {
        "question": "假设在一个淘汰锦标赛中有 n=2^k 个队，其中在第一轮有 n/2 场比赛，n/2=2^(k-1) 个赢的队进入第二轮比赛，以此进行。建立一个关于锦标赛的轮数的递推关系。",
        "answer": "如果只有一个团队，则不需要轮次，所以基本情况是 R(1) = 0。由于将团队数量减半需要一轮，我们有 R(n) = 1 + R(n/2)。",
        "answer_symbols": [
            "=",
            "+",
            "/"
        ]
    },
    "8.3 16": {
        "question": "求解练习 14 所描述的关于锦标赛轮数的递推关系。",
        "answer": "对于 n = 2^k，这个递推关系的解是 R(2^k) = k，原因与练习 10 相同。",
        "answer_symbols": [
            "=",
            "^"
        ]
    },
    "8.3 18 a)": {
        "question": "假设在一组 n 个人中，每个人从候选人的提名中恰好选两个人担任一个委员会的两个职务。只要每人得到超过 n/2 的选票，这前两个人将赢得这两个席位。设计一个分治算法，确定两个得到最多选票的候选人是否每个人至少得到了 n/2 的选票。如果是，确定这两个候选人是谁。",
        "answer": "我们的递归算法将处理一个包含 2n 个名字的序列（每个选民提供的两个不同的名字），并确定得票最多的两名候选人是否在列表中出现超过 n/2 次，如果是，则确定他们是谁。我们假设列表中每个选民的投票相邻（第一个选民的选择在位置 1 和 2，第二个选民的选择在位置 3 和 4，依此类推）。注意，可能有超过两名候选人获得超过 n/2 票；例如，三个选民的选择可能是 AB、AC 和 BC，那么所有三人都符合条件。然而，不可能有多于三名候选人符合条件，因为四个大于 n/2 的数之和大于 2n，即总投票数。如果 n = 1，则列表中的两个人都是胜者。对于递归步骤，将列表分成两个大小相等的部分——前一半和后一半。如练习 17 的提示所述，如果一个候选人在整个列表中没有获得多数（这里指超过 n/2 票），那么他在其中一个部分中也没有获得多数，因为如果一个候选人在每个部分中都获得了不超过一半的选票，那么他在整个列表中也获得了不超过一半的选票（这实际上是分配律）。递归地将算法应用于每一部分，最多可以得到",
        "answer_symbols": [
            "/",
            "*",
            "+",
            "="
        ]
    },
    "8.3 19 a)": {
        "question": "使用 5.4 节中的练习 26 的递归算法为计算 x^n 所需要的乘法次数建立一个分治递推关系，其中 x 为实数，n 是正整数。",
        "answer": "f(n) = f(n/2) + 2",
        "answer_symbols": [
            "=",
            "/",
            "+"
        ]
    },
    "8.3 19 b)": {
        "question": "使用在 a) 中找到的递推关系构造使用递归算法计算 x^n 所用乘法的次数的大 O 估计。",
        "answer": "O(log n)",
        "answer_symbols": [
            "(",
            ")",
            "log"
        ]
    },
    "8.3 20 a)": {
        "question": "使用 5.4 节中的例 4 的递归算法为计算 a^mod m 所需要的模乘法的次数建立一个分治递推关系，其中 a、m、n 为正整数。",
        "answer": "We compute a^n mod m, when n is even, by first computing y := a^(n/2) mod m recursively and then doing one modular multiplication, namely y * y. When n is odd, we first compute y := a^((n-1)/2) recursively and then do two multiplications, namely y * y * a. So if f(n) is the number of multiplications required, assuming the worst, then we have essentially f(n) = f(n/2) + 2.",
        "answer_symbols": [
            "^",
            "/",
            "*",
            "+",
            ":="
        ]
    },
    "8.3 20 b)": {
        "question": "使用在 a) 中找到的递推关系构造使用递归算法计算 a^mod m 所用模乘法的次数的大 O 估计。",
        "answer": "By the master theorem, with a = 1, b = 2, c = 2, and d = 0, we see that f(n) is O(n^0 log n) = O(log n).",
        "answer_symbols": [
            "=",
            "^",
            "log"
        ]
    },
    "8.3 21 a)": {
        "question": "设函数 f 满足递推关系 f(n)=2f(√n)+1，其中 n 是大于 1 的完全平方数且 f(2)=1。求 f(16)。",
        "answer": "7",
        "answer_symbols": []
    },
    "8.3 21 b)": {
        "question": "设函数 f 满足递推关系 f(n)=2f(√n)+1，其中 n 是大于 1 的完全平方数且 f(2)=1。求关于 f(n) 的大 O 估计。[提示：做替换 m=log n。]",
        "answer": "O(log n)",
        "answer_symbols": [
            "(",
            ")",
            "log"
        ]
    },
    "8.3 22 a)": {
        "question": "设函数 f 满足递推关系 f(n)=2f(√n)+log n，其中 n 是大于 1 的完全平方数且 f(2)=1。求 f(16)。",
        "answer": "f(16) = 2f(4) + 4 = 2(2f(2) + 2) + 4 = 2(2 * 1 + 2) + 4 = 12",
        "answer_symbols": [
            "=",
            "+",
            "*",
            "(",
            ")"
        ]
    },
    "8.3 22 b)": {
        "question": "设函数 f 满足递推关系 f(n)=2f(√n)+log n，其中 n 是大于 1 的完全平方数且 f(2)=1。求关于 f(n) 的大 O 估计。[提示：做替换 m=log n。]",
        "answer": "Let m = log n, so that n = 2^m. Also, let g(m) = f(2^m). Then our recurrence becomes f(2^m) = 2f(2^(m/2)) + m, since √(2^m) = (2^m)^(1/2) = 2^(m/2). Rewriting this in terms of g, we have g(m) = 2g(m/2) + m. Theorem 2 (with a = 2, b = 2, c = 1, and d = 1) tells us that g(m) is O(m log m). Since m = log n, this says that our function is O(log n * log log n).",
        "answer_symbols": [
            "=",
            "^",
            "+",
            "*",
            "√",
            "(",
            ")",
            "log"
        ]
    },
    "8.3 27": {
        "question": "如果两点间的距离定义为 d((x_i, y_i), (x_j, y_j)) = max(|x_i - x_j|, |y_i - y_j|)，使用例 12 描述的算法中应用的那些合理的步骤并加以改变，构造求两点之间最小距离的算法。",
        "answer": "该算法基本上与示例12中给出的算法相同。中心条带仍然宽度为2d，但我们需要考虑两个大小为d × d的盒子而不是八个大小为(d/2)×(d/2)的盒子。递推关系与示例12中的递推关系相同，只是系数7被替换为1。",
        "answer_symbols": [
            "×",
            "×",
            "×"
        ]
    },
    "8.3 23 a)": {
        "question": "使用伪码描述一个求解该问题的算法，这个算法依次寻找从第一项开始的连续项之和，从第二项开始的连续项之和，等等，并在算法执行时记录当前找到的最大和。",
        "answer": "过程最大和(a1,..., an) 最佳 := 0 {空子序列的和为0} 对于 i := 1 到 n 和 := 0 对于 j := i + 1 到 n 和 := 和 + aj 如果 和 > 最佳 那么 最佳 := 和 {最佳是列表中数字的最大可能和}",
        "answer_symbols": [
            "+",
            ":="
        ]
    },
    "8.3 23 b)": {
        "question": "依照所做的计算和的次数与比较次数确定在 a) 中算法的计算复杂度。",
        "answer": "O(n^²)",
        "answer_symbols": [
            "(",
            ")",
            "^"
        ]
    },
    "8.3 23 c)": {
        "question": "设计一个分治算法求解这个问题。提示：假设序列中有偶数个项，把这个序列分成两半。解释当连续项的最大和包含了在两个半序列的项时怎样处理这种情况。",
        "answer": "我们将列表分为前半部分和后半部分，并递归地应用算法以找到每个部分的最大连续项和。整个序列的最大连续项和要么是这两个数字之一，要么是跨越列表中间的一系列连续项的和。为了找到跨越列表中间的一系列连续项的最大可能和，我们从中间开始向前移动以找到后半部分列表中的最大可能和，并向后移动以找到前半部分列表中的最大可能和；所需的和是这两个量的总和。最终答案是这三个数中最大的一个。基本情况是一个项的序列的最大和是该数与0之间的较大值。",
        "answer_symbols": [
            "+",
            ":",
            ">"
        ]
    },
    "8.3 23 d)": {
        "question": "使用 c) 中的算法求下面每个序列的连续项的最大和：-2, 4, -1, 3, 5, -6, 1, 2; 4, 1, -3, 7, -1, -5, 3, -2; -1, 6, 3, -4, -5, 8, -1, 7。",
        "answer": "11, 9, 14",
        "answer_symbols": []
    },
    "8.3 23 e)": {
        "question": "通过 c) 中的分治算法使用的求和次数和比较次数寻找一个递推关系。",
        "answer": "S(n) = 2S(n/2) + n, C(n) = 2C(n/2) + n + 2, S(1) = 0, C(1) = 1",
        "answer_symbols": [
            "=",
            "+",
            "/",
            ","
        ]
    },
    "8.3 23 f)": {
        "question": "使用主定理估计这个分治算法的计算复杂度。依照计算复杂度把这个算法与 a) 中的算法做比较，结果如何？",
        "answer": "O(n log n)，优于O(n^²)",
        "answer_symbols": [
            "(",
            ")",
            "log",
            "^",
            ","
        ]
    },
    "8.3 24": {
        "question": "应用例 12 描述的求最近点对的算法，使用点之间的欧几里得距离，求下述点 (1, 3), (1, 7), (2, 4), (2, 9), (3, 1), (3, 5), (4, 3), (4, 7) 的最近点对。",
        "answer": "To carry this down to its base level would require applying the algorithm three times, so we will show only the outermost step. The points are already sorted for us, and so we divide them into two groups, using x coordinate. The left side will have the first four points listed in it (they all have x coordinates less than 2.5), and the right side will have the rest, all of which have x coordinates greater than 2.5. Thus our vertical line will be taken to be x = 2.5. Now assume that we have already applied the algorithm recursively to find the minimum distance between two points on the left, and the minimum distance on the right. It turns out that d_L = √2 and d_R = √5, so d = √2. This is achieved by the points (1, 3) and (2, 4). Thus we want to concentrate on the strip from x = 2.5 - √2 ≈ 1.1 to x = 2.5 + √2 ≈ 3.9 of width 2d. The only points in this strip are (2, 4), (2, 9), (3, 1), and (3, 5). Working from the bottom up, we compute distances from these points to points as much as d = √2 ≈ 1.4 vertical units above them. According to the discussion in the text, there can never be more than seven such computations for each point in the strip. In this case, there is in fact only one, namely (2, 4) and (3, 5). This distance is again √2, and it ties the minimum distance already obtained. So the minimum distance is √2.",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "√",
            "≈",
            "(",
            ")",
            ","
        ]
    },
    "8.3 25": {
        "question": "应用例 12 描述的求最近点对的算法，使用点之间的欧几里得距离，求下述点 (1, 2), (1, 6), (2, 4), (2, 8), (3, 1), (3, 6), (3, 10), (4, 3), (5, 1), (5, 5), (6, 7), (7, 1), (7, 4), (7, 9), (8, 6) 的最近点对。",
        "answer": "(1, 6) 和 (3, 6) 距离为 2",
        "answer_symbols": [
            "(",
            ")",
            "和"
        ]
    },
    "8.3 26": {
        "question": "使用伪码描述例 12 中所叙述的解最近点对问题的递归算法。",
        "answer": "In our algorithm, d contains the shortest distance and is the value returned by the algorithm. We assume a function dist that computes Euclidean distance given two points (a, b) and (c, d), namely √((a - c)^² + (b - d)^²). We also assume that some global preprocessing has been done to sort the points in nondecreasing order of x coordinates before calling this program, and to produce a separate list P of the points in nondecreasing order of y coordinates, but having an identification as to which points in the original list they are.",
        "answer_symbols": [
            "²",
            "(",
            ",",
            "-",
            "+",
            "√",
            "≈",
            ")"
        ]
    },
    "8.3 28 a)": {
        "question": "给定数 x 和 n 个元素的集合，证明每个问题问 2 次并且当发现说谎时可以多问一个问题，那么乌拉姆问题可以用 2 log n + 1 次询问求解。",
        "answer": "We follow the discussion here. At each stage, we ask the same question twice: 'Is x in this part of the set?' If both answers are consistent, we know they are true and we recursively proceed on the half known to contain the number. If the answers are inconsistent, we ask a third time to determine the truth (the first person cannot lie twice, so the third answer is true). After detecting a lie, we no longer need to ask each question twice because all answers must be true. However, if the lie appears in our last query, then we use the full 2 log n + 1 questions (the last one is the third question when the lie is detected).",
        "answer_symbols": [
            "log"
        ]
    },
    "8.3 28 b)": {
        "question": "把初始的 n 元素集合划分成 4 部分，每部分具有 n/4 个元素，证明使用 2 次询问就可以排除 1/4 的元素。提示：使用 2 次询问，其中每次询问都问是否这个元素在两个 n/4 个元素的子集的并集中，并且其中一个 n/4 个元素的子集出现在两次询问中。",
        "answer": "Divide the set into four (almost) equal parts, A, B, C, and D. To determine which of these subsets contains the first person's number, ask the following questions: 'Is your number in A ∪ B?' and 'Is your number in A ∪ C?' If both answers are 'yes', we can exclude D because at least one answer is true, so the secret number is in A ∪ B ∪ C. By similar reasoning, if both answers are 'no', we can exclude A; if the first answer is 'yes' and the second is 'no', we can exclude C; if the first answer is 'no' and the second is 'yes', we can exclude B. Therefore, after two questions, the problem size is approximately 3n/4 (exactly so when 4 | n).",
        "answer_symbols": [
            "∪"
        ]
    },
    "8.3 28 c)": {
        "question": "利用 b) 证明如果 f(n) 等于用 b) 中的方法求解乌拉姆问题所用到的询问次数，且 n 被 4 整除，那么 f(n) = f(3n/4) + 2。",
        "answer": "Since we reduce the problem to a 3n/4 size problem at each stage, the number of questions f(n) satisfies f(n) = f(3n/4) + 2 when n is divisible by 4.",
        "answer_symbols": [
            "="
        ]
    },
    "8.3 28 d)": {
        "question": "求解 c) 中关于 f(n) 的递推关系。",
        "answer": "Using iteration, we solve the recurrence relation from part (c). We have f(n) = 2 + f((3/4)n) = 2 + 2 + f((3/4)^² n) = 2 + 2 + 2 + f((3/4)^³ n) = ... = 2 + 2 + ... + 2, where there are approximately log_4/3 n twos in the sum. Noting that log_4/3 n = log n / log 4/3 ≈ 2.4 log n, we have f(n) ≈ 4.8 log n.",
        "answer_symbols": [
            "+",
            "²",
            "³",
            "≈",
            "log"
        ]
    },
    "8.3 28 e)": {
        "question": "每个这种问题问两次来求解乌拉姆问题的天真方法与基于 b) 的分治方法相比，哪种具有更高的效率？求解乌拉姆问题的最有效的方法已经由 A. 派尔克 (A. Pelc) 确定 [Pe87]。",
        "answer": "The direct method is better, using fewer than half the number of questions. Another way to look at it is to observe that in the second method, after four questions, the size of the set is reduced to 9/16 of its original size, while in the first method, after just two questions, the set size is even smaller (1/2).",
        "answer_symbols": [
            "/"
        ]
    },
    "8.3 29": {
        "question": "证明：如果 a = b^d 且 n 是 b 的幂，那么 f(n) = f(1)n^d + cn^d log n。",
        "answer": "假设 k = logb n，则 f(n) = a^k f(1) + Σ(k-1 j=0) a^j c(n/b^j)^d = a^k f(1) + Σ(k-1 j=0) cnd = a^k f(1) + kcnd = a^(logb n) f(1) + cnd logb n = n^(logb a) f(1) + cnd logb n = n^d f(1) + cnd logb n.",
        "answer_symbols": [
            "=",
            "log",
            "^",
            "(",
            ")",
            "Σ",
            "+",
            "*",
            "/"
        ]
    },
    "8.3 30": {
        "question": "使用练习 29 证明：如果 a = b^d，那么 f(n) 是 O(n^d log n)。",
        "answer": "Clearly the second term dominates. Moreover, log_b n is just a constant multiple of log n. Now from the fact that f is increasing, the statement follows.",
        "answer_symbols": [
            "log"
        ]
    },
    "8.3 31": {
        "question": "证明：如果 a ≠ b^d 且 n 是 b 的幂，那么 f(n) = C_1 n^d + C_2 n^(d log_b a)，其中 C_1 = b^d c / (b^d - a) C_2 = f(1) + b^d c / (a - b^d)",
        "answer": "假设 k = logb n 其中 n 是 b 的幂。基本步骤：如果 n = 1 且 k = 0，那么 c1n^d + c2n^(logb a) = c1 + c2 = b^d c / (b^d - a) + f(1) + b^d c/(a - b^d) = f(1)。归纳步骤：假设对 k 成立，其中 n = b^k。那么对于 n = b^(k+1)，f(n) = af(n/b) + cn^d = a{[b^d c/(b^d - a)](n/b)^d + [f(1) + b^d c/(a - b^d)] · (n/b)^(logb a)} + cn^d = b^d c/(b^d - a)n^d a/b^d + [f(1) + b^d c/(a - b^d)]n^(logb a) + cn^d = n^d[ac/(b^d - a) + c(b^d - a)/(b^d - a)] + [f(1) + b^d c/(a - b^d)]n^(logb a) = [b^d c/(b^d - a)]n^d + [f(1) + b^d c/(a - b^d)]n^(logb a).",
        "answer_symbols": [
            "=",
            "log",
            "^",
            "(",
            ")",
            "Σ",
            "+",
            "*",
            "/"
        ]
    },
    "8.3 32": {
        "question": "使用练习 31 证明：如果 a < b^d，那么 f(n) 是 O(n^d)。",
        "answer": "If a < bd, then log_b a < d, so the first term dominates. Now from the fact that f is increasing, the statement follows.",
        "answer_symbols": [
            "<",
            "log"
        ]
    },
    "8.3 33": {
        "question": "使用练习 31 证明：如果 a > b^d，那么 f(n) 是 O(n^(d log_b a))。",
        "answer": "如果 a > b^d，那么 logb a > d，因此第二项占主导地位，得到 O(n^(logb a))。",
        "answer_symbols": [
            ">",
            "log",
            "^",
            "("
        ]
    },
    "8.3 34": {
        "question": "当 n = 4^k 时，求 f(n)，其中 f 满足递推关系 f(n) = 5f(n/4) + 6n，f(1) = 1。",
        "answer": "From Exercise 31 (note here a = 5, b = 4, c = 6, d = 1), we have f(n) = -24n + 25n log_4 5.",
        "answer_symbols": [
            "=",
            "+",
            "log"
        ]
    },
    "8.3 35": {
        "question": "如果 f 是增函数，给出练习 34 中 f 的大 O 估计。",
        "answer": "O(n^(log4 5))",
        "answer_symbols": [
            "(",
            ")",
            "log",
            "^"
        ]
    },
    "8.3 36": {
        "question": "当 n = 2^k 时，求 f(n)，其中 f 满足递推关系 f(n) = 8f(n/2) + n^2，f(1) = 1。",
        "answer": "From Exercise 31 (note here a = 8, b = 2, c = 1, d = 2), we have f(n) = -n^² + 2n log 8 = -n^² + 2n^³.",
        "answer_symbols": [
            "=",
            "+",
            "²",
            "³",
            "log"
        ]
    },
    "8.3 37": {
        "question": "如果 f 是增函数，给出练习 36 中 f 的大 O 估计。",
        "answer": "O(n^³)",
        "answer_symbols": [
            "(",
            ")",
            "^"
        ]
    },
    "8.4 1": {
        "question": "求关于有穷序列2,2,2,2,2,2的生成函数。",
        "answer": "f(x) = 2(x^⁶ - 1)/(x - 1)",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "-",
            "/",
            "⁶"
        ]
    },
    "8.4 3 a)": {
        "question": "求关于下面每个序列生成函数的直接表达式。（a）0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, ... ",
        "answer": "f(x) = 2x(1 - x^⁶)/(1 - x)",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "-",
            "/",
            "⁶"
        ]
    },
    "8.4 3 b)": {
        "question": "求关于下面每个序列生成函数的直接表达式。（b）0, 0, 1, 1, 1, 1, 1, 1, 1, ... ",
        "answer": "x^³/(1 - x)",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "/",
            "³"
        ]
    },
    "8.4 3 c)": {
        "question": "求关于下面每个序列生成函数的直接表达式。（c）0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, ... ",
        "answer": "x/(1 - x^³)",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "/",
            "³"
        ]
    },
    "8.4 3 d)": {
        "question": "求关于下面每个序列生成函数的直接表达式。（d）2, 4, 8, 16, 32, 64, 128, 256, ... ",
        "answer": "2/(1 - 2x)",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "/",
            "²"
        ]
    },
    "8.4 3 e)": {
        "question": "求关于下面每个序列生成函数的直接表达式。（e）7 0, 7 1, 7 2, …, 7 7, 0, 0, 0, 0, 0, 0, … ",
        "answer": "(1 + x)^⁷",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "⁷"
        ]
    },
    "8.4 3 f)": {
        "question": "求关于下面每个序列生成函数的直接表达式。（f）2, -2, 2, -2, 2, -2, 2, -2, ... ",
        "answer": "2/(1 + x)",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "+",
            "/"
        ]
    },
    "8.4 3 g)": {
        "question": "求关于下面每个序列生成函数的直接表达式。（g）0, 0, 0, 1, 2, 3, 4, ... ",
        "answer": "[1/(1 - x)] - x^²",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "/",
            "-",
            "²"
        ]
    },
    "8.4 3 h)": {
        "question": "求关于下面每个序列生成函数的直接表达式。（h）0, 0, 1, 1, 1, 1, 1, 1, ... ",
        "answer": "x^³/(1 - x)^²",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "/",
            "³",
            "²"
        ]
    },
    "8.4 5 a)": {
        "question": "求关于序列 {aₙ} 的生成函数的直接表达式，其中（a）aₙ = 5，对所有的 n = 0, 1, 2, … ",
        "answer": "a₀ = -64, a₁ = 144, a₂ = -108, a₃ = 27, 且 aₙ = 0 对于所有 n ≥ 4",
        "answer_symbols": [
            "=",
            "≥"
        ]
    },
    "8.4 5 b)": {
        "question": "求关于序列 {aₙ} 的生成函数的直接表达式，其中（b）aₙ = 3^n，对所有的 n = 0, 1, 2, … ",
        "answer": "唯一非零系数是 a₀ = 1, a₃ = 3, a₆ = 3, a₉ = 1.",
        "answer_symbols": [
            "=",
            ","
        ]
    },
    "8.4 5 c)": {
        "question": "求关于序列 {aₙ} 的生成函数的直接表达式，其中（c）aₙ = 2，对 n = 3, 4, 5, … 且 a₀ = a₁ = a₂ = 0 ",
        "answer": "aₙ = 5^ⁿ",
        "answer_symbols": [
            "=",
            "ⁿ"
        ]
    },
    "8.4 5 d)": {
        "question": "求关于序列 {aₙ} 的生成函数的直接表达式，其中（d）aₙ = 2n + 3 对所有的 n = 0, 1, 2, … ",
        "answer": "aₙ = (-3)^ⁿ - 3 对于 n ≥ 3，且 a₀ = a₁ = a₂ = 0",
        "answer_symbols": [
            "=",
            "≥",
            "-"
        ]
    },
    "8.4 5 e)": {
        "question": "求关于序列 {aₙ} 的生成函数的直接表达式，其中（e）aₙ = 8n，对所有的 n = 0, 1, 2, … ",
        "answer": "a₀ = 8, a₁ = 3, a₂ = 2, aₙ = 0 对于大于2的奇数 n 和 aₙ = 1 对于大于2的偶数 n",
        "answer_symbols": [
            "=",
            "≥",
            "≥"
        ]
    },
    "8.4 8 a)": {
        "question": "对于下面每一个生成函数给出关于它所确定序列的直接表达式。（a）(x^2 + 1)^3 ",
        "answer": "根据二项式定理（表1中的第三行）我们得到 a_2n = C(3, n) 对于 n = 0, 1, 2, 3，其他系数均为0。或者，我们也可以直接展开这个有限多项式并注意非零系数：a_0 = 1, a_2 = 3, a_4 = 3, a_6 = 1。",
        "answer_symbols": [
            "C",
            "="
        ]
    },
    "8.4 8 b)": {
        "question": "对于下面每一个生成函数给出关于它所确定序列的直接表达式。（b）(3x - 1)^3 ",
        "answer": "这个问题类似于部分(a)。首先我们需要提取出 -1 并写成 -(1 - 3x)^3。然后根据二项式定理（表1中的第二行）我们得到 a_n = -C(3, n)(-3)^n 对于 n = 0, 1, 2, 3，其他系数均为0。或者，我们可以（手动或使用Maple）直接展开这个有限多项式并注意非零系数：a_0 = -1, a_1 = 9, a_2 = -27, a_3 = 27。",
        "answer_symbols": [
            "-",
            "C",
            "x",
            "^",
            "(",
            ")",
            "="
        ]
    },
    "8.4 8 c)": {
        "question": "对于下面每一个生成函数给出关于它所确定序列的直接表达式。（c）1/(1 - 2x^2) ",
        "answer": "这个问题需要结合表1中第六和第七个恒等式的结果。x^(2n) 的系数是 2n，奇数系数均为0。",
        "answer_symbols": [
            "x",
            "^",
            "=",
            "2",
            "n"
        ]
    },
    "8.4 8 d)": {
        "question": "对于下面每一个生成函数给出关于它所确定序列的直接表达式。（d）x^2/(1 - x)^3 ",
        "answer": "我们知道 x^2 / (1 - x)^3 = x^2 ∑_{n=0}^{∞} C(n + 2, 2)x^n = ∑_{n=0}^{∞} C(n + 2, 2)x^(n+2) = ∑_{n=2}^{∞} C(n, 2)x^n。因此 a_n = C(n, 2) = n(n - 1)/2 对于 n ≥ 2 且 a_0 = a_1 = 0。（实际上，由于 C(0, 2) = C(1, 2) = 0，我们真的不需要对 n < 2 做特别说明。）",
        "answer_symbols": [
            "x",
            "^",
            "/",
            "(",
            ")",
            "∑",
            "C",
            "=",
            "n",
            "-",
            "≥"
        ]
    },
    "8.4 8 e)": {
        "question": "对于下面每一个生成函数给出关于它所确定序列的直接表达式。（e）x - 1 + 1/(1 - 3x) ",
        "answer": "最后一项从表1中给出 a_n = 3^n。我们需要调整 n = 0 和 n = 1 的情况，因为前两项。因此 a_0 = -1 + 3^0 = 0，a_1 = 1 + 3^1 = 4。",
        "answer_symbols": [
            "=",
            "^",
            "+",
            "-"
        ]
    },
    "8.4 8 f)": {
        "question": "对于下面每一个生成函数给出关于它所确定序列的直接表达式。（f）(1 + x^3)/(1 + x)^3 ",
        "answer": "我们将这个分成两部分并像部分(d)那样进行处理：1 / (1 + x)^3 + x^3 / (1 + x)^3 = ∑_{n=0}^{∞} (-1)^n C(n + 2, 2)x^n + x^3 ∑_{n=0}^{∞} (-1)^n C(n + 2, 2)x^n = ∑_{n=0}^{∞} (-1)^n C(n + 2, 2)x^n + ∑_{n=0}^{∞} (-1)^n C(n + 2, 2)x^(n+3) = ∑_{n=0}^{∞} (-1)^n C(n + 2, 2)x^n + ∑_{n=3}^{∞} (-1)^n-3 C(n - 1, 2)x^n。注意到 n 和 n - 3 的奇偶性相反。因此 a_n = (-1)^n C(n + 2, 2) + (-1)^n-3 C(n - 1, 2) = (-1)^n (C(n + 2, 2) - C(n - 1, 2)) = (-1)^n 3n 对于 n ≥ 3 且 a_n = (-1)^n C(n + 2, 2) = (-1)^n (n + 2)(n + 1)/2 对于 n < 3。这个答案可以使用Maple的series命令验证。",
        "answer_symbols": [
            "+",
            "-",
            "x",
            "^",
            "/",
            "(",
            ")",
            "∑",
            "C",
            "n",
            "=",
            "≥",
            "<"
        ]
    },
    "8.4 8 g)": {
        "question": "对于下面每一个生成函数给出关于它所确定序列的直接表达式。（g）x/(1 + x + x^2) ",
        "answer": "关键是回忆代数恒等式 1 - x^3 = (1 - x)(1 + x + x^2)。因此给定函数可以重写为 x(1 - x) / (1 - x^3)，然后可以拆分为 x / (1 - x^3) 加上 -x^2 / (1 - x^3)。从表1我们知道 1 / (1 - x^3) = 1 + x^3 + x^6 + x^9 + ...。因此 x / (1 - x^3) = x + x^4 + x^7 + x^10 + ...，-x^2 / (1 - x^3) = -x^2 - x^5 - x^8 - x^11 - ...。因此我们看到当 n 是3的倍数时 a_n 为0，当 n 比3的倍数多1时 a_n 为1，当 n 比3的倍数多2时 a_n 为-1。可以用Maple检查这个答案。",
        "answer_symbols": [
            "-",
            "x",
            "^",
            "(",
            ")",
            "/",
            "+",
            "=",
            "..."
        ]
    },
    "8.4 8 h)": {
        "question": "对于下面每一个生成函数给出关于它所确定序列的直接表达式。（h）e^(x^2) - 1 ",
        "answer": "从表1我们知道 e^x = 1 + x + x^2 / 2! + x^3 / 3! + ...。因此 e^(3x^2) = 1 + 3x^2 + (3x^2)^2 / 2! + (3x^2)^3 / 3! + ... 我们可以读取生成函数 e^(3x^2) - 1 的系数。首先，显然 a_0 = 0。其次，当 n 为奇数时 a_n = 0。最后，当 n 为偶数时，我们有 a_2m = 3^m / m!。",
        "answer_symbols": [
            "e",
            "x",
            "^",
            "+",
            "!",
            "(",
            ")",
            "=",
            "..."
        ]
    },
    "8.4 9 a)": {
        "question": "求出下面每个函数的幂级数中 x^10 的系数。（a）(1 + x^2 + x^4 + x^6 + ⋯)^3 ",
        "answer": "6",
        "answer_symbols": []
    },
    "8.4 9 b)": {
        "question": "求出下面每个函数的幂级数中 x^10 的系数。（b）(x^3 + x^4 + x^5 + x^6 + x^7 + ⋯)^3 ",
        "answer": "3",
        "answer_symbols": []
    },
    "8.4 9 c)": {
        "question": "求出下面每个函数的幂级数中 x^10 的系数。（c）(x^2 + x^4 + x^6)(x^3 + x^4 + x^5 + x^6 + ⋯)(1 + x^2 + x^4 + x^6 + ⋯) ",
        "answer": "9",
        "answer_symbols": []
    },
    "8.4 9 d)": {
        "question": "求出下面每个函数的幂级数中 x^10 的系数。（d）(x^2 + x^4 + x^6 + x^8 + ⋯)(x^3 + x^5 + x^7 + ⋯)(x^4 + x^6 + x^8 + ⋯) ",
        "answer": "0",
        "answer_symbols": []
    },
    "8.4 9 e)": {
        "question": "求出下面每个函数的幂级数中 x^10 的系数。（e）(1 + x^2 + x^4 + x^6 + ⋯)(1 + x^4 + x^8 + x^12 + ⋯)(1 + x^6 + x^12 + x^18 + ⋯) ",
        "answer": "5",
        "answer_symbols": []
    },
    "8.4 11 a)": {
        "question": "求出下面每个函数的幂级数中 x^10 的系数。（a）1/(1 - 2x) ",
        "answer": "1024",
        "answer_symbols": []
    },
    "8.4 11 b)": {
        "question": "求出下面每个函数的幂级数中 x^10 的系数。（b）1/(1 + x)^2 ",
        "answer": "11",
        "answer_symbols": []
    },
    "8.4 11 c)": {
        "question": "求出下面每个函数的幂级数中 x^10 的系数。（c）1/(1 - x)^3 ",
        "answer": "66",
        "answer_symbols": []
    },
    "8.4 11 d)": {
        "question": "求出下面每个函数的幂级数中 x^10 的系数。（d）1/(1 + 2x)^4 ",
        "answer": "292,864",
        "answer_symbols": []
    },
    "8.4 11 e)": {
        "question": "求出下面每个函数的幂级数中 x^10 的系数。（e）x^2/(1 - 3x)^3 ",
        "answer": "20,412",
        "answer_symbols": []
    },
    "8.4 13": {
        "question": "把10个相同的球分给4个孩子，如果每个孩子至少得到2个球，使用生成函数确定不同的分配方法数。",
        "answer": "10",
        "answer_symbols": []
    },
    "8.4 15": {
        "question": "把 15 个相同的动物玩具分给 6 个孩子使得每个孩子至少得到 1 个但不超过 3 个，使用生成函数确定不同的分配方法数。",
        "answer": "50",
        "answer_symbols": []
    },
    "8.4 17": {
        "question": "把 25 个相同的多纳圈分给 4 个警察使得每个警察至少得到 3 个但不超过 7 个，有多少种方式？",
        "answer": "20",
        "answer_symbols": []
    },
    "8.4 19": {
        "question": "求序列 (c_k) 的生成函数，其中 c_k 是使用 1 美元、2 美元、5 美元和 10 美元纸币换 k 美元的方法数。",
        "answer": "f(x) = 1/[(1 - x)(1 - x^²)(1 - x^⁵)(1 - x¹^⁰)]",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "²",
            "⁵",
            "¹⁰",
            "/"
        ]
    },
    "8.4 23 a)": {
        "question": "什么是关于 (a_k) 的生成函数？这里 a_k 是 x_1 + x_2 + x_3 = k 的解的个数，其中 x_1, x_2 和 x_3 是满足 x_1 ≥ 2, 0 ≤ x_2 ≤ 3, 2 ≤ x_3 ≤ 5 的整数。",
        "answer": "x^⁴(1 + x + x^² + x^³)^²/(1 - x)",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "²",
            "⁴",
            "³",
            "+",
            "/"
        ]
    },
    "8.4 23 b)": {
        "question": "使用 a) 的答案求 a_6。",
        "answer": "6",
        "answer_symbols": []
    },
    "8.4 25 a)": {
        "question": "解释怎样使用生成函数找到用 3 分、4 分和 20 分的邮票在信封上贴满 r 分邮费的方式数。假设不考虑贴邮票的次序。",
        "answer": "x^r 在幂级数展开式 1/[(1-x^³)(1-x^⁴)(1-x^²^⁰)] 中的系数",
        "answer_symbols": [
            "=",
            "³",
            "⁴",
            "²⁰",
            "/"
        ]
    },
    "8.4 25 b)": {
        "question": "解释怎样使用生成函数找到用 3 分、4 分和 20 分的邮票在信封上贴满 r 分邮费的方式数。假设邮票贴成一行并且考虑贴的次序。",
        "answer": "1/(1-x^³-x^⁴-x^²^⁰)",
        "answer_symbols": [
            "=",
            "³",
            "⁴",
            "²⁰",
            "/"
        ]
    },
    "8.4 25 c)": {
        "question": "当不考虑贴邮票的次序时，使用 a) 的答案确定用 3 分、4 分和 20 分的邮票在信封上贴满 46 分邮费的方式数。（建议使用计算机代数程序。）",
        "answer": "7",
        "answer_symbols": []
    },
    "8.4 25 d)": {
        "question": "当考虑贴邮票的次序时，使用 b) 的答案确定用 3 分、4 分和 20 分的邮票在信封上贴满一行 46 分邮费的方式数。（建议使用计算机代数程序。）",
        "answer": "3224",
        "answer_symbols": []
    },
    "8.4 26 a)": {
        "question": "重复掷一个骰子，考虑掷的次序并且使得掷出的点数之和为 n，证明关于这种方式数的生成函数是 1/(1 - x - x^2 - x^3 - x^4 - x^5 - x^6)。",
        "answer": "On each roll, we can get a total of one pip, two pips,..., six pips. So the generating function for each roll is x + x^² + x^³ + x^⁴ + x^⁵ + x^⁶. The exponent on x gives the number of pips. If we want to achieve a total of k pips in n rolls, then we need the coefficient of xᵏ in (x + x^² + x^³ + x^⁴ + x^⁵ + x^⁶)^ⁿ. Since n is free to vary here, we must add these generating functions for all possible values of n. Therefore the generating function for this problem is ∑ from n=0 to ∞ of (x + x^² + x^³ + x^⁴ + x^⁵ + x^⁶)^ⁿ. By the formula for summing a geometric series, this is the same as 1 / (1 - (x + x^² + x^³ + x^⁴ + x^⁵ + x^⁶)) = 1 / (1 - x - x^² - x^³ - x^⁴ - x^⁵ - x^⁶).",
        "answer_symbols": [
            "x",
            "+",
            "²",
            "³",
            "⁴",
            "⁵",
            "⁶",
            "(",
            ")",
            "∑",
            "∞",
            "n",
            "=",
            "k",
            "xᵏ",
            "ⁿ",
            "/",
            "-",
            "¹"
        ]
    },
    "8.4 26 b)": {
        "question": "使用 a) 的答案求出重复掷一个骰子，考虑掷的次序并且使得掷出的总点数为 8 的方式数。（建议使用计算机代数程序。）",
        "answer": "We seek the coefficient of x^⁸ in the power series for our answer to part(a). The best way to get the answer is probably asking Maple or another computer algebra package to find this power series, which it will probably do using calculus. If we do so, the answer turns out to be 125 (the series starts out 1 + x + 2x^² + 4x^³ + 8x^⁴ + 16x^⁵ + 32x^⁶ + 63x^⁷ + 125x^⁸ + 248x^⁹).",
        "answer_symbols": [
            "x",
            "+",
            "²",
            "³",
            "⁴",
            "⁵",
            "⁶",
            "⁷",
            "⁸",
            "⁹",
            "x⁸",
            "125"
        ]
    },
    "8.4 27 a)": {
        "question": "使用生成函数（如果需要，使用计算机代数程序）求出换 1 美元的方式数。用 10 美分和 25 美分。",
        "answer": "3",
        "answer_symbols": []
    },
    "8.4 27 b)": {
        "question": "使用生成函数（如果需要，使用计算机代数程序）求出换 1 美元的方式数。用 5 美分、10 美分和 25 美分。",
        "answer": "29",
        "answer_symbols": []
    },
    "8.4 27 c)": {
        "question": "使用生成函数（如果需要，使用计算机代数程序）求出换 1 美元的方式数。用 1 美分、10 美分和 25 美分。",
        "answer": "29",
        "answer_symbols": []
    },
    "8.4 27 d)": {
        "question": "使用生成函数（如果需要，使用计算机代数程序）求出换 1 美元的方式数。用 1 美分、5 美分、10 美分和 25 美分。",
        "answer": "242",
        "answer_symbols": []
    },
    "8.4 28 a)": {
        "question": "使用生成函数（如果需要，使用计算机代数程序）求出用 1 美分、5 美分、10 美分和 25 美分换 1 美元的方式数，使得 1 美分不超过 10 个。",
        "answer": "The generating function for the pennies is 1 + x + x^² + ... + x¹^⁰ = (1 - x¹¹) / (1 - x). Thus our entire generating function is (1 - x¹¹) / (1 - x) * 1 / (1 - x^⁵) * 1 / (1 - x¹^⁰) * 1 / (1 - x^²^⁵). Maple says that the coefficient of x¹^⁰^⁰ in this is 79.",
        "answer_symbols": [
            "x",
            "+",
            "²",
            "³",
            "⁴",
            "⁵",
            "⁶",
            "⁷",
            "⁸",
            "⁹",
            "¹⁰",
            "¹¹",
            "(",
            ")",
            "/",
            "*",
            "x¹⁰⁰",
            "79"
        ]
    },
    "8.4 28 b)": {
        "question": "使用生成函数（如果需要，使用计算机代数程序）求出用 1 美分、5 美分、10 美分和 25 美分换 1 美元的方式数，使得 1 美分不超过 10 个且 5 美分不超过 10 个。",
        "answer": "This is just like part(a), except that now the generating function is (1 - x¹¹) / (1 - x) * (1 - (x^⁵)¹¹) / (1 - x^⁵) * 1 / (1 - x¹^⁰) * 1 / (1 - x^²^⁵). This time Maple reports that the answer is 58.",
        "answer_symbols": [
            "x",
            "+",
            "²",
            "³",
            "⁴",
            "⁵",
            "⁶",
            "⁷",
            "⁸",
            "⁹",
            "¹⁰",
            "¹¹",
            "(",
            ")",
            "/",
            "*",
            "x⁵",
            "58"
        ]
    },
    "8.4 28 c)": {
        "question": "使用生成函数（如果需要，使用计算机代数程序）求出用 1 美分、5 美分、10 美分和 25 美分换 1 美元的方式数，使得硬币不超过 10 个。",
        "answer": "This problem can be solved by using a generating function with two variables, one for the number of coins (say y) and one for the values (say x). Then the generating function for nickels, for instance, is 1 + x^⁵y + x¹^⁰y^² + ... = 1 / (1 - x^⁵y). We multiply the four generating functions together, for the four different denominations, and get a function of x and y. Then we ask Maple to expand this as a power series and get the coefficient of x¹^⁰^⁰. This coefficient is a polynomial in y. We ask Maple to extract and simplify this polynomial and it turns out to be y^⁴ + y^⁶ + 2y^⁷ + 2y^⁸ + 2y^⁹ + 4y¹^⁰ plus higher order terms that we don’t want, since we need the number of coins (which is what the exponent on y tells us) to be less than 11. Since the total of these coefficients is 12, the answer is 12, which can be confirmed by brute force enumeration.",
        "answer_symbols": [
            "x",
            "+",
            "²",
            "³",
            "⁴",
            "⁵",
            "⁶",
            "⁷",
            "⁸",
            "⁹",
            "¹⁰",
            "¹¹",
            "(",
            ")",
            "/",
            "*",
            "y",
            "x⁵y",
            "y⁴",
            "y⁶",
            "y⁷",
            "y⁸",
            "y⁹",
            "y¹⁰",
            "12"
        ]
    },
    "8.4 21": {
        "question": "对 (1 + x + x^2 + x^3 + ⋯)^3 展开式中 x^4 的系数给出组合解释。使用这个解释求出这个数。",
        "answer": "15",
        "answer_symbols": []
    },
    "8.4 29 a)": {
        "question": "使用生成函数求出换 100 美元的方式数。用 10 美元、20 美元和 50 美元纸币。",
        "answer": "10",
        "answer_symbols": []
    },
    "8.4 29 b)": {
        "question": "使用生成函数求出换 100 美元的方式数。用 5 美元、10 美元、20 美元和 50 美元纸币。",
        "answer": "49",
        "answer_symbols": []
    },
    "8.4 29 c)": {
        "question": "使用生成函数求出换 100 美元的方式数。用 5 美元、10 美元、20 美元和 50 美元纸币，并且每种纸币至少使用 1 张。",
        "answer": "2",
        "answer_symbols": []
    },
    "8.4 29 d)": {
        "question": "使用生成函数求出换 100 美元的方式数。用 5 美元、10 美元和 20 美元纸币，并且每种纸币至少使用 1 张但不超过 4 张。",
        "answer": "4",
        "answer_symbols": []
    },
    "8.4 30 a)": {
        "question": "如果 G(x) 是关于序列 (a_k) 的生成函数，那么关于下列每个序列的生成函数是什么？2a_0, 2a_1, 2a_2, 2a_3, …",
        "answer": "Multiplication distributes over addition, even when we are talking about infinite sums, so the generating function is just 2G(x).",
        "answer_symbols": [
            "x",
            "+",
            "2G(x)"
        ]
    },
    "8.4 30 b)": {
        "question": "如果 G(x) 是关于序列 (a_k) 的生成函数，那么关于下列每个序列的生成函数是什么？0, a_0, a_1, a_2, a_3, …（假定除了第一项以外各项服从此模式）",
        "answer": "What used to be the coefficient of x^⁰ is now the coefficient of x¹, and similarly for the other terms. The way that happened is that the whole series got multiplied by x. Therefore the generating function for this series is xG(x). In symbols, a₀x + a₁x^² + a₂x^³ + ... = x(a₀ + a₁x + a₂x^² + ...) = xG(x).",
        "answer_symbols": [
            "x",
            "+",
            "²",
            "³",
            "a₀",
            "a₁",
            "a₂",
            "xG(x)"
        ]
    },
    "8.4 30 c)": {
        "question": "如果 G(x) 是关于序列 (a_k) 的生成函数，那么关于下列每个序列的生成函数是什么？0, 0, 0, a_2, a_3, …（假定除了前四项以外各项服从此模式）",
        "answer": "The terms involving a₀ and a₁ are missing; G(x) - a₀ - a₁x = a₂x^² + a₃x^³ + .... Here, however, we want a₂ to be the coefficient of x^⁴, not x^² (and similarly for the other powers), so we must throw in an extra factor. Thus the answer is x^²(G(x) - a₀ - a₁x).",
        "answer_symbols": [
            "x",
            "+",
            "²",
            "³",
            "a₀",
            "a₁",
            "a₂",
            "a₃",
            "G(x)"
        ]
    },
    "8.4 30 d)": {
        "question": "如果 G(x) 是关于序列 (a_k) 的生成函数，那么关于下列每个序列的生成函数是什么？a_2, a_3, a_4, …",
        "answer": "This is just like part(c), except that we slide the powers down. Thus the answer is (G(x) - a₀ - a₁x) / x^².",
        "answer_symbols": [
            "x",
            "+",
            "²",
            "³",
            "a₀",
            "a₁",
            "a₂",
            "a₃",
            "G(x)"
        ]
    },
    "8.4 30 e)": {
        "question": "如果 G(x) 是关于序列 (a_k) 的生成函数，那么关于下列每个序列的生成函数是什么？a_1, 2a_2, 3a_3, 4a_4, … [提示：这里需要微积分。]",
        "answer": "根据提示，我们对 G(x)= ∑∞ n=0 a_n * x^n 求导以获得 G'(x)= ∑∞ n=0 n * a_n * x^(n-1)。通过变量变化，这变为 ∑∞ n=0 (n+1) * a_(n+1) * x^n = a_1 + 2 * a_2 * x + 3 * a_3 * x^2 + ...，这就是我们给出的序列的生成函数。因此，G'(x) 是这个序列的生成函数。",
        "answer_symbols": [
            "∑",
            "∞",
            "=",
            "*",
            "+",
            "(",
            ")",
            "^",
            "'"
        ]
    },
    "8.4 30 f)": {
        "question": "如果 G(x) 是关于序列 (a_k) 的生成函数，那么关于下列每个序列的生成函数是什么？a_0^2, 2a_0a_1, a_1^2 + 2a_0a_2, 2a_0a_3 + 2a_1a_2, 2a_0a_4 + 2a_1a_3 + a_2^2, …",
        "answer": "如果我们查看定理1，不难看出这里显示的序列正是 G(x) · G(x) 的系数。",
        "answer_symbols": [
            "·"
        ]
    },
    "8.4 31 a)": {
        "question": "如果 G(x) 是关于序列 {a_n} 的生成函数，那么关于下述每个序列的生成函数是什么？ 0, 0, 0, a_3, a_4, a_5, … (假定除了前三项以外各项服从此模式)",
        "answer": "G(x) - a₀ - a₁x - a₂x^²",
        "answer_symbols": [
            "-",
            "=",
            "²"
        ]
    },
    "8.4 31 b)": {
        "question": "如果 G(x) 是关于序列 {a_n} 的生成函数，那么关于下述每个序列的生成函数是什么？ a_0, 0, a_1, 0, a_2, 0, …",
        "answer": "G(x^²)",
        "answer_symbols": [
            "²"
        ]
    },
    "8.4 31 c)": {
        "question": "如果 G(x) 是关于序列 {a_n} 的生成函数，那么关于下述每个序列的生成函数是什么？ 0, 0, 0, 0, a_0, a_1, a_2, … (假定除了前四项以外各项服从此模式)",
        "answer": "x^⁴ G(x)",
        "answer_symbols": [
            "⁴"
        ]
    },
    "8.4 31 d)": {
        "question": "如果 G(x) 是关于序列 {a_n} 的生成函数，那么关于下述每个序列的生成函数是什么？ a_0, 2a_1, 4a_2, 8a_3, 16a_4, …",
        "answer": "G(2x)",
        "answer_symbols": [
            "²"
        ]
    },
    "8.4 31 e)": {
        "question": "如果 G(x) 是关于序列 {a_n} 的生成函数，那么关于下述每个序列的生成函数是什么？ 0, a_0, a_1/2, a_2/3, a_3/4, … [提示：这里需要微积分。]",
        "answer": "∫ x 0 G(t)dt",
        "answer_symbols": [
            "∫",
            "(",
            ")",
            "t",
            "dt"
        ]
    },
    "8.4 31 f)": {
        "question": "如果 G(x) 是关于序列 {a_n} 的生成函数，那么关于下述每个序列的生成函数是什么？ a_0, a_0 + a_1, a_0 + a_1 + a_2, a_0 + a_1 + a_2 + a_3, …",
        "answer": "G(x)/(1-x)",
        "answer_symbols": [
            "(",
            ")",
            "/"
        ]
    },
    "8.4 32": {
        "question": "使用生成函数求解递推关系 a_k = 7a_{k-1}，初始条件 a_0 = 5。",
        "answer": "这个问题类似于示例16。首先令 G(x)=∑∞ k=0 a_k * x^k。那么 xG(x)=∑∞ k=0 a_k * x^(k+1)=∑∞ k=1 a_(k-1) * x^k（通过将变量名称从 k 改为 k+1）。因此 G(x) - 7xG(x)= ∑∞ k=0 a_k * x^k - ∑∞ k=1 7 * a_(k-1) * x^k= a_0 + ∑∞ k=1 (a_k - 7 * a_(k-1)) * x^k= a_0 + 0 = 5，因为给定的递推关系和初始条件。因此 G(x)(1 - 7x) = 5，所以 G(x) = 5 / (1 - 7x)。从表1我们知道，a_k = 5 * 7^k。",
        "answer_symbols": [
            "∑",
            "∞",
            "=",
            "*",
            "+",
            "(",
            ")",
            "-",
            "^",
            "/"
        ]
    },
    "8.4 33": {
        "question": "使用生成函数求解递推关系 a_k = 3a_{k-1} + 2，初始条件 a_0 = 1。",
        "answer": "aₖ = 2·3^(k-1)",
        "answer_symbols": [
            "=",
            "·",
            "³",
            "⁻"
        ]
    },
    "8.4 34": {
        "question": "使用生成函数求解递推关系 a_k = 3a_{k-1} + 4^(k-1)，初始条件 a_0 = 1。",
        "answer": "令 G(x)=∑∞ k=0 a_k * x^k。那么 xG(x)=∑∞ k=0 a_k * x^(k+1)=∑∞ k=1 a_(k-1) * x^k（通过将变量名称从 k 改为 k+1）。因此 G(x) - 3xG(x)= ∑∞ k=0 a_k * x^k - ∑∞ k=1 3 * a_(k-1) * x^k= a_0 + ∑∞ k=1 (a_k - 3 * a_(k-1)) * x^k= 1 + ∑∞ k=1 4^(k-1) * x^k = 1 + x ∑∞ k=1 4^(k-1) * x^(k-1)= 1 + x ∑∞ k=0 4^k * x^k= 1 + x * 1 / (1 - 4x) = (1 - 3x) / (1 - 4x)。因此 G(x)(1 - 3x) = (1 - 3x) / (1 - 4x)，所以 G(x) = 1 / (1 - 4x)。因此，a_k = 4^k，从表1得出。",
        "answer_symbols": [
            "∑",
            "∞",
            "=",
            "*",
            "+",
            "(",
            ")",
            "-",
            "^",
            "/"
        ]
    },
    "8.4 35": {
        "question": "使用生成函数求解递推关系 a_k = 5a_{k-1} - 6a_{k-2}，初始条件 a_0 = 6 和 a_1 = 30。",
        "answer": "aₖ = 18·3^(k-1) - 12·2^k",
        "answer_symbols": [
            "=",
            "·",
            "³",
            "⁻",
            "²"
        ]
    },
    "8.4 36": {
        "question": "使用生成函数求解递推关系 a_k = a_{k-1} + 2a_{k-2} + 2^k，初始条件 a_0 = 4 和 a_1 = 12。",
        "answer": "令 G(x)=∑∞ k=0 a_k * x^k。那么 xG(x)=∑∞ k=0 a_k * x^(k+1)=∑∞ k=1 a_(k-1) * x^k（通过将变量名称从 k 改为 k+1），并且 x^2G(x)=∑∞ k=0 a_k * x^(k+2)=∑∞ k=2 a_(k-2) * x^k。因此 G(x) - xG(x) - 2x^2G(x)= ∑∞ k=0 a_k * x^k - ∑∞ k=1 a_(k-1) * x^k - ∑∞ k=2 2 * a_(k-2) * x^k= a_0 + a_1 * x - a_0 * x + ∑∞ k=2 2^k * x^k = 4 + 8x + 1 / (1 - 2x)，因为给定的递推关系、初始条件、表1和代数。由于此方程的左侧因式分解为 G(x)(1 - 2x)(1 + x)，我们有 G(x) = (4 - 12x^2) / ((1 + x)(1 - 2x)^2)。此时我们必须使用部分分式来分解分母。设 (4 - 12x^2) / ((1 + x)(1 - 2x)^2) = A / (1 + x) + B / (1 - 2x) + C / (1 - 2x)^2，通过通分并等式两边系数相等，我们发现 A = -8/9, B = 38/9, 和 C = 2/3。因此 G(x) = -8/9 * 1 / (1 + x) + 38/9 * 1 / (1 - 2x) + 2/3 * 1 / (1 - 2x)^2 = ∑∞ k=0 (-8/9 * (-1)^k + 38/9 * 2^k + 2/3 * (k + 1) * 2^k) * x^k （从表1得出）。因此，a_k = (-8/9) * (-1)^k + (38/9) * 2^k + (2/3) * (k + 1) * 2^k。顺便说一句，最好检查我们的答案，要么使用计算机代数包，要么通过从递推关系和公式计算序列的下一个项（在这里 a_2 = 24 两种方式）。",
        "answer_symbols": [
            "∑",
            "∞",
            "=",
            "*",
            "+",
            "(",
            ")",
            "-",
            "^",
            "/",
            "√"
        ]
    },
    "8.4 37": {
        "question": "使用生成函数求解递推关系 a_k = 4a_{k-1} - 4a_{k-2} + k^2，初始条件 a_0 = 2 和 a_1 = 5。",
        "answer": "aₖ = k^² + 8k + 20 + (6k - 18)2^k",
        "answer_symbols": [
            "=",
            "²",
            "+",
            "·",
            "⁻",
            "²"
        ]
    },
    "8.4 38": {
        "question": "使用生成函数求解递推关系 a_k = 2a_{k-1} + 3a_{k-2} + 4^k + 6，初始条件 a_0 = 20 和 a_1 = 60。",
        "answer": "令 G(x)=∑∞ k=0 a_k * x^k。那么 xG(x)=∑∞ k=0 a_k * x^(k+1)=∑∞ k=1 a_(k-1) * x^k（通过将变量名称从 k 改为 k+1）。From k to k + 1, and similarly x^²G(x) = ∑(k=0 to ∞) a_k x^(k+2) = ∑(k=2 to ∞) a_(k-2) x^k. Thus, G(x) - 2xG(x) - 3x^²G(x) = ∑(k=0 to ∞) a_k x^k - ∑(k=1 to ∞) 2a_(k-1) x^k - ∑(k=2 to ∞) 3a_(k-2) x^k = a_0 + a_1 x - 2a_0 x + ∑(k=2 to ∞) (4k + 6) x^k = 20 + 20x + 1 / (1 - 4x) + 6 / (1 - x) - 7 - 10x = 13 + 10x + 1 / (1 - 4x) + 6 / (1 - x) = 20 - 80x + 2x^² + 40x^³ / ((1 - 4x)(1 - x)), because of the given recurrence relation, the initial conditions, and Table 1. Since the left-hand side of this equation factors as G(x)(1 - 3x)(1 + x), we know that G(x) = (20 - 80x + 2x^² + 40x^³) / ((1 - 4x)(1 - x)(1 + x)(1 - 3x)). At this point, we must use partial fractions to break up the denominator. Setting this last expression equal to A / (1 - 4x) + B / (1 - x) + C / (1 + x) + D / (1 - 3x), multiplying through by the common denominator, and equating coefficients, we find that A = 16/5, B = -3/2, C = 31/20, and D = 67/4. Thus, G(x) = 16/5 / (1 - 4x) + (-3/2) / (1 - x) + 31/20 / (1 + x) + 67/4 / (1 - 3x) = ∑(k=0 to ∞) (16/5 * 4^k - 3/2 + 31/20 * (-1)^k + 67/4 * 3^k) x^k (from Table 1). Therefore, a_k = (16/5) * 4^k - (3/2) + (31/20) * (-1)^k + (67/4) * 3^k. We check our answer by computing the next term of the sequence from both the recurrence and the formula (here a_2 = 202 both ways). Alternatively, we ask Maple for the solution: rsolve({a(k) = 2 * a(k - 1) + 3 * a(k - 2) + 4^k + 6, a(0) = 20, a(1) = 60}, a(k));",
        "answer_symbols": []
    },
    "8.4 39": {
        "question": "使用生成函数找出关于斐波那契数的显式公式。",
        "answer": "令 G(x) = Σ∞ k=0 fₖx^k。在调整求和索引并添加级数之后，我们看到 G(x) - x G(x) - x^² G(x) = f₀ + (f₁ - f₀)x + Σ∞ k=2 (fₖ - fₖ₋₁ - fₖ₋₂)x^k = 0 + x + Σ∞ k=2 0x^k。因此，G(x) - x G(x) - x^² G(x) = x。解 G(x) 得到 G(x) = x/(1 - x - x^²)。通过部分分数法可以证明 x/(1 - x - x^²) = (1/√5)[1/(1 - αx) - 1/(1 - βx)]，其中 α = (1 + √5)/2 和 β = (1 - √5)/2。使用 1/(1 - αx) = Σ∞ k=0 α^k x^k，得出 G(x) = (1/√5)·Σ∞ k=0 (α^k - β^k)x^k。因此，fₖ = (1/√5)·(α^k - β^k)。",
        "answer_symbols": [
            "=",
            "Σ",
            "∞",
            "·",
            "²",
            "⁻",
            "(",
            ")",
            "√",
            "+",
            "-",
            "/"
        ]
    },
    "8.4 40 a)": {
        "question": "证明：如果 n 是正整数，那么 (n choose -1/2) = (2n choose n) / (-4)^n",
        "answer": "By definition, (-1/2 choose n) = (-1/2)(-3/2)(-5/2) ... (-(2n - 1)/2) / n! = (-1)^n * 1 * 3 * 5 * ... * (2n - 1) / 2^n * n! = (-1)^n * 1 * 3 * 5 * ... * (2n - 1) / 2^n * n! * 2 * 4 * 6 * ... * (2n) / 2^n * n! = (-1)^n * (2n)! / n! * n! * 4^n = (-1)^n * (2n choose n) / 4^n = (2n choose n) / (-4)^n",
        "answer_symbols": [
            "choose",
            "*",
            "/",
            "!",
            "(",
            ")",
            "+",
            "-",
            "^",
            "n",
            "2n",
            "2",
            "4",
            "6",
            "2n - 1",
            "(-1)^n",
            "(2n)!"
        ]
    },
    "8.4 40 b)": {
        "question": "使用广义二项式定理和 a) 证明对于一切非负整数 n，在 (1 - 4x)^(-1/2) 的展开式中 x^n 的系数是 (2n choose n)。",
        "answer": "By the extended binomial theorem (Theorem 2), with -4x in place of x and u = -1/2, we have (1 - 4x)^(-1/2) = ∑(n=0 to ∞) (-1/2 choose n) * (-4x)^n = ∑(n=0 to ∞) (2n choose n) * (-4)^n * (-4x)^n = ∑(n=0 to ∞) (2n choose n) * x^n.",
        "answer_symbols": [
            "∑",
            "*",
            "^",
            "+",
            "-",
            "(",
            ")",
            "choose",
            "n",
            "x",
            "2n",
            "4",
            "∞",
            "1 - 4x",
            "-1/2",
            "(-1/2 choose n)",
            "(-4x)^n",
            "(2n choose n)",
            "(-4)^n"
        ]
    },
    "8.4 41 a)": {
        "question": "设 {C_n} 是卡特兰数的序列，即具有初值 C_0 = C_1 = 1 的递推关系 C_n = ∑_{k=0}^{n-1} C_k C_{n-1-k} 的解 (见 8.1 节例 5)。 证明：如果 G(x) 是关于卡特兰数的序列的生成函数，那么 xG(x)^2 - G(x) + 1 = 0。（使用初始条件）推断 G(x) = (1 - √(1 - 4x))/(2x)。",
        "answer": "令 G(x) = Σ∞ n=0 Cₙx^n 为 {Cₙ} 的生成函数。那么 G(x)^² = Σ∞ n=0 (Σn k=0 Cₖ Cₙ-k) x^n = Σ∞ n=1 (Σn-1 k=0 Cₖ Cₙ-1-k)x^n-1 = Σ∞ n=1 Cₙx^n-1。因此，x G(x)^² = Σ∞ n=1 Cₙx^n，这意味着 x G(x)^² - G(x) + 1 = 0。应用二次公式显示 G(x) = (1 ± √(1 - 4x)) / 2x。我们在公式中选择减号，因为选择加号会导致除以零。",
        "answer_symbols": [
            "=",
            "Σ",
            "∞",
            "·",
            "²",
            "⁻",
            "(",
            ")",
            "√",
            "+",
            "-",
            "/"
        ]
    },
    "8.4 41 b)": {
        "question": "使用练习 40 推断 G(x) = ∑_{n=0}^{∞} 1/(n+1) (2n choose n) x^n 从而 C_n = 1/(n+1) (2n choose n)",
        "answer": "根据练习40，(1 - 4x)^(-1/2) = Σ∞ n=0 (2n n)x^n。逐项积分（根据微积分定理这是有效的）显示 ∫ x 0 (1 - 4t)^(-1/2) dt = Σ∞ n=0 1x Σ∞ n=0 1 0 (1 - 4t)^(-1/2) dt = 1 - √(1 - 4x) = x G(x)，等效系数显示 Cₙ = 1",
        "answer_symbols": [
            "=",
            "Σ",
            "∞",
            "·",
            "²",
            "⁻",
            "(",
            ")",
            "√",
            "+",
            "-",
            "/"
        ]
    },
    "8.4 42": {
        "question": "当 n 和 r 是正整数 (r < n) 时，使用生成函数证明帕斯卡恒等式：C(n, r) = C(n-1, r) + C(n-1, r-1)。[提示：使用恒等式 (1 + x)^n = (1 + x)^(n-1) + x(1 + x)^(n-1)。]",
        "answer": "First, we note, as the hint suggests, that (1 + x)^n = (1 + x) * (1 + x)^(n-1) = (1 + x)^(n-1) + x * (1 + x)^(n-1). Expanding both sides of this equality using the binomial theorem, we have ∑(r=0 to n) C(n, r) * x^r = ∑(r=0 to n-1) C(n-1, r) * x^r + ∑(r=0 to n-1) C(n-1, r) * x^(r+1) = ∑(r=0 to n-1) C(n-1, r) * x^r + ∑(r=1 to n) C(n-1, r-1) * x^r.",
        "answer_symbols": [
            "^",
            "(",
            "∑",
            "r+1",
            "=",
            "x",
            "C",
            "+",
            "*",
            ")",
            "r",
            "n",
            "n-1",
            "-"
        ]
    },
    "8.4 43": {
        "question": "使用生成函数证明范德蒙恒等式：C(m+n, r) = ∑_{k=0}^{r} C(m, r-k) C(n, k)，其中 m、n 和 r 是非负整数，且 r 不超过 m 或 n。[提示：查看在 (1 + x)^(m+n) = (1 + x)^m (1 + x)^n 两边的 x^r 的系数。]",
        "answer": "应用二项式定理到等式 (1 + x)^(m+n) = (1 + x)^m (1 + x)^n，显示 Σm+n r=0 C(m+n, r)x^r = Σm r=0 C(m, r)x^r · Σr=0 C(n, r) x^r = Σm+n r=0 [Σr k=0 C(m, r - k) C(n, k)] x^r。比较系数得到所需的恒等式。",
        "answer_symbols": [
            "=",
            "Σ",
            "∞",
            "·",
            "²",
            "⁻",
            "(",
            ")",
            "+",
            "-",
            "/"
        ]
    },
    "8.4 44 a)": {
        "question": "证明 (x^2 + x)/(1 - x)^4 是关于序列 {a_n} 的生成函数，其中 a_n = 1^2 + 2^2 + ⋯ + n^2。",
        "answer": "我们使用生成函数的方法来解递推关系和初始条件：a_n = a_(n−1) + n^2，a_0 = 0（例如，参见练习34）：G(x) − xG(x) = ∑_{n=0}^{∞} a_n * x^n − ∑_{n=1}^{∞} a_(n−1) * x^n = ∑_{n=0}^{∞} n^2 * x^n。根据练习37，序列 {n^2} 的生成函数是 2/(1 − x)^3 − 3/(1 − x)^2 + 1/(1 − x) = (x^2 + x)/(1 − x)^3，所以 (1 − x)G(x) = (x^2 + x)/(1 − x)^3。两边同时除以 1 − x 得到所需的 G(x) 表达式。",
        "answer_symbols": [
            "-",
            "+",
            "=",
            "∑",
            "∞",
            "^",
            "/",
            "(",
            ")",
            "*"
        ]
    },
    "8.4 44 b)": {
        "question": "使用 a) 找出关于 1^2 + 2^2 + ⋯ + n^2 的显式公式。",
        "answer": "我们将找到的 G(x) = ∑_{n=0}^{∞} a_n * x^n 分成两部分并使用表1：x^2 / (1 − x)^4 + x / (1 − x)^4 = ∑_{n=0}^{∞} C(n + 3, 3) * x^(n+2) + ∑_{n=0}^{∞} C(n + 3, 3) * x^(n+1) = ∑_{n=0}^{∞} C(n + 1, 3) * x^n + ∑_{n=0}^{∞} C(n + 2, 3) * x^n = ∑_{n=0}^{∞} [n(n + 1)(n − 1) + (n + 2)(n + 1)n] / 6 * x^n = ∑_{n=0}^{∞} n(n + 1)(2n + 1) / 6 * x^n，如所期望的。（注意，在第3行中我们不需要改变求和的范围，因为 C(1, 3) = C(2, 3) = 0。）",
        "answer_symbols": [
            "+",
            "-",
            "=",
            "∑",
            "∞",
            "^",
            "/",
            "(",
            ")",
            "*",
            "C"
        ]
    },
    "8.4 45 a)": {
        "question": "求一个关于序列 {a_n} 的指数生成函数的封闭形式，其中 a_n = 2",
        "answer": "2e^x",
        "answer_symbols": [
            "=",
            "e",
            "^"
        ]
    },
    "8.4 45 b)": {
        "question": "求一个关于序列 {a_n} 的指数生成函数的封闭形式，其中 a_n = (-1)^n",
        "answer": "e^(-x)",
        "answer_symbols": [
            "=",
            "e",
            "^",
            "-"
        ]
    },
    "8.4 45 c)": {
        "question": "求一个关于序列 {a_n} 的指数生成函数的封闭形式，其中 a_n = 3^n",
        "answer": "e^(3x)",
        "answer_symbols": [
            "=",
            "e",
            "^",
            "³"
        ]
    },
    "8.4 45 d)": {
        "question": "求一个关于序列 {a_n} 的指数生成函数的封闭形式，其中 a_n = n + 1",
        "answer": "x e^x + e^x",
        "answer_symbols": [
            "=",
            "e",
            "^",
            "+"
        ]
    },
    "8.4 46 a)": {
        "question": "求一个关于序列 {aₙ} 的指数生成函数的闭合形式，其中 aₙ = (-2)^ⁿ",
        "answer": "∑_{n=0}^{∞} (−2)^n / n! * x^n = 2 ∑_{n=0}^{∞} 1/n! * (−2x)^n = e^(−2x)",
        "answer_symbols": [
            "∑",
            "∞",
            "^",
            "/",
            "!",
            "*",
            "=",
            "e"
        ]
    },
    "8.4 46 b)": {
        "question": "求一个关于序列 {aₙ} 的指数生成函数的闭合形式，其中 aₙ = -1",
        "answer": "∑_{n=0}^{∞} (−1) / n! * x^n = − ∑_{n=0}^{∞} 1/n! * x^n = −e^x",
        "answer_symbols": [
            "∑",
            "∞",
            "^",
            "/",
            "!",
            "*",
            "=",
            "e"
        ]
    },
    "8.4 46 c)": {
        "question": "求一个关于序列 {aₙ} 的指数生成函数的闭合形式，其中 aₙ = n",
        "answer": "∑_{n=0}^{∞} n / n! * x^n = ∑_{n=1}^{∞} x^n / (n − 1)! = x ∑_{n=0}^{∞} x^n / n! = x * e^x，通过变量替换（也可以使用微积分）。",
        "answer_symbols": [
            "∑",
            "∞",
            "^",
            "/",
            "!",
            "*",
            "=",
            "e",
            "−"
        ]
    },
    "8.4 46 d)": {
        "question": "求一个关于序列 {aₙ} 的指数生成函数的闭合形式，其中 aₙ = n(n - 1)",
        "answer": "这个生成函数可以通过微积分或不使用微积分来获得。不使用微积分时，写成 ∑_{n=0}^{∞} n(n − 1) * x^n / n! = ∑_{n=2}^{∞} x^n / (n − 2)! = x^2 ∑_{n=0}^{∞} x^n / n! = x^2 * e^x，通过变量替换。使用微积分时，从 e^x = ∑_{n=0}^{∞} x^n / n! 开始，对两边求两次导数得到 e^x = ∑_{n=0}^{∞} n(n − 1) / n! * x^(n−2) = 1/x^2 ∑_{n=0}^{∞} n(n − 1) * x^n / n!。因此 ∑_{n=0}^{∞} n(n − 1) * x^n / n! = x^2 * e^x。",
        "answer_symbols": [
            "∑",
            "∞",
            "^",
            "/",
            "!",
            "*",
            "=",
            "e",
            "−",
            "(",
            ")"
        ]
    },
    "8.4 47 c)": {
        "question": "求以下函数为指数生成函数的序列。f(x) = e^²ˣ - 3e^²ˣ",
        "answer": "aₙ= 3^ⁿ − 3 · 2^ⁿ",
        "answer_symbols": [
            "-",
            "·",
            "³",
            "²"
        ]
    },
    "8.4 47 d)": {
        "question": "求以下函数为指数生成函数的序列。f(x) = (1 - x) + e^⁻^²ˣ",
        "answer": "aₙ= (−2)^ⁿ for n ≥ 2, a₁= −3, a₀= 2",
        "answer_symbols": [
            "=",
            "≥",
            "−",
            "²"
        ]
    },
    "8.4 47 e)": {
        "question": "求以下函数为指数生成函数的序列。f(x) = e^⁻^²ˣ - (1/(1 - x))",
        "answer": "aₙ= (−2)^ⁿ+ n!",
        "answer_symbols": [
            "+",
            "−",
            "!"
        ]
    },
    "8.4 47 f)": {
        "question": "求以下函数为指数生成函数的序列。f(x) = e^⁻^²ˣ - (1 + x) + (1/(1 - 2x))",
        "answer": "aₙ= (−3)^ⁿ+ n! · 2^ⁿ for n ≥ 2, a₀= 1, a₁= −2",
        "answer_symbols": [
            "+",
            "−",
            "·",
            "!",
            "≥",
            "²"
        ]
    },
    "8.4 47 g)": {
        "question": "求以下函数为指数生成函数的序列。f(x) = eˣ^²",
        "answer": "aₙ= 0 if n is odd and aₙ= n!/(n/2)! if n is even",
        "answer_symbols": [
            "=",
            "/",
            "!",
            "²"
        ]
    },
    "8.4 49 a)": {
        "question": "一个编码系统用八进制数字串对信息编码。一个码字是有效的，当且仅当它包含偶数个 7。求一个关于 n 位长有效码字个数的线性非齐次递推关系。初始条件是什么？",
        "answer": "aₙ= 6aₙ₋₁+ 8^ⁿ^⁻¹ for n ≥ 1, a₀= 1",
        "answer_symbols": [
            "=",
            "+",
            "⁻",
            "⁸",
            "≥"
        ]
    },
    "8.4 49 b)": {
        "question": "使用 8.2 节的定理 6 解这个递推关系。",
        "answer": "The general solution of the associated linear homogeneous recurrence relation is a(h)ₙ= α6^ⁿ. A particular solution is a(p)ₙ= 21 · 8^ⁿ. Hence, the general solution is aₙ= α6^ⁿ+ 21 · 8^ⁿ. Using the initial condition, it follows that α= 21. Hence, aₙ= (6^ⁿ+ 8^ⁿ)/2.",
        "answer_symbols": [
            "=",
            "+",
            "·",
            "⁶",
            "⁸",
            "/"
        ]
    },
    "8.4 49 c)": {
        "question": "用生成函数解这个递推关系。",
        "answer": "Let G(x)=∑∞ k=0 aₖxᵏ. Using the recurrence relation for {aₖ}, it can be shown that G(x)−6x G(x)=(1−7x)/(1−8x). Hence, G(x)=(1−7x)/[(1−6x)(1−8x)]. Using partial fractions, it follows that G(x)=(1/2)/(1 − 6x)+(1/2)/(1 − 8x). With the help of Table 1, it follows that aₙ= (6^ⁿ+ 8^ⁿ)/2.",
        "answer_symbols": [
            "=",
            "∑",
            "∞",
            "−",
            "+",
            "/",
            "(",
            ")",
            "⁶",
            "⁸"
        ]
    },
    "8.4 50 a)": {
        "question": "一个编码系统用四进制数字串（即数字来自集合 {0, 1, 2, 3}）对信息编码。一个码字是有效的当且仅当它包含偶数个 0 和偶数个 1。设 aₙ 等于长为 n 的有效码字个数。此外令 bₙ 为具有偶数个 0 和奇数个 1 的 n 位四进制数字串个数，cₙ 为具有奇数个 0 和偶数个 1 的 n 位四进制数字串个数，dₙ 为具有奇数个 0 和奇数个 1 的 n 位四进制数字串个数。证明 dₙ = 4^ⁿ - aₙ - bₙ - cₙ。使用这个式子证明 aₙ₊₁ = 2aₙ + bₙ + cₙ，bₙ₊₁ = bₙ - cₙ + 4^ⁿ 和 cₙ₊₁ = cₙ - bₙ + 4^ⁿ。",
        "answer": "因为所有长度为 n 的 4 进制字符串都属于由 a_n, b_n, c_n 和 d_n 计数的四个类别之一，显然 d_n = 4^n - a_n - b_n - c_n。接下来让我们看看如何通过添加一个数字来从长度为 n 的字符串得到不同类型的长度为 n+1 的字符串。要获得具有偶数个 0 和偶数个 1 的长度为 n+1 的字符串，我们可以取具有相同奇偶性的长度为 n 的字符串并在末尾添加 2 或 3（因此有 2a_n 个这种类型的字符串），或者我们可以取具有偶数个 0 和奇数个 1 的长度为 n 的字符串并在末尾添加 1（因此有 b_n 个这种类型的字符串），或者我们可以取具有奇数个 0 和偶数个 1 的长度为 n 的字符串并在末尾添加 0（因此有 c_n 个这种类型的字符串）。因此我们有 a_{n+1} = 2a_n + b_n + c_n。同样地，我们发现 b_{n+1} = 2b_n + a_n + d_n，这等于 b_n - c_n + 4^n，在此解决方案开始时用到了这个恒等式。类似地，c_{n+1} = 2c_n + a_n + d_n = c_n - b_n + 4^n。",
        "answer_symbols": [
            "=",
            "-",
            "+",
            "^",
            "_"
        ]
    },
    "8.4 50 b)": {
        "question": "a₁，b₁，c₁ 和 d₁ 是什么？",
        "answer": "长度为 1 的字符串是 0、1、2 和 3。所以很明显 a_1 = 2，b_1 = c_1 = 1，d_1 = 0。（注意 0 是偶数。）实际上我们还可以这样说：a_0 = 1（空字符串），b_0 = c_0 = d_0 = 0。",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "_"
        ]
    },
    "8.4 50 c)": {
        "question": "使用 a) 和 b) 求出 a₃，b₃，c₃ 和 d₃。",
        "answer": "我们应用部分 a) 中的递推公式两次：a_2 = 2 * 2 + 1 + 1 = 6；a_3 = 2 * 6 + 4 + 4 = 20；b_2 = 1 - 1 + 4 = 4；b_3 = 4 + 16 - 4 = 16；c_2 = 1 - 1 + 4 = 4；c_3 = 4 + 16 - 4 = 16；d_2 = 16 - 6 - 4 - 4 = 2；d_3 = 64 - 20 - 16 - 16 = 12。",
        "answer_symbols": [
            "=",
            "*",
            "+",
            "-",
            "_"
        ]
    },
    "8.4 50 d)": {
        "question": "使用 a) 的递推关系和 b) 的初始条件分别建立与序列 {aₙ}，{bₙ} 和 {cₙ} 的生成函数 A(x)，B(x) 和 C(x) 相关的三个方程。",
        "answer": "在按问题要求进行之前，我们注意到一个捷径。由于对称性，b_n 必须与 c_n 相同。将这一点代入我们的递推公式，我们立即发现对于 n >= 1，b_n = c_n = 4^(n-1)。因此 a_n = 2a_{n-1} + 2 * 4^(n-2)。这个递推式加上初始条件 a_1 = 2 可以很容易地通过本节或第 8.2 节的方法求解，给出 a_n = 2^(n-1) + 4^(n-1)。但让我们按指示进行。设 A(x)，B(x) 和 C(x) 是所需的生成函数。那么 xA(x) = ∑(n=0 到 ∞) a_n x^(n+1) = ∑(n=1 到 ∞) a_{n-1} x^n，对于 B 和 C 也一样，因此我们有 A(x) - xB(x) - xC(x) - 2xA(x) = ∑(n=0 到 ∞) a_n x^n - ∑(n=1 到 ∞) b_{n-1} x^n - ∑(n=1 到 ∞) c_{n-1} x^n - ∑(n=1 到 ∞) 2a_{n-1} x^n = a_0 = 1。同样地，B(x) - xB(x) + xC(x) = ∑(n=0 到 ∞) b_n x^n - ∑(n=1 到 ∞) b_{n-1} x^n + ∑(n=1 到 ∞) c_{n-1} x^n = b_0 + ∑(n=1 到 ∞) 4^(n-1) x^n = 0 + x ∑(n=0 到 ∞) 4^n x^n = x / (1 - 4x)。显然 C 满足相同的方程。因此我们的三个方程组（省略 A、B 和 C 的参数）是 (1 - 2x)A - xB - xC = 1，(1 - x)B + xC = x / (1 - 4x)，xB + (1 - x)C = x / (1 - 4x)。",
        "answer_symbols": [
            "=",
            ">",
            "+",
            "-",
            "*",
            "/",
            "∑",
            "(",
            ")",
            "^",
            "_"
        ]
    },
    "8.4 50 e)": {
        "question": "求解 d) 的方程得到关于 A(x)，B(x) 和 C(x) 的显式公式，并且利用这些公式得到关于 aₙ，bₙ，cₙ 和 dₙ 的显式公式。",
        "answer": "从部分 d) 的第三个方程中减去第二个方程表明 B = C，然后将此结果代回第二个方程立即得出 B(x) = C(x) = x / (1 - 4x)。将这些代入第一个方程得出 (1 - 2x)A - 2x * x / (1 - 4x) = 1，解得 A(x) = (1 - 4x + 2x^²) / ((1 - 2x)(1 - 4x))。Now that we know the generating functions, we can recover the coefficients. For B and C (using Table 1) we immediately get a coefficient of 4n−1 for all n ≥ 1, with b0= c0= 0. We rewrite A(x) using partial fractions as A(x)= 1/4 + 1/2 / (1 − 2x) + 1/4 / (1 − 4x), so we have an= 1/2 · 2n + 1/4 · 4n = 2n−1 + 4n−1 for n ≥ 1, with a0= 1/4 + 1/2 + 1/4 = 1.\n",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "*",
            "/",
            "(",
            ")",
            "^"
        ]
    },
    "8.4 51": {
        "question": "证明：在 1/((1 - x)(1 - x^²)(1 - x^³)⋯) 的形式幂级数展开式中 x^ⁿ 的系数 p(n) 等于 n 的分析数。",
        "answer": "1 1 1",
        "answer_symbols": []
    },
    "8.4 52": {
        "question": "证明：在 1/((1 - x)(1 - x^²)(1 - x^³)⋯) 的形式幂级数展开式中 x^ⁿ 的系数 p(n) 等于将 n 分析成奇整数（即把 n 写成正奇数之和）的方式数，其中不管这些奇数的次序并且允许重复。",
        "answer": "To form a partition of n using only odd-sized parts, we must choose some 1s, some 3s, some 5s, and so on. The generating function for choosing 1s is 1 + x + x^² + x^³ + · · · = 1 / (1 − x) (the exponent gives the number so obtained). Similarly, the generating function for choosing 3s is 1 + x^³ + x^⁶ + x^⁹ + · · · = 1 / (1 − x^³) (again the exponent gives the number so obtained). The other choices have analogous generating functions. Therefore the generating function for the entire problem, so that the coefficient of x^ⁿ will give po(n), the number of partitions of n into odd-sized parts, is the infinite product 1 / (1 − x) · 1 / (1 − x^³) · 1 / (1 − x^⁵) · · ·.",
        "answer_symbols": [
            "+",
            "=",
            "-",
            "*",
            "^",
            "·",
            "…"
        ]
    },
    "8.4 53": {
        "question": "证明：在 (1 + x)(1 + x^²)(1 + x^³)⋯ 的形式幂级数展开式中 x^ⁿ 的系数 p_d(n) 等于将 n 分析成不相等的整数（即把 n 写成正整数之和）的方式数，其中不管这些整数的次序但不允许重复。",
        "answer": "(1+ x)(1+ x)^2(1+ x)^3 ···",
        "answer_symbols": [
            "(",
            ")",
            "·",
            "^"
        ]
    },
    "8.4 54": {
        "question": "对于 1 ≤ n ≤ 8，通过对每个整数写出每一个不同类型的分析求 p_s(n) 和 p_d(n)，其中 p_s(n) 是将 n 分析成允许重复的奇整数的方式数，p_d(n) 是将 n 分析成不相等的整数的方式数。",
        "answer": "We need to carefully organize our work so as not to miss any of the partitions. We start with largest-sized parts first in all cases. For n= 1, we have 1= 1 as the only partition of either type, and so po(1)= pd(1)= 1. For n= 2, we have 2= 2 as the only partition into distinct parts, and 2= 1+ 1 as the only partition into odd parts, so po(1)= pd(1)= 1. For n= 3, we have 3= 3 and 3= 2+ 1 as the only partitions into distinct parts, and 3= 3 and 3= 1+ 1+ 1 as the only partitions into odd parts, so po(1)= pd(1)= 2. For n= 4, we have 4= 4 and 4= 3+ 1 as the only partitions into distinct parts, and 4= 3+ 1 and 4= 1+ 1+ 1+ 1 as the only partitions into odd parts, so po(1)= pd(1)= 2. For n= 5, we have 5= 5, 5= 4+ 1, and 5= 3+ 2 as the only partitions into distinct parts, and 5= 5, 5= 3+ 1+ 1, and 5= 1+ 1+ 1+ 1+ 1 as the only partitions into odd parts, so po(1)= pd(1)= 3. For n= 6, we have 6= 6, 6= 5+ 1, 6= 4+ 2, and 6= 3+ 2+ 1 as the only partitions into distinct parts, and 6= 5+ 1, 6= 3+ 3, 6= 3+ 1+ 1+ 1, and 6= 1+ 1+ 1+ 1+ 1+ 1 as the only partitions into odd parts, so po(1)= pd(1)= 4. For n= 7, we have 7= 7, 7= 6+ 1, 7= 5+ 2, 7= 4+ 3, and 7= 4+ 2+ 1 as the only partitions into distinct parts, and 7= 7, 7= 5+ 1+ 1, 7= 3+ 3+ 1, 7= 3+ 1+ 1+ 1+ 1, and 7= 1+ 1+ 1+ 1+ 1+ 1+ 1 as the only partitions into odd parts, so po(1)= pd(1)= 5. Finally, for n= 8, we have 8= 8, 8= 7+ 1, 8= 6+ 2, 8= 5+ 3, 8= 5+ 2+ 1, and 8= 4+ 3+ 1 as the only partitions into distinct parts, and 8= 7+ 1, 8= 5+ 3, 8= 5+ 1+ 1+ 1, 8= 3+ 3+ 1+ 1, 8= 3+ 1+ 1+ 1+ 1+ 1, and 8= 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1 as the only partitions into odd parts, so po(1)= pd(1)= 6. As we will prove in Exercise 55, it is no coincidence that these numbers all agree.",
        "answer_symbols": [
            "+",
            "=",
            "…"
        ]
    },
    "8.4 55": {
        "question": "证明：如果 n 是正整数，那么将 n 分析成不相等的整数的方式数等于将 n 分析成允许重复的奇整数的方式数，即 p_s(n) = p_d(n)。[提示：证明关于 p_s(n) 和 p_d(n) 的生成函数相等。]",
        "answer": "The generating functions obtained in Exercises 52 and 53 are equal because (1+ x)(1+ x2)(1+ x3)···= 1−x2 / 1−x · 1−x4 / 1−x2 · 1−x6 / 1−x3 ···= 1 / 1",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "·",
            "−",
            "/"
        ]
    },
    "8.4 56": {
        "question": "使用关于 p(n) 的生成函数证明对某个常数 C，p(n) ≤ e^(C√n)。[Hardy 和 Ramanujan 证明了 p(n) ∼ e^(C√2n)/(4√3n)，这意味着当 n 达到无限时 p(n) 与右边的比达到 1。]",
        "answer": "This is a very difficult problem. A solution can be found in The Theory of Partitions by George Andrews (Addison-Wesley, 1976), Chapter 6.",
        "answer_symbols": []
    },
    "8.4 57 a)": {
        "question": "证明如果 G_X 是随机变量 X 的概率生成函数，使得 X(s) 对于所有的 s ∈ S 是非负整数，那么 G_X(1) = 1",
        "answer": "Gₓ(1)=∑∞ k=0 p(X= k) · 1ᵏ= ∑∞ k=0 P(X= k)= 1",
        "answer_symbols": [
            "=",
            "∑",
            "∞",
            "·",
            "(",
            ")"
        ]
    },
    "8.4 57 b)": {
        "question": "证明如果 G_X 是随机变量 X 的概率生成函数，使得 X(s) 对于所有的 s ∈ S 是非负整数，那么 E(X) = G_X'(1)",
        "answer": "G′ₓ(1)=d/dx ∑∞ k=0 p(X= k)·k·xᵏ^⁻¹|x=1=∑∞ k=0 p(X= k)· k= E(X)",
        "answer_symbols": [
            "=",
            "d",
            "dx",
            "∑",
            "∞",
            "·",
            "|",
            "⁻",
            "(",
            ")"
        ]
    },
    "8.4 57 c)": {
        "question": "证明如果 G_X 是随机变量 X 的概率生成函数，使得 X(s) 对于所有的 s ∈ S 是非负整数，那么 V(X) = G_X''(1) + G_X'(1) - [G_X'(1)]^²",
        "answer": "G′ₓ′(1)= d^²/dx^² ∑∞ k=0 p(X=k) · xᵏ|x=1= ∑∞ k=0 p(X= k) · k(k − 1) · xᵏ^⁻^²|x=1=∑∞ k=0 p(X= k)·(k^²−k)= V(X)+ E(X)^²−E(X). Combining this with part(b) gives the desired results.",
        "answer_symbols": [
            "=",
            "d",
            "dx",
            "∑",
            "∞",
            "·",
            "|",
            "⁻",
            "²",
            "(",
            ")"
        ]
    },
    "8.4 58 a)": {
        "question": "做独立的伯努利实验，每次实验成功的概率为 p。设 X 是随机变量，如果第 n 次实验出现首次成功， X 的值就是 n。求关于概率生成函数 G_X 的闭公式。",
        "answer": "In order to have the first success on the nth trial, where n ≥ 1, we must have n−1 failures followed by a success. Therefore p(X= n)= q^(n−1)p, where p is the probability of success and q= 1 −p is the probability of failure. Therefore the probability generating function is G(x)= ∑ from n=1 to ∞ q^(n−1)px^n = px ∑ from n=1 to ∞ (qx)^(n−1) = px ∑ from n=0 to ∞ (qx)^n = px / (1 − qx).",
        "answer_symbols": [
            "=",
            "-",
            "+",
            "*",
            "^",
            "∑",
            "∞",
            "(",
            ")",
            "/"
        ]
    },
    "8.4 58 b)": {
        "question": "使用练习 57 和 a) 中得到的关于概率生成函数的闭公式求 X 的期望值和方差。",
        "answer": "根据练习57，E(X) 是G(x) 在x=1时的导数。这里我们有 G'(x) = p / (1 - qx)^2，因此 G'(1) = p / (1 - q)^2 = p / p^2 = 1/p。\n从同一个练习中我们知道方差是 G''(1) + G'(1) - (G'(1))^2；所以我们计算：G''(x) = 2pq / (1 - qx)^3，所以 G''(1) = 2pq / (1 - q)^3 = 2pq / p^3 = 2q / p^2，\n因此\nV(X) = G''(1) + G'(1) - (G'(1))^2 = 2q / p^2 + 1/p - 1/p^2 = q / p^2。",
        "answer_symbols": [
            "·",
            "−",
            "="
        ]
    },
    "8.4 59 a)": {
        "question": "设 m 是正整数，当做独立的伯努利实验时每次实验成功的概率为 p。设 X_m 是随机变量，如果第 n + m 次实验出现第 m 次成功，则 X 的值就是 n。使用第 6 章的补充练习 28 证明概率生成函数 G_X_m 由 G_X_m(x) = pᵐ / (1 - qx)ᵐ 给出，其中 q = 1 - p。",
        "answer": "G(x)=pᵐ/(1 − qx)ᵐ",
        "answer_symbols": [
            "=",
            "/",
            "−",
            "(",
            ")"
        ]
    },
    "8.4 59 b)": {
        "question": "使用练习 57 和 a) 中得到的关于概率生成函数的闭公式求 X_m 的期望值和方差。",
        "answer": "V(x)= mq/p^²",
        "answer_symbols": [
            "=",
            "/",
            "²"
        ]
    },
    "8.4 60": {
        "question": "证明：如果 X 和 Y 是样本空间 S 上的独立随机变量，使得 X(s) 和 Y(s) 对于所有 s ∈ S 为非负整数，那么 G_X+Y(x) = G_X(x) G_Y(x)。",
        "answer": "我们从定义开始，然后使用两个非负整数之和为k的唯一方法是一个为i，另一个为k-i，其中i在0和k之间（包括0和k）。然后我们调用独立性，最后是无限级数乘法的定义：\nGX+Y(x) = Σ(k=0到∞) P(X+Y=k) * x^k\n= Σ(k=0到∞) (Σ(i=0到k) P(X=i且Y=k-i)) * x^k\n= Σ(k=0到∞) (Σ(i=0到k) P(X=i) * P(Y=k-i)) * x^k\n= GX(x) * GY(x)",
        "answer_symbols": [
            "·",
            "−",
            "="
        ]
    },
    "8.5 16": {
        "question": "有 4 个集合，每个集合有 100 个元素，每一对集合有 50 个公共元素，每 3 个集合有 25 个公共元素，并且有 5 个元素在所有的 4 个集合中。问在这 4 个集合的并集中有多少个元素？",
        "answer": "4 · 100 − 6 · 50 + 4 · 25 − 5 = 195",
        "answer_symbols": [
            "·",
            "−",
            "="
        ]
    },
    "8.5 18": {
        "question": "在容斥原理所给出的有关 10 个集合并集元素数的公式中有多少项？",
        "answer": "There are C(10, 1) + C(10, 2) + · · · + C(10, 10) = 2^10 − C(10, 0) = 1023 terms on the right-hand side of the equation.",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "·",
            "·",
            "·",
            "=",
            "^",
            "−"
        ]
    },
    "8.5 20": {
        "question": "有 5 个集合，如果每个集合包含 10 000 个元素，每对集合包含 1000 个公共元素，每 3 个集合包含 100 个公共元素，每 4 个集合包含 10 个公共元素，且这 5 个集合有 1 个公共元素。问在这 5 个集合的并集中有多少个元素？",
        "answer": "5 · 10000 − 10 · 1000 + 10 · 100 − 5 · 10 + 1 = 40,951",
        "answer_symbols": [
            "·",
            "−",
            "+",
            "=",
            ","
        ]
    },
    "8.5 22": {
        "question": "使用数学归纳法证明容斥原理。",
        "answer": "The base case is n = 2, for which we already know the formula to be valid. Assume that the formula is true for n sets. Look at a situation with n + 1 sets, and temporarily consider A_n ∪ A_(n+1) as one set. Then by the inductive hypothesis we have: |A_1 ∪ · · · ∪ A_(n+1)| = ∑ |A_i| + |A_n ∪ A_(n+1)| − ∑ |A_i ∩ A_j| − ∑ |A_i ∩ (A_n ∪ A_(n+1))| + · · · + (−1)^n |A_1 ∩ · · · ∩ A_(n−1) ∩ (A_n ∪ A_(n+1))|. Next, we apply the distributive law to each term on the right involving A_n ∪ A_(n+1), giving us: ∑ |(A_i1 ∩ · · · ∩ A_im) ∩ (A_n ∪ A_(n+1))| = ∑ |(A_i1 ∩ · · · ∩ A_im ∩ A_n) ∪ (A_i1 ∩ · · · ∩ A_im ∩ A_(n+1))|. Now we apply the basis step to rewrite each of these terms as: ∑ |A_i1 ∩ · · · ∩ A_im ∩ A_n| + ∑ |A_i1 ∩ · · · ∩ A_im ∩ A_(n+1)| − ∑ |A_i1 ∩ · · · ∩ A_im ∩ A_n ∩ A_(n+1)|, which gives us precisely the summation we want.",
        "answer_symbols": [
            "=",
            "+",
            "−",
            "∪",
            "∩",
            "|",
            "∑",
            "·",
            "·",
            "·",
            "(",
            ")",
            "^"
        ]
    },
    "8.5 24": {
        "question": "当一个硬币掷 5 次时求头像向下恰好 3 次、第一次和最后一次头像向下或第二次和第四次头像向上的概率。",
        "answer": "Let E1, E2, and E3 be these three events, in the order given. Then p(E1) = C(5, 3)/2^5 = 10/32; p(E2) = 2^3/2^5 = 8/32; and p(E3) = 2^3/2^5 = 8/32. Furthermore, p(E1 ∩ E2) = C(3, 1)/2^5 = 3/32; p(E1 ∩ E3) = 1/32; and p(E2 ∩ E3) = 2/32. Finally, p(E1 ∩ E2 ∩ E3) = 1/32. Therefore, the probability that at least one of these events occurs is (10 + 8 + 8 − 3 − 1 − 2 + 1)/32 = 21/32.",
        "answer_symbols": [
            "=",
            "/",
            "^",
            "+",
            "−",
            "∩"
        ]
    },
    "8.5 26": {
        "question": "一个样本空间有 4 个事件，如果其中没有 3 个事件同时出现，求关于这 4 个事件的并的概率公式。",
        "answer": "We only need to list the terms that have one or two events in them. Thus we have: p(E1 ∪ E2 ∪ E3 ∪ E4) = ∑ (1 ≤ i ≤ 4) p(Ei) − ∑ (1 ≤ i < j ≤ 4) p(Ei ∩ Ej), or, explicitly, p(E1 ∪ E2 ∪ E3 ∪ E4) = p(E1) + p(E2) + p(E3) + p(E4) − p(E1 ∩ E2) − p(E1 ∩ E3) − p(E1 ∩ E4) − p(E2 ∩ E3) − p(E2 ∩ E4) − p(E3 ∩ E4).",
        "answer_symbols": [
            "=",
            "∪",
            "∩",
            "≤",
            "<",
            "+",
            "−",
            "∑"
        ]
    },
    "8.5 28": {
        "question": "一个样本空间有 n 个事件，如果其中没有 2 个事件同时出现，求关于这 n 个事件的并的概率公式。",
        "answer": "The probability of the union, in this case, is the sum of the probabilities of the events: p(E1 ∪ E2 ∪ · · · ∪ E_n) = ∑ (i = 1 to n) p(Ei) = p(E1) + p(E2) + · · · + p(E_n)",
        "answer_symbols": [
            "=",
            "∪",
            "∑",
            "+",
            "·",
            "·",
            "·"
        ]
    },
    "8.6 2": {
        "question": "1000 个人申请喜马拉雅登山旅游，450 个人有高山病，622 个人不是处在很好的状态，30 个人有过敏症。一个申请人是合格的当且仅当他没有高山病、状态良好，并且没有过敏症。如果 111 个申请人有高山病且不是在良好状态，14 人有高山病和过敏症，18 人不是在良好的状态并且有过敏症，9 个人有高山病并且不是在良好状态和有过敏症，那么有多少申请人合格？",
        "answer": "1000 - 450 - 622 - 30 + 111 + 14 + 18 - 9 = 32",
        "answer_symbols": [
            "·",
            "−",
            "+",
            "=",
            ","
        ]
    },
    "8.6 4": {
        "question": "求方程 x1 + x2 + x3 + x4 = 17 的解的个数，其中 xi (i = 1, 2, 3, 4) 是非负整数，满足条件 x1 ≤ 3、x2 ≤ 4、x3 ≤ 5 且 x4 ≤ 8。",
        "answer": "C(4 + 17 - 1, 17) - C(4 + 13 - 1, 13) - C(4 + 12 - 1, 12) - C(4 + 11 - 1, 11) - C(4 + 8 - 1, 8) + C(4 + 8 - 1, 8) + C(4 + 7 - 1, 7) + C(4 + 4 - 1, 4) + C(4 + 6 - 1, 6) + C(4 + 3 - 1, 3) + C(4 + 2 - 1, 2) - C(4 + 2 - 1, 2) = 20",
        "answer_symbols": [
            "·",
            "−",
            "+",
            "=",
            ","
        ]
    },
    "8.6 6": {
        "question": "一个整数叫做无平方因子，如果它不被一个大于 1 的正整数的平方整除。求小于 100 的无平方的正整数个数。",
        "answer": "无平方因子的数是指不能被一个素数的平方整除的数。我们这样计算：99 - (99 / 2^2) - (99 / 3^2) - (99 / 5^2) - (99 / 7^2) + (99 / (2^2 * 3^2)) = 61。",
        "answer_symbols": [
            "·",
            "−",
            "+",
            "=",
            ","
        ]
    },
    "8.6 8": {
        "question": "从 7 元素集合到 5 元素集合有多少个映上函数？",
        "answer": "57 - C(5, 1) * 47 + C(5, 2) * 37 - C(5, 3) * 27 + C(5, 4) * 17 = 16,800",
        "answer_symbols": [
            "·",
            "−",
            "+",
            "=",
            ","
        ]
    },
    "8.6 10": {
        "question": "8 个不同的球放入 3 个不同的罐子中，如果每个罐子至少有 1 个球，那么有多少种放法？",
        "answer": "这个问题是要求从一个有8个元素的集合（球）到一个有3个元素的集合（罐子）的所有满射函数的数量。因此答案是 3^8 - C(3, 1) * 2^8 + C(3, 2) * 1^8 = 5796。",
        "answer_symbols": [
            "·",
            "−",
            "+",
            "=",
            ","
        ]
    },
    "8.6 12": {
        "question": "列出 (1, 2, 3, 4) 的所有的错位排列。",
        "answer": "2143, 2341, 2413, 3142, 3412, 3421, 4123, 4312, 4321",
        "answer_symbols": [
            "·",
            "−",
            "+",
            "=",
            ","
        ]
    },
    "8.6 14": {
        "question": "如果寄存帽子的人随机发回帽子，10 个人中没有一个人得到他自己帽子的概率是多少？",
        "answer": "我们使用定理2，其中n = 10，这给我们\nD10 / 10! = 1 - 1 / 1! + 1 / 10! = 1334961 / 3628800 = 16481 / 44800 ≈ 0.3678794643，\n这几乎等于 e^-1 ≈ 0.3678794412...",
        "answer_symbols": [
            "·",
            "−",
            "+",
            "=",
            ","
        ]
    },
    "8.6 15 a)": {
        "question": "一个把信放入信袋的机器发生了故障并且随机把信放入信袋中。在一组 100 封信中发生下面事件的概率是多少？（a）没有信放对了信袋。",
        "answer": "D₁₀₀/100!",
        "answer_symbols": [
            "/",
            "!"
        ]
    },
    "8.6 15 b)": {
        "question": "一个把信放入信袋的机器发生了故障并且随机把信放入信袋中。在一组 100 封信中发生下面事件的概率是多少？（b）恰好 1 封信放对了信袋。",
        "answer": "100D₉₉/100!",
        "answer_symbols": [
            "·",
            "/",
            "!"
        ]
    },
    "8.6 15 c)": {
        "question": "一个把信放入信袋的机器发生了故障并且随机把信放入信袋中。在一组 100 封信中发生下面事件的概率是多少？（c）恰好 98 封信放对了信袋。",
        "answer": "C(100,2)/100!",
        "answer_symbols": [
            "C",
            "/",
            "!"
        ]
    },
    "8.6 15 d)": {
        "question": "一个把信放入信袋的机器发生了故障并且随机把信放入信袋中。在一组 100 封信中发生下面事件的概率是多少？（d）恰好 99 封信放对了信袋。",
        "answer": "0",
        "answer_symbols": []
    },
    "8.6 15 e)": {
        "question": "一个把信放入信袋的机器发生了故障并且随机把信放入信袋中。在一组 100 封信中发生下面事件的概率是多少？（e）所有的信都放对了信袋。",
        "answer": "1/100!",
        "answer_symbols": [
            "/",
            "!"
        ]
    },
    "8.6 16": {
        "question": "一组有 n 个学生。在同一个教室内给他们分派座位。一共上两次课，如果没有学生在这两次课时分派在同一个座位上，有多少种方式？",
        "answer": "做第一次分配的方法有n!种。我们可以将这种第一次就座视为将学生n分配给我们将标记为n的椅子。那么第二次就座必须相对于这个编号是一个错排，所以有Dn种可能的第二次就座方式。因此答案是n! * Dn。",
        "answer_symbols": [
            "·",
            "−",
            "+",
            "=",
            ","
        ]
    },
    "8.6 18": {
        "question": "设 Dn 表示 n 个物体的错位排列数，用组合论证证明序列 {Dn} 满足递推关系 Dn = (n - 1)(Dn-1 + Dn-2) n ≥ 2 [提示：对于错位排列中的第 1 个元素 k 有 n - 1 种选择。单独考虑以 k 开始的错位排列，它的第 k 位可以是 1 也可以不是 1。]",
        "answer": " 在1到n的数字的一个错排中，数字1不能放在第一位，所以设k ≠ 1是放在第一位的数字。k有n - 1种选择。现在有两种方法可以得到以k开头的错排。一种方法是将1放在第k个位置。如果我们这样做，那么剩下的数字有Dn-2种错排方式。另一方面，如果1不放在第k个位置，则可以将数字1暂时重新标记为k。在这种情况下，通过找到数字2到n在位置2到n中的错排来完成错排，所以有Dn-1种方式。结合所有这些，根据乘法规则和加法规则，我们得到所需的递推关系式。初始条件是D0 = 1 和 D1 = 0。",
        "answer_symbols": [
            "·",
            "−",
            "+",
            "=",
            ","
        ]
    },
    "8.6 20": {
        "question": "使用练习 19 求关于 Dn 的显式公式。",
        "answer": "我们对公式Dn = n * Dn-1 + (-1)^n应用迭代，得到\nDn = n * ((n - 1) * Dn-2 + (-1)^(n-1)) + (-1)^n = n * (n - 1) * Dn-2 + n * (-1)^(n-1) + (-1)^n = n * (n - 1) * ((n - 2) * Dn-3 + (-1)^(n-2)) + n * (-1)^(n-1) + (-1)^n = n * (n - 1) * (n - 2) * Dn-3 + n * (n - 1) * (-1)^(n-2) + n * (-1)^(n-1) + (-1)^n\n...\n= n * (n - 1) * ... * 2 * D1 + n * (n - 1) * ... * 3 - n * (n - 1) * ... * 4 + ... + n * (-1)^(n-1) + (-1)^n\n= n * (n - 1) * ... * 3 - n * (n - 1) * ... * 4 + ... + n * (-1)^(n-1) + (-1)^n，\n提取出n!后，就得到了定理2中的公式。",
        "answer_symbols": [
            "·",
            "−",
            "+",
            "=",
            ","
        ]
    },
    "8.6 22": {
        "question": "假设 p 和 q 是不同的素数。使用容斥原理求 φ(pq)，即不超过 pq 且与 pq 互素的整数的个数。",
        "answer": "与pq互质的数是那些没有p和/或q作为因数的数。因此我们有\nφ(pq) = pq - pq / p - pq / q + pq / (pq) = pq - q - p + 1 = (p - 1) * (q - 1)。",
        "answer_symbols": [
            "·",
            "−",
            "+",
            "=",
            ","
        ]
    },
    "8.6 24": {
        "question": "证明：如果 n 是正整数，那么 n! = C(n, 0)Dn + C(n, 1)Dn-1 + ⋯ + C(n, n-1)D1 + C(n, n)D0 其中 Dk 是 k 个物体的错位排列数。",
        "answer": "当然，等式的左边计算了从 1 到 n 的整数集合的排列数。右边也通过两步过程计算了它：首先决定固定多少个和哪些元素（这可以通过 C(n, k) 方式完成，对于每个 k = 0, 1, ..., n），然后在每种情况下重新排列剩余的元素（这可以通过 D_n-k 方式完成）。",
        "answer_symbols": [
            "(",
            ")",
            ",",
            "=",
            "-",
            "+",
            "!",
            "C",
            "D"
        ]
    },
    "8.6 26": {
        "question": "以整数 1, 2, 3 结束的 (1, 2, 3, 4, 5, 6) 的错位排列数有多少个？",
        "answer": "这个排列以 4、5、6 的某种顺序开始（有 3! = 6 种选择方式），接着是 1、2、3 的某种顺序（有 3! = 6 种决定方式）。因此答案是 6 * 6 = 36。",
        "answer_symbols": [
            "!",
            "*",
            "="
        ]
    },
    "8 Supplementary Exercises 6": {
        "question": "一个小邮局只有 4 分、6 分和 10 分邮票。如果考虑邮票使用的次序, 求与这些邮票构成 n 分邮资的方式数有关的递推关系。这个递推关系的初始条件是什么？",
        "answer": "我们可以先放任何一张邮票，留下一个较小金额的问题需要解决。因此递推关系为 a_n = a_{n-4} + a_{n-6} + a_{n-10}。我们需要 10 个初始条件，很容易看出 a_0 = 1，a_1 = a_2 = a_3 = a_5 = a_7 = a_9 = 0，而 a_4 = a_6 = a_8 = 1。",
        "answer_symbols": [
            "=",
            "+",
            "_"
        ]
    },
    "8 Supplementary Exercises 7 a)": {
        "question": "使用补充练习 6 描述的规则, 构成 12 分邮资有多少种方式？",
        "answer": "2",
        "answer_symbols": []
    },
    "8 Supplementary Exercises 7 b)": {
        "question": "使用补充练习 6 描述的规则, 构成 14 分邮资有多少种方式？",
        "answer": "5",
        "answer_symbols": []
    },
    "8 Supplementary Exercises 7 c)": {
        "question": "使用补充练习 6 描述的规则, 构成 18 分邮资有多少种方式？",
        "answer": "8",
        "answer_symbols": []
    },
    "8 Supplementary Exercises 13": {
        "question": "假设在 8.1 节的例 1 中, 一对兔子在繁殖 2 次以后就离开这个岛。求与第 n 个月中的岛上兔子对数有关的递推关系。",
        "answer": "aₙ= aₙ₋₂+ aₙ₋₃",
        "answer_symbols": [
            "=",
            "+",
            "−"
        ]
    },
    "8 Supplementary Exercises 14 a)": {
        "question": "证明: 如果 wⱼ > w, 则 M(j, w) = M(j-1, w)。",
        "answer": "在这种情况下，物品 j 的重量本身超过了 w，因此总重量不超过 w 的前 j 项的任何子集都不能包含物品 j。因此，前 j 项中总重量不超过 w 的最大值是由前 j - 1 项的一个子集实现的，即 M(j - 1, w) 是该最大值。",
        "answer_symbols": [
            "<=",
            "<",
            ">"
        ]
    },
    "8 Supplementary Exercises 14 b)": {
        "question": "证明: 如果 wⱼ ≤ w, 则 M(j, w) = max(M(j-1, w), wⱼ + M(j-1, w-wⱼ))。",
        "answer": "前 j 项中总重量不超过 w 的最大值要么通过使用物品 j 实现，要么不使用物品 j 实现。在后一种情况下，该最大值与前 j - 1 项中总重量不超过 w 的最大值相同，即 M(j - 1, w)。在前一种情况下，前 j - 1 项的子集能贡献的最大重量是 M(j - 1, w - w_j)，因此在这种情况下 M(j, w) = w_j + M(j - 1, w - w_j)。",
        "answer_symbols": [
            "=",
            "+",
            "-"
        ]
    },
    "8 Supplementary Exercises 1 a)": {
        "question": "如果没有人收到的信多于 1 封，求与这个通信活动的第 n 步寄出信数有关的递推关系.",
        "answer": "Aₙ= 4Aₙ₋₁",
        "answer_symbols": [
            "=",
            "−"
        ]
    },
    "8 Supplementary Exercises 1 b)": {
        "question": "在 a) 中的递推关系的初始条件是什么？",
        "answer": "A₁= 40",
        "answer_symbols": [
            "="
        ]
    },
    "8 Supplementary Exercises 1 c)": {
        "question": "在通信活动的第 n 步寄出了多少封信？",
        "answer": "Aₙ= 10 · 4^n",
        "answer_symbols": [
            "=",
            "·",
            "^"
        ]
    },
    "8 Supplementary Exercises 2 a)": {
        "question": "对 n 小时后留下的同位素的量建立一个递推关系.",
        "answer": "设 a_n 是 n 小时后剩余的数量。那么 a_n = 0.99 * a_{n-1}。",
        "answer_symbols": [
            "=",
            "*",
            "-"
        ]
    },
    "8 Supplementary Exercises 2 b)": {
        "question": "对于 a) 的递推关系，初始条件是什么？",
        "answer": "通过迭代我们找到解 a_n = (0.99)^n * a_0，其中 a_0 是同位素的原始数量。",
        "answer_symbols": [
            "=",
            "^",
            "*",
            "(",
            ")"
        ]
    },
    "8 Supplementary Exercises 3 a)": {
        "question": "建立一个关于第 n 小时总钱数的递推关系.",
        "answer": "Mₙ= Mₙ₋₁+ 160,000",
        "answer_symbols": [
            "=",
            "+",
            "−"
        ]
    },
    "8 Supplementary Exercises 3 b)": {
        "question": "a) 中递推关系的初始条件是什么？",
        "answer": "M₁= 186,000",
        "answer_symbols": [
            "="
        ]
    },
    "8 Supplementary Exercises 3 c)": {
        "question": "求解第 n 小时总钱数的递推关系.",
        "answer": "Mₙ= 160,000n+ 26,000",
        "answer_symbols": [
            "=",
            "+",
            "·"
        ]
    },
    "8 Supplementary Exercises 3 d)": {
        "question": "建立一个前 n 小时总钱数的递推关系.",
        "answer": "Tₙ= Tₙ₋₁+ 160,000n+ 26,000",
        "answer_symbols": [
            "=",
            "+",
            "−",
            "·"
        ]
    },
    "8 Supplementary Exercises 4 a)": {
        "question": "建立关于 n 小时后存在细菌数目的递推关系.",
        "answer": "设 B_n 是 n 小时后的细菌数量。初始条件是 B_0 = 100 和 B_1 = 300。之后，B_n = B_{n-1} + 2 * B_{n-1} - B_{n-2} = 3 * B_{n-1} - B_{n-2}。",
        "answer_symbols": [
            "=",
            "+",
            "*",
            "-",
            "_"
        ]
    },
    "8 Supplementary Exercises 4 b)": {
        "question": "这个递推关系的解是什么？",
        "answer": "特征方程是 r^2 - 3r + 1 = 0，其根为 (3 ± √5)/2。因此一般解为 B_n = α1 * ((3 + √5)/2)^n + α2 * ((3 - √5)/2)^n。代入初始条件我们确定 α1 = 50 + 30√5 和 α2 = 50 - 30√5。因此解为 B_n = (50 + 30√5) * ((3 + √5)/2)^n + (50 - 30√5) * ((3 - √5)/2)^n。",
        "answer_symbols": [
            "=",
            "^",
            "+",
            "-",
            "*",
            "√",
            "/",
            "(",
            ")"
        ]
    },
    "8 Supplementary Exercises 4 c)": {
        "question": "什么时候这群细菌的个数将超过 100 万个?",
        "answer": "代入小值 n，我们发现 B_9 = 676,500 和 B_10 = 1,771,100。因此菌落将在 10 小时后含有超过一百万的细菌。",
        "answer_symbols": [
            "=",
            ","
        ]
    },
    "8 Supplementary Exercises 5 a)": {
        "question": "求与在 n 微秒中可以发送的不同信号数有关的递推关系。",
        "answer": "aₙ= aₙ₋₂+ aₙ₋₃",
        "answer_symbols": [
            "=",
            "+",
            "−"
        ]
    },
    "8 Supplementary Exercises 5 b)": {
        "question": "对于 a) 的递推关系, 初始条件是什么？",
        "answer": "a₁= 0, a₂= 1, a₃= 1",
        "answer_symbols": [
            "=",
            ","
        ]
    },
    "8 Supplementary Exercises 5 c)": {
        "question": "在 12 微秒内可以发送多少个不同的信息？",
        "answer": "a₁₂= 127",
        "answer_symbols": [
            "="
        ]
    },
    "8 Supplementary Exercises 7 d)": {
        "question": "使用补充练习 6 描述的规则, 构成 22 分邮资有多少种方式？",
        "answer": "16",
        "answer_symbols": []
    },
    "8 Supplementary Exercises 8": {
        "question": "求联立方程组 aₙ = aₙ₋₁ + bₙ₋₁ 和 bₙ = aₙ₋₁ - bₙ₋₁ 的解, 其中 a₀ = 1 和 b₀ = 2。",
        "answer": "如果我们将方程相加，我们得到 a_n + b_n = 2 * a_{n-1}，这意味着 b_n = 2 * a_{n-1} - a_n。如果我们现在将此代回第一个方程，我们有 a_n = a_{n-1} + (2 * a_{n-2} - a_{n-1}) = 2 * a_{n-2}。初始条件是 a_0 = 1（给定）和 a_1 = 3（由第一个递推关系和给定的初始条件得出）。我们可以使用特征方程 r^2 - 2 = 0 来求解，但更简单的方法（避免无理数）如下。显然 a_{2n} = 2^n * a_0 = 2^n，而 a_{2n+1} = 2^n * a_1 = 3 * 2^n。这是一个很好的显式公式，这就是“解”的真正含义。当然，我们也需要 b_n 的公式。从 b_n = 2 * a_{n-1} - a_n（上面获得的），我们有 b_{2n} = 3 * 2^n - 2^n = 2^(n+1)，而 b_{2n+1} = 2 * 2^n - 3 * 2^n = -2^n。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "*",
            "^",
            "_"
        ]
    },
    "8 Supplementary Exercises 9": {
        "question": "如果 a₀ = 1、a₁ = 2, 求解递推关系 aₙ = aₙ₋₁^² / aₙ₋₂。[提示: 两边取对数得到关于序列 log aₙ 的递推关系, n = 0, 1, 2, ⋯]",
        "answer": "aₙ= 2n",
        "answer_symbols": [
            "=",
            "·"
        ]
    },
    "8 Supplementary Exercises 10": {
        "question": "如果 a₀ = 2 和 a₁ = 2, 求解递推关系 aₙ = aₙ₋₁^³ / aₙ₋₂^²。(见补充练习 9 的提示。)",
        "answer": "按照提示，我们设 b_n = log a_n。那么递推关系变为 b_n = 3 * b_{n-1} + 2 * b_{n-2}，初始条件为 b_0 = b_1 = 1。这是通常方法解决的。特征方程是 r^2 - 3r - 2 = 0，给出根 (3 ± √17)/2。将初始条件代入一般解并进行一些复杂的代数运算，得到 b_n = (17 - √17)/34 * ((3 + √17)/2)^n + (17 + √17)/34 * ((3 - √17)/2)^n。原来的解是 a_n = 2^{b_n}。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "*",
            "^",
            "log",
            "√",
            "(",
            ")"
        ]
    },
    "8 Supplementary Exercises 11": {
        "question": "如果 a₀ = 2、a₁ = 4 和 a₂ = 8, 求解递推关系 aₙ = 3 aₙ₋₁ - 3 aₙ₋₂ + aₙ₋₃ + 1。",
        "answer": "aₙ= 2+ 4n/3+ n^²/2+ n^³/6",
        "answer_symbols": [
            "=",
            "+",
            "/",
            "²",
            "³"
        ]
    },
    "8 Supplementary Exercises 12": {
        "question": "如果 a₀ = 2、a₁ = 2 和 a₂ = 4, 求解递推关系 aₙ = 3 aₙ₋₁ - 3 aₙ₋₂ + aₙ₋₃。",
        "answer": "特征方程是 r^³ - 3r^² + 3r - 1 = 0。这可以分解为 (r - 1)^³ = 0，所以只有一个根 1，且其重数为 3。因此一般解为 a_n = α1 + α2 * n + α3 * n^²。代入初始条件得到 2 = α1，2 = α1 + α2 + α3，和 4 = α1 + 2 * α2 + 4 * α3。求解得到 α1 = 2，α2 = -1，和 α3 = 1。因此解为 a_n = 2 - n + n^²。",
        "answer_symbols": [
            "^",
            "=",
            "(",
            "²",
            "+",
            "*",
            ")",
            "³",
            "-"
        ]
    },
    "8 Supplementary Exercises 14 c)": {
        "question": "使用 a) 和 b) 设计一个动态规划算法, 该算法用于确定不超过 W 的对象子集的最大权重之和。在算法中保存计算得到的 M(j, w) 值。",
        "answer": "不失一般性，我们可以假设每个 w_j ≤ W；超重的物品不能对所需的子集做出贡献，因此可以在开始之前将其丢弃。我们需要计算所有 1 ≤ j ≤ n 和所有 0 ≤ w ≤ W 的 M(j, w)。为了初始化，我们设置 M(1, w) = w_1 对于 w_1 ≤ w ≤ W，设置 M(1, w) = 0 对于 0 ≤ w < w_1，并且设置 M(j, 0) = 0 对于 1 ≤ j ≤ n。然后我们遍历 j = 2, 3, ..., n，并且对于每个 j 遍历 w = 1, 2, ..., W，根据 (a) 和 (b) 部分给出的规则计算 M(j, w) 的值。",
        "answer_symbols": [
            "=",
            "<=",
            "<",
            ">",
            "≤",
            "≥"
        ]
    },
    "8 Supplementary Exercises 14 d)": {
        "question": "解释如何使用 c) 中计算的 M(j, w) 值找到不超过 W 的具有最大权重之和的对象的子集合。",
        "answer": "最大总重量由 M(n, W) 给出。通过算法的工作方式，该值要么是 M(n - 1, W)，要么是 w_n + M(n - 1, W - w_n)。通过计算这两个量，我们可以确定它是哪一个；在前者情况下我们知道物品 n 不在最优子集中，我们可以继续进行相同的计算，查看 M(n - 1, W)，而在后者情况下我们知道物品 n 在最优子集中，我们可以继续进行相同的计算，查看 M(n - 1, W - w_n)。",
        "answer_symbols": [
            "=",
            "+",
            "-"
        ]
    },
    "8 Supplementary Exercises 15 a)": {
        "question": "证明如果 aₘ = bₙ, 则当 p > 1 时, cₚ = aₘ = bₙ 并且 c₁, c₂, ⋯, cₚ₋₁ 是两个序列 a₁, a₂, ⋯, aₘ₋₁ 和 b₁, b₂, ⋯, bₙ₋₁ 的最长相同子序列。",
        "answer": "Under the given conditions, one longest common subsequence clearly ends at the last term in each sequence, so aₘ= bₙ= cₚ. Furthermore, a longest common subsequence of what is left of the a-sequence and the b-sequence after those last terms are deleted has to form the beginning of a longest common subsequence of the original sequences.",
        "answer_symbols": [
            "=",
            "−"
        ]
    },
    "8 Supplementary Exercises 15 b)": {
        "question": "设 aₘ ≠ bₙ。证明如果 cₚ ≠ aₘ, 则 c₁, c₂, ⋯, cₚ 是两个序列 a₁, a₂, ⋯, aₘ₋₁ 和 b₁, b₂, ⋯, bₙ 的最长相同子序列, 同时证明如果 cₚ ≠ bₙ, 则 c₁, c₂, ⋯, cₚ 是两个序列 a₁, a₂, ⋯, aₘ 和 b₁, b₂, ⋯, bₙ₋₁ 的最长相同子序列。",
        "answer": "If cₚ = aₘ, then the longest common subsequence’s appearance in the a-sequence must terminate before the end; therefore the c-sequence must be a longest common subsequence of a₁, a₂,..., aₘ−₁ and b₁, b₂,..., bₙ. The other half is similar.",
        "answer_symbols": [
            "=",
            "−"
        ]
    },
    "8 Supplementary Exercises 16": {
        "question": "设 L(i, j) 表示两个序列 a₁, a₂, ⋯, aᵢ 和 b₁, b₂, ⋯, bⱼ 的最长相同子序列, 其中 0 ≤ i ≤ m, 0 ≤ j ≤ n。使用补充练习 15 中 a) 和 b) 证明 L(i, j) 满足递推关系 L(i, j) = L(i-1, j-1) + 1, 如果 i 和 j 都不为 0 且 aᵢ = bⱼ; L(i, j) = max(L(i, j-1), L(i-1, j)), 如果 i 和 j 都不为 0 且 aᵢ ≠ bⱼ; 初始条件如果 i = 0 或者 j = 0, 则 L(i, j) = 0。",
        "answer": "初始条件 L(i, 0) = L(0, j) = 0 是显而易见的。当最后一个符号匹配时，L(i, j) = L(i - 1, j - 1) + 1 直接从练习 15a 得出。当最后一个符号不匹配时，L(i, j) = max(L(i, j - 1), L(i - 1, j)) 直接从练习 15b 得出。",
        "answer_symbols": [
            "=",
            "+",
            "max",
            "(",
            ")"
        ]
    },
    "8 Supplementary Exercises 18": {
        "question": "使用在补充练习 17 中算法的 L(i, j) 的值, 设计一个算法寻找两个序列 a₁, a₂, ⋯, aₘ 和 b₁, b₂, ⋯, bₙ 的最长相同子序列。",
        "answer": "最长公共子序列的长度由 L(m, n) 给出。如果 a_m = b_n，则我们知道最长公共子序列以该符号结束，前 L(m, n) - 1 个符号可以通过继续进行相同的计算来找到，查看 L(m - 1, n - 1)。否则我们比较 L(m, n - 1) 和 L(m - 1, n) 并继续在表中较大值的位置进行相同的计算（该值将与 L(m, n) 相同）。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "max",
            "(",
            ")"
        ]
    },
    "8 Supplementary Exercises 19": {
        "question": "求解递推关系 f(n) = f(n/2) + n^², 其中 n = 2ᵏ, k 是正整数, f(1) = 1。",
        "answer": "f(n)=(4n^²−1)/3",
        "answer_symbols": [
            "(",
            ")",
            "^",
            "-",
            "/"
        ]
    },
    "8 Supplementary Exercises 20": {
        "question": "当 n 可被 5 整除时, 求解递推关系 f(n) = 3 f(n/5) + 2 nᵏ, 其中 n = 5ᵏ, k 是正整数, f(1) = 1。",
        "answer": "我们使用第 8.3 节练习 31 的结果，其中 a = 3, b = 5, c = 2, 和 d = 4。因此解为 f(n) = 625n^⁴ / 311 - 314n log₅ 3 / 311。",
        "answer_symbols": [
            "=",
            "*",
            "+",
            "-",
            "/",
            "⁴",
            "log₅"
        ]
    },
    "8 Supplementary Exercises 21": {
        "question": "如果 f 是增函数, 给出补充练习 20 中 f 的大 O 估计。",
        "answer": "O(n^⁴)",
        "answer_symbols": [
            "O",
            "(",
            ")",
            "^"
        ]
    },
    "8 Supplementary Exercises 22": {
        "question": "找出与下述算法所使用的比较次数有关的递推关系：通过把 n 个数的序列递归地划分成两个子序列来找出最大和第二大的元素，在每一步划分时要求这两个子序列的项数相等或一个子序列比另一个子序列多一项。当子序列达到 2 项时停止划分。",
        "answer": "该算法比较两个半部分的最大元素（这是一次比较），然后它将较小的最大元素与另一个半部分的第二大元素进行比较（再进行一次比较）。这足以确定列表中的最大和第二大的元素。（如果列表中只有一个元素，则第二大元素被声明为 -∞。）设 f(n) 是此算法在大小为 n 的列表上使用的比较次数。列表被分成大小分别为 (n/2) 和 2n/23 的两个列表。因此我们的递推关系为 f(n) = f((n/2)) + f(2n/23) + 2，初始条件为 f(1) = 0。（此算法可以通过将基本情况设为 n = 2 和 n = 3 而不是 n = 1 来稍微提高效率。）",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "(",
            ")",
            "/",
            "max"
        ]
    },
    "8 Supplementary Exercises 23": {
        "question": "估计补充练习 22 描述的算法所使用的比较次数。",
        "answer": "O(n)",
        "answer_symbols": [
            "O",
            "(",
            ")"
        ]
    },
    "8 Supplementary Exercises 24 a)": {
        "question": "证明 a_m 是序列中唯一的大于此项前面的元素和此项后面的元素的元素项。",
        "answer": "a_m 大于 a_m - 1 且大于 a_m + 1 直接从给定的定义得出。请注意，可能会发生 a_m = a_1 或 a_m = a_n 的情况，在这种情况下，条件的一半自然满足。此外，由于项严格增加到 a_m 并在此之后严格减少，因此不可能有两个项满足这个条件。",
        "answer_symbols": [
            "=",
            ">",
            "+",
            "<",
            "-"
        ]
    },
    "8 Supplementary Exercises 24 b)": {
        "question": "证明如果 a_i < a_(i+1) (1 ≤ i < n)，则 i + 1 ≤ m ≤ n。",
        "answer": "如果 m 小于或等于 i，则条件 a_i < a_{i+1} 将违反一旦遇到 a_m 序列项必须减少的事实。",
        "answer_symbols": [
            "<"
        ]
    },
    "8 Supplementary Exercises 24 c)": {
        "question": "证明如果 a_i > a_(i+1) (1 ≤ i < n)，则 1 ≤ m ≤ i。",
        "answer": "如果 m 大于 i，则条件 a_i > a_{i+1} 将违反在遇到 a_m 之前序列项必须增加的事实。",
        "answer_symbols": [
            ">"
        ]
    },
    "8 Supplementary Exercises 24 d)": {
        "question": "开发一个分治算法确定单峰序列的 m 值。[提示：设 i < m < j，使用 a)、b) 和 c) 确定或者 [(i + j)/2] + 1 ≤ m ≤ n，1 ≤ m ≤ [(i + j)/2] - 1 或者 m = [(i + j)/2]。]",
        "answer": "该算法类似于二分查找。假设我们已经将搜索范围缩小到 a_i, a_{i+1},..., a_j，最初 i=1 且 j=n。如果 j - i=1，则 a_m=a_i；如果 j - i=2，则 a_m 是 a_i 和 a_j 中较大的一个。否则，我们查看该序列中的中间项 a_k，其中 k=((i+j)/2)。根据部分 (b)，如果 a_{k-1} < a_k，则我们知道 a_m 必须在 a_k, a_{k+1},..., a_j 中，因此我们可以用 k 替换 i 并迭代。根据部分 (c)，如果 a_k > a_{k+1}，则我们知道 a_m 必须在 a_i, a_{i+1},..., a_k 中，因此我们可以用 k 替换 j 并迭代。（如果愿意，我们可以在满足这两个条件时声明 a_m=a_k。）该算法也可以递归地编写。",
        "answer_symbols": [
            "-",
            "+",
            "=",
            "<",
            ">",
            "/"
        ]
    },
    "8 Supplementary Exercises 25": {
        "question": "证明补充练习 24 的算法的比较次数有最坏情况时间复杂度 O(log n)。",
        "answer": "使用仅仅两次比较，算法能够将m的搜索范围缩小到原始序列的前半部分或后半部分。由于每次序列长度都会减半，总共大约需要2 log₂ n次比较。",
        "answer_symbols": [
            "log"
        ]
    },
    "8 Supplementary Exercises 26 a)": {
        "question": "求 Δ^k a_n，其中 a_n = 3。",
        "answer": "Δa_n= 3 - 3= 0",
        "answer_symbols": [
            "-",
            "="
        ]
    },
    "8 Supplementary Exercises 26 b)": {
        "question": "求 Δ^k a_n，其中 a_n = 4n + 7。",
        "answer": "Δa_n= 4(n+1)+7 -(4n+7)= 4",
        "answer_symbols": [
            "+",
            "-",
            "="
        ]
    },
    "8 Supplementary Exercises 26 c)": {
        "question": "求 Δ^k a_n，其中 a_n = n^2 + n + 1。",
        "answer": "Δa_n=((n+1)^2+(n+1)+1)-(n^2+n+1)= 2n+2",
        "answer_symbols": [
            "+",
            "-",
            "^",
            "="
        ]
    },
    "8 Supplementary Exercises 28": {
        "question": "假设 a_n = P(n)，其中 P 是 d 次多项式。证明：对于所有的非负整数 n，Δ^(d+1) a_n = 0。",
        "answer": "我们证明一个稍强一点的结论。如果 a_n= P(n) 是最高次数为 d 的多项式，则 Δa_n 是最高次数为 d-1 的多项式。为了看到这一点，设 P(n)= c_d*n^d +（低阶项）。那么 ΔP(n)= c_d*(n+1)^d +（低阶项）- c_d*n^d +（低阶项）= c_d*n^d +（低阶项）- c_d*n^d +（低阶项）=（低阶项）。如果我们应用这个结果 d+1 次，那么我们得到 Δ^(d+1)a_n 的次数最多为 -1，即恒等于 0。",
        "answer_symbols": [
            "=",
            "-",
            "+",
            "^"
        ]
    },
    "8 Supplementary Exercises 29": {
        "question": "令 {a_n} 和 {b_n} 是实数序列。证明 Δ(a_n b_n) = a_(n+1)(Δb_n) + b_n(Δa_n)。",
        "answer": "(a^ⁿb^ⁿ)= a^ⁿ^⁺¹b^ⁿ^⁺¹− a^ⁿb^ⁿ= a^ⁿ^⁺¹(b^ⁿ^⁺¹ − b^ⁿ)+ b^ⁿ(a^ⁿ^⁺¹ − a^ⁿ)= a^ⁿ^⁺¹b^ⁿ + b^ⁿa^ⁿ",
        "answer_symbols": [
            "(",
            ")",
            "^",
            "+",
            "-",
            "="
        ]
    },
    "8 Supplementary Exercises 30": {
        "question": "证明：如果 F(x) 和 G(x) 分别是序列 {a_n} 和 {b_n} 的生成函数，且 c 和 d 是实数，那么 (cF + dG)(x) 是 {ca_n + db_n} 的生成函数。",
        "answer": "由于绝对收敛的无穷级数可以使用交换律、结合律和分配律，我们简单地写为 (cF + dG)(x)= cF(x) + dG(x)= c * (无限求和从 k=0 到 ∞) a_k*x^k + d * (无限求和从 k=0 到 ∞) b_k*x^k= (无限求和从 k=0 到 ∞) (c*a_k + d*b_k)*x^k。",
        "answer_symbols": [
            "+",
            "*",
            "∞",
            "="
        ]
    },
    "8 Supplementary Exercises 32": {
        "question": "假设在离散数学班的第一次考试中 14 个学生得 A，第二次考试中 18 个得 A。如果 22 个学生在第一或第二次考试中得 A，有多少学生两次考试都得 A?",
        "answer": "14 + 18 - 22 = 10",
        "answer_symbols": [
            "+",
            "-",
            "="
        ]
    },
    "8 Supplementary Exercises 33": {
        "question": "在蒙默郡 (英国威尔士郡原郡名) 323 个农场中至少有马、牛或羊其中的 1 种。如果 224 个农场有马、85 个有牛、57 个有羊 3 种家畜全有，那么有多少个农场恰好有这 3 种家畜中的 2 种?",
        "answer": "7",
        "answer_symbols": []
    },
    "8 Supplementary Exercises 34": {
        "question": "查询某学院关于学生记录的数据库得到下述数据：学院有 2175 个学生，其中 1675 个不是一年级学生、1074 个学生选了微积分、444 个学生选了离散数学、607 个不是一年级学生且选了微积分、350 个学生选了微积分和离散数学、201 个不是一年级学生且选了离散数学、143 个不是一年级学生并且选了微积分和离散数学。所有这些对查询都是正确的吗?",
        "answer": "如果查询是正确的，那么通过包含-排除原理，没有修过这两门课程的大一新生人数应等于 2175 - 1675 - 1074 - 444 + 607 + 350 + 201 - 143 = -3。由于这里不可能出现负数，我们得出结论：这些回答不可能都是准确的。",
        "answer_symbols": [
            "-",
            "+",
            "="
        ]
    },
    "8 Supplementary Exercises 35": {
        "question": "某大学数学学院的学生可以选择下述一个或多个方向作为主修方向：应用数学 (AM)、纯粹数学 (PM)、运筹学 (OR) 和计算机科学 (CS)。如果 (包括同时主修) 主修 AM 的有 23 个学生；主修 PM 的有 17 个学生；主修 OR 的 44 个；主修 CS 的 63 个；主修 AM 与 PM 的 5 个；主修 AM 和 CS 的 8 个；主修 AM 和 OR 的 4 个；主修 PM 和 CS 的 6 个；主修 PM 和 OR 的 5 个；主修 OR 和 CS 的 14 个；主修 PM、OR 和 CS 的 2 个；主修 AM、PM 和 OR 的 1 个；主修 PM、AM 和 CS 的 1 个；还有 1 个主修所有 4 个方向。问这个学院有多少学生?",
        "answer": "110",
        "answer_symbols": []
    },
    "8 Supplementary Exercises 36": {
        "question": "当使用容斥原理表示 7 个集合的并集中的元素个数时，如果其中没有 6 个或更多的集合含有公共元素，那么需要多少项?",
        "answer": "将涉及 i 个集合组合的项数为 C(7, i)。因此答案是 C(7, 1) + C(7, 2) + C(7, 3) + C(7, 4) + C(7, 5) = 119。",
        "answer_symbols": [
            "(",
            ")",
            ",",
            "+",
            "="
        ]
    },
    "8 Supplementary Exercises 37": {
        "question": "方程 x_1 + x_2 + x_3 = 20，2 ≤ x_1 ≤ 6，6 ≤ x_2 < 10，0 ≤ x_3 < 5，有多少个正整数解?",
        "answer": "0",
        "answer_symbols": []
    },
    "8 Supplementary Exercises 38 a)": {
        "question": "有多少小于 1 000 000 的正整数，能够被 2、3 或 5 整除?",
        "answer": "(M/2) + (M/3) + (M/5) - (M/(2 * 3)) - (M/(2 * 5)) - (M/(3 * 5)) + (M/(2 * 3 * 5)) = 733,334",
        "answer_symbols": [
            "(",
            ")",
            "/",
            "+",
            "-",
            "="
        ]
    },
    "8 Supplementary Exercises 38 b)": {
        "question": "有多少小于 1 000 000 的正整数，不能被 7、11 或 13 整除?",
        "answer": "M - (M/7) - (M/11) - (M/13) + (M/(7 * 11)) + (M/(7 * 13)) + (M/(11 * 13)) - (M/(7 * 11 * 13)) = 719,281",
        "answer_symbols": [
            "(",
            ")",
            "/",
            "+",
            "-",
            "="
        ]
    },
    "8 Supplementary Exercises 38 c)": {
        "question": "有多少小于 1 000 000 的正整数，能够被 3 整除但不能被 7 整除?",
        "answer": "这是在询问能被 3 整除但不能被 21 整除的数。由于能被 21 整除的数集是能被 3 整除的数集的子集，这仅仅是 (M/3) - (M/21) = 285,714。",
        "answer_symbols": [
            "(",
            ")",
            "/",
            "-",
            "="
        ]
    },
    "8 Supplementary Exercises 40": {
        "question": "把 6 个不同的工作分给 3 个不同的雇员，如果最难的工作分给最有经验的雇员并且最容易的工作分给最缺乏经验的雇员，那么有多少种分法?",
        "answer": "在最难和最简单的任务分配之后，还有 4 个不同的任务需要分配给 3 个不同的员工。没有提到任何限制，所以我们假设没有限制。因此我们只是在寻找从一个有 4 个元素的集合到一个有 3 个元素的集合的函数的数量，共有 3^4 = 81 个这样的函数。（如果我们施加每个员工至少获得一个任务的限制，那么会稍微复杂一些。",
        "answer_symbols": [
            "^",
            "="
        ]
    },
    "8 Supplementary Exercises 41": {
        "question": "由寄存帽子的人随机发还给 n 个人帽子，那么恰好一个人拿到自己帽子的概率是多少?",
        "answer": "D(n−1)/(n − 1)!",
        "answer_symbols": [
            "(",
            ")",
            "-",
            "!"
        ]
    },
    "8 Supplementary Exercises 42": {
        "question": "有多少个 6 位二进制串不包含 4 个连续的 1?",
        "answer": "我们将计算确实包含四个连续 1 的位串的数量。位 1 到 4 可以是 1，或者位 2 到 5 是 1，或者位 3 到 6 是 1，在每种情况下都有 4 个字符串满足这些条件（因为其他两个位是自由的）。这总共给出 12 个。然而我们重复计算了，因为存在多种情况同时发生的方式。有 2 个字符串在位 1 到 4 和位 2 到 5 是 1，2 个字符串在位 2 到 5 和位 3 到 6 是 1，以及 1 个字符串在位 1 到 4 和位 3 到 6 是 1。最后，有 1 个字符串在这三个子串都是 1。因此，包含 4 个连续 1 的位串数量为 12 - 2 - 2 - 1 + 1 = 8。因此，该练习的答案是 2^6 - 8 = 56。",
        "answer_symbols": [
            "^",
            "+",
            "-"
        ]
    },
    "8 Supplementary Exercises 43": {
        "question": "一个 6 位二进制串包含至少 4 个 1 的概率是多少?",
        "answer": "11/32",
        "answer_symbols": [
            "/"
        ]
    },
    "9.1 2 a)": {
        "question": "列出集合 {1, 2, 3, 4, 5, 6} 上的关系 R = {(a, b) | a 整除 b} 中所有的有序对。",
        "answer": "(1, 1)，(1, 2)，(1, 3)，(1, 4)，(1, 5)，(1, 6)，(2, 2)，(2, 4)，(2, 6)，(3, 3)，(3, 6)，(4, 4)，(5, 5)，(6, 6)",
        "answer_symbols": []
    },
    "9.1 2 b)": {
        "question": "仿照例 4 用图表示这个关系。",
        "answer": "每当a能整除b时，我们从a画一条线到b，使用单独的点集；这种图的另一种形式可以只用一个点集。",
        "answer_symbols": []
    },
    "9.1 2 c)": {
        "question": "仿照例 4 用表表示这个关系。",
        "answer": "如果且仅当i能整除j时，在第i行和第j列放置一个×。",
        "answer_symbols": []
    },
    "9.1 4 a)": {
        "question": "确定定义在所有人的集合上的关系 R 是否是自反的、对称的、反对称的和传递的，其中 (a, b) ∈ R 当且仅当a 比 b 高。",
        "answer": "\"比……高\"不是自反的（我不比我自己高），也不是对称的（我比我的女儿高，但她不比我高）。它是反对称的（由于从没有A比B高同时B又比A高的情况，即使A=B）。它显然是传递的。",
        "answer_symbols": []
    },
    "9.1 4 b)": {
        "question": "确定定义在所有人的集合上的关系 R 是否是自反的、对称的、反对称的和传递的，其中 (a, b) ∈ R 当且仅当a 和 b 生在同一天。",
        "answer": "这显然是自反、对称和传递的（这是一个等价关系——参见第9.5节）。它不是反对称的，因为例如双胞胎是不同的人，但出生在同一天。",
        "answer_symbols": []
    },
    "9.1 4 c)": {
        "question": "确定定义在所有人的集合上的关系 R 是否是自反的、对称的、反对称的和传递的，其中 (a, b) ∈ R 当且仅当a 和 b 同名。",
        "answer": "这与部分(b)的答案完全相同，因为有相同的第一个名字就像有相同的生日一样。",
        "answer_symbols": []
    },
    "9.1 4 d)": {
        "question": "确定定义在所有人的集合上的关系 R 是否是自反的、对称的、反对称的和传递的，其中 (a, b) ∈ R 当且仅当a 和 b 有共同的祖父母。",
        "answer": "这显然是自反和对称的。它不是反对称的，因为我和我的堂兄弟有一个共同的祖父母，而我和我的堂兄弟也有一个共同的祖父母，但我并不等于我的堂兄弟。这个关系不是传递的。我和我的堂兄弟有一个共同的祖父母；我的堂兄弟和她另一边家庭的堂兄弟有一个共同的祖父母。我的堂兄弟的堂兄弟和我没有共同的祖父母。",
        "answer_symbols": []
    },
    "9.1 6 a)": {
        "question": "确定所有实数集合上的关系 R 是否是自反的、对称的、反对称的和传递的，其中 (x, y) ∈ R 当且仅当x + y = 0。",
        "answer": "因为1 + 1 ≠ 0，所以这个关系不是自反的。因为x + y = y + x，所以如果x + y = 0，则y + x = 0，因此这个关系是对称的。因为(1, -1) 和 (-1, 1) 都在R中，所以这个关系不是反对称的。这个关系不是传递的；例如，(1, -1) ∈ R 和 (-1, 1) ∈ R，但 (1, 1) ∉ R。",
        "answer_symbols": [
            "+",
            "=",
            "≠",
            "∈",
            "∉"
        ]
    },
    "9.1 6 b)": {
        "question": "确定所有实数集合上的关系 R 是否是自反的、对称的、反对称的和传递的，其中 (x, y) ∈ R 当且仅当x = ±y。",
        "answer": "因为x = ±x（选择加号），所以这个关系是自反的。因为x = ±y 当且仅当 y = ±x，所以这个关系是对称的。因为(1, -1) 和 (-1, 1) 都在R中，所以这个关系不是反对称的。这个关系是传递的，基本上是因为1和-1的乘积是±1。",
        "answer_symbols": [
            "=",
            "±"
        ]
    },
    "9.1 6 c)": {
        "question": "确定所有实数集合上的关系 R 是否是自反的、对称的、反对称的和传递的，其中 (x, y) ∈ R 当且仅当x - y 是有理数。",
        "answer": "这个关系是自反的，因为x - x = 0 是一个有理数。这个关系是对称的，因为如果x - y是有理数，那么-(x - y) = y - x也是有理数。因为(1, -1) 和 (-1, 1) 都在R中，所以这个关系不是反对称的。为了证明这个关系是传递的，注意如果(x, y) ∈ R 和 (y, z) ∈ R，那么x - y 和 y - z 都是有理数。因此它们的和x - z 也是有理数，这意味着(x, z) ∈ R。",
        "answer_symbols": [
            "∈",
            "=",
            "+",
            "-"
        ]
    },
    "9.1 6 d)": {
        "question": "确定所有实数集合上的关系 R 是否是自反的、对称的、反对称的和传递的，其中 (x, y) ∈ R 当且仅当x = 2y。",
        "answer": "因为 1 ≠ 2 * 1，所以这个关系不是自反的。它不是对称的，因为 (2, 1) 属于 R，但 (1, 2) 不属于 R。要证明它是反对称的，假设 x = 2y 并且 y = 2x。那么 y = 4y，从而得出 y = 0 且因此 x = 0。因此 (x, y) 和 (y, x) 同时属于 R 的唯一情况是 x = y（并且两者都为 0）。这个关系显然不是传递的，因为 (4, 2) 属于 R 且 (2, 1) 属于 R，但 (4, 1) 不属于 R。",
        "answer_symbols": [
            "*",
            "=",
            "∈"
        ]
    },
    "9.1 6 e)": {
        "question": "确定所有实数集合上的关系 R 是否是自反的、对称的、反对称的和传递的，其中 (x, y) ∈ R 当且仅当xy ≥ 0。",
        "answer": "这个关系是自反的，因为平方总是非负的。它显然是对称的（x 和 y 在陈述中的角色可以互换）。它不是反对称的，因为 (2, 3) 和 (3, 2) 都在 R 中。它不是传递的；例如，(1, 0) 属于 R 且 (0, -2) 属于 R，但 (1, -2) 不属于 R。",
        "answer_symbols": [
            "∈",
            "-"
        ]
    },
    "9.1 6 f)": {
        "question": "确定所有实数集合上的关系 R 是否是自反的、对称的、反对称的和传递的，其中 (x, y) ∈ R 当且仅当xy = 0。",
        "answer": "这不是自反的，因为 (1, 1) 不属于 R。它显然是对称的（x 和 y 在陈述中的角色可以互换）。它不是反对称的，因为 (2, 0) 和 (0, 2) 都在 R 中。它不是传递的；例如，(1, 0) 属于 R 且 (0, -2) 属于 R，但 (1, -2) 不属于 R。",
        "answer_symbols": [
            "∈",
            "-"
        ]
    },
    "9.1 6 g)": {
        "question": "确定所有实数集合上的关系 R 是否是自反的、对称的、反对称的和传递的，其中 (x, y) ∈ R 当且仅当x = 1。",
        "answer": "这不是自反的，因为 (2, 2) 不属于 R。它不是对称的，因为 (1, 2) 属于 R 但 (2, 1) 不属于 R。它是反对称的，因为如果 (x, y) 属于 R 且 (y, x) 属于 R，则 x = 1 且 y = 1，所以 x = y。它是传递的，因为如果 (x, y) 属于 R 且 (y, z) 属于 R，则 x = 1（并且 y = 1，尽管这无关紧要），所以 (x, z) 属于 R。",
        "answer_symbols": [
            "∈",
            "="
        ]
    },
    "9.1 6 h)": {
        "question": "确定所有实数集合上的关系 R 是否是自反的、对称的、反对称的和传递的，其中 (x, y) ∈ R 当且仅当x = 1 或 y = 1。",
        "answer": "这不是自反的，因为 (2, 2) 不属于 R。它显然是对称的（x 和 y 在陈述中的角色可以互换）。它不是反对称的，因为 (2, 1) 和 (1, 2) 都在 R 中。它不是传递的；例如，(3, 1) 属于 R 且 (1, 7) 属于 R，但 (3, 7) 不属于 R。",
        "answer_symbols": [
            "∈"
        ]
    },
    "9.1 8": {
        "question": "证明定义在非空集合 S 上的关系 R = ∅ 是对称的和传递的，但不是自反的。",
        "answer": "如果 R = Ø，那么对称和传递定义中的条件语句的假设从未成立，因此这些语句按定义总是成立的。因为 S\" = Ø，对于 S 的一个元素，(a, a) 属于 R 的陈述是假的，所以 ∀a(a, a) 属于 R 是不成立的；因此 R 不是自反的。",
        "answer_symbols": [
            "Ø",
            "∀",
            "∈"
        ]
    },
    "9.1 9": {
        "question": "证明定义在空集 S = ∅ 上的关系 R = ∅ 是自反的、对称的和传递的。",
        "answer": "Each of the three properties is vacuously satisfied.",
        "answer_symbols": []
    },
    "9.1 10 a)": {
        "question": "给出一个集合上的关系的例子，要求它是对称的和反对称的。",
        "answer": "{a} 上的空集（空集是对称和反对称的）",
        "answer_symbols": [
            "Ø"
        ]
    },
    "9.1 10 b)": {
        "question": "给出一个集合上的关系的例子，要求它既不是对称的也不是反对称的。",
        "answer": "{(a, b), (b, a), (a, c)} 在 {a, b, c} 上",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "9.1 11": {
        "question": "练习 3 中，哪些关系是反自反的？",
        "answer": "(c), (d), (f)",
        "answer_symbols": []
    },
    "9.1 12": {
        "question": "练习 4 中，哪些关系是反自反的？",
        "answer": "只有 (a) 部分的关系是非自反的（其他部分都是自反的）。",
        "answer_symbols": []
    },
    "9.1 13": {
        "question": "练习 5 中，哪些关系是反自反的？",
        "answer": "a) Not irreflexive b) Not irreflexive c) Not irreflexive d) Not irreflexive",
        "answer_symbols": []
    },
    "9.1 15": {
        "question": "集合上的关系可能既不是自反的也不是反自反的吗？",
        "answer": "Yes, for instance {(1, 1)} on {1, 2}",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            "="
        ]
    },
    "9.1 16": {
        "question": "使用量词表示一个关系是反自反的。",
        "answer": "∀x((x, x) 不属于 R)",
        "answer_symbols": [
            "∀",
            "(",
            ")",
            "∈"
        ]
    },
    "9.1 17": {
        "question": "给出在所有人的集合上的一个反自反关系的例子。",
        "answer": "(a, b) ∈ R 当且仅当 a 比 b 高",
        "answer_symbols": [
            "b",
            "a",
            "=",
            "→",
            "当且仅当",
            ">",
            "∈"
        ]
    },
    "9.1 18": {
        "question": "练习 3 中的哪些关系是非对称的？",
        "answer": "(a)、(b) 和 (e) 部分的关系不是非对称的，因为它们包含形式为 (x, x) 的对。显然 (c) 部分的关系不是非对称的。(f) 部分的关系不是非对称的（(1, 3) 和 (3, 1) 都在关系中）。很容易看出 (d) 部分的关系是非对称的。",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "9.1 19": {
        "question": "练习 4 中的哪些关系是非对称的？",
        "answer": "(a)",
        "answer_symbols": []
    },
    "9.1 20": {
        "question": "练习 5 中的哪些关系是非对称的？",
        "answer": "根据第 18 题的前言，非对称关系是指 (a, b) 属于 R 且 (b, a) 属于 R 不能同时成立，即使 a = b。因此 R 是非对称的当且仅当 R 是反对称的且也是非自反的。",
        "answer_symbols": [
            "(",
            ")",
            "∈"
        ]
    },
    "9.1 21": {
        "question": "练习 6 中的哪些关系是非对称的？",
        "answer": "None",
        "answer_symbols": []
    },
    "9.1 22": {
        "question": "非对称的关系一定是反对称的吗？反对称的关系一定是非对称的吗？对你的答案说明理由。",
        "answer": "An asymmetric relation must be antisymmetric, since the hypothesis of the condition for antisymmetry is false if the relation is asymmetric. The relation {(a, a)} on {a} is antisymmetric but not asymmetric, however, so the answer to the second question is no. In fact, it is easy to see that R is asymmetric if and only if R is antisymmetric and irreflexive.",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            "∈",
            "≠"
        ]
    },
    "9.1 23": {
        "question": "使用量词表示一个关系是非对称的。",
        "answer": "∀a∀b[(a, b) ∈ R → (b, a) ∈/ R]",
        "answer_symbols": [
            "∀",
            "→",
            "∉",
            "∈",
            "∈/"
        ]
    },
    "9.1 24": {
        "question": "给出在所有人的集合上一个非对称关系的例子。",
        "answer": "Of course many answers are possible. The empty relation is always asymmetric (x is never related to y). A less trivial example would be (a, b) ∈ R if and only if a is taller than b. Clearly it is impossible that both a is taller than b and b is taller than a at the same time.",
        "answer_symbols": [
            "∈",
            "≠"
        ]
    },
    "9.1 25": {
        "question": "从 m 元素集合到 n 元素集合上有多少个不同的关系？",
        "answer": "2m^ⁿ",
        "answer_symbols": [
            "²",
            "ⁿ",
            "="
        ]
    },
    "9.1 26 a)": {
        "question": "设 R 是整数集合上的关系，R = {(a, b) | a < b}，求 R^⁻¹",
        "answer": "R−1 = {(b, a) | (a, b) ∈ R} = {(b, a) | a < b} = {(a, b) | a > b}",
        "answer_symbols": [
            "−",
            "{",
            "}",
            "(",
            ")",
            "|",
            "∈",
            "<",
            ">"
        ]
    },
    "9.1 26 b)": {
        "question": "设 R 是整数集合上的关系，R = {(a, b) | a < b}，求 Ṙ",
        "answer": "R = {(a, b) | (a, b) ∉ R} = {(a, b) | a ≮ b} = {(a, b) | a ≥ b}",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            "|",
            "∉",
            "≮",
            "≥"
        ]
    },
    "9.1 28 a)": {
        "question": "设 R 是美国所有州的集合上的关系，R 由有序对 (a, b) 构成，其中 a 州与 b 州相邻接，求 R^⁻¹",
        "answer": "Since this relation is symmetric, R−1 = R.",
        "answer_symbols": [
            "−",
            "="
        ]
    },
    "9.1 28 b)": {
        "question": "设 R 是美国所有州的集合上的关系，R 由有序对 (a, b) 构成，其中 a 州与 b 州相邻接，求 Ṙ",
        "answer": "This relation consists of all pairs (a, b) in which state a does not border state b.",
        "answer_symbols": [
            "(",
            ")",
            "∈"
        ]
    },
    "9.1 29": {
        "question": "设从 A 到 B 的函数 f 是一一对应的。令 R 是和 f 的图相等的关系，即 R = {(a, f(a)) | a ∈ A}。逆关系 R^⁻¹ 是什么？",
        "answer": "The graph of f^⁻¹",
        "answer_symbols": [
            "f⁻¹"
        ]
    },
    "9.1 30 a)": {
        "question": "令 R₁ = {(1, 2), (2, 3), (3, 4)}，R₂ = {(1, 1), (1, 2), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3), (3, 4)} 是从 {1, 2, 3} 到 {1, 2, 3, 4} 的关系，求 R₁ ∪ R₂",
        "answer": "{(1, 1), (1, 2), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3), (3, 4)} = R2",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            "="
        ]
    },
    "9.1 30 b)": {
        "question": "令 R₁ = {(1, 2), (2, 3), (3, 4)}，R₂ = {(1, 1), (1, 2), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3), (3, 4)} 是从 {1, 2, 3} 到 {1, 2, 3, 4} 的关系，求 R₁ ∩ R₂",
        "answer": "{(1, 2), (2, 3), (3, 4)} = R1",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            "="
        ]
    },
    "9.1 30 c)": {
        "question": "令 R₁ = {(1, 2), (2, 3), (3, 4)}，R₂ = {(1, 1), (1, 2), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3), (3, 4)} 是从 {1, 2, 3} 到 {1, 2, 3, 4} 的关系，求 R₁ - R₂",
        "answer": "Ø",
        "answer_symbols": [
            "Ø"
        ]
    },
    "9.1 30 d)": {
        "question": "令 R₁ = {(1, 2), (2, 3), (3, 4)}，R₂ = {(1, 1), (1, 2), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3), (3, 4)} 是从 {1, 2, 3} 到 {1, 2, 3, 4} 的关系，求 R₂ - R₁",
        "answer": "{(1, 1), (2, 1), (2, 2), (3, 1), (3, 2), (3, 3)}",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")"
        ]
    },
    "9.1 32": {
        "question": "设 R 是关系 {(1, 2), (1, 3), (2, 3), (2, 4), (3, 1)}，S 是关系 {(2, 1), (3, 1), (3, 2), (4, 2)}，求 S ∘ R。",
        "answer": "Since (1, 2) ∈ R and (2, 1) ∈ S, we have (1, 1) ∈ S ◦ R. We use similar reasoning to form the rest of the pairs in the composition, giving us the answer {(1, 1), (1, 2), (2, 1), (2, 2)}.",
        "answer_symbols": [
            "∈",
            "◦",
            "{",
            "}",
            "(",
            ")",
            "="
        ]
    },
    "9.1 33": {
        "question": "设关系 R 是由人的集合上的有序对 (a, b) 组成的集合，其中 a 是 b 的父母。设关系 S 是由人的集合上的有序对 (a, b) 组成的集合，其中 a 是 b 的兄弟姐妹。S ∘ R 和 R ∘ S 是什么关系？",
        "answer": "7",
        "answer_symbols": [
            "b",
            "a",
            "sibling",
            "|",
            "an",
            "{",
            "and",
            "is",
            "=",
            "R◦S",
            "parent",
            "has",
            "aunt",
            "S◦R",
            "of",
            "}",
            "or",
            "uncle"
        ]
    },
    "9.1 34 a)": {
        "question": "求 R₁ ∪ R₃",
        "answer": "The union of two relations is the union of these sets. Thus R1 ∪ R3 holds between two real numbers if R1 holds or R3 holds (or both, it goes without saying). Here this means that the first number is greater than the second or vice versa—in other words, that the two numbers are not equal. This is just relation R6.",
        "answer_symbols": [
            "∪",
            ">",
            "<",
            "≠"
        ]
    },
    "9.1 34 b)": {
        "question": "求 R₁ ∪ R₅",
        "answer": "For (a, b) to be in R3 ∪ R6, we must have a > b or a = b. Since this happens precisely when a ≥ b, we see that the answer is R2.",
        "answer_symbols": [
            "∪",
            ">",
            "=",
            "≥"
        ]
    },
    "9.1 34 c)": {
        "question": "求 R₂ ∩ R₄",
        "answer": "The intersection of two relations is the intersection of these sets. Thus R2 ∩ R4 holds between two real numbers if R2 holds and R4 holds as well. Thus for (a, b) to be in R2 ∩ R4, we must have a ≥ b and a ≤ b. Since this happens precisely when a = b, we see that the answer is R5.",
        "answer_symbols": [
            "∩",
            "≥",
            "≤",
            "="
        ]
    },
    "9.1 34 d)": {
        "question": "求 R₃ ∩ R₅",
        "answer": "For (a, b) to be in R3 ∩ R5, we must have a < b and a = b. It is impossible for a < b and a = b to hold at the same time, so the answer is Ø, i.e., the relation that never holds.",
        "answer_symbols": [
            "∩",
            "<",
            "=",
            "Ø"
        ]
    },
    "9.1 34 e)": {
        "question": "求 R₁ - R₃",
        "answer": "Recall that R1 − R2 = R1 ∩ R2. But R2 = R3, so we are asked for R1 ∩ R3. It is impossible for a > b and a < b to hold at the same time, so the answer is Ø, i.e., the relation that never holds.",
        "answer_symbols": [
            "−",
            "∩",
            ">",
            "<",
            "Ø"
        ]
    },
    "9.1 34 f)": {
        "question": "求 R₂ - R₄",
        "answer": "Reasoning as in part (f), we want R2 ∩ R1 = R2 ∩ R4, which is R5 (this was part (c)).",
        "answer_symbols": [
            "∩",
            "="
        ]
    },
    "9.1 34 g)": {
        "question": "求 R₁ ⊕ R₃",
        "answer": "Recall that R1 ⊕ R3 = (R1 ∩ R3) ∪ (R3 ∩ R1). We see that R1 ∩ R3 = R1 ∩ R2 = R1, and R3 ∩ R1 = R3 ∩ R4 = R3. Thus our answer is R1 ∪ R3 = R6 (as in part (a)).",
        "answer_symbols": [
            "⊕",
            "∩",
            "∪",
            "="
        ]
    },
    "9.1 34 h)": {
        "question": "求 R₂ ⊕ R₄",
        "answer": "Recall that R2 ⊕ R4 = (R2 ∩ R4) ∪ (R4 ∩ R2). We see that R2 ∩ R4 = R2 ∩ R1 = R1, and R4 ∩ R2 = R4 ∩ R3 = R3. Thus our answer is R1 ∪ R3 = R6 (as in part (a)).",
        "answer_symbols": [
            "⊕",
            "∩",
            "∪",
            "="
        ]
    },
    "9.1 36 a)": {
        "question": "求 R_1 ∘ R_1",
        "answer": "For (a, c) to be in R1 ◦ R1, we must find an element b such that (a, b) ∈ R1 and (b, c) ∈ R1. This means that a > b and b > c. Clearly this can be done if and only if a > c to begin with. But that is precisely the statement that (a, c) ∈ R1. Therefore we have R1 ◦ R1 = R1. We can interpret (part of) this as showing that R1 is transitive.",
        "answer_symbols": [
            "◦",
            "∈",
            ">",
            "="
        ]
    },
    "9.1 36 b)": {
        "question": "求 R_1 ∘ R_2",
        "answer": "对于(a, c)属于R1 ◦ R2，我们必须找到一个元素b，使得(a, b) 属于 R2 并且(b, c) 属于 R1。这意味着 a ≥ b 且 b > c。显然，这当且仅当 a > c 时才能完成。但这正是陈述(a, c) 属于 R1。因此我们有 R1 ◦ R2 = R1。",
        "answer_symbols": [
            "∈",
            "≥",
            ">",
            "◦"
        ]
    },
    "9.1 36 c)": {
        "question": "求 R_1 ∘ R_3",
        "answer": "对于(a, c)属于R1 ◦ R3，我们必须找到一个元素b，使得(a, b) 属于 R3 并且(b, c) 属于 R1。这意味着 a < b 且 b > c。显然，这总是可以通过选择足够大的b来完成。因此我们有 R1 ◦ R3 = R2，即关系始终成立。",
        "answer_symbols": [
            "∈",
            "<",
            ">",
            "◦"
        ]
    },
    "9.1 36 d)": {
        "question": "求 R_1 ∘ R_4",
        "answer": "对于(a, c)属于R1 ◦ R4，我们必须找到一个元素b，使得(a, b) 属于 R4 并且(b, c) 属于 R1。这意味着 a ≤ b 且 b > c。显然，这总是可以通过选择足够大的b来完成。因此我们有 R1 ◦ R4 = R2，即关系始终成立。",
        "answer_symbols": [
            "∈",
            "≤",
            ">",
            "◦"
        ]
    },
    "9.1 36 e)": {
        "question": "求 R_1 ∘ R_5",
        "answer": "对于(a, c)属于R1 ◦ R5，我们必须找到一个元素b，使得(a, b) 属于 R5 并且(b, c) 属于 R1。这意味着 a = b 且 b > c。显然，这当且仅当 a > c 时才能完成（选择 b = a）。但这正是陈述(a, c) 属于 R1。因此我们有 R1 ◦ R5 = R1。一种看待这个问题的方式是说 R5，等价关系，作为合成运算的单位元（在右侧——尽管它也是左侧的单位元）。",
        "answer_symbols": [
            "∈",
            "=",
            ">",
            "◦"
        ]
    },
    "9.1 36 f)": {
        "question": "求 R_1 ∘ R_6",
        "answer": "对于(a, c)属于R1 ◦ R6，我们必须找到一个元素b，使得(a, b) 属于 R6 并且(b, c) 属于 R1。这意味着 a ≠ b 且 b > c。显然，这总是可以通过选择足够大的b来完成。因此我们有 R1 ◦ R6 = R2，即关系始终成立。",
        "answer_symbols": [
            "∈",
            "≠",
            ">",
            "◦"
        ]
    },
    "9.1 36 g)": {
        "question": "求 R_2 ∘ R_3",
        "answer": "对于(a, c)属于R2 ◦ R3，我们必须找到一个元素b，使得(a, b) 属于 R3 并且(b, c) 属于 R2。这意味着 a < b 且 b ≥ c。显然，这总是可以通过选择足够大的b来完成。因此我们有 R2 ◦ R3 = R2，即关系始终成立。",
        "answer_symbols": [
            "∈",
            "<",
            "≥",
            "◦"
        ]
    },
    "9.1 36 h)": {
        "question": "求 R_3 ∘ R_3",
        "answer": "对于(a, c)属于R3 ◦ R3，我们必须找到一个元素b，使得(a, b) 属于 R3 并且(b, c) 属于 R3。这意味着 a < b 且 b < c。显然，这当且仅当 a < c 时才能完成。但这正是陈述(a, c) 属于 R3。因此我们有 R3 ◦ R3 = R3。我们可以将（部分）解释为显示 R3 是传递的。",
        "answer_symbols": [
            "∈",
            "<",
            "◦"
        ]
    },
    "9.1 38": {
        "question": "设 R 是所有人的集合上的双亲关系。什么情况下，一个有序对在关系 R^2 中？",
        "answer": "对于(a, b)属于R3，我们必须找到人 c 和 d，使得(a, c) 属于 R，(c, d) 属于 R，且 (d, b) 属于 R。用语言来说，这是 a 是某个人的父母，这个人又是某个人的父母，而这个人的父母是 b。更简单地说，a 是 b 的曾祖父母。",
        "answer_symbols": [
            "∈"
        ]
    },
    "9.1 39": {
        "question": "设 R 是定义在具有博士学位的人的集合上的关系，(a, b) ∈ R 当且仅当 a 是 b 的论文导师。什么情况下一个有序对 (a, b) 在 R^2 中？什么情况下一个有序对 (a, b) 在 R^n 中？这里 n 是正整数。（注意每个具有博士学位的人都有一个论文导师。）",
        "answer": "b got his or her doctorate under someone who got his or her doctorate under a; there is a sequence of n + 1 people, starting with a and ending with b, such that each is the advisor of the next person in the sequence",
        "answer_symbols": [
            "n",
            "+",
            "1"
        ]
    },
    "9.1 40 a)": {
        "question": "设 R_1 和 R_2 分别是所有正整数集合上的“整除”和“倍数”关系，即 R_1 = {(a, b) | a 整除 b} 和 R_2 = {(a, b) | a 是 b 的倍数}。求 R_1 ∪ R_2",
        "answer": "两个关系的并集是这些集合的并集。因此，如果 R1 成立或 R2 成立（或两者都成立），则 R1 ∪ R2 在两个整数之间成立。因此，(a, b) 属于 R1 ∪ R2 当且仅当 a | b 或 b | a。没有更好的简化方式来表述这一点。",
        "answer_symbols": [
            "∪",
            "|"
        ]
    },
    "9.1 40 b)": {
        "question": "设 R_1 和 R_2 分别是所有正整数集合上的“整除”和“倍数”关系，即 R_1 = {(a, b) | a 整除 b} 和 R_2 = {(a, b) | a 是 b 的倍数}。求 R_1 ∩ R_2",
        "answer": "两个关系的交集是这些集合的交集。因此，如果 R1 成立且 R2 成立，则 R1 ∩ R2 在两个整数之间成立。因此，(a, b) 属于 R1 ∩ R2 当且仅当 a | b 且 b | a。这当且仅当 a = ±b 且 a ≠ 0。",
        "answer_symbols": [
            "∩",
            "|",
            "=",
            "≠"
        ]
    },
    "9.1 40 c)": {
        "question": "设 R_1 和 R_2 分别是所有正整数集合上的“整除”和“倍数”关系，即 R_1 = {(a, b) | a 整除 b} 和 R_2 = {(a, b) | a 是 b 的倍数}。求 R_1 - R_2",
        "answer": "根据定义，R1 - R2 = R1 ∩ R2。因此，如果 R1 成立且 R2 不成立，则此关系在两个整数之间成立。我们可以用符号表示为 (a, b) 属于 R1 - R2 当且仅当 a | b 且 b 不整除 a。这等同于 a | b 且 a ≠ ±b。",
        "answer_symbols": [
            "-",
            "∩",
            "|",
            "≠"
        ]
    },
    "9.1 40 d)": {
        "question": "设 R_1 和 R_2 分别是所有正整数集合上的“整除”和“倍数”关系，即 R_1 = {(a, b) | a 整除 b} 和 R_2 = {(a, b) | a 是 b 的倍数}。求 R_2 - R_1",
        "answer": "根据定义，R2 - R1 = R2 ∩ R1。因此，如果 R2 成立且 R1 不成立，则此关系在两个整数之间成立。我们可以用符号表示为 (a, b) 属于 R2 - R1 当且仅当 b | a 且 a 不整除 b。这等同于 b | a 且 a ≠ ±b。",
        "answer_symbols": [
            "-",
            "∩",
            "|",
            "≠"
        ]
    },
    "9.1 40 e)": {
        "question": "设 R_1 和 R_2 分别是所有正整数集合上的“整除”和“倍数”关系，即 R_1 = {(a, b) | a 整除 b} 和 R_2 = {(a, b) | a 是 b 的倍数}。求 R_1 ⊕ R_2",
        "answer": "我们知道 R1 ⊕ R2 = (R1 - R2) ∪ (R2 - R1)，所以我们查看部分 c 和部分 d 的解决方案。因此，如果 R1 成立且 R2 不成立，或者反之亦然，则此关系在两个整数之间成立。这当且仅当 a | b 或 b | a，但 a ≠ ±b。",
        "answer_symbols": [
            "⊕",
            "-",
            "∪",
            "|",
            "≠"
        ]
    },
    "9.1 42": {
        "question": "列出集合 {0, 1} 上的 16 个不同的关系。",
        "answer": "这只是 {(0, 0), (0, 1), (1, 0), (1, 1)} 的 16 个不同子集。1. Ø\n2. {(0, 0)}\n3. {(0, 1)}\n4. {(1, 0)}\n5. {(1, 1)}\n6. {(0, 0), (0, 1)}\n7. {(0, 0), (1, 0)}\n8. {(0, 0), (1, 1)}\n9. {(0, 1), (1, 0)}\n10. {(0, 1), (1, 1)}\n11. {(1, 0), (1, 1)}\n12. {(0, 0), (0, 1), (1, 0)}\n13. {(0, 0), (0, 1), (1, 1)}\n14. {(0, 0), (1, 0), (1, 1)}\n15. {(0, 1), (1, 0), (1, 1)}\n16. {(0, 0), (0, 1), (1, 0), (1, 1)}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "9.1 43": {
        "question": "集合 {0, 1} 上的 16 个不同的关系中有多少个包含了有序对 (0, 1)？",
        "answer": "8",
        "answer_symbols": []
    },
    "9.1 44 a)": {
        "question": "在练习 42 列出的 {0, 1} 集合上的 16 个关系中，哪些是自反的？",
        "answer": "8, 13, 14, 16",
        "answer_symbols": []
    },
    "9.1 44 b)": {
        "question": "在练习 42 列出的 {0, 1} 集合上的 16 个关系中，哪些是反自反的？",
        "answer": "1, 3, 4, 9",
        "answer_symbols": []
    },
    "9.1 44 c)": {
        "question": "在练习 42 列出的 {0, 1} 集合上的 16 个关系中，哪些是对称的？",
        "answer": "1, 2, 5, 8, 9, 12, 15, 16",
        "answer_symbols": []
    },
    "9.1 44 d)": {
        "question": "在练习 42 列出的 {0, 1} 集合上的 16 个关系中，哪些是反对称的？",
        "answer": "1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 13, 14",
        "answer_symbols": []
    },
    "9.1 44 e)": {
        "question": "在练习 42 列出的 {0, 1} 集合上的 16 个关系中，哪些是非对称的？",
        "answer": "1, 3, 4",
        "answer_symbols": []
    },
    "9.1 44 f)": {
        "question": "在练习 42 列出的 {0, 1} 集合上的 16 个关系中，哪些是传递的？",
        "answer": "1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 13, 14, 16",
        "answer_symbols": []
    },
    "9.1 46 a)": {
        "question": "设 S 是含有 n 个元素的集合，a 和 b 是 S 中的不同元素。S 上有多少个关系 R，满足下列条件 (a, b) ∈ R？",
        "answer": "Half of these relations contain (a, b) and half do not, so the answer is 2^(n^²)/2 = 2^(n^² - 1). Looking at it another way, we see that there are n^² - 1 choices involved in specifying such a relation, since we have no choice about (a, b).",
        "answer_symbols": [
            "^",
            "/",
            "-",
            "("
        ]
    },
    "9.1 46 b)": {
        "question": "设 S 是含有 n 个元素的集合，a 和 b 是 S 中的不同元素。S 上有多少个关系 R，满足下列条件 (a, b) ∉ R？",
        "answer": "The analysis and answer are exactly the same as in part (a).",
        "answer_symbols": [
            "("
        ]
    },
    "9.1 46 c)": {
        "question": "设 S 是含有 n 个元素的集合，a 和 b 是 S 中的不同元素。S 上有多少个关系 R，满足下列条件 在关系 R 中，没有有序对以 a 作为它们的第一元素？",
        "answer": "Of the n^² possible pairs to put in R, exactly n of them have a as their first element. We must use none of these, so there are n^² - n pairs that we are free to work with. Therefore there are 2^(n^² - n) possible choices for R.",
        "answer_symbols": [
            "^",
            "-",
            "("
        ]
    },
    "9.1 46 d)": {
        "question": "设 S 是含有 n 个元素的集合，a 和 b 是 S 中的不同元素。S 上有多少个关系 R，满足下列条件 在关系 R 中，至少有一个有序对以 a 作为第一元素？",
        "answer": "By part (c) we know that there are 2^(n^² - n) relations that do not contain at least one ordered pair with a as its first element, so all the other relations, namely 2^(n^²) - 2^(n^² - n) of them, do contain at least one ordered pair with a as its first element.",
        "answer_symbols": [
            "^",
            "-",
            "("
        ]
    },
    "9.1 46 e)": {
        "question": "设 S 是含有 n 个元素的集合，a 和 b 是 S 中的不同元素。S 上有多少个关系 R，满足下列条件 在关系 R 中，没有有序对以 a 作为它们的第一元素，或也没有有序对以 b 作为它们的第二元素？",
        "answer": "We reason as in part (c). There are n ordered pairs that have a as their first element, and n more that have b as their second element, although this counts (a, b) twice, so there are a total of 2n - 1 pairs that violate the condition. This means that there are n^² - 2n + 1 = (n - 1)^² pairs that we are free to choose for R. Thus the answer is 2^((n - 1)^²). Another way to look at this is to visualize the matrix representing R. The a-th row must be all 0’s, as must the b-th column. If we cross out that row and column we have in effect an n - 1 by n - 1 matrix, with (n - 1)^² entries. Since we can fill each entry with either a 0 or a 1, there are 2^((n - 1)^²) choices for specifying S.",
        "answer_symbols": [
            "^",
            "-",
            "=",
            "(",
            ")"
        ]
    },
    "9.1 46 f)": {
        "question": "设 S 是含有 n 个元素的集合，a 和 b 是 S 中的不同元素。S 上有多少个关系 R，满足下列条件 在关系 R 中，至少有一个有序对以 a 作为它的第一元素或者以 b 作为它的第二元素？",
        "answer": "This is the opposite condition from part (e). Therefore reasoning as in part (d), we have 2^(n^²) - 2^((n - 1)^²) possible relations.",
        "answer_symbols": [
            "^",
            "-",
            "("
        ]
    },
    "9.1 48 a)": {
        "question": "n 元素集合上有多少个传递的关系？如果 n = 1",
        "answer": "There are two relations on a set with only one element, and they are both transitive.",
        "answer_symbols": []
    },
    "9.1 48 b)": {
        "question": "n 元素集合上有多少个传递的关系？如果 n = 2",
        "answer": "There are 16 relations on a set with two elements, and we saw in Exercise 42f that 13 of them are transitive.",
        "answer_symbols": []
    },
    "9.1 48 c)": {
        "question": "n 元素集合上有多少个传递的关系？如果 n = 3",
        "answer": "For n = 3 there are 2^9 = 512 relations. One way to find out how many of them are transitive is to use a computational method or a combinatorial approach.",
        "answer_symbols": [
            "=",
            "^"
        ]
    },
    "9.1 49": {
        "question": "找出在下面定理证明中的错误。“定理”：设 R 是集合 A 上的对称的和传递的关系，则 R 是自反的。“证明”：设 a ∈ A。取元素 b ∈ A 使得 (a, b) ∈ R。由于 R 是对称的，所以有 (b, a) ∈ R。现在使用传递性，由 (a, b) ∈ R 和 (b, a) ∈ R 可以得出 (a, a) ∈ R。",
        "answer": "There may be no such b.",
        "answer_symbols": []
    },
    "9.1 50 a)": {
        "question": "假设 R 和 S 是集合 A 上的自反关系。证明或反驳下面的每个论断。R ∪ S 是自反的",
        "answer": "Because relation R contains all pairs (x, x), so R ∪ S also contains these pairs. Therefore R ∪ S is reflexive.",
        "answer_symbols": [
            "∪"
        ]
    },
    "9.1 50 b)": {
        "question": "假设 R 和 S 是集合 A 上的自反关系。证明或反驳下面的每个论断。R ∩ S 是自反的",
        "answer": "Because relation R and S both contain all pairs (x, x), so R ∩ S also contains these pairs. Therefore R ∩ S is reflexive.",
        "answer_symbols": [
            "∩"
        ]
    },
    "9.1 50 c)": {
        "question": "假设 R 和 S 是集合 A 上的自反关系。证明或反驳下面的每个论断。R ⊕ S 是反自反的",
        "answer": "Because relation R and S both contain all pairs (x, x), we know that R ⊕ S does not contain these pairs. Therefore R ⊕ S is non-reflexive.",
        "answer_symbols": [
            "⊕"
        ]
    },
    "9.1 50 d)": {
        "question": "假设 R 和 S 是集合 A 上的自反关系。证明或反驳下面的每个论断。R - S 是反自反的",
        "answer": "Because relation R and S both contain all pairs (x, x), we know that R - S does not contain these pairs. Therefore R - S is non-reflexive.",
        "answer_symbols": [
            "-"
        ]
    },
    "9.1 50 e)": {
        "question": "假设 R 和 S 是集合 A 上的自反关系。证明或反驳下面的每个论断。S ∘ R 是自反的",
        "answer": "Because relation R and S both contain all pairs (x, x), so S ◦ R also contains these pairs. Therefore S ◦ R is reflexive.",
        "answer_symbols": [
            "◦"
        ]
    },
    "9.1 51": {
        "question": "证明：集合 A 上的关系 R 是对称的当且仅当 R = R^-1，其中 R^-1 是 R 的逆关系。",
        "answer": "If R is symmetric and (a, b) ∈ R, then (b, a) ∈ R, so (a, b) ∈ R^⁻¹. Hence, R ⊆ R^⁻¹. Similarly, R^⁻¹ ⊆ R. So R = R^⁻¹. Conversely, if R = R^⁻¹ and (a, b) ∈ R, then (a, b) ∈ R^⁻¹, so (b, a) ∈ R. Thus R is symmetric.",
        "answer_symbols": [
            "∈",
            "R⁻¹",
            "⊆",
            "=",
            "→"
        ]
    },
    "9.1 52": {
        "question": "证明：集合 A 上的关系 R 是反对称的当且仅当 R ∩ R^-1 是恒等关系 Δ = {(a, a) | a ∈ A} 的子集。",
        "answer": "According to the definition, saying R is antisymmetric means R ∩ R^-1 only contains pairs of the form (a, a). The statement we are asked to prove is just another way of stating this definition.",
        "answer_symbols": [
            "∩",
            "^",
            "-"
        ]
    },
    "9.1 53": {
        "question": "证明：集合 A 上的关系 R 是自反的当且仅当其逆关系 R^-1 是自反的。",
        "answer": "R is reflexive if and only if (a, a) ∈ R for all a ∈ A if and only if (a, a) ∈ R^⁻¹ [because (a, a) ∈ R if and only if (a, a) ∈ R^⁻¹] if and only if R^⁻¹ is reflexive.",
        "answer_symbols": [
            "∈",
            "R⁻¹",
            "if",
            "and",
            "only",
            "if"
        ]
    },
    "9.1 54": {
        "question": "证明：集合 A 上的关系 R 是自反的当且仅当其补关系 R 是反自反的。",
        "answer": "This follows directly from the definition, because R is reflexive if and only if it contains all pairs (x, x), which is also if and only if R does not contain these pairs, i.e., R is irreflexive.",
        "answer_symbols": []
    },
    "9.1 55": {
        "question": "设 R 是自反的和传递的关系。证明对所有的正整数 n，R^n = R。",
        "answer": "Use mathematical induction. The result is trivial for n = 1. Assume R^ⁿ is reflexive and transitive. By Theorem 1, R^ⁿ^⁺¹ ⊆ R. To see that R ⊆ R^ⁿ^⁺¹ = R^ⁿ◦R, let (a, b) ∈ R. By the inductive hypothesis, R^ⁿ = R and hence, is reflexive. Thus (b, b) ∈ R^ⁿ. Therefore (a, b) ∈ R^ⁿ^⁺¹.",
        "answer_symbols": [
            "⊆",
            "Rⁿ⁺¹",
            "Rⁿ◦R",
            "∈",
            "Rⁿ",
            "→"
        ]
    },
    "9.1 57": {
        "question": "设 R 是自反关系，证明对所有的正整数 n，R^n 也是自反的。",
        "answer": "Use mathematical induction. The result is trivial for n = 1. Assume R^ⁿ is reflexive. Then (a, a) ∈ R^ⁿ for all a ∈ A and (a, a) ∈ R. Thus (a, a) ∈ R^ⁿ◦R = R^ⁿ^⁺¹ for all a ∈ A.",
        "answer_symbols": [
            "∈",
            "Rⁿ",
            "Rⁿ⁺¹",
            "→"
        ]
    },
    "9.1 58": {
        "question": "设 R 是对称关系，证明对所有的正整数 n，R^n 也是对称的。",
        "answer": "We prove this by induction. In the base step (n = 1) there is nothing to prove. Assume the induction hypothesis that R^ⁿ is symmetric, and let (a, c) ∈ R^(n+1) = R^ⁿ ◦ R. Then there exists a b ∈ A such that (a, b) ∈ R and (b, c) ∈ R^ⁿ. Since R^ⁿ and R are symmetric, (b, a) ∈ R and (c, b) ∈ R^ⁿ. Therefore by definition (c, a) ∈ R ◦ R^ⁿ. If we can show that R ◦ R^ⁿ = R^(n+1), we are done. This is divided into two steps. First, composition of relations is associative, i.e., (R ◦ S) ◦ T = R ◦ (S ◦ T), for relations with appropriate domains and codomains. (This proof is a direct application of the definition.) Second, we prove by induction that R ◦ R^ⁿ = R^(n+1). The base step is trivial. By the induction hypothesis, R ◦ R^(n+1) = R ◦ (R^ⁿ ◦ R) = (R ◦ R^ⁿ) ◦ R = R^(n+1) ◦ R = R^(n+2), as desired.",
        "answer_symbols": [
            "∈",
            "◦",
            "=",
            "^"
        ]
    },
    "9.1 59": {
        "question": "假设关系 R 是反自反的，R^n 一定是反自反的吗？对你的答案给出理由。",
        "answer": "No, for instance, take R = {(1, 2), (2, 1)}.",
        "answer_symbols": [
            "(",
            "}",
            "=",
            ")",
            "{",
            ","
        ]
    },
    "9.2 1": {
        "question": "列出关系 {(a, b, c) ∣ a, b 和 c 是整数且 0<a<b<c<5} 中的三元组。",
        "answer": "{(1, 2, 3),(1, 2, 4),(1, 3, 4),(2, 3, 4)}",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            ","
        ]
    },
    "9.2 2": {
        "question": "在关系 {(a, b, c, d) ∣ a, b, c, d 是正整数且 abcd=6} 中有哪些 4 元组?",
        "answer": "We must find all solutions to this equation, ensuring that all permutations are included. The quadruples are (6, 1, 1, 1), (1, 6, 1, 1), (1, 1, 6, 1), (1, 1, 1, 6), (3, 2, 1, 1), (3, 1, 2, 1), (3, 1, 1, 2), (2, 3, 1, 1), (2, 1, 3, 1), (2, 1, 1, 3), (1, 3, 2, 1), (1, 3, 1, 2), (1, 2, 3, 1), (1, 2, 1, 3), (1, 1, 3, 2), and (1, 1, 2, 3).",
        "answer_symbols": []
    },
    "9.2 3": {
        "question": "列出表 8 所示关系中的 5 元组。",
        "answer": "(Nadir, 122, 34, Detroit, 08:10),(Acme, 221, 22, Denver, 08:17),(Acme, 122, 33, Anchorage, 08:22),(Acme, 323, 34, Honolulu, 08:30), (Nadir, 199, 13, Detroit, 08:47),(Acme, 222, 22, Denver, 09:10),(Nadir, 322, 34, Detroit, 09:44)",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "9.2 5": {
        "question": "假设不增加新的 n 元组, 对于表 8 中的数据库找出一个由两个域构成的复合主键, 其中一个域是航空公司。",
        "answer": "航空公司和航班号，航空公司和出发时间",
        "answer_symbols": [
            "和",
            "，"
        ]
    },
    "9.2 6": {
        "question": "假设不增加新的 n 元组, 对于表 7 中的数据库找出一个由两个域构成的复合主键, 其中一个域是教授。",
        "answer": "We see that the professor field itself is not a key, because there are more than one tuples containing the same professor. We can make the tuples uniquely identifiable by adding the course number or adding the time. Thus, professor-course number or professor-time can be used. However, note that if more data is added, neither of these methods may work, because different departments can have the same course number, and a professor can teach two courses at the same time in the same classroom (for example, a graduate course and its undergraduate version).",
        "answer_symbols": []
    },
    "9.2 8 a)": {
        "question": "4 元关系中的 4 元组表示了出版图书的下述属性：书名、书号、出版日期、页数。（a）什么可能是这个关系的主键？",
        "answer": "The ISBN is unique for each book, and it is probably the one and only primary key (and certainly the best one in any case).",
        "answer_symbols": []
    },
    "9.2 8 b)": {
        "question": "4 元关系中的 4 元组表示了出版图书的下述属性：书名、书号、出版日期、页数。（b）在什么条件下（书名、出版日期）是复合主键？",
        "answer": "This would work as long as there were not two books published the same year (date is usually given only as a year) with the same title. In practice, this could easily not happen.",
        "answer_symbols": []
    },
    "9.2 8 c)": {
        "question": "4 元关系中的 4 元组表示了出版图书的下述属性：书名、书号、出版日期、页数。（c）在什么条件下（书名、页数）是复合主键？",
        "answer": "This would work as long as there were not two books with the same title and the same number of pages. In practice, this could possibly not happen, although it is perhaps less likely than in part (b).",
        "answer_symbols": []
    },
    "9.2 10": {
        "question": "设 C 是条件：教室 = A100。当使用选择运算符 s_C 到表 7 的数据库时，可以得到什么？",
        "answer": "The selection operator picks out all the tuples that match the criteria. The 5-tuples in Table 7 that have A100 as their room are: (Cruz, Zoology, 335, A100, 9:00 A.M.), (Cruz, Zoology, 412, A100, 8:00 A.M.), (Farber, Psychology, 501, A100, 3:00 P.M.)",
        "answer_symbols": []
    },
    "9.2 11": {
        "question": "设 C 是条件：目的地 = 底特律。当使用选择运算符 s_C 到表 8 的数据库时，可以得到什么？",
        "answer": "(Nadir, 122, 34, Detroit, 08: 10),(Nadir, 199, 13, Detroit, 08: 47),(Nadir, 322, 34, Detroit, 09: 44)",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "9.2 12": {
        "question": "设 C 是条件：（项目 = 2）∧（数量 ≥ 50）。当使用选择运算符 s_C 到表 10 的数据库时，可以得到什么？",
        "answer": "The selection operator picks out all the tuples that match the criteria. There is only one 4-tuple in Table 10 that has a quantity of at least 50 and project number 2, namely (9191, 2, 80, 4).",
        "answer_symbols": []
    },
    "9.2 13": {
        "question": "设 C 是条件：（航空公司 = Nadir）∨（目的地 = 丹佛）。当使用选择运算符 s_C 到表 8 的数据库时，可以得到什么？",
        "answer": "(Nadir, 122, 34, Detroit, 08: 10),(Nadir, 199, 13, Detroit, 08: 47),(Nadir, 322, 34, Detroit, 09: 44),(Acme, 221, 22, Denver, 08: 17), (Acme, 222, 22, Denver, 09: 10)",
        "answer_symbols": []
    },
    "9.2 14": {
        "question": "当使用投影 P_2,3,5 到 5 元组 (a, b, c, d, e) 时，能得到什么？",
        "answer": "We keep only the second, third, and fifth columns, obtaining (b, c, e).",
        "answer_symbols": []
    },
    "9.2 15": {
        "question": "哪个投影映射用于删除一个 6 元组的第一、第二和第四个分量？",
        "answer": "P3.5.6",
        "answer_symbols": []
    },
    "9.2 16": {
        "question": "给出使用投影 P_1,2,4 到表 8 以后得到的表。",
        "answer": "The table uses columns 1, 2, and 4 of Table 8. We start by deleting columns 3 and 5 from Table 8. Since no rows are duplicates of earlier rows, this table is the answer: Airline | Flight number | Destination Nadir | 122 | Detroit Acme | 221 | Denver Acme | 122 | Anchorage Acme | 323 | Honolulu Nadir | 199 | Detroit Acme | 222 | Denver Nadir | 322 | Detroit",
        "answer_symbols": []
    },
    "9.2 17": {
        "question": "给出使用投影 P_1,3 到表 8 以后得到的表。",
        "answer": "航空公司 目的地",
        "answer_symbols": [
            "，"
        ]
    },
    "9.2 18": {
        "question": "把连接运算符 J_3 应用到 5 元组的表和 8 元组的表后所得到的表中的 n 元组里有多少个分量？",
        "answer": "By definition, there are 5 + 8 - 3 = 10 components.",
        "answer_symbols": [
            "+",
            "-",
            "="
        ]
    },
    "9.2 19": {
        "question": "构造把连接运算符 J_2 应用到表 9 和表 10 的关系中所得到的表。",
        "answer": "| Supplier | Part_number | Project | Quantity | Color_code || --- | --- | --- | --- | --- || 2323233131 | 10921101904849753477 | 134 | 2112 | 212 || 2323233131 | 10921101904849753477 | 3 6 22 25 2 | 3 6 22 25 2 | 3 6 22 25 2 || 32 6984 4 10 1 | 32 9191 2 80 4 | 33 1001 1 14 8 |",
        "answer_symbols": [
            "|",
            "||",
            "---",
            "---"
        ]
    },
    "9.2 20": {
        "question": "证明：如果 C_1 和 C_2 是 n 元关系 R 的元素可能满足的条件，那么 s_C1 ∧ s_C2 (R) = s_C1 (s_C2 (R))。",
        "answer": "Both sides of this equation pick out the subset of R consisting of those n-tuples satisfying both conditions C1 and C2. This follows immediately from the definitions of conjunction and the selection operator.",
        "answer_symbols": []
    },
    "9.2 21": {
        "question": "证明：如果 C_1 和 C_2 是 n 元关系 R 的元素可能满足的条件，那么 s_C1 (s_C2 (R)) = s_C2 (s_C1 (R))。",
        "answer": "方程的两边都指出了满足条件 C1 和 C2 的 R 中的子集",
        "answer_symbols": []
    },
    "9.2 22": {
        "question": "证明：如果 C 是 n 元关系 R 和 S 的元素可能满足的条件，那么 s_C (R ∪ S) = s_C (R) ∪ s_C (S)。",
        "answer": "Both sides of this equation pick out the set of n-tuples that satisfy condition C, and furthermore are in R or S (or both, of course). This follows immediately from the definitions of union and the selection operator.",
        "answer_symbols": []
    },
    "9.2 23": {
        "question": "证明：如果 C 是 n 元关系 R 和 S 的元素可能满足的条件，那么 s_C (R ∩ S) = s_C (R) ∩ s_C (S)。",
        "answer": "方程的两边都指出了在 R 中、在 S 中且满足条件 C 的 n 元组集合",
        "answer_symbols": []
    },
    "9.2 24": {
        "question": "证明：如果 C 是 n 元关系 R 和 S 的元素可能满足的条件，那么 s_C (R - S) = s_C (R) - s_C (S)。",
        "answer": "Both sides of this equation pick out the set of n-tuples that satisfy condition C, and are in R and are not in S. This follows immediately from the definitions of set difference and the selection operator.",
        "answer_symbols": []
    },
    "9.2 25": {
        "question": "证明：如果 R 和 S 是两个 n 元关系，那么 P_i1,i2,...,im (R ∪ S) = P_i1,i2,...,im (R) ∪ P_i1,i2,...,im (S)。",
        "answer": "方程的两边都指出了由 R 或 S 中的 n 元组的第 i1 个、第 i2 个、...、第 im 个分量组成的 m 元组",
        "answer_symbols": []
    },
    "9.2 26": {
        "question": "给出一个例子证明：如果 R 和 S 是两个 n 元关系，那么 P_i1,i2,...,im (R ∩ S) 可能与 P_i1,i2,...,im (R) ∩ P_i1,i2,...,im (S) 不同。",
        "answer": "Note that we lose information when we delete columns. Therefore, we might have more in the second set than in the first, since it could be easier to be in the intersection in the second case. A simple example would be to let R = {(a, b)} and S = {(a, c)}, n = 2, m = 1, and i1 = 1. Then R ∩ S = Ø, so P1(R ∩ S) = Ø. On the other hand, P1(R) = P1(S) = {(a)}, so P1(R) ∩ P1(S) = {(a)}.",
        "answer_symbols": [
            "∩",
            "Ø"
        ]
    },
    "9.2 27": {
        "question": "给出一个例子证明：如果 R 和 S 是两个 n 元关系，那么 P_i1,i2,...,im (R - S) 可能与 P_i1,i2,...,im (R) - P_i1,i2,...,im (S) 不同。",
        "answer": "设 R = {(a, b)} 和 S = {(a, c)}，n = 2，m = 1，i1 = 1；P1(R - S) = {(a)}，但 P1(R) - P1(S) = ∅",
        "answer_symbols": [
            "{",
            "}",
            ",",
            "−",
            "∅"
        ]
    },
    "9.2 28 a)": {
        "question": "与下述用 SQL 语句表示的查询相对应的运算是什么？SELECT Supplier FROM Part_needs WHERE 1000 ≤ Part_number ≤ 5000",
        "answer": "We apply the selection operator with the condition “1000 ≤ Part number ≤ 5000” to the 3-tuples given in Table 9, picking out those rows that have a part number in the indicated range. Then we choose the supplier field from those rows, and delete duplicates.",
        "answer_symbols": [
            "≤"
        ]
    },
    "9.2 28 b)": {
        "question": "假设以表 9 的数据库作为输入，这个查询的输出是什么？",
        "answer": "Five of the 3-tuples in the joined database satisfy the condition, namely: (23, 1092, 1), (23, 1101, 3), (31, 4975, 3), (31, 3477, 2), (33, 1001, 1) The suppliers appearing here are 23, 31, 33.",
        "answer_symbols": []
    },
    "9.2 29 a)": {
        "question": "与下述用 SQL 语句表示的查询相对应的运算是什么？SELECT Supplier, Project FROM Part_needs, Parts_inventory WHERE Quantity ≤ 10",
        "answer": "J2 后跟 P1,3",
        "answer_symbols": []
    },
    "9.2 29 b)": {
        "question": "假设以表 9 和表 10 的数据库作为输入，这个查询的输出是什么？",
        "answer": "(23, 1), (23, 3), (31, 3), (32, 4)",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "9.2 30": {
        "question": "试确定例2中的关系是否有一个主键。",
        "answer": "主键是一个其值确定所有其他域值的域。对于这个关系，这种情况没有发生。第一个域不是主键，因为例如三元组 (1, 2, 3) 和 (1, 3, 5) 都在这个关系中（这些项形成一个等差数列）。同样，三元组 (1, 3, 5) 和 (2, 3, 4) 都在这个关系中，所以第二个域不是键；三元组 (1, 3, 5) 和 (3, 4, 5) 都在这个关系中，所以第三个域也不是键。",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "9.2 31": {
        "question": "试确定例3中的关系是否有一个主键。",
        "answer": "没有主键",
        "answer_symbols": []
    },
    "9.2 32": {
        "question": "证明具有一个主键的关系可以看做是某一函数的图，该函数将各个主键的值映射为由其他域构成的 n-1 元组。",
        "answer": "主键唯一确定 n 元组。因此，我们可以将 n 元组视为由主键（无论它位于哪个字段）和由其他 n−1 个域的值组成的 (n−1) 元组组成的一对。所有这样的对的集合按定义是从主键域的子集（其中出现的值）到其他 n−1 个域的笛卡尔积的函数的图。",
        "answer_symbols": [
            "n",
            "−",
            "1",
            "(",
            ")",
            ","
        ]
    },
    "9.3 1 a)": {
        "question": "用矩阵表示下面每个定义在 {1, 2, 3} 上的关系（按增序列出集合中的元素）。{(1, 1), (1, 2), (1, 3)}",
        "answer": "[1 1 1 0 0 0 0 0 0]",
        "answer_symbols": [
            "[",
            "]"
        ]
    },
    "9.3 1 b)": {
        "question": "用矩阵表示下面每个定义在 {1, 2, 3} 上的关系（按增序列出集合中的元素）。{(1, 2), (2, 1), (2, 2), (3, 3)}",
        "answer": "[0 1 0 1 1 0 0 0 1]",
        "answer_symbols": [
            "[",
            "]"
        ]
    },
    "9.3 1 c)": {
        "question": "用矩阵表示下面每个定义在 {1, 2, 3} 上的关系（按增序列出集合中的元素）。{(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)}",
        "answer": "[1 1 1 0 1 1 0 0 1]",
        "answer_symbols": [
            "[",
            "]"
        ]
    },
    "9.3 1 d)": {
        "question": "用矩阵表示下面每个定义在 {1, 2, 3} 上的关系（按增序列出集合中的元素）。{(1, 3), (3, 1)}",
        "answer": "[0 0 1 0 0 0 1 0 0]",
        "answer_symbols": [
            "[",
            "]"
        ]
    },
    "9.3 3 a)": {
        "question": "列出和下面矩阵对应的关系在{1, 2, 3}上的关系中的有序对(其中行和列对应于按增序列出的整数)。（a）⎡1 0 1⎤ ⎢0 1 0⎥ ⎢1 0 1⎥",
        "answer": "(1, 1), (1, 3), (2, 2), (3, 1), (3, 3)",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "9.3 3 b)": {
        "question": "列出和下面矩阵对应的关系在{1, 2, 3}上的关系中的有序对(其中行和列对应于按增序列出的整数)。（b）⎡0 1 0⎤ ⎢0 1 0⎥ ⎢0 0 1⎥",
        "answer": "(1, 2), (2, 2), (3, 2)",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "9.3 3 c)": {
        "question": "列出和下面矩阵对应的关系在{1, 2, 3}上的关系中的有序对(其中行和列对应于按增序列出的整数)。（c）⎡1 1 1⎤ ⎢1 0 1⎥ ⎢1 1 1⎥",
        "answer": "(1, 1), (1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2), (3, 3)",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "9.3 4 a)": {
        "question": "列出和下面矩阵对应的关系在{1, 2, 3, 4}上的关系中的有序对(其中行和列对应于按增序列出的整数)。（a）⎡1 1 0 1⎤ ⎢0 1 0 1⎥ ⎢0 1 1 1⎥ ⎢1 0 1 1⎥",
        "answer": "由于 (1, 1) 位置的元素是 1，(1, 1) 在关系中。由于 (1, 3) 位置的元素是 0，(1, 3) 不在关系中。继续这种方式，我们看到关系包含 (1, 1)，(1, 2)，(1, 4)，(2, 1)，(2, 3)，(3, 2)，(3, 3)，(3, 4)，(4, 1)，(4, 3)，和 (4, 4)。",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "9.3 4 b)": {
        "question": "列出和下面矩阵对应的关系在{1, 2, 3, 4}上的关系中的有序对(其中行和列对应于按增序列出的整数)。（b）⎡1 1 1 0⎤ ⎢0 1 0 0⎥ ⎢0 0 1 1⎥ ⎢1 0 0 1⎥",
        "answer": "(1, 1)，(1, 2)，(1, 3)，(2, 2)，(3, 3)，(3, 4)，(4, 1)，和 (1, 4)",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "9.3 4 c)": {
        "question": "列出和下面矩阵对应的关系在{1, 2, 3, 4}上的关系中的有序对(其中行和列对应于按增序列出的整数)。（c）⎡0 1 0 1⎤ ⎢1 0 1 0⎥ ⎢0 1 0 1⎥ ⎢1 0 1 0⎥",
        "answer": "(1, 2)，(1, 4)，(2, 1)，(2, 3)，(3, 2)，(3, 4)，(4, 1)，和 (4, 3)",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "9.3 5": {
        "question": "怎样用表示集合A上的关系R的有向图确定这个关系是否是反自反的?",
        "answer": "如果关系的矩阵对角线全为 0，则该关系是反自反的",
        "answer_symbols": []
    },
    "9.3 6": {
        "question": "怎样用表示集合A上的关系R的有向图确定这个关系是否是非对称的?",
        "answer": "非对称关系（参见第 9.1 节练习 18 前的说明）是指 (a, b) ∈ R 和 (b, a) ∈ R 不能同时成立，即使 a = b。在矩阵中，这意味着主对角线（位置 m_ii 对于某些 i）上没有 1，并且主对角线周围没有对称放置的 1 对（即，我们不能有 m_ij = m_ji = 1 对于任何 i 和 j 的值）。",
        "answer_symbols": [
            "(",
            ")",
            "∈",
            "=",
            "m",
            "_",
            "i",
            "j"
        ]
    },
    "9.3 9 a)": {
        "question": "R是包含了前100个正整数的集合A={1, 2, …, 100}上的关系，如果R满足下述条件，那么表示R的矩阵中有多少个非0的元素?（a）{(a, b) | a > b}",
        "answer": "4950",
        "answer_symbols": []
    },
    "9.3 9 b)": {
        "question": "R是包含了前100个正整数的集合A={1, 2, …, 100}上的关系，如果R满足下述条件，那么表示R的矩阵中有多少个非0的元素?（b）{(a, b) | a ≠ b}",
        "answer": "9900",
        "answer_symbols": []
    },
    "9.3 9 c)": {
        "question": "R是包含了前100个正整数的集合A={1, 2, …, 100}上的关系，如果R满足下述条件，那么表示R的矩阵中有多少个非0的元素?（c）{(a, b) | a = b + 1}",
        "answer": "99",
        "answer_symbols": []
    },
    "9.3 9 d)": {
        "question": "R是包含了前100个正整数的集合A={1, 2, …, 100}上的关系，如果R满足下述条件，那么表示R的矩阵中有多少个非0的元素?（d）{(a, b) | a = 1}",
        "answer": "100",
        "answer_symbols": []
    },
    "9.3 9 e)": {
        "question": "R是包含了前100个正整数的集合A={1, 2, …, 100}上的关系，如果R满足下述条件，那么表示R的矩阵中有多少个非0的元素?（e）{(a, b) | ab = 1}",
        "answer": "1",
        "answer_symbols": []
    },
    "9.3 10 a)": {
        "question": "R是包含了前1000个正整数的集合A={1, 2, …, 1000}上的关系，如果R满足下述条件，那么表示R的矩阵中有多少个非0的元素?（a）{(a, b) | a ≤ b}",
        "answer": "对于每个不超过1000的不同的正整数对，矩阵中都有一个1，即在位置(a, b)处，其中a ≤ b，以及对角线上的1。因此，答案是从1000个元素中选择2个元素的子集的数量加上1000，即C(1000, 2) + 1000 = 499500 + 1000 = 500,500。",
        "answer_symbols": [
            "(",
            ")",
            ",",
            "≤",
            "+"
        ]
    },
    "9.3 10 b)": {
        "question": "R是包含了前1000个正整数的集合A={1, 2, …, 1000}上的关系，如果R满足下述条件，那么表示R的矩阵中有多少个非0的元素?（b）{(a, b) | a = b ± 1}",
        "answer": "每行矩阵中有两个1，除了第一行和最后一行，这两行中只有一个1。因此，答案是998 × 2 + 2 = 1998。",
        "answer_symbols": [
            "×",
            "+"
        ]
    },
    "9.3 10 c)": {
        "question": "R是包含了前1000个正整数的集合A={1, 2, …, 1000}上的关系，如果R满足下述条件，那么表示R的矩阵中有多少个非0的元素?（c）{(a, b) | a + b = 1000}",
        "answer": "在矩阵中，每个条目都在“反对角线”上方和左侧的位置有1（即在位置(1, 999)，(2, 998)，...，(999, 1)）。因此，答案是999。",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "9.3 10 d)": {
        "question": "R是包含了前1000个正整数的集合A={1, 2, …, 1000}上的关系，如果R满足下述条件，那么表示R的矩阵中有多少个非0的元素?（d）{(a, b) | a + b ≤ 1001}",
        "answer": "在矩阵中，每个条目都在或在“反对角线”上方（左侧）的位置有1。这与部分(a)中的1的数量相同，所以答案也是500,500。",
        "answer_symbols": [
            "("
        ]
    },
    "9.3 10 e)": {
        "question": "R是包含了前1000个正整数的集合A={1, 2, …, 1000}上的关系，如果R满足下述条件，那么表示R的矩阵中有多少个非0的元素?（e）{(a, b) | a ≠ 0}",
        "answer": "条件显然是成立的（因为1 ≤ a ≤ 1000），所以所有1,000,000个条目都是1。",
        "answer_symbols": [
            "≤"
        ]
    },
    "9.3 11": {
        "question": "当R是有穷集A上的关系时，怎样从表示R的关系矩阵得到表示这个关系的补R的矩阵?",
        "answer": "将每个 0 改为 1，将每个 1 改为 0",
        "answer_symbols": []
    },
    "9.3 12": {
        "question": "当R是有穷集A上的关系时，怎样从表示R的关系矩阵得到表示这个关系的逆R^-1的矩阵?",
        "answer": "我们取矩阵的转置，因为我们希望R−1的(i, j)位置的条目为1当且仅当R的(j, i)位置的条目为1。",
        "answer_symbols": [
            "-",
            "(",
            ")",
            ","
        ]
    },
    "9.3 13 a)": {
        "question": "设R是矩阵M_R = ⎡0 1 1⎤ ⎢1 1 0⎥ ⎢1 0 1⎥所表示的关系，求表示下述关系的矩阵。（a）R^-1",
        "answer": "[0 1 1 1 1 0 1 0 1]",
        "answer_symbols": [
            "[",
            "]"
        ]
    },
    "9.3 13 b)": {
        "question": "设R是矩阵M_R = ⎡0 1 1⎤ ⎢1 1 0⎥ ⎢1 0 1⎥所表示的关系，求表示下述关系的矩阵。（b）R",
        "answer": "[1 0 0 0 0 1 0 1 0]",
        "answer_symbols": [
            "[",
            "]"
        ]
    },
    "9.3 13 c)": {
        "question": "设R是矩阵M_R = ⎡0 1 1⎤ ⎢1 1 0⎥ ⎢1 0 1⎥所表示的关系，求表示下述关系的矩阵。（c）R^2",
        "answer": "[1 1 1 1 1 1 1 1 1]",
        "answer_symbols": [
            "[",
            "]"
        ]
    },
    "9.3 14 a)": {
        "question": "设R_1和R_2是集合A上的关系，由以下矩阵表示。M_R1 = ⎡0 1 0⎤ ⎢1 1 1⎥ ⎢1 0 0⎥ M_R2 = ⎡0 1 0⎤ ⎢0 1 1⎥ ⎢1 1 1⎥ 求表示下述关系的矩阵。（a）R_1 ∪ R_2",
        "answer": "并集的矩阵是通过取并集形成的：[ 0 1 0 ] [ 1 1 1 ] [ 1 1 1 ]",
        "answer_symbols": [
            "[",
            "]",
            "0",
            "1"
        ]
    },
    "9.3 14 b)": {
        "question": "设R_1和R_2是集合A上的关系，由以下矩阵表示。M_R1 = ⎡0 1 0⎤ ⎢1 1 1⎥ ⎢1 0 0⎥ M_R2 = ⎡0 1 0⎤ ⎢0 1 1⎥ ⎢1 1 1⎥ 求表示下述关系的矩阵。（b）R_1 ∩ R_2",
        "answer": "交集的矩阵是通过取交集形成的：[ 0 1 0 ] [ 0 1 1 ] [ 1 0 0 ]",
        "answer_symbols": [
            "[",
            "]",
            "0",
            "1"
        ]
    },
    "9.3 14 c)": {
        "question": "设R_1和R_2是集合A上的关系，由以下矩阵表示。M_R1 = ⎡0 1 0⎤ ⎢1 1 1⎥ ⎢1 0 0⎥ M_R2 = ⎡0 1 0⎤ ⎢0 1 1⎥ ⎢1 1 1⎥ 求表示下述关系的矩阵。（c）R_2 ∘ R_1",
        "answer": "矩阵是布尔乘积MR1 - MR2：[ 0 1 1 ] [ 1 1 1 ] [ 0 1 0 ]",
        "answer_symbols": [
            "-",
            "[",
            "]",
            "0",
            "1"
        ]
    },
    "9.3 14 d)": {
        "question": "设R_1和R_2是集合A上的关系，由以下矩阵表示。M_R1 = ⎡0 1 0⎤ ⎢1 1 1⎥ ⎢1 0 0⎥ M_R2 = ⎡0 1 0⎤ ⎢0 1 1⎥ ⎢1 1 1⎥ 求表示下述关系的矩阵。（d）R_1 ∘ R_2",
        "answer": "矩阵是布尔乘积MR1 - MR1：[ 1 1 1 ] [ 1 1 1 ] [ 0 1 0 ]",
        "answer_symbols": [
            "-",
            "[",
            "]",
            "0",
            "1"
        ]
    },
    "9.3 14 e)": {
        "question": "设R_1和R_2是集合A上的关系，由以下矩阵表示。M_R1 = ⎡0 1 0⎤ ⎢1 1 1⎥ ⎢1 0 0⎥ M_R2 = ⎡0 1 0⎤ ⎢0 1 1⎥ ⎢1 1 1⎥ 求表示下述关系的矩阵。（e）R_1 ⊕ R_2",
        "answer": "矩阵是逐元素异或：[ 0 0 0 ] [ 1 0 0 ] [ 0 1 1 ]",
        "answer_symbols": [
            "[",
            "]",
            "0",
            "1"
        ]
    },
    "9.3 15 a)": {
        "question": "设R是矩阵M_R = ⎡0 1 0⎤ ⎢0 0 1⎥ ⎢1 0 0⎥表示的关系，求表示下述关系的矩阵（a）R^2",
        "answer": "[0 0 1 1 1 0 0 1 1]",
        "answer_symbols": [
            "[",
            "]"
        ]
    },
    "9.3 15 b)": {
        "question": "设R是矩阵M_R = ⎡0 1 0⎤ ⎢0 0 1⎥ ⎢1 0 0⎥表示的关系，求表示下述关系的矩阵（b）R^3",
        "answer": "[1 1 0 0 1 1 1 1 1]",
        "answer_symbols": [
            "[",
            "]"
        ]
    },
    "9.3 15 c)": {
        "question": "设R是矩阵M_R = ⎡0 1 0⎤ ⎢0 0 1⎥ ⎢1 0 0⎥表示的关系，求表示下述关系的矩阵（c）R^4",
        "answer": "[0 1 1 1 1 1 1 1 1]",
        "answer_symbols": [
            "[",
            "]"
        ]
    },
    "9.3 16": {
        "question": "设 R 是 n 元素集合 A 上的关系。如果在表示 R 的矩阵 M_R 中存在 k 个非 0 的元素，那么在表示 R 的逆 R^-1 的矩阵 M_R^-1 中存在多少个非 0 元素？",
        "answer": "由于R−1的矩阵只是R的矩阵的转置（见练习12），条目是相同的0和1的集合，因此MR−1中也有k个非零条目。",
        "answer_symbols": [
            "-",
            "("
        ]
    },
    "9.3 17": {
        "question": "设 R 是 n 元素集合 A 上的关系。如果在表示 R 的矩阵 M_R 中存在 k 个非 0 的元素，那么在表示 R 的补 R 的矩阵 M_R 中存在多少个非 0 元素？",
        "answer": "n^2 - k",
        "answer_symbols": [
            "^",
            "-"
        ]
    },
    "9.3 18": {
        "question": "画出表示练习 1 中每个关系的有向图.",
        "answer": "我们画出有向图，每种情况下顶点集为{1, 2, 3}，并且每当(i, j)在关系中时，从i到j画一条边。",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            ","
        ]
    },
    "9.3 20": {
        "question": "画出表示练习 3 中每个关系的有向图.",
        "answer": "每种情况下，我们在三个顶点上画一个有向图，对于关系中的每个对(a, b)，从a到b画一条边，即每当矩阵中的位置(a, b)有一个1时。例如，在部分(a)中，我们需要一条边。从1到它自身有一条边，因为矩阵中的位置（1, 1）有一个1，并且有一条从1到3的边，但没有从1到2的边。",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "9.3 22": {
        "question": "画出表示关系 (a, a), (a, b), (b, c), (c, b), (c, d), (d, a), (d, b) 的有向图.",
        "answer": "我们画出顶点集为{a, b, c, d}的有向图，每当（i, j）在关系中时，就有一条从i到j的边。",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            ","
        ]
    },
    "9.3 23": {
        "question": "在练习 23～28 中，列出由下述有向图所表示的关系中的有序对。 a / \\ b c",
        "answer": "{(a, b), (a, c), (b, c), (c, b)}",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            ","
        ]
    },
    "9.3 24": {
        "question": "在练习 23～28 中，列出由下述有向图所表示的关系中的有序对。 a / \\ b c",
        "answer": "我们列出所有在有向图中从x到y有一条边的对（x, y）：{(a, a), (a, c), (b, a), (b, b), (b, c), (c, c)}。",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            ","
        ]
    },
    "9.3 25": {
        "question": "在练习 23～28 中，列出由下述有向图所表示的关系中的有序对。 a / \\ b c",
        "answer": "(a, c), (b, a), (c, d), (d, b)",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "9.3 26": {
        "question": "在练习 23～28 中，列出由下述有向图所表示的关系中的有序对。 a / \\ b c",
        "answer": "我们列出所有在有向图中从x到y有一条边的对（x, y）：{(a, a), (a, b), (b, a), (b, b), (c, a), (c, c), (c, d), (d, d)}。",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            ","
        ]
    },
    "9.3 27": {
        "question": "在练习 23～28 中，列出由下述有向图所表示的关系中的有序对。 a / \\ b c",
        "answer": "{(a, a), (a, b), (a, c), (b, a), (b, b), (b, c), (c, a), (c, b), (d, d)}",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            ","
        ]
    },
    "9.3 28": {
        "question": "在练习 23～28 中，列出由下述有向图所表示的关系中的有序对。 a / \\ b c",
        "answer": "我们列出所有在有向图中从x到y有一条边的对（x, y）：{(a, a), (a, b), (b, a), (b, b), (c, c), (c, d), (d, c), (d, d)}。",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            ","
        ]
    },
    "9.3 29": {
        "question": "怎样用定义在有穷集 A 上的关系 R 的有向图确定一个关系是否是非对称的？",
        "answer": "关系是反对称的当且仅当有向图没有环且没有长度为 2 的闭路径",
        "answer_symbols": []
    },
    "9.3 30": {
        "question": "怎样用定义在有穷集 A 上的关系 R 的有向图确定一个关系是否是反自反的？",
        "answer": "显然，R是不可自反的当且仅当R的有向图中没有环。",
        "answer_symbols": []
    },
    "9.3 31": {
        "question": "确定练习 23～25 所示的有向图表示的关系是否为自反的、反自反的、对称的、反对称的和传递的.",
        "answer": "练习 23：反自反。练习 24：自反、反对称、传递。练习 25：反自反、反对称。",
        "answer_symbols": []
    },
    "9.3 32": {
        "question": "确定练习 26～28 所示的有向图表示的关系是否为自反的、反自反的、对称的、反对称的和传递的.",
        "answer": "回想一下，如果每个顶点都有一个环，则该关系是自反的；如果没有环，则该关系是不可自反的；如果边只出现在反平行对中（从一个顶点到另一个顶点的边和从第二个顶点回到第一个顶点的边），则该关系是对称的；如果没有任何一对反平行边，则该关系是反对称的；如果既反对称又不可自反，则该关系是非对称的；如果长度为2的所有路径（一对边（x, y）和（y, z））都伴随着相应的长度为1的路径（边（x, z）），则该关系是传递的。练习26中绘制的关系是自反的但不是不可自反的，因为每个顶点都有环。它不是对称的，因为例如，存在边（c, a）但不存在边（a, c）。它不是反对称的，因为同时存在边（a, b）和（b, a）。因此它也不是非对称的。它不是传递的，因为从c到b的路径（c, a）和（a, b）没有伴随的边（c, b）。练习27中绘制的关系既不是自反的也不是不可自反的，因为有些顶点有环但并不是每个顶点都有环。它是对称的，因为边以反平行对的形式出现。它不是反对称的，因为例如，同时存在边（a, b）和（b, a）。因此它也不是非对称的。它不是传递的，因为存在边（c, a）和（a, c），但不存在（c, c）。练习28中绘制的关系是自反的而不是不可自反的，因为所有顶点都有环。它是对称的但不是反对称的或非对称的。它是传递的；唯一非平凡的长度为2的路径都有必要的环捷径。",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            ",",
            "→"
        ]
    },
    "9.3 33": {
        "question": "设 R 是定义在集合 A 上的关系，解释如何用表示 R 的有向图得到表示关系的逆 R^-1 的有向图？",
        "answer": "反转有向图中每条边的方向",
        "answer_symbols": []
    },
    "9.3 34": {
        "question": "设 R 是定义在集合 A 上的关系，解释如何用表示 R 的有向图得到表示关系的补 R 的有向图？",
        "answer": "对于每对顶点（a, b）（包括两个顶点相同的对（a, a）），如果从a到b有一条边，则擦除它；如果从a到b没有边，则添加它。",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            ","
        ]
    },
    "9.3 35": {
        "question": "证明：如果 M_R 是表示关系 R 的矩阵，那么 M_R^-1 是表示关系 R^-1 的矩阵.",
        "answer": "数学归纳法证明。基础步骤：对于 n = 1 是平凡的。归纳步骤：假设对于 k 成立。因为 R^(k+1) = R^k ∘ R，其矩阵为 M_R ∘ M_(R^k)。根据归纳假设，这是 M_R ∘ M_(R^k) = M_(R^(k+1))",
        "answer_symbols": [
            "^",
            "=",
            "∘"
        ]
    },
    "9.3 36": {
        "question": "给定表示两个关系的有向图，如何得到表示这些关系的并、交、对称差、差以及合成的有向图？",
        "answer": "假设这两个关系是在同一集合上。对于并集，我们只需取有向图的并集，即在相同顶点上取有向图，并在任一有向图中从i到j有一条边时加入一条从i到j的边。对于交集，我们只需取有向图的交集。例如，在相同的顶点上取有向图，并在从 i 到 j 有边的情况下添加一条边。对于对称差，我们只需取有向图的对称差，即在相同的顶点上取有向图，并在从 i 到 j 在其中一个图中有边但不在另一个图中有边的情况下添加一条边。类似地，为了形成差，我们取有向图的差，即在相同的顶点上取有向图，并在从 i 到 j 在第一个图中有边但在第二个图中没有边的情况下添加一条边。为了形成关系 R 和 S 的合成 S ◦ R 的有向图，我们在相同的顶点集上绘制一个有向图，并在从 i 到 j 存在一个顶点 k 使得从 i 到 k 在 R 中有边且从 k 到 j 在 S 中有边时添加一条边。",
        "answer_symbols": [
            "(",
            "∪",
            "∩",
            "{",
            ",",
            "}",
            ")"
        ]
    },
    "9.4 1 a)": {
        "question": "设 R 是定义在集合 {0, 1, 2, 3} 上的关系，R 中包含有序对 (0, 1), (1, 1), (1, 2), (2, 0), (2, 2) 和 (3, 0)，求 R 的自反闭包.",
        "answer": "{(0, 0), (0, 1), (1, 1), (1, 2), (2, 0), (2, 2), (3, 0), (3, 3)}",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            ","
        ]
    },
    "9.4 1 b)": {
        "question": "设 R 是定义在集合 {0, 1, 2, 3} 上的关系，R 中包含有序对 (0, 1), (1, 1), (1, 2), (2, 0), (2, 2) 和 (3, 0)，求 R 的对称闭包.",
        "answer": "{(0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2), (3, 0)}",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            ","
        ]
    },
    "9.4 2": {
        "question": "w_ij^(k) 等于 1 当且仅当 w_ij^(k-1) = 1 或者 w_ik^(k-1) = 1 和 w_kj^(k-1) = 1。",
        "answer": "当我们把所有 (x, x) 对添加到给定的关系中时，我们拥有整个 Z × Z；换句话说，我们拥有了始终成立的关系。",
        "answer_symbols": [
            "×"
        ]
    },
    "9.4 3": {
        "question": "设 W_k = [w_ij^(k)] 是 0-1 矩阵，它的 (i, j) 位置为 1 当且仅当存在一条从 v_i 到 v_j 的路径，其内部顶点取自集合 {v_1, v_2, ⋯, v_k}，那么 w_ij^(k) = w_ij^(k-1) ∨ (w_ik^(k-1) ∧ w_kj^(k-1))。",
        "answer": "{(a, b) | a 整除 b 或 b 整除 a}",
        "answer_symbols": [
            "{",
            "}",
            "|"
        ]
    },
    "9.4 4": {
        "question": "使用引理 2 把沃舍尔算法的伪码在算法 2 中给出。",
        "answer": "为了形成自反闭包，我们只需要在每个没有自环的顶点处添加一个自环。",
        "answer_symbols": []
    },
    "9.4 6": {
        "question": "从 W_(k-1) 求出 W_k 的所有 n^2 个项需要 2n^2 次位运算。",
        "answer": "我们通过取给定的有向图并在所有没有自环的顶点处附加自环来形成自反闭包。",
        "answer_symbols": []
    },
    "9.4 8": {
        "question": "从有穷集上关系的有向图怎样构造表示它的对称闭包的有向图？",
        "answer": "为了形成对称闭包的有向图，我们只需要在有向图中尚未存在从 x 到 y 的边但存在从 y 到 x 的边时添加一条从 x 到 y 的边。",
        "answer_symbols": [
            "→"
        ]
    },
    "9.4 10": {
        "question": "找出包含了例 2 中关系的最小的自反和对称的关系。",
        "answer": "在示例 2 中找到的对称闭包是“不等于”关系。如果我们现在使这个关系也自反，我们将得到始终成立的关系。",
        "answer_symbols": []
    },
    "9.4 12": {
        "question": "假设有穷集 A 上的关系 R 由矩阵 M_R 表示，证明表示 R 的自反闭包的矩阵是 M_R ∨ I_n。",
        "answer": "M_R ∨ I_n 按定义与 M_R 相同，只是主对角线上全是 1。这必须代表 R 的自反闭包，因为这个闭包除了添加所有不在 R 中的 (x, x) 对之外，与 R 相同。",
        "answer_symbols": [
            "∨"
        ]
    },
    "9.4 13": {
        "question": "假设有穷集 A 上的关系 R 由矩阵 M_R 表示，证明表示 R 的对称闭包的矩阵是 M_R ∨ M_R^T。",
        "answer": "R 的对称闭包是 R ∪ R^⁻¹。M_(R ∪ R^⁻¹) = M_R ∨ M_(R^⁻¹) = M_R ∨ M_t(R).",
        "answer_symbols": [
            "∨",
            "⁻¹",
            "-",
            "∪",
            "^"
        ]
    },
    "9.4 14": {
        "question": "证明关系 R 关于性质 P 的闭包，如果存在，就是所有包含 R 的具有性质 P 的关系的交。",
        "answer": "假设闭包 C 存在。我们必须证明 C 是具有性质 P 并包含 R 的所有关系 S 的交集 I。显然 I ⊆ C，因为 C 是交集中的一组。相反，根据闭包的定义，C 是每个具有性质 P 并包含 R 的关系 S 的子集；因此 C 包含在它们的交集中。",
        "answer_symbols": [
            "⊆"
        ]
    },
    "9.4 15": {
        "question": "什么时候可能定义一个关系 R 的反自反闭包，即一个包含 R 的关系是反自反的且包含在每一个包含 R 的反自反关系中？",
        "answer": "仅当 R 是反自反时。",
        "answer_symbols": []
    },
    "9.4 16 a)": {
        "question": "确定下面的顶点序列是否为右面的有向图中的路径。（a）a, b, c, e",
        "answer": "这是一个路径。",
        "answer_symbols": []
    },
    "9.4 16 b)": {
        "question": "确定下面的顶点序列是否为右面的有向图中的路径。（b）b, e, c, b, e",
        "answer": "这不是一个路径（从 e 到 c 没有边）。",
        "answer_symbols": [
            "→"
        ]
    },
    "9.4 16 c)": {
        "question": "确定下面的顶点序列是否为右面的有向图中的路径。（c）a, a, b, e, d, e",
        "answer": "这是一个路径。",
        "answer_symbols": []
    },
    "9.4 16 d)": {
        "question": "确定下面的顶点序列是否为右面的有向图中的路径。（d）b, c, e, d, a, a, b",
        "answer": "这不是一个路径（从 d 到 a 没有边）。",
        "answer_symbols": [
            "→"
        ]
    },
    "9.4 16 e)": {
        "question": "确定下面的顶点序列是否为右面的有向图中的路径。（e）b, c, b, e, d, e, d",
        "answer": "这是一个路径。",
        "answer_symbols": []
    },
    "9.4 16 f)": {
        "question": "确定下面的顶点序列是否为右面的有向图中的路径。（f）a, a, b, b, c, b, e, d",
        "answer": "这不是一个路径（b 处没有自环）。",
        "answer_symbols": []
    },
    "9.4 17": {
        "question": "求出练习 16 的有向图中所有长为 3 的路径。",
        "answer": "a, a, a, a; a, b, e, a; a, d, e, a; b, c, c, b; b, e, a, b; c, b, c, c; c, c, b, c; c, c, c, c; d, e, a, d; d, e, e, d; e, a, b, e; e, a, d, e; e, d, e, e; e, e, d, e; e, e, e, e",
        "answer_symbols": []
    },
    "9.4 18 a)": {
        "question": "确定练习 16 的有向图中是否存在一条以下面给定的第一顶点作为起点、以第二顶点作为终点的路径。（a）a, b",
        "answer": "一条路径是 a, b。",
        "answer_symbols": []
    },
    "9.4 18 b)": {
        "question": "确定练习 16 的有向图中是否存在一条以下面给定的第一顶点作为起点、以第二顶点作为终点的路径。（b）b, a",
        "answer": "一条路径是 b, e, a。",
        "answer_symbols": []
    },
    "9.4 18 c)": {
        "question": "确定练习 16 的有向图中是否存在一条以下面给定的第一顶点作为起点、以第二顶点作为终点的路径。（c）b, b",
        "answer": "一条路径是 b, c, b；更短的一条路径是 b。",
        "answer_symbols": []
    },
    "9.4 18 d)": {
        "question": "确定练习 16 的有向图中是否存在一条以下面给定的第一顶点作为起点、以第二顶点作为终点的路径。（d）a, e",
        "answer": "一条路径是 a, b, e。",
        "answer_symbols": []
    },
    "9.4 18 e)": {
        "question": "确定练习 16 的有向图中是否存在一条以下面给定的第一顶点作为起点、以第二顶点作为终点的路径。（e）b, d",
        "answer": "一条路径是 b, e, d。",
        "answer_symbols": []
    },
    "9.4 18 f)": {
        "question": "确定练习 16 的有向图中是否存在一条以下面给定的第一顶点作为起点、以第二顶点作为终点的路径。（f）c, d",
        "answer": "一条路径是 c, e, d。",
        "answer_symbols": []
    },
    "9.4 18 g)": {
        "question": "确定练习 16 的有向图中是否存在一条以下面给定的第一顶点作为起点、以第二顶点作为终点的路径。（g）d, d",
        "answer": "一条路径是 d, e, d。另一条路径是从 d 到自身的长度为 0 的路径。",
        "answer_symbols": []
    },
    "9.4 18 h)": {
        "question": "确定练习 16 的有向图中是否存在一条以下面给定的第一顶点作为起点、以第二顶点作为终点的路径。（h）e, a",
        "answer": "一条路径是 e, a。另一条路径是 e, a, b, e, a, b, e, a, b, e, a。",
        "answer_symbols": []
    },
    "9.4 18 i)": {
        "question": "确定练习 16 的有向图中是否存在一条以下面给定的第一顶点作为起点、以第二顶点作为终点的路径。（i）e, c",
        "answer": "一条路径是 e, a, b, c。",
        "answer_symbols": []
    },
    "9.4 20 a)": {
        "question": "设 R 是关系，如果存在一条从 a 城到 b 城的直达航班，则 R 包含有序对 (a, b)。什么时候 (a, b) 在下面的关系中？（a）R^²",
        "answer": "当存在一个城市 c 使得从 a 到 c 有直飞航班且从 c 到 b 有直飞航班时，(a, b) 对属于 R^²——换句话说，当可以经由某个中转城市（可能需要换乘飞机）从 a 飞到 b 时。",
        "answer_symbols": [
            "(",
            ")",
            "→"
        ]
    },
    "9.4 20 b)": {
        "question": "设 R 是关系，如果存在一条从 a 城到 b 城的直达航班，则 R 包含有序对 (a, b)。什么时候 (a, b) 在下面的关系中？（b）R^³",
        "answer": "当存在城市 c 和 d 使得从 a 到 c 有直飞航班，从 c 到 d 有直飞航班，且从 d 到 b 有直飞航班时，(a, b) 对属于 R^³——换句话说，当可以经由两个中转城市（可能在其中一个或两个城市需要换乘飞机）从 a 飞到 b 时。",
        "answer_symbols": [
            "(",
            ")",
            "→"
        ]
    },
    "9.4 20 c)": {
        "question": "设 R 是关系，如果存在一条从 a 城到 b 城的直达航班，则 R 包含有序对 (a, b)。什么时候 (a, b) 在下面的关系中？（c）R*",
        "answer": "(a, b) 对属于 R* 当且仅当可以从 a 飞到 b。",
        "answer_symbols": [
            "(",
            ")",
            "→"
        ]
    },
    "9.4 22": {
        "question": "假设关系 R 是自反的，证明 R* 是自反的。",
        "answer": "由于 R ⊆ R*，显然如果 Δ ⊆ R，则 Δ ⊆ R*。",
        "answer_symbols": [
            "⊆"
        ]
    },
    "9.4 23": {
        "question": "假设关系 R 是对称的，证明 R* 是对称的。",
        "answer": "结果由 (R*)^⁻¹= (∪∞ n=1 R^ⁿ)^⁻¹=∪∞ n=1(R^ⁿ)^⁻¹=∪∞ n=1 R^ⁿ= R* 得出。",
        "answer_symbols": [
            "⁻¹",
            "∪",
            "∞",
            "ⁿ"
        ]
    },
    "9.4 24": {
        "question": "假设关系 R 是反自反的，关系 R^² 一定是反自反的吗？",
        "answer": "R^² 可能包含一些对 (a, a)。例如，设 R = {(1, 2), (2, 1)}。",
        "answer_symbols": [
            "(",
            ")",
            "⊆"
        ]
    },
    "9.4 26 a)": {
        "question": "使用算法 1 找出下面 {a, b, c, d, e} 上的关系的传递闭包。（a）{(a, c), (b, d), (c, a), (d, b), (e, d)}",
        "answer": "我们展示涉及的各种矩阵。首先，\nA =\n| 0 0 1 0 0 |\n| 0 0 0 0 0 |\n| 1 0 1 0 0 |\n| 0 0 0 0 0 |\n| 1 0 0 0 1 |\nA[2] =\n| 1 0 0 0 0 |\n| 0 1 0 0 0 |\n| 0 0 1 0 0 |\n| 0 0 0 1 0 |\n| 0 1 0 0 0 |\nA[3] =\n| 0 0 1 0 0 |\n| 0 0 0 0 0 |\n| 1 0 1 0 0 |\n| 0 0 0 0 0 |\n| 1 0 0 0 1 | = A\n由此得出 A[4] = A[2] 和 A[5] = A[3]。因此答案 B，所有 A 的交集，是 A ∨ A[2]，即\n| 1 0 1 0 0 |\n| 0 1 0 1 0 |\n| 1 0 1 0 0 |\n| 0 1 0 1 0 |\n| 0 1 0 1 0 |",
        "answer_symbols": [
            "|",
            "=",
            "∨"
        ]
    },
    "9.4 26 b)": {
        "question": "使用算法 1 找出下面 {a, b, c, d, e} 上的关系的传递闭包。（b）{(b, c), (b, e), (c, e), (d, a), (e, b), (e, c)}",
        "answer": "对于这部分和剩余部分，我们仅展示产生的矩阵。\nA =\n| 0 0 0 0 0 |\n| 0 0 1 0 1 |\n| 0 0 0 0 1 |\n| 1 0 0 0 0 |\n| 0 1 1 0 0 |\nA[2] =\n| 0 0 0 0 0 |\n| 0 1 1 0 1 |\n| 0 1 0 1 1 |\n| 0 0 0 0 0 |\n| 0 0 1 0 1 |\nA[3] =\n| 0 0 0 0 0 |\n| 0 1 1 0 1 |\n| 0 0 1 0 1 |\n| 0 0 0 0 0 |\n| 0 1 1 0 1 |\nA[4] =\n| 0 0 0 0 0 |\n| 0 1 1 0 1 |\n| 0 1 0 1 1 |\n| 0 0 0 0 0 |\n| 0 1 1 0 1 | = A[5]\nB =\n| 0 0 0 0 0 |\n| 0 1 1 0 1 |\n| 0 1 0 1 1 |\n| 0 0 0 0 0 |\n| 0 1 1 0 1 |",
        "answer_symbols": [
            "|",
            "="
        ]
    },
    "9.4 26 c)": {
        "question": "使用算法 1 找出下面 {a, b, c, d, e} 上的关系的传递闭包。（c）{(a, b), (a, c), (b, a), (b, c), (c, a), (c, b), (d, a), (e, d)}",
        "answer": "A = | 0 1 1 0 1 | | 1 0 1 0 0 | | 1 1 0 0 0 | | 1 0 0 0 0 | | 0 1 1 0 1 | A[2] = | 1 1 1 1 0 | | 1 1 1 0 1 | | 1 1 1 1 0 | | 0 1 1 0 1 | | 1 0 1 0 1 | A[3] = | 1 1 1 0 1 | | 1 1 1 1 1 | | 1 1 1 1 1 | | 1 1 1 0 1 | | 1 0 1 0 1 | A[4] = [ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 0 1 0 ] A[5] = [ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 ] B = [ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ]",
        "answer_symbols": [
            "|"
        ]
    },
    "9.4 26 d)": {
        "question": "使用算法 1 找出下面 {a, b, c, d, e} 上的关系的传递闭包。（d）{(a, e), (b, a), (b, d), (c, a), (d, a), (d, c), (e, a), (e, b), (e, c), (e, e)}",
        "answer": "A = [ 0 0 0 0 1 1 0 0 1 0 0 0 0 1 0 1 0 1 0 0 1 1 1 0 1 ] A[2] = [ 1 1 1 0 1 1 0 1 0 1 0 0 0 1 1 1 0 1 0 1 1 1 1 1 1 ] A[3] = [ 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 ] A[4] = [ 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 ] A[5] = [ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ] = B",
        "answer_symbols": [
            "[",
            "]"
        ]
    },
    "9.4 27": {
        "question": "使用沃舍尔算法找出练习 25 中关系的传递闭包。",
        "answer": "答案与练习 25 相同。",
        "answer_symbols": []
    },
    "9.4 30": {
        "question": "完成引理 1 当 a ≠ b 情况下的证明。",
        "answer": "设 m 是从 a 到 b 的最短路径的长度，并设 a = x0, x1,..., xm−1, xm = b 是这样一条路径。如果 m > n - 1，则 m ≥ n，因此 m + 1 ≥ n + 1，这意味着顶点 x0, x1, x2,..., xm 不全是不同的。因此存在某个 i 和 j 满足 0 ≤ i < j ≤ m（但不同时满足 i = 0 和 j = m，因为 a ≠ b）。我们可以去掉从 xi 到 xj 的环，留下一条从 a 到 b 的更短的路径，即 x0,..., xi, xj+1,..., xm。这与 m 的选择矛盾。因此 m ≤ n - 1，如所需。",
        "answer_symbols": [
            "≥",
            "≠"
        ]
    },
    "9.4 31": {
        "question": "已经设计出算法用 O(n^²) 次位运算来计算两个 n×n 的 0-1 矩阵的布尔积。假设可以使用这些算法，给出用算法 1 和沃舍尔算法求 n 元素集合上关系的传递闭包所用位运算次数的大 O 估计。",
        "answer": "算法 1: O(n^³·^⁸); 算法 2: O(n^³)",
        "answer_symbols": [
            "O",
            "(",
            ")",
            "³",
            "·",
            "⁸",
            "³"
        ]
    },
    "9.4 32": {
        "question": "如果有向图的两个顶点间的最短路径存在，设计一个算法，利用路径中内点的概念求这种最短路径的长度。",
        "answer": "Warshall 的算法确定路径的存在性。如果我们跟踪路径的长度，那么我们可以获得所需的信息。因此我们对算法 2 进行以下更改。首先，不是将 W 初始化为 MR，而是将 W 初始化为 MR 并将每个 0 替换为 ∞。其次，计算步骤变为 wij := min(wij, wik + wkj)。",
        "answer_symbols": [
            "∞",
            ":=",
            "+",
            "min"
        ]
    },
    "9.4 33": {
        "question": "修改算法 1 找出 n 元素集合上关系的传递闭包的自反闭包。",
        "answer": "用 A:= M_R ∨ I_n 初始化并仅循环 i:= 2 到 n − 1。",
        "answer_symbols": [
            "∨",
            "I",
            "n",
            "−"
        ]
    },
    "9.4 34": {
        "question": "修改沃舍尔算法找出 n 元素集合上关系的传递闭包的自反闭包。",
        "answer": "我们只需要确保所有 (x, x) 对都包含在内。一个简单的方法是在最后添加它们，通过设置 W := W ∨ In。",
        "answer_symbols": [
            "∨",
            ":="
        ]
    },
    "9.5 2 a)": {
        "question": "下面是定义在所有人的集合上的关系，其中哪些是等价关系？给出其他关系所缺少的等价关系应具有的性质。{(a, b) | a与b有相同的年龄}",
        "answer": "根据练习 9(f(x) 是 x 的年龄)，这是一个等价关系。",
        "answer_symbols": []
    },
    "9.5 2 b)": {
        "question": "下面是定义在所有人的集合上的关系，其中哪些是等价关系？给出其他关系所缺少的等价关系应具有的性质。{(a, b) | a与b有相同的父母}",
        "answer": "根据练习 9(f(x) 是 x 的父母)，这是一个等价关系。",
        "answer_symbols": []
    },
    "9.5 2 c)": {
        "question": "下面是定义在所有人的集合上的关系，其中哪些是等价关系？给出其他关系所缺少的等价关系应具有的性质。{(a, b) | a与b有一个相同的父亲或者一个相同的母亲}",
        "answer": "这不是一个等价关系，因为它可能不是传递的。（假设涉及的是生物学上的亲子关系，所以 A 可能是 W 和 X 的孩子，B 可能是 X 和 Y 的孩子，C 可能是 Y 和 Z 的孩子。那么 A 与 B 相关，B 与 C 相关，但 A 不与 C 相关。）",
        "answer_symbols": [
            "≠"
        ]
    },
    "9.5 2 d)": {
        "question": "下面是定义在所有人的集合上的关系，其中哪些是等价关系？给出其他关系所缺少的等价关系应具有的性质。{(a, b) | a与b相识}",
        "answer": "这不是一个等价关系，因为它显然不是传递的。",
        "answer_symbols": []
    },
    "9.5 2 e)": {
        "question": "下面是定义在所有人的集合上的关系，其中哪些是等价关系？给出其他关系所缺少的等价关系应具有的性质。{(a, b) | a与b说同一种语言}",
        "answer": "同样，就像在 (c) 部分一样，这不是传递的。",
        "answer_symbols": []
    },
    "9.5 4": {
        "question": "定义3个在你们离散数学班中学生集合上的等价关系，要求与书中讨论的关系不同，确定关于这些等价关系的等价类。",
        "answer": "一种关系是 a 和 b 如果他们在同一个美国州出生（“不在美国州”算作一个州）。这里等价类是非空的学生集合，每个州的学生集合。另一个例子是 a 与 b 相关，如果 a 和 b 生活了相同数量的完整十年。等价类是所有 10 至 19 岁的人的集合、所有 20 至 29 岁的人的集合等等（这些集合中非空的集合）。第三个例子是 a 与 b 相关，如果 10 是 a 的年龄和 b 的年龄之差的除数，其中“年龄”是指自出生以来的整年数，从开学第一天算起。对于每个 i = 0, 1, ..., 9，有一个等价类（如果它非空），其成员是那些年龄以数字 i 结尾的学生。",
        "answer_symbols": []
    },
    "9.5 5": {
        "question": "在大学校园里的建筑物集合上定义3个等价关系，确定关于这些等价关系的等价类。",
        "answer": "许多答案是可能的。(1) 如果两栋建筑在同一时间开放，则它们是等价的；等价类包括给定年份内开放的所有建筑（只要该年至少有一栋建筑开放）。(2) 如果两栋建筑有相同的故事数，则它们是等价的；等价类包括 1 层建筑的集合、2 层建筑的集合，等等（每个 n 至少有一栋 n 层建筑）。(3) 您在其中上课的每栋建筑都等价于您在其中上课的每栋建筑（包括它自己），而您不在其中上课的每栋建筑都等价于您不在其中上课的每栋建筑（包括它自己）；有两个等价类——您在其中上课的建筑的集合和您不在其中上课的建筑的集合（假设这些是非空的）。",
        "answer_symbols": []
    },
    "9.5 6": {
        "question": "在你们学校拥有的班级集合上定义3个等价关系，确定关于这些等价关系的等价类。",
        "answer": "一种方法是按级别划分班级。在许多学校，课程编号有三位数，第一位数字大致表示课程的级别，因此编号为 100–199 的课程由大一学生修读，200–299 由大二学生修读，依此类推。形式上，如果两个课程编号在百位数上有相同的数字，则这两个课程相关；等价类是所有 100 级别课程的集合、所有 200 级别课程的集合等。第二个例子关注部门。如果两个课程由同一部门开设，则这两个课程等价；例如，MATH 154 与 MATH 372 等价，但与 EGR 141 不等价。等价类是由每个部门开设的所有课程的集合（数学课程集、工程课程集等）。第三个——更自我中心的——分类是将一个等价类设为你成功完成的所有课程，另一个等价类设为所有其他课程。形式上，如果两个课程对问题“我是否成功完成了这门课程？”的回答相同，则这两个课程等价。",
        "answer_symbols": []
    },
    "9.5 7": {
        "question": "证明：定义在所有复合命题集合上的逻辑等价的关系是等价关系。这里T和F的等价类是什么？",
        "answer": "“p 等价于 q”意味着 p 和 q 在它们的真值表中具有相同的条目。R 是自反的，因为 p 与其自身的真值表相同。R 是对称的，因为如果 p 和 q 在它们的真值表中具有相同的条目，那么 q 和 p 也有相同的条目。如果 p 和 q 在它们的真值表中有相同的条目且 q 和 r 在它们的真值表中有相同的条目，那么 p 和 r 也有相同的条目，因此 R 是传递的。T 的等价类是所有重言式的集合；F 的等价类是所有矛盾的集合。",
        "answer_symbols": []
    },
    "9.5 8": {
        "question": "设R是所有的实数集合构成的集合上的关系，SRT当且仅当S和T有相同的基数。证明R是等价关系。集合{0, 1, 2}和Z的等价类是什么？",
        "answer": "Recall (Definition 1 in Section 2.5) that two sets have the same cardinality if there is a bijection (one-to-one and onto function) from one set to the other. We must show that R is reflexive, symmetric, and transitive. - Every set has the same cardinality as itself because of the identity function. - If f is a bijection from S to T, then f^(-1) is a bijection from T to S, so R is symmetric. - Finally, if f is a bijection from S to T and g is a bijection from T to U, then g ∘ f is a bijection from T to U, so R is transitive (see Exercise 33 in Section 2.3). The equivalence class of {1, 2, 3} is the set of all three-element sets of real numbers, including such sets as {4, 25, 1948} and {e, π, √2}. Similarly, [Z] is the set of all infinite countable sets of real numbers (see Section 2.5), such as the set of natural numbers, the set of rational numbers, and the set of the prime numbers, but not including the set {1, 2, 3} (it’s too small) or the set of all real numbers (it’s too big). See Section 2.5 for more on countable sets.",
        "answer_symbols": [
            "-",
            "^",
            "(",
            ")",
            "→",
            "∘"
        ]
    },
    "9.5 10": {
        "question": "假设A是非空集合，R是A上的等价关系，证明存在以A作为定义域的函数f，使得(x, y) ∈ R当且仅当f(x) = f(y)。",
        "answer": "The function that sends each x ∈ A to its equivalence class [x] is obviously such a function.",
        "answer_symbols": [
            "∈",
            "["
        ]
    },
    "9.5 11": {
        "question": "设R是长度至少为3的所有位串的集合上的关系，R由有序对(x, y)构成，其中x和y是长度至少为3的位串，且它们的前3位相同。证明R是等价关系。",
        "answer": "令 x 是长度为 3 或更长的位字符串。因为 x 与其自身在前三个位上一致，(x, x) ∈ R。因此，R 是自反的。假设 (x, y) ∈ R。则 x 和 y 在前三个位上一致。因此，y 和 x 在前三个位上一致。因此，(y, x) ∈ R。如果 (x, y) 和 (y, z) 在 R 中，则 x 和 y 在前三个位上一致，y 和 z 也在前三个位上一致。因此，x 和 z 在前三个位上一致。因此，(x, z) ∈ R。因此，R 是传递的。",
        "answer_symbols": [
            "∈",
            "="
        ]
    },
    "9.5 12": {
        "question": "设 R 是长度至少为 3 的所有位串的集合上的关系，R 由有序对 (x, y) 构成，其中 x 和 y 是长度至少为 3 的位串，且除了在它们的前 3 位有可能不同之外其他位都相同。证明 R 是等价关系。",
        "answer": "This follows from Exercise 9, where f is the function that takes a bit string of length n ≥ 3 to its last n − 3 bits.",
        "answer_symbols": [
            "≥",
            "−"
        ]
    },
    "9.5 13": {
        "question": "设 R 是长度至少为 3 的所有位串的集合上的关系，R 由有序对 (x, y) 构成，其中 x 和 y 在它们的第 1 位和第 3 位相同。证明 R 是等价关系。",
        "answer": "这由练习 9 推出，其中 f 是将长度为 3 或更长的位字符串映射到其有序对的第一个分量为第一个位，第二个分量为第三个位的函数。",
        "answer_symbols": []
    },
    "9.5 14": {
        "question": "设 R 是由有序对 (x, y) 构成的关系，x 和 y 是大小写的英文字母，而且对每一个正整数 n，x 和 y 的第 n 个字符是相同的大写或小写字母。证明 R 是等价关系。",
        "answer": "This follows from Exercise 9, where f is the function that takes a string of uppercase and lowercase English letters and changes all the lower case letters to their uppercase equivalents (and leaves the uppercase letters unchanged).",
        "answer_symbols": []
    },
    "9.5 15": {
        "question": "设 R 是定义在正整数的有序对构成的集合上的关系，((a, b), (c, d)) ∈ R 当且仅当 a + d = b + c。证明 R 是等价关系。",
        "answer": "对于自反性，((a, b), (a, b)) ∈ R 因为 a + b = b + a。对于对称性，如果 ((a, b), (c, d)) ∈ R，则 a + d = b + c，所以 c + b = d + a，所以 ((c, d), (a, b)) ∈ R。对于传递性，如果 ((a, b), (c, d)) ∈ R 且 ((c, d), (e, f)) ∈ R，则 a + d = b + c 且 c + e = d + f，所以 a + d + c + e = b + c + d + f，所以 a + e = b + f，所以 ((a, b), (e, f)) ∈ R。一个更简单的解法是注意到通过代数，给定条件等同于 f((a, b)) = f((c, d))，其中 f((x, y)) = x - y；因此，由练习 9 这是一个等价关系。",
        "answer_symbols": [
            "∈",
            "+",
            "=",
            "-",
            "→"
        ]
    },
    "9.5 16": {
        "question": "设 R 是定义在正整数的有序对构成的集合上的关系，((a, b), (c, d)) ∈ R 当且仅当 ad = bc。证明 R 是等价关系。",
        "answer": "This follows from Exercise 9, where f is the function from the set of pairs of positive integers to the set of positive rational numbers that takes (a, b) to a/b, since clearly ad = bc if and only if a/b = c/d. If we want an explicit proof, we can argue as follows. For reflexivity, ((a, b), (a, b)) ∈ R because a · b = b · a. If ((a, b), (c, d)) ∈ R then ad = bc, which also means that cb = da, so ((c, d), (a, b)) ∈ R; this tells us that R is symmetric. Finally, if ((a, b), (c, d)) ∈ R and ((c, d), (e, f)) ∈ R then ad = bc and cf = de. Multiplying these equations gives acdf = bcde, and since all these numbers are nonzero, we have af = be, so ((a, b), (e, f)) ∈ R; this tells us that R is transitive.",
        "answer_symbols": [
            "∈",
            "(",
            ")",
            "/",
            "=",
            "·",
            "→"
        ]
    },
    "9.5 18 a)": {
        "question": "设 n 是正整数，R 是定义在实系数多项式集合上的关系，R 由所有的有序对 (f, g) 构成，其中 f^⁽^ⁿ^⁾(x) = g^⁽^ⁿ^⁾(x) [这里的 f^⁽^ⁿ^⁾(x) 是 f(x) 的 n 阶导数]，证明 R 是等价关系。",
        "answer": "This follows from Exercise 9, where the function f from the set of polynomials to the set of polynomials is the operator that takes the derivative n times—i.e., f of a function g is the function g^(n). The best way to think about this is that any relation defined by a statement of the form “a and b are equivalent if they have the same whatever” is an equivalence relation. Here “whatever” is “nth derivative”; in the general situation of Exercise 9, “whatever” is “function value under f.”",
        "answer_symbols": [
            "(",
            ")",
            "→",
            "^"
        ]
    },
    "9.5 18 b)": {
        "question": "什么函数与函数 f(x) = x^³ 在同一个等价类中，其中 n = 3？",
        "answer": "The third derivative of x^4 is 24x. Since the third derivative of a polynomial of degree 2 or less is 0, the polynomials of the form x^4 + ax^2 + bx + c have the same third derivative. Thus these are the functions in the same equivalence class as f.",
        "answer_symbols": [
            "^",
            "+"
        ]
    },
    "9.5 19": {
        "question": "设 R 是定义在所有 URL (或 Web 地址) 集合上的关系，x R y 当且仅当 x 的 Web 页与在 y 的 Web 页相同，证明 R 是等价关系。",
        "answer": "这由练习 9 推出，其中函数 f 从所有 URL 的集合到所有网页的集合是将每个 URL 映射到该 URL 的网页的函数。",
        "answer_symbols": [
            "→"
        ]
    },
    "9.5 20": {
        "question": "设 R 是定义在已经访问过某个特定 Web 页的所有人的集合上的关系，x R y 当且仅当网页浏览器 x 和网页浏览器 y 从这个网页开始按照同样的一组链接进行访问 (从一个 Web 页跳转到另一个 Web 页直到他们停止使用 Web)。证明 R 是等价关系。",
        "answer": "This follows from Exercise 9, where the function f from the set of people to the set of Web-traversing behaviors starting at the given particular Web page takes the person to the behavior that person exhibited.",
        "answer_symbols": []
    },
    "9.5 25": {
        "question": "设 R 是定义在所有位串集合上的关系，s R t 当且仅当 s 和 t 包含相同个数的 1，证明 R 是等价关系。",
        "answer": "R 是自反的，因为位字符串 s 有相同的 1 的数量。R 是对称的，因为 s 和 t 有相同的 1 的数量意味着 t 和 s 也有相同的 1 的数量。R 是传递的，因为 s 和 t 有相同的 1 的数量，t 和 u 有相同的 1 的数量意味着 s 和 u 也有相同的 1 的数量。",
        "answer_symbols": [
            "=",
            "∈"
        ]
    },
    "9.5 26": {
        "question": "练习 1 中的等价关系的等价类是什么？",
        "answer": "Only parts (a) and (c) are equivalence relations. In part (a), each element is in its own equivalence class. In part (c), elements 1 and 2 are in one equivalence class, and 0 and 3 are each in their own equivalence class.",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "9.5 28": {
        "question": "练习 3 中的等价关系的等价类是什么？",
        "answer": "Only parts (a) and (d) are equivalence relations. In part (a), for each n in Z, there is an equivalence class containing all functions that take the value n at 1. In part (d), there is no good way to describe the equivalence classes. For each function f: Z → Z, there is an equivalence class containing all those functions g such that there exists a constant C such that g(n) = f(n) + C for all n in Z.",
        "answer_symbols": [
            "→",
            "∈",
            "=",
            "+",
            "∀"
        ]
    },
    "9.5 29": {
        "question": "对于练习 25 中的等价关系，位串 011 的等价类是什么？",
        "answer": "所有恰好有两个 1 的位字符串的集合",
        "answer_symbols": []
    },
    "9.5 30 a)": {
        "question": "对于练习 11 中的等价关系，下列位串的等价类是什么？(a) 010",
        "answer": "All strings starting with 010",
        "answer_symbols": []
    },
    "9.5 30 b)": {
        "question": "对于练习 11 中的等价关系，下列位串的等价类是什么？(b) 1011",
        "answer": "All strings starting with 101",
        "answer_symbols": []
    },
    "9.5 30 c)": {
        "question": "对于练习 11 中的等价关系，下列位串的等价类是什么？(c) 11111",
        "answer": "All strings starting with 111",
        "answer_symbols": []
    },
    "9.5 30 d)": {
        "question": "对于练习 11 中的等价关系，下列位串的等价类是什么？(d) 01010101",
        "answer": "All strings starting with 010",
        "answer_symbols": []
    },
    "9.5 31 a)": {
        "question": "对于练习12中的等价关系，练习30中的位串的等价类是什么。(a) 010",
        "answer": "所有长度为 3 的位字符串的集合",
        "answer_symbols": []
    },
    "9.5 31 b)": {
        "question": "对于练习12中的等价关系，练习30中的位串的等价类是什么。(b) 1011",
        "answer": "所有以 1 结尾的长度为 4 的位字符串的集合",
        "answer_symbols": []
    },
    "9.5 31 c)": {
        "question": "对于练习12中的等价关系，练习30中的位串的等价类是什么。(c) 11111",
        "answer": "所有以 11 结尾的长度为 5 的位字符串的集合",
        "answer_symbols": []
    },
    "9.5 31 d)": {
        "question": "对于练习12中的等价关系，练习30中的位串的等价类是什么。(d) 01010101",
        "answer": "所有以 10101 结尾的长度为 8 的位字符串的集合",
        "answer_symbols": []
    },
    "9.5 32 a)": {
        "question": "对于练习13中的等价关系，练习30中的位串的等价类是什么？(a) 010",
        "answer": "所有以 010 或 000 开头的比特字符串",
        "answer_symbols": []
    },
    "9.5 32 b)": {
        "question": "对于练习13中的等价关系，练习30中的位串的等价类是什么？(b) 1011",
        "answer": "所有以 101 或 111 开头的比特字符串",
        "answer_symbols": []
    },
    "9.5 32 c)": {
        "question": "对于练习13中的等价关系，练习30中的位串的等价类是什么？(c) 11111",
        "answer": "所有以 101 或 111 开头的比特字符串",
        "answer_symbols": []
    },
    "9.5 32 d)": {
        "question": "对于练习13中的等价关系，练习30中的位串的等价类是什么？(d) 01010101",
        "answer": "所有以 000 或 010 开头的比特字符串",
        "answer_symbols": []
    },
    "9.5 34 a)": {
        "question": "对于例5中所有位串集合上的等价关系R_5，练习30中的位串的等价类是什么？(位串s、t在关系R_5下等价，当且仅当s = t或者s和t都至少含有5位，且它们的前5位相同。)(a) 010",
        "answer": "Since the string length is less than 5, its equivalence class contains only itself.",
        "answer_symbols": []
    },
    "9.5 34 b)": {
        "question": "对于例5中所有位串集合上的等价关系R_5，练习30中的位串的等价类是什么？(位串s、t在关系R_5下等价，当且仅当s = t或者s和t都至少含有5位，且它们的前5位相同。)(b) 1011",
        "answer": "This is similar to part (a): [1011]R5 = {1011}.",
        "answer_symbols": [
            "{",
            "}",
            "="
        ]
    },
    "9.5 34 c)": {
        "question": "对于例5中所有位串集合上的等价关系R_5，练习30中的位串的等价类是什么？(位串s、t在关系R_5下等价，当且仅当s = t或者s和t都至少含有5位，且它们的前5位相同。)(c) 11111",
        "answer": "Since the string length is 5, its equivalence class contains all strings starting with 11111.",
        "answer_symbols": []
    },
    "9.5 34 d)": {
        "question": "对于例5中所有位串集合上的等价关系R_5，练习30中的位串的等价类是什么？(位串s、t在关系R_5下等价，当且仅当s = t或者s和t都至少含有5位，且它们的前5位相同。)(d) 01010101",
        "answer": "This is similar to part (c): [01010101]R5 = {01010s | s is any bit string}.",
        "answer_symbols": [
            "{",
            "}",
            "|",
            "→"
        ]
    },
    "9.5 21": {
        "question": "判断有向图中所示的关系是否为等价关系。",
        "answer": "否",
        "answer_symbols": []
    },
    "9.5 22": {
        "question": "判断有向图中所示的关系是否为等价关系。",
        "answer": "We need to observe whether the relation is reflexive (there is a loop at each vertex), symmetric (every edge that appears is accompanied by its antiparallel mate—an edge involving the same two vertices but pointing in the opposite direction), and transitive (paths of length 2 are accompanied by the path of length 1—i.e., edge—between the same two vertices in the same direction). We see that this relation is an equivalence relation, satisfying all three properties. The equivalence classes are {a, d} and {b, c}.",
        "answer_symbols": [
            "}",
            "{",
            ","
        ]
    },
    "9.5 23": {
        "question": "判断有向图中所示的关系是否为等价关系。",
        "answer": "否",
        "answer_symbols": []
    },
    "9.5 24 a)": {
        "question": "判断由下面的 0-1 矩阵表示的关系是否为等价关系。1 1 1 0 1 1 1 1 1",
        "answer": "This is not an equivalence relation, because it is not symmetric.",
        "answer_symbols": []
    },
    "9.5 24 b)": {
        "question": "判断由下面的 0-1 矩阵表示的关系是否为等价关系。1 0 1 0 0 1 0 1 1 0 1 0 0 1 0 1",
        "answer": "This is an equivalence relation; one equivalence class consists of the first and third elements, and the other equivalence class consists of the second and fourth elements.",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "9.5 24 c)": {
        "question": "判断由下面的 0-1 矩阵表示的关系是否为等价关系。1 1 1 0 1 1 1 0 1 1 1 0 0 0 0 1",
        "answer": "This is an equivalence relation; one equivalence class consists of the first, second, and third elements, and the other equivalence class consists of the fourth element.",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "9.5 32": {
        "question": "对于练习 13 中的等价关系，练习 30 中的位串的等价类是什么？",
        "answer": "Since two bit strings are related if and only if they have the same first and third bits, the equivalence class of the bit string xyzt (where x, y, z are bits, t is a bit string) is the set of all bit strings of the form xy'zt', where y' is any bit, t' is any bit string.",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "9.5 33": {
        "question": "对于例 5 中所有位串集合上的等价关系 R_4，练习 30 中的位串的等价类是什么？(位串 s、t 在关系 R_4 下等价，当且仅当 s = t 或者 s 和 t 都至少含有 4 位，且它们的前 4 位相同。)",
        "answer": "每个长度小于四的 15 位字符串都在一个等价类中： [λ]R4 = {λ}, [0]R4 = {0}, [1]R4 = {1}, [00]R4 = {00}, [01]R4 = {01}, ..., [111]R4 = {111}. 剩余的 16 个等价类由长度为 4 的位字符串确定： [0000]R4 = {0000, 00000, 00001, 000000, 000001, 000010, 000011, 0000000, ...}, [0001]R4 = {0001, 00010, 00011, 000100, 000101, 000110, 000111, 0001000, ...}, ..., [1111]R4 = {1111, 11110, 11111, 111100, 111101, 111110, 111111, 1111000, ...}",
        "answer_symbols": [
            "=",
            "{"
        ]
    },
    "9.5 35 a)": {
        "question": "当n为2时，同余类[n]5（即n关于模5同余的等价类）是什么？",
        "answer": "[2]5 = {i | i ≡ 2 (mod 5)} = {..., -8, -3, 2, 7, 12, ...}",
        "answer_symbols": [
            "=",
            "|",
            "≡",
            "(",
            ")",
            "..."
        ]
    },
    "9.5 35 b)": {
        "question": "当n为3时，同余类[n]5（即n关于模5同余的等价类）是什么？",
        "answer": "[3]5 = {i | i ≡ 3 (mod 5)} = {..., -7, -2, 3, 8, 13, ...}",
        "answer_symbols": [
            "=",
            "|",
            "≡",
            "(",
            ")",
            "..."
        ]
    },
    "9.5 35 c)": {
        "question": "当n为6时，同余类[n]5（即n关于模5同余的等价类）是什么？",
        "answer": "[6]5 = {i | i ≡ 6 (mod 5)} = {..., -9, -4, 1, 6, 11, ...}",
        "answer_symbols": [
            "=",
            "|",
            "≡",
            "(",
            ")",
            "..."
        ]
    },
    "9.5 35 d)": {
        "question": "当n为-3时，同余类[n]5（即n关于模5同余的等价类）是什么？",
        "answer": "[-3]5 = {i | i ≡ -3 (mod 5)} = {..., -8, -3, 2, 7, 12, ...}",
        "answer_symbols": [
            "=",
            "|",
            "≡",
            "(",
            ")",
            "..."
        ]
    },
    "9.5 36 a)": {
        "question": "当m为2时，[4]m的同余类是什么？",
        "answer": "{4 + 2n | n ∈ Z} = {..., -2, 0, 2, 4, ...}",
        "answer_symbols": [
            "{",
            "}",
            "|",
            "∈",
            "=",
            "+",
            "..."
        ]
    },
    "9.5 36 b)": {
        "question": "当m为3时，[4]m的同余类是什么？",
        "answer": "{4 + 3n | n ∈ Z} = {..., -2, 1, 4, 7, ...}",
        "answer_symbols": [
            "{",
            "}",
            "|",
            "∈",
            "=",
            "+",
            "..."
        ]
    },
    "9.5 36 c)": {
        "question": "当m为6时，[4]m的同余类是什么？",
        "answer": "{4 + 6n | n ∈ Z} = {..., -2, 4, 10, 16, ...}",
        "answer_symbols": [
            "{",
            "}",
            "|",
            "∈",
            "=",
            "+",
            "..."
        ]
    },
    "9.5 36 d)": {
        "question": "当m为8时，[4]m的同余类是什么？",
        "answer": "{4 + 8n | n ∈ Z} = {..., -4, 4, 12, 20, ...}",
        "answer_symbols": [
            "{",
            "}",
            "|",
            "∈",
            "=",
            "+",
            "..."
        ]
    },
    "9.5 37": {
        "question": "给出每一个模6同余类的描述。",
        "answer": "{6n + k | n ∈ Z} for k ∈ {0, 1, 2, 3, 4, 5}",
        "answer_symbols": [
            "+",
            "|",
            "∈",
            "Z"
        ]
    },
    "9.5 38 a)": {
        "question": "对于练习14中的等价关系，字符串No的等价类是什么？",
        "answer": "{NO, No, nO, no}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "9.5 38 b)": {
        "question": "对于练习14中的等价关系，字符串Yes的等价类是什么？",
        "answer": "{YES, YEs, YeS, Yes, yES, yEs, yeS, yes}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "9.5 38 c)": {
        "question": "对于练习14中的等价关系，字符串Help的等价类是什么？",
        "answer": "{HELP, HELp, HElP, HElp, HeLP, HeLp, HelP, Help, hELP, hELp, hElP, hElp, heLP, heLp, helP, help}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "9.5 39 a)": {
        "question": "对于练习15中的等价关系，(1, 2)的等价类是什么？",
        "answer": "[(1, 2)] = {(a, b) | a - b = -1} = {(1, 2), (3, 4), (4, 5), (5, 6), ...}",
        "answer_symbols": [
            "=",
            "|",
            "-",
            "="
        ]
    },
    "9.5 39 b)": {
        "question": "对于练习15中的等价关系R，解释等价类的含义。[提示：差a-b对应(a, b)。]",
        "answer": "每个等价类可以解释为一个整数（负数、正数或零）；具体来说，[(a, b)] 可以解释为 a - b.",
        "answer_symbols": [
            "-",
            "="
        ]
    },
    "9.5 40 a)": {
        "question": "对于练习16中的等价关系，(1, 2)的等价类是什么？",
        "answer": "According to our observation in Exercise 16, the equivalence class of (1, 2) is the set of all pairs (a, b) such that the fraction a/b equals 1/2.",
        "answer_symbols": [
            "{",
            "}",
            "/",
            "="
        ]
    },
    "9.5 40 b)": {
        "question": "对于练习16中的等价关系R，解释等价类的含义。[提示：比a/b对应(a, b)。]",
        "answer": "Similarly according to our observation, the equivalence class is the positive rational numbers. (In fact, this is a rigorous definition of the rational numbers, which is why fractions are so difficult for children to understand.)",
        "answer_symbols": [
            "{",
            "}",
            "+"
        ]
    },
    "9.5 41 a)": {
        "question": "下面哪些子集族是{1, 2, 3, 4, 5, 6}的划分？（a）{1, 2}, {2, 3, 4}, {4, 5, 6}",
        "answer": "No",
        "answer_symbols": []
    },
    "9.5 41 b)": {
        "question": "下面哪些子集族是{1, 2, 3, 4, 5, 6}的划分？（b）{1}, {2, 3, 6}, {4}, {5}",
        "answer": "Yes",
        "answer_symbols": []
    },
    "9.5 41 c)": {
        "question": "下面哪些子集族是{1, 2, 3, 4, 5, 6}的划分？（c）{2, 4, 6}, {1, 3, 5}",
        "answer": "Yes",
        "answer_symbols": []
    },
    "9.5 41 d)": {
        "question": "下面哪些子集族是{1, 2, 3, 4, 5, 6}的划分？（d）{1, 4, 5}, {2, 6}",
        "answer": "No",
        "answer_symbols": []
    },
    "9.5 42 a)": {
        "question": "下面哪些子集族是{-3, -2, -1, 0, 1, 2, 3}的划分？（a）{-3, -1, 1, 3}, {-2, 0, 2}",
        "answer": "This is a partition, since it satisfies the definition.",
        "answer_symbols": []
    },
    "9.5 42 b)": {
        "question": "下面哪些子集族是{-3, -2, -1, 0, 1, 2, 3}的划分？（b）{-3, -2, -1, 0}, {0, 1, 2, 3}",
        "answer": "This is not a partition, since the subsets are not disjoint.",
        "answer_symbols": []
    },
    "9.5 42 c)": {
        "question": "下面哪些子集族是{-3, -2, -1, 0, 1, 2, 3}的划分？（c）{-3, 3}, {-2, 2}, {-1, 1}, {0}",
        "answer": "This is a partition, since it satisfies the definition.",
        "answer_symbols": []
    },
    "9.5 42 d)": {
        "question": "下面哪些子集族是{-3, -2, -1, 0, 1, 2, 3}的划分？（d）{-3, -2, 2, 3}, {-1, 1}",
        "answer": "This is not a partition, since the union of the subsets leaves out 0.",
        "answer_symbols": []
    },
    "9.5 44 a)": {
        "question": "下面哪些子集族是整数集合的划分？（a）偶数集合与奇数集合。",
        "answer": "This is clearly a partition.",
        "answer_symbols": []
    },
    "9.5 44 b)": {
        "question": "下面哪些子集族是整数集合的划分？（b）正整数集合与负整数集合。",
        "answer": "This is not a partition, since 0 is in neither set.",
        "answer_symbols": []
    },
    "9.5 44 c)": {
        "question": "下面哪些子集族是整数集合的划分？（c）被3整除的整数集合；当被3除时余数为1的整数集合；当被3除时余数为2的整数集合。",
        "answer": "This is a partition by the division algorithm.",
        "answer_symbols": []
    },
    "9.5 44 d)": {
        "question": "下面哪些子集族是整数集合的划分？（d）小于-100的整数集合；绝对值不超过100的整数集合；大于100的整数集合。",
        "answer": "This is a partition, since the second set mentioned is the set of all numbers between -100 and 100, inclusive.",
        "answer_symbols": []
    },
    "9.5 44 e)": {
        "question": "下面哪些子集族是整数集合的划分？（e）不能被3整除的整数集合；偶数集合；当被6除时余数为3的整数集合。",
        "answer": "The first two sets are not disjoint (4 is in both), so this is not a partition.",
        "answer_symbols": []
    },
    "9.5 46 a)": {
        "question": "下面哪些是实数集合的划分?（a）负实数集合、{0}、正实数集合",
        "answer": "This is a partition, since it satisfies the definition.",
        "answer_symbols": []
    },
    "9.5 46 b)": {
        "question": "下面哪些是实数集合的划分?（b）无理数集合、有理数集合",
        "answer": "This is a partition, since it satisfies the definition.",
        "answer_symbols": []
    },
    "9.5 46 c)": {
        "question": "下面哪些是实数集合的划分?（c）区间[k, k+1], k=..., -2, -1, 0, 1, 2, ...",
        "answer": "This is not a partition, since the intervals are not disjoint (they share endpoints).",
        "answer_symbols": []
    },
    "9.5 46 d)": {
        "question": "下面哪些是实数集合的划分?（d）区间(k, k+1), k=..., -2, -1, 0, 1, 2, ...",
        "answer": "This is not a partition, since the union of the subsets leaves out the integers.",
        "answer_symbols": []
    },
    "9.5 46 e)": {
        "question": "下面哪些是实数集合的划分?（e）区间(k, k+1], k=..., -2, -1, 0, 1, 2, ...",
        "answer": "This is a partition, since it satisfies the definition.",
        "answer_symbols": []
    },
    "9.5 46 f)": {
        "question": "下面哪些是实数集合的划分?（f）集合{x+n | n∈Z}, 对所有 x∈[0, 1)",
        "answer": "This is a partition, since it satisfies the definition. Each equivalence class consists of all real numbers with a fixed fractional part.",
        "answer_symbols": []
    },
    "9.5 47 a)": {
        "question": "列出由{0, 1, 2, 3, 4, 5}的划分产生的等价关系中的有序对。{0}, {1, 2}, {3, 4, 5}",
        "answer": "{(0, 0), (1, 1), (1, 2), (2, 1), (2, 2), (3, 3), (3, 4), (3, 5), (4, 3), (4, 4), (4, 5), (5, 3), (5, 4), (5, 5)}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "9.5 47 b)": {
        "question": "列出由{0, 1, 2, 3, 4, 5}的划分产生的等价关系中的有序对。{0, 1}, {2, 3}, {4, 5}",
        "answer": "{(0, 0), (0, 1), (1, 0), (1, 1), (2, 2), (2, 3), (3, 2), (3, 3), (4, 4), (4, 5), (5, 4), (5, 5)}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "9.5 47 c)": {
        "question": "列出由{0, 1, 2, 3, 4, 5}的划分产生的等价关系中的有序对。{0, 1, 2}, {3, 4, 5}",
        "answer": "{(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2), (3, 3), (3, 4), (3, 5), (4, 3), (4, 4), (4, 5), (5, 3), (5, 4), (5, 5)}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "9.5 47 d)": {
        "question": "列出由{0, 1, 2, 3, 4, 5}的划分产生的等价关系中的有序对。{0}, {1}, {2}, {3}, {4}, {5}",
        "answer": "{(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5)}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "9.5 48 a)": {
        "question": "列出由{a, b, c, d, e, f, g}的划分产生的等价关系中的有序对。{a, b}, {c, d}, {e, f, g}",
        "answer": "{(a, a), (a, b), (b, a), (b, b), (c, c), (c, d), (d, c), (d, d), (e, e), (e, f), (e, g), (f, e), (f, f), (f, g), (g, e), (g, f), (g, g)}",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "9.5 48 b)": {
        "question": "列出由{a, b, c, d, e, f, g}的划分产生的等价关系中的有序对。{a}, {b}, {c, d}, {e, f}, {g}",
        "answer": "{(a, a), (b, b), (c, c), (c, d), (d, c), (d, d), (e, e), (e, f), (f, e), (f, f), (g, g)}",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "9.5 48 c)": {
        "question": "列出由{a, b, c, d, e, f, g}的划分产生的等价关系中的有序对。{a, b, c, d}, {e, f, g}",
        "answer": "{(a, a), (a, b), (a, c), (a, d), (b, a), (b, b), (b, c), (b, d), (c, a), (c, b), (c, c), (c, d), (d, a), (d, b), (d, c), (d, d), (e, e), (e, f), (e, g), (f, e), (f, f), (f, g), (g, e), (g, f), (g, g)}",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "9.5 48 d)": {
        "question": "列出由{a, b, c, d, e, f, g}的划分产生的等价关系中的有序对。{a, c, e, g}, {b, d}, {f}",
        "answer": "{(a, a), (a, c), (a, e), (a, g), (c, a), (c, c), (c, e), (c, g), (e, a), (e, c), (e, e), (e, g), (g, a), (g, c), (g, e), (g, g), (b, b), (b, d), (d, b), (d, d), (f, f)}",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "9.5 49": {
        "question": "证明：由模 6 同余类构成的划分是模 3 同余类构成的划分的加细。",
        "answer": "[0]6 ⊆ [0]3, [1]6 ⊆ [1]3, [2]6 ⊆ [2]3, [3]6 ⊆ [0]3, [4]6 ⊆ [1]3, [5]6 ⊆ [2]3",
        "answer_symbols": [
            "⊆"
        ]
    },
    "9.5 50": {
        "question": "证明：对于住在美国的人的集合，由住在同一郡或教区的人的子集构成的划分是住在同一州的人的子集构成划分的加细。",
        "answer": "We need to show that every equivalence class consisting of people living in the same county (or parish) and same state is contained in an equivalence class of all people living in the same state. This is clear. The equivalence class of all people living in county c in state s is a subset of the set of people living in state s.",
        "answer_symbols": [
            "⊆"
        ]
    },
    "9.5 51": {
        "question": "证明：对于 16 位的位串集合，最后 8 位相同的位串的等价类所构成的划分是由最后 4 位相同的位串的等价类所构成的划分的加细。",
        "answer": "设 A 是第一个划分中的一个集合。选择 A 中的一个特定元素 x。与 x 在最后四位上一致的所有长度为 16 的位字符串集是第二个划分中的一个集合，显然 A 中的每个字符串都在该集合中。",
        "answer_symbols": []
    },
    "9.5 52": {
        "question": "证明：由等价关系 Rn 对应的位串等价类构成的所有位串的划分是由等价关系 R3 对应的位串等价类构成的划分的加细。",
        "answer": "We are asked to show that every equivalence class for R4 is a subset of some equivalence class for R3. Let [y]R4 be an arbitrary equivalence class for R4. We claim that [y]R4 ⊆ [y]R3; proving this claim finishes the proof. To show that one set is a subset of another set, we choose an arbitrary bit string x in the first set and show that it is also an element of the second set. In this case, since y ∈ [x]R4, we know that y is equivalent to x under R4, that is, that either y = x or y and x are each at least 4 bits long and agree on their first 4 bits. Because strings that are at least 4 bits long and agree on their first 4 bits are also at least 3 bits long and agree on their first 3 bits, we know that either y = x or y and x are each at least 3 bits long and agree on their first 3 bits. This means that y is equivalent to x under R3, that is, that y ∈ [x]R3.",
        "answer_symbols": [
            "⊆",
            "∈"
        ]
    },
    "9.5 53": {
        "question": "证明：由等价关系 R3 对应的标识符等价类构成的 C 语言中所有标识符的划分是由等价关系 R8 对应的标识符等价类构成的划分的加细。（旧的 C 语言编译器只要多个标识符的前 8 个字符相同就将它们视为相同，而标准 C 的编译器需要多个标识符的前 31 个字符相同才将它们视为相同。）",
        "answer": "我们声称每个等价类 [x]R31 是等价类 [x]R8 的子集。为此，选择任意元素 y ∈ [x]R31。那么 y 在 R31 下与 x 等价，因此要么 y = x 要么 y 和 x 都至少有 31 个字符并且前 31 个字符相同。由于至少有 31 个字符并且前 31 个字符相同的字符串必定至少有 8 个字符并且前 8 个字符相同，我们知道要么 y = x 要么 y 和 x 都至少有 8 个字符并且前 8 个字符相同。这意味着 y 在 R8 下与 x 等价，所以 y ∈ [x]R8。",
        "answer_symbols": [
            "⊆",
            "=",
            "∈"
        ]
    },
    "9.5 54": {
        "question": "假设 R1 和 R2 是定义在集合 A 上的等价关系，P1 和 P2 分别是对应于 R1 和 R2 的划分。证明 R1≌R2，当且仅当 P1 是 P2 的加细。",
        "answer": "First, suppose that R1 ⊆ R2. We must show that P1 is a refinement of P2. Let [a]R1 be an equivalence class in P1. We must show that [a]R1 is contained in an equivalence class in P2. In fact, we will show that [a]R1 ⊆ [a]R2. To this end, let b ∈ [a]R1. Then (a, b) ∈ R1 ⊆ R2. Therefore b ∈ [a]R2, as desired. Conversely, suppose that P1 is a refinement of P2. Since a ∈ [a]R2, the definition of \"refinement\" forces [a]R1 ⊆ [a]R2 for all a ∈ A. This means that for all b ∈ A we have (a, b) ∈ R1 → (a, b) ∈ R2; in other words, R1 ⊆ R2.",
        "answer_symbols": [
            "⊆",
            "∈",
            "→"
        ]
    },
    "9.5 55": {
        "question": "求出在集合{a, b, c, d, e}上包含关系{(a, b), (a, c), (d, e)}的最小的等价关系。",
        "answer": "{(a, a), (a, b), (a, c), (b, a), (b, b), (b, c), (c, a), (c, b), (c, c), (d, d), (d, e), (e, d), (e, e)}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "9.5 57 a)": {
        "question": "考虑例 2 中的等价关系，即 R={(x, y) | x−y 是整数}。关于这个等价关系的 1 的等价类是什么?",
        "answer": "Z",
        "answer_symbols": []
    },
    "9.5 57 b)": {
        "question": "考虑例 2 中的等价关系，即 R={(x, y) | x−y 是整数}。关于这个等价关系的 1/2 的等价类是什么?",
        "answer": "{n + 21 | n ∈ Z}",
        "answer_symbols": [
            "+",
            "|",
            "∈",
            "Z"
        ]
    },
    "9.5 59 a)": {
        "question": "设 R 是定义在 2×2 棋盘的所有涂色集合上的关系，其中 4 个方格中的每一个可以被涂成红色或蓝色。设 C1 和 C2 是被这样涂色的 2×2 棋盘，(C1, C2)属于 R 当且仅当 C2 可以由旋转 C1 或旋转 C1 然后再翻转 C1 得到。证明 R 是等价关系。",
        "answer": "R 是自反的，因为任何着色都可以通过 360 度旋转从自身获得。要看到 R 是对称和传递的，使用每个旋转是两个反射的组合这一事实，反之亦然，两个反射的组合是一个旋转。因此，(C1, C2) 属于 R 当且仅当 C2 可以通过反射的组合从 C1 获得。所以如果 (C1, C2) 属于 R，那么 (C2, C1) 也属于 R，因为反射组合的逆也是反射组合（顺序相反）。因此，R 是对称的。要看到 R 是传递的，假设 (C1, C2) 和 (C2, C3) 属于 R。取每种情况下的反射组合，得到一个反射组合，表明 (C1, C3) 属于 R。",
        "answer_symbols": [
            "∈",
            "→",
            "↔",
            "≡"
        ]
    },
    "9.5 59 b)": {
        "question": "设 R 是定义在 2×2 棋盘的所有涂色集合上的关系，其中 4 个方格中的每一个可以被涂成红色或蓝色。设 C1 和 C2 是被这样涂色的 2×2 棋盘，(C1, C2)属于 R 当且仅当 C2 可以由旋转 C1 或旋转 C1 然后再翻转 C1 得到。R 的等价类是什么？",
        "answer": "我们用长度为四的序列表示着色，r 和 b 分别表示红色和蓝色。我们列出表示左上角、右上角、左下角和右下角的颜色的字母，按此顺序。等价类是：{rrrr}, {bbbb}, {rrrb, rrbr, rbrr, brrr}, {bbbr, bbrb, brbb, rbbb}, {rbbr, brrb}, {rrbb, brbr, bbrr, rbrb}.",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "9.5 61": {
        "question": "通过列举说明定义在 3 个元素的集合上的不同的等价关系的个数。",
        "answer": "5",
        "answer_symbols": []
    },
    "9.5 63": {
        "question": "当我们构造一个关系的自反闭包的对称闭包的传递闭包时，一定能得到一个等价关系吗？",
        "answer": "Yes",
        "answer_symbols": []
    },
    "9.5 65": {
        "question": "假设我们使用定理 2 从一个等价关系 R 构造一个划分 P。如果再次使用定理 2 从 P 构造一个等价关系，那么得到的等价关系 R′ 是什么？",
        "answer": "R",
        "answer_symbols": []
    },
    "9.5 67": {
        "question": "设计一个算法，找出包含一个给定关系的最小的等价关系。",
        "answer": "首先形成 R 的自反闭包，然后形成自反闭包的对称闭包，最后形成对称闭包的自反闭包的传递闭包。",
        "answer_symbols": []
    },
    "9.5 69": {
        "question": "用练习 68 求 n 元素集合上的不同等价关系的个数，其中 n 是不超过 10 的正整数。",
        "answer": "p(0) = 1, p(1) = 1, p(2) = 2, p(3) = 5, p(4) = 15, p(5) = 52, p(6) = 203, p(7) = 877, p(8) = 4140, p(9) = 21147, p(10) = 115975",
        "answer_symbols": [
            "=",
            ","
        ]
    },
    "9.6 1 a)": {
        "question": "以下这些定义在集合 {0, 1, 2, 3} 上的关系，哪些是偏序的？如果不是偏序的，请给出它缺少偏序的哪些性质。(a) {(0, 0), (1, 1), (2, 2), (3, 3)}",
        "answer": "Is a partial ordering",
        "answer_symbols": []
    },
    "9.6 1 b)": {
        "question": "以下这些定义在集合 {0, 1, 2, 3} 上的关系，哪些是偏序的？如果不是偏序的，请给出它缺少偏序的哪些性质。(b) {(0, 0), (1, 1), (2, 0), (2, 2), (2, 3), (3, 3)}",
        "answer": "Not antisymmetric, not transitive",
        "answer_symbols": []
    },
    "9.6 1 c)": {
        "question": "以下这些定义在集合 {0, 1, 2, 3} 上的关系，哪些是偏序的？如果不是偏序的，请给出它缺少偏序的哪些性质。(c) {(0, 0), (1, 1), (1, 2), (2, 2), (3, 3)}",
        "answer": "Is a partial ordering",
        "answer_symbols": []
    },
    "9.6 1 d)": {
        "question": "以下这些定义在集合 {0, 1, 2, 3} 上的关系，哪些是偏序的？如果不是偏序的，请给出它缺少偏序的哪些性质。(d) {(0, 0), (1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)}",
        "answer": "Is a partial ordering",
        "answer_symbols": []
    },
    "9.6 1 e)": {
        "question": "以下这些定义在集合 {0, 1, 2, 3} 上的关系，哪些是偏序的？如果不是偏序的，请给出它缺少偏序的哪些性质。(e) {(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 2), (3, 3)}",
        "answer": "Not antisymmetric, not transitive",
        "answer_symbols": []
    },
    "9.6 2 a)": {
        "question": "以下这些定义在集合 {0, 1, 2, 3} 上的关系，哪些是偏序的？如果不是偏序的，请给出它缺少偏序的哪些性质。(a) {(0, 0), (2, 2), (3, 3)}",
        "answer": "这个关系不是自反的，因为 1 不与自己相关。因此 R 不是偏序关系。这个关系是反对称的，因为 a 与 b 相关的唯一方式是 a 等于 b。同样，这个关系是传递的，因为如果 a 与 b 相关，b 与 c 相关，则 a 必须等于 b 和 c，所以 a 与 c 相关。",
        "answer_symbols": [
            "≠",
            "∈"
        ]
    },
    "9.6 2 b)": {
        "question": "以下这些定义在集合 {0, 1, 2, 3} 上的关系，哪些是偏序的？如果不是偏序的，请给出它缺少偏序的哪些性质。(b) {(0, 0), (1, 1), (2, 0), (2, 2), (2, 3), (3, 3)}",
        "answer": "这是一个偏序关系，因为它具有自反性，并且 (2, 0) 和 (2, 3) 不会引入反对称性或传递性的违反。",
        "answer_symbols": []
    },
    "9.6 2 c)": {
        "question": "以下这些定义在集合 {0, 1, 2, 3} 上的关系，哪些是偏序的？如果不是偏序的，请给出它缺少偏序的哪些性质。(c) {(0, 0), (1, 1), (1, 2), (2, 2), (3, 3)}",
        "answer": "这不是一个偏序关系，因为它不具有传递性：3 R 1 且 1 R 2，但 3 不与 2 相关。它是自反的，并且 (1, 2) 和 (3, 1) 不会引入反对称性的违反。",
        "answer_symbols": [
            "R"
        ]
    },
    "9.6 2 d)": {
        "question": "以下这些定义在集合 {0, 1, 2, 3} 上的关系，哪些是偏序的？如果不是偏序的，请给出它缺少偏序的哪些性质。(d) {(0, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 2), (2, 3), (3, 0), (3, 3)}",
        "answer": "这不是一个偏序关系，因为它不具有传递性：1 R 2 且 2 R 0，但 1 不与 0 相关。它是自反的，并且非自反对不会引入反对称性的违反。",
        "answer_symbols": [
            "R"
        ]
    },
    "9.6 2 e)": {
        "question": "以下这些定义在集合 {0, 1, 2, 3} 上的关系，哪些是偏序的？如果不是偏序的，请给出它缺少偏序的哪些性质。(e) {(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 2), (3, 3)}",
        "answer": "该关系显然是自反的，但它不是反对称的（0 R 1 且 1 R 0，但 0 ≠ 1）也不是传递的（2 R 0 且 0 R 1，但 2 不与 1 相关）。",
        "answer_symbols": [
            "R",
            "≠"
        ]
    },
    "9.6 3 a)": {
        "question": "设 a 和 b 是人，S 是全世界所有人构成的集合，(a, b) ∈ R。请问 (S, R) 是否为偏序集，如果(a) a 比 b 的个子高",
        "answer": "No",
        "answer_symbols": []
    },
    "9.6 3 b)": {
        "question": "设 a 和 b 是人，S 是全世界所有人构成的集合，(a, b) ∈ R。请问 (S, R) 是否为偏序集，如果(b) a 不比 b 高",
        "answer": "No",
        "answer_symbols": []
    },
    "9.6 3 c)": {
        "question": "设 a 和 b 是人，S 是全世界所有人构成的集合，(a, b) ∈ R。请问 (S, R) 是否为偏序集，如果(c) a = b 或 a 是 b 的祖先",
        "answer": "Yes",
        "answer_symbols": []
    },
    "9.6 4 a)": {
        "question": "设 a 和 b 是人，S 是全世界所有人构成的集合，(a, b) ∈ R。请问 (S, R) 是否为偏序集，如果(a) a 不比 b 个子矮",
        "answer": "由于显然存在身高相同但不相等的人（无论高度测量到什么精度），这个关系不是反对称的，所以 (S, R) 不能是偏序集。",
        "answer_symbols": [
            "R",
            "≠"
        ]
    },
    "9.6 4 b)": {
        "question": "设 a 和 b 是人，S 是全世界所有人构成的集合，(a, b) ∈ R。请问 (S, R) 是否为偏序集，如果(b) a 的体重比 b 重",
        "answer": "由于没有人比自己更重，这个关系不是自反的，所以 (S, R) 不能是偏序集。",
        "answer_symbols": []
    },
    "9.6 4 c)": {
        "question": "设 a 和 b 是人，S 是全世界所有人构成的集合，(a, b) ∈ R。请问 (S, R) 是否为偏序集，如果(c) a = b 或 a 是 b 的后代",
        "answer": "这是一个偏序集。R 的定义中的等式条款保证了 R 是自反的。为了检查反对称性和传递性，只需考虑不相等的元素（这些规则对于相等的元素是平凡成立的）。如果 a 是 b 的后代，那么 b 不能是 a 的后代（因为后代需要在任何祖先之后出生），所以这个关系是空洞地反对称的。如果 a 是 b 的后代，b 是 c 的后代，那么根据“后代”的定义，我们知道 a 是 c 的后代；因此 R 是传递的。",
        "answer_symbols": [
            "R"
        ]
    },
    "9.6 4 d)": {
        "question": "设 a 和 b 是人，S 是全世界所有人构成的集合，(a, b) ∈ R。请问 (S, R) 是否为偏序集，如果(d) a 和 b 没有共同的朋友",
        "answer": "这个关系不是自反的，因为任何人和他的朋友有共同的朋友。",
        "answer_symbols": []
    },
    "9.6 5 a)": {
        "question": "下面哪些是偏序集？(a) (ℤ, =)",
        "answer": "Yes",
        "answer_symbols": []
    },
    "9.6 5 b)": {
        "question": "下面哪些是偏序集？(b) (ℤ, ≠)",
        "answer": "No",
        "answer_symbols": []
    },
    "9.6 5 c)": {
        "question": "下面哪些是偏序集？(c) (ℤ, ≥)",
        "answer": "Yes",
        "answer_symbols": []
    },
    "9.6 5 d)": {
        "question": "下面哪些是偏序集？(d) (ℤ, ≮)",
        "answer": "No",
        "answer_symbols": []
    },
    "9.6 6 a)": {
        "question": "下面哪些是偏序集？(a) (ℝ, =)",
        "answer": "任何集合上的等价关系满足所有三个条件，因此是一个偏序关系。（这是最小的偏序关系；自反性保证每个偏序关系至少包含所有的 (a, a) 对。）",
        "answer_symbols": []
    },
    "9.6 6 b)": {
        "question": "下面哪些是偏序集？(b) (ℝ, <)",
        "answer": "这不是一个偏序集，因为该关系不是自反的，尽管它是反对称的和传递的。任何这种关系都可以通过添加所有的 (a, a) 对变成一个偏序关系。",
        "answer_symbols": []
    },
    "9.6 6 c)": {
        "question": "下面哪些是偏序集？(c) (ℝ, ≤)",
        "answer": "这是一个偏序集，非常类似于例 1。",
        "answer_symbols": []
    },
    "9.6 6 d)": {
        "question": "下面哪些是偏序集？(d) (ℝ, ≠)",
        "answer": "这不是一个偏序集，因为该关系不是自反的，不是反对称的，也不是传递的（缺少其中任何一个属性就足以给出否定的答案）。",
        "answer_symbols": []
    },
    "9.6 7 a)": {
        "question": "确定以下 0-1 矩阵表示的关系是否为偏序。(a) [1 1 1; 1 1 0; 0 0 1]",
        "answer": "No",
        "answer_symbols": []
    },
    "9.6 7 b)": {
        "question": "确定以下 0-1 矩阵表示的关系是否为偏序。(b) [1 1 1; 0 1 0; 0 0 1]",
        "answer": "Yes",
        "answer_symbols": []
    },
    "9.6 7 c)": {
        "question": "确定以下 0-1 矩阵表示的关系是否为偏序。(c) [1 1 1 0; 0 1 1 0; 0 0 1 1; 1 1 0 1]",
        "answer": "No",
        "answer_symbols": []
    },
    "9.6 8 a)": {
        "question": "确定由下面的 0-1 矩阵表示的关系是否为偏序。(a) [1 1 1 0; 0 1 1 0; 0 0 1 1; 1 1 0 1]",
        "answer": "这个关系是 {(1, 1)，(1, 3)，(2, 1)，(2, 2)，(3, 3)}。很明显，它是自反和反对称的。唯一可能影响传递性的非对角线对是 (2, 1) 和 (1, 3)。如果这个关系是传递的，那么我们还需要关系中的 (2, 3) 对。因为它不在那里，所以这个关系不是一个偏序。",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            ",",
            "∈"
        ]
    },
    "9.6 9": {
        "question": "在练习9～11中确定有向图所表示的关系是否为偏序。",
        "answer": "No",
        "answer_symbols": []
    },
    "9.6 10": {
        "question": "在练习9～11中确定有向图所表示的关系是否为偏序。",
        "answer": "这个关系不是传递的（从 c 到 b 没有箭头），所以它不是一个偏序。",
        "answer_symbols": [
            "→"
        ]
    },
    "9.6 11": {
        "question": "在练习9～11中确定有向图所表示的关系是否为偏序。",
        "answer": "Yes",
        "answer_symbols": []
    },
    "9.6 12": {
        "question": "设(S, R)是偏序集。证明：(S, R^⁻¹)也是偏序集，其中R^⁻¹是R的逆。偏序集(S, R^⁻¹)称为(S, R)的对偶。",
        "answer": "这直接从定义中得出。显然，如果 R 是自反的，那么 R−1 也是自反的。对于反对称性，假设 (a, b) 属于 R−1 且 a 不等于 b。那么 (b, a) 属于 R，所以 (a, b) 不属于 R，从而 (b, a) 也不属于 R−1。最后，如果 (a, b) 属于 R−1 且 (b, c) 属于 R−1，那么 (b, a) 属于 R 且 (c, b) 属于 R，所以 (c, a) 属于 R（因为 R 是传递的），因此 (a, c) 属于 R−1；因此 R−1 是传递的。",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            ",",
            "∈",
            "−",
            "≠",
            "→"
        ]
    },
    "9.6 13 a)": {
        "question": "求下面偏序集的对偶。（a）(0, 1, 2), ≤",
        "answer": "{(0, 0), (1, 0), (1, 1), (2, 0), (2, 1), (2, 2)}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "9.6 13 b)": {
        "question": "求下面偏序集的对偶。（b）(ℤ, ≥)",
        "answer": "(Z, ≤)",
        "answer_symbols": [
            "≤"
        ]
    },
    "9.6 13 c)": {
        "question": "求下面偏序集的对偶。（c）(𝒫(ℤ), ⊆)",
        "answer": "(P(Z), ⊆)",
        "answer_symbols": [
            "⊆"
        ]
    },
    "9.6 13 d)": {
        "question": "求下面偏序集的对偶。（d）(ℤ^⁺, |)",
        "answer": "(Z+, \"is a multiple of\")",
        "answer_symbols": [
            "\""
        ]
    },
    "9.6 14 a)": {
        "question": "在偏序集(ℤ^⁺, |)中，下面哪些元素对是可比的？（a）5, 15",
        "answer": "这些是可比较的，因为 5 | 15。",
        "answer_symbols": [
            "|"
        ]
    },
    "9.6 14 b)": {
        "question": "在偏序集(ℤ^⁺, |)中，下面哪些元素对是可比的？（b）6, 9",
        "answer": "这些是不可比较的，因为它们互不整除。",
        "answer_symbols": [
            "|"
        ]
    },
    "9.6 14 c)": {
        "question": "在偏序集(ℤ^⁺, |)中，下面哪些元素对是可比的？（c）8, 16",
        "answer": "这些是可比较的，因为 8 | 16。",
        "answer_symbols": [
            "|"
        ]
    },
    "9.6 14 d)": {
        "question": "在偏序集(ℤ^⁺, |)中，下面哪些元素对是可比的？（d）7, 7",
        "answer": "这些是可比较的，因为 7 | 7。",
        "answer_symbols": [
            "|"
        ]
    },
    "9.6 15 a)": {
        "question": "在下面的偏序集中，找出两个不可比的元素。（a）(𝒫({0, 1, 2}), ⊆)",
        "answer": "{0} 和 {1}, 例如",
        "answer_symbols": []
    },
    "9.6 15 b)": {
        "question": "在下面的偏序集中，找出两个不可比的元素。（b）({1, 2, 4, 6, 8}, |)",
        "answer": "4 和 6, 例如",
        "answer_symbols": []
    },
    "9.6 16 a)": {
        "question": "设S = {1, 2, 3, 4}。考虑基于通常“小于”关系的字典顺序。（a）找出所有在S×S中小于(2, 3)的序对。",
        "answer": "我们需要第一个坐标小于 2 的数，或者第一个坐标为 2 且第二个坐标小于 3 的数。因此答案是 (1, 1)，(1, 2)，(1, 3)，(1, 4)，(2, 1)，和 (2, 2)。",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            ",",
            "<"
        ]
    },
    "9.6 16 b)": {
        "question": "设S = {1, 2, 3, 4}。考虑基于通常“小于”关系的字典顺序。（b）找出所有在S×S中大于(3, 1)的序对。",
        "answer": "我们需要第一个坐标大于 3 的数，或者第一个坐标为 3 且第二个坐标大于 1 的数。因此答案是 (4, 1)，(4, 2)，(4, 3)，(4, 4)，(3, 2)，(3, 3)，和 (3, 4)。",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            ",",
            ">"
        ]
    },
    "9.6 16 c)": {
        "question": "设S = {1, 2, 3, 4}。考虑基于通常“小于”关系的字典顺序。（c）画出偏序集(S×S, ≤)的哈塞图。",
        "answer": "哈斯图是一条直线，上面有 16 个点，因为这是一个全序。对 (4, 4) 在顶部，(4, 3) 在其下方，(4, 2) 在其下方，依此类推，(1, 1) 在底部。为了节省空间，我们不会实际绘制这张图。",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            ",",
            "→"
        ]
    },
    "9.6 17 a)": {
        "question": "找出下面的n元组的字典顺序。（a）(1, 1, 2), (1, 2, 1)",
        "answer": "(1, 1, 2) < (1, 2, 1)",
        "answer_symbols": [
            "<"
        ]
    },
    "9.6 17 b)": {
        "question": "找出下面的n元组的字典顺序。（b）(0, 1, 2, 3), (0, 1, 3, 2)",
        "answer": "(0, 1, 2, 3) < (0, 1, 3, 2)",
        "answer_symbols": [
            "<"
        ]
    },
    "9.6 17 c)": {
        "question": "找出下面的n元组的字典顺序。（c）(1, 0, 1, 0, 1), (0, 1, 1, 1, 0)",
        "answer": "(0, 1, 1, 1, 0) < (1, 0, 1, 0, 1)",
        "answer_symbols": [
            "<"
        ]
    },
    "9.6 18 a)": {
        "question": "找出下面小写英语字母构成的字符串的字典顺序。（a）quack, quick, quicksilver, quicksand, quacking",
        "answer": "字符串 \"quack\" 排在前面，因为它是一个 \"quacking\" 的初始子字符串，接下来是 \"quacking\"（因为其他三个字符串都以 \"qui\" 开头，而不是 \"qua\"）。类似地，最后三个字符串的顺序是 \"quick\"，\"quicksand\"，\"quicksilver\"。",
        "answer_symbols": [
            "\"",
            "→"
        ]
    },
    "9.6 18 b)": {
        "question": "找出下面小写英语字母构成的字符串的字典顺序。（b）open, opener, opera, operand, opened",
        "answer": "顺序是 \"open\"，\"opened\"，\"opener\"，\"opera\"，\"operand\"。",
        "answer_symbols": [
            "\""
        ]
    },
    "9.6 18 c)": {
        "question": "找出下面小写英语字母构成的字符串的字典顺序。（c）zoo, zero, zoom, zoology, zoological",
        "answer": "顺序是 \"zero\"，\"zoo\"，\"zoological\"，\"zoology\"，\"zoom\"。",
        "answer_symbols": [
            "\""
        ]
    },
    "9.6 19": {
        "question": "找出位串0, 01, 11, 001, 010, 011, 0001和0101的基于0<1的字典顺序。",
        "answer": "0 < 0001 < 001 < 01 < 010 < 0101 < 011 < 11",
        "answer_symbols": [
            "<"
        ]
    },
    "9.6 20": {
        "question": "画出定义在{0, 1, 2, 3, 4, 5}上的“大于或等于”关系的哈塞图。",
        "answer": "这个全序的哈斯图是一条直线，如图所示，0 在顶部（在“大于或等于”关系下，它是“最大”的元素），5 在底部。",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            ",",
            "→",
            "≥"
        ]
    },
    "9.6 21": {
        "question": "画出定义在{0, 2, 5, 10, 11, 15}上的“小于或等于”关系的哈塞图。",
        "answer": "15 11 10 5 2 0",
        "answer_symbols": []
    },
    "9.6 23 a)": {
        "question": "画出定义在下述集合上的整除关系的哈塞图。（a）{1, 2, 3, 4, 5, 6, 7, 8}",
        "answer": "8 4 2 6 3 5 7 1",
        "answer_symbols": []
    },
    "9.6 23 b)": {
        "question": "画出定义在下述集合上的整除关系的哈塞图。（b）{1, 2, 3, 5, 7, 11, 13}",
        "answer": "2 3 5 7 11 13 1",
        "answer_symbols": []
    },
    "9.6 24": {
        "question": "画出定义在集合𝒫(S)上的包含关系的哈塞图，其中S = {a, b, c, d}。",
        "answer": "This picture is a four-dimensional cube. We draw the sets with k elements at level k: the empty set at level 0 (the bottom), the entire set at level 4 (the top).",
        "answer_symbols": [
            "∅"
        ]
    },
    "9.6 25": {
        "question": "列出哈塞图所示的偏序中的所有有序对。",
        "answer": "(a, b), (a, c), (a, d), (b, c), (b, d), (a, a), (b, b), (c, c), (d, d)",
        "answer_symbols": [
            ",",
            "(",
            ")"
        ]
    },
    "9.6 26": {
        "question": "列出哈塞图所示的偏序中的所有有序对。",
        "answer": "The procedure is the same as in Exercise 25: {(a, a), (a, b), (a, c), (a, d), (a, e), (b, b), (b, d), (b, e), (c, c), (c, d), (d, d), (e, e)}",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "9.6 27": {
        "question": "列出哈塞图所示的偏序中的所有有序对。",
        "answer": "(a, a), (a, g), (a, d), (a, e), (a, f), (b, b), (b, g), (b, d), (b, e), (b, f), (c, c), (c, g), (c, d), (c, e), (c, f), (g, d), (g, e), (g, f), (g, g), (d, d), (e, e), (f, f)",
        "answer_symbols": [
            ",",
            "(",
            ")"
        ]
    },
    "9.6 28": {
        "question": "定义在{1, 2, 3, 4, 6, 12}上的偏序{(a, b) | a 整除 b}的覆盖关系是什么?",
        "answer": "In this problem a divides b when a divides b. For (a, b) to be in the covering relation, we need a to be a proper divisor of b but we also must have no element in our set {1, 2, 3, 4, 6, 12} being a proper multiple of a and a proper divisor of b. For example, (2, 12) is not in the covering relation, since 2 divides 6 and 6 divides 12. With this understanding it is easy to list the pairs in the covering relation: (1, 2), (1, 3), (2, 4), (2, 6), (3, 6), (4, 12), and (6, 12).",
        "answer_symbols": [
            "|",
            "(",
            ")",
            ","
        ]
    },
    "9.6 29": {
        "question": "定义在S的幂集上的偏序{(A, B) | A⊆B}的覆盖关系是什么? 其中S={a, b, c}。",
        "answer": "(∅, {a}), (∅, {b}), (∅, {c}), ({a}, {a, b}), ({a}, {a, c}), ({b}, {a, b}), ({b}, {b, c}), ({c}, {a, c}), ({c}, {b, c}), ({a, b}, {a, b, c}), ({a, c}, {a, b, c}) ({b, c}, {a, b, c})",
        "answer_symbols": [
            ",",
            "(",
            ")",
            "∅",
            "{",
            "}"
        ]
    },
    "9.6 30": {
        "question": "在例25中定义的关于安全种类偏序集中的偏序的覆盖关系是什么?",
        "answer": "这个偏序集有32个元素，由所有对(A, C)组成，其中A是0、1、2和3中的一个（这里代表未分类、机密、秘密和绝密），C是{s, m, d}的八个子集之一（这些字母代表间谍、鼹鼠和双重间谍）。以下列表给出了覆盖关系： (0, 空集) ≺(0,{s}),(0, 空集) ≺(0,{m}),(0, 空集) ≺(0,{d}),(0,{s}) ≺(0,{s, m}),(0,{s}) ≺(0,{s, d}),(0,{m}) ≺ (0,{s, m}),(0,{m}) ≺(0,{m, d}),(0,{d}) ≺(0,{s, d}),(0,{d}) ≺(0,{m, d}),(0,{s, m}) ≺(0,{s, m, d}), (0,{s, d}) ≺(0,{s, m, d}),(0,{m, d}) ≺(0,{s, m, d})，以及用1、2和3分别替换0的36个类似形式，加上8个形式为(0, C) ≺(1, C),(1, C) ≺(2, C)，和 (2, C) ≺(3, C)的陈述，其中C是{s, m, d}的子集。总共，覆盖关系有72对。",
        "answer_symbols": [
            "{",
            "}",
            "≺",
            "(",
            ")",
            ","
        ]
    },
    "9.6 31": {
        "question": "证明: 一个有穷偏序集可以从它的覆盖关系重新构造出来。[提示: 证明偏序集是它的覆盖关系的传递闭包的自反闭包。]",
        "answer": "Let (S, ≤) be a finite poset. We will show that this poset is the reflexive transitive closure of its covering relation. Suppose that (a, b) is in the reflexive transitive closure of the covering relation. Then a = b or a ≺ b, so a ≤ b, or else there is a sequence a₁, a₂, ..., aₙ such that a ≺ a₁ ≺ a₂ ≺ ... ≺ aₙ ≺ b, in which case again a ≤ b by the transitivity of ≤. Conversely, suppose that a ≺ b. If a = b then (a, b) is in the reflexive transitive closure of the covering relation. If a ≺ b and there is no z such that a ≺ z ≺ b, then (a, b) is in the covering relation and therefore in its reflexive transitive closure. Otherwise, let a ≺ a₁ ≺ a₂ ≺ ... ≺ aₙ ≺ b be a longest possible sequence of this form (which exists because the poset is finite). Then no intermediate elements can be inserted, so each pair (a, a₁), (a₁, a₂), ..., (aₙ, b) is in the covering relation, so again (a, b) is in its reflexive transitive closure.",
        "answer_symbols": [
            "=",
            "≺",
            "≤",
            "(",
            ")",
            "∈",
            "...",
            "∄",
            "→",
            "∧",
            "∨",
            "∴"
        ]
    },
    "9.6 32 a)": {
        "question": "对于下面的哈塞图表示的偏序, 回答下面的问题。（a）求极大元。",
        "answer": "最大元素是没有其他元素在其上方的元素，即l和m。",
        "answer_symbols": []
    },
    "9.6 32 b)": {
        "question": "对于下面的哈塞图表示的偏序, 回答下面的问题。（b）求极小元。",
        "answer": "最小元素是没有其他元素在其下方的元素，即a、b和c。",
        "answer_symbols": []
    },
    "9.6 32 c)": {
        "question": "对于下面的哈塞图表示的偏序, 回答下面的问题。（c）存在最大元吗?",
        "answer": "没有最大元素，因为l和m之间没有一个比另一个更大。",
        "answer_symbols": []
    },
    "9.6 32 d)": {
        "question": "对于下面的哈塞图表示的偏序, 回答下面的问题。（d）存在最小元吗?",
        "answer": "没有最小元素，因为a和b之间没有一个比另一个更小。",
        "answer_symbols": []
    },
    "9.6 32 e)": {
        "question": "对于下面的哈塞图表示的偏序, 回答下面的问题。（e）求{a, b, c}的所有上界。",
        "answer": "我们需要找到可以从其向下到达a、b和c的所有元素。很明显，k、l和m是符合此描述的元素。",
        "answer_symbols": []
    },
    "9.6 32 f)": {
        "question": "对于下面的哈塞图表示的偏序, 回答下面的问题。（f）如果存在, 求{a, b, c}的最小上界。",
        "answer": "由于k小于l和m，它是a、b和c的最小上界。",
        "answer_symbols": [
            "<"
        ]
    },
    "9.6 32 g)": {
        "question": "对于下面的哈塞图表示的偏序, 回答下面的问题。（g）求{f, g, h}的所有下界。",
        "answer": "没有元素小于f和h，所以没有下界。",
        "answer_symbols": [
            "<"
        ]
    },
    "9.6 32 h)": {
        "question": "对于下面的哈塞图表示的偏序, 回答下面的问题。（h）如果存在, 求{f, g, h}的最大下界。",
        "answer": "由于没有下界，因此没有最大下界。",
        "answer_symbols": []
    },
    "9.6 34 a)": {
        "question": "对偏序集{(2, 4, 6, 9, 12, 18, 27, 36, 48, 60, 72), |}, 回答下列问题。（a）找出极大元。",
        "answer": "显然数字27、48、60和72是最大的，因为每个数字除自身外不除以列表中的任何其他数字。然而，所有其他数字都除以72，因此它们不是最大的。",
        "answer_symbols": []
    },
    "9.6 34 b)": {
        "question": "对偏序集{(2, 4, 6, 9, 12, 18, 27, 36, 48, 60, 72), |}, 回答下列问题。（b）找出极小元。",
        "answer": "只有2和9是最小的。其他所有元素都可以被2或9整除。",
        "answer_symbols": []
    },
    "9.6 34 c)": {
        "question": "对偏序集{(2, 4, 6, 9, 12, 18, 27, 36, 48, 60, 72), |}, 回答下列问题。（c）存在最大元吗?",
        "answer": "没有最大元素，因为例如集合中没有一个数字同时被60和72整除。",
        "answer_symbols": []
    },
    "9.6 34 d)": {
        "question": "对偏序集{(2, 4, 6, 9, 12, 18, 27, 36, 48, 60, 72), |}, 回答下列问题。（d）存在最小元吗?",
        "answer": "没有最小元素，因为集合中没有一个数字同时能被2和9整除。",
        "answer_symbols": []
    },
    "9.6 34 e)": {
        "question": "对偏序集{(2, 4, 6, 9, 12, 18, 27, 36, 48, 60, 72), |}, 回答下列问题。（e）找出{2, 9}的所有上界。",
        "answer": "我们需要找到列表中既是2又是9的倍数的数字。显然18、36和72是我们要找的数字。",
        "answer_symbols": [
            "×"
        ]
    },
    "9.6 34 f)": {
        "question": "对偏序集{(2, 4, 6, 9, 12, 18, 27, 36, 48, 60, 72), |}, 回答下列问题。（f）如果存在, 找出{2, 9}的最小上界。",
        "answer": "在我们前一部分找到的数字中，18满足最小上界的定义，因为它可以被其他两个上界整除。",
        "answer_symbols": [
            "÷"
        ]
    },
    "9.6 34 g)": {
        "question": "对偏序集{(2, 4, 6, 9, 12, 18, 27, 36, 48, 60, 72), |}, 回答下列问题。（g）找出{60, 72}的所有下界。",
        "answer": "我们需要找到列表中同时是60和72的因数的数字。显然2、4、6和12是我们要找的数字。",
        "answer_symbols": [
            "÷"
        ]
    },
    "9.6 34 h)": {
        "question": "对偏序集{(2, 4, 6, 9, 12, 18, 27, 36, 48, 60, 72), |}, 回答下列问题。（h）如果存在, 找出{60, 72}的最大下界。",
        "answer": "在我们前一部分找到的数字中，12满足最大下界的定义，因为其他三个下界都可以整除它。",
        "answer_symbols": [
            "÷"
        ]
    },
    "9.6 36 a)": {
        "question": "给出满足下述条件的偏序集。（a）有一个极小元但没有极大元。",
        "answer": "一个例子是自然数在“小于等于”下的关系。这里1是（唯一的）最小元素，而没有最大元素。",
        "answer_symbols": [
            "≤"
        ]
    },
    "9.6 36 b)": {
        "question": "给出满足下述条件的偏序集。（b）有一个极大元但没有极小元。",
        "answer": "与部分(a)对偶，答案是自然数在“大于等于”下的关系。",
        "answer_symbols": [
            "≥"
        ]
    },
    "9.6 36 c)": {
        "question": "给出满足下述条件的偏序集。（c）既没有极大元也没有极小元。",
        "answer": "结合前两部分的答案，我们考虑整数在“小于等于”下的关系。显然没有最大或最小元素。",
        "answer_symbols": [
            "≤"
        ]
    },
    "9.6 37": {
        "question": "证明：字典顺序是两个偏序集的笛卡尔积上的偏序。",
        "answer": "Because (a, b) ≤ (a, b), ≤ is reflexive. If (a₁, a₂) ≤ (b₁, b₂) and (a₁, a₂) ≠ (b₁, b₂), either a₁ ≺ b₁, or a₁ = b₁ and a₂ ≺ b₂. In either case, (b₁, b₂) is not less than or equal to (a₁, a₂). Hence, ≤ is antisymmetric. Suppose that (a₁, a₂) ≺ (b₁, b₂) ≺ (c₁, c₂). Then if a₁ ≺ b₁ or b₁ ≺ c₁, we have a₁ ≺ c₁, so (a₁, a₂) ≺ (c₁, c₂), but if a₁ = b₁ = c₁, then a₂ ≺ b₂ ≺ c₂, which implies that (a₁, a₂) ≺ (c₁, c₂). Hence, ≤ is transitive.",
        "answer_symbols": [
            "=",
            "≺",
            "≤",
            "(",
            ")",
            "≠",
            "∨",
            "∧",
            "→",
            "∴"
        ]
    },
    "9.6 38": {
        "question": "证明：字典顺序是一个定义在偏序集的字符串的集合上的偏序。",
        "answer": "自反性从定义中显而易见。为了证明反对称性，假设a1... am < b1... bn，并设 t = min(m, n)。这意味着要么a1... at = b1... bt 且 m < n，使得 b1... bn < a1... am，或者a1... at < b1... bt，使得 b1... bt < a1... at 因此再次 b1... bn < a1... am。最后对于 传递性，假设a1... am < b1... bn < c1... cp。设t = min(m, n)，r = min(n, p)，s = min(m, p)， 和l = min(m, n, p)。现在如果a1... al < b1... bl < c1... cl，则显然a1... am < c1... cp。否则，不失一般性，我们可以假设a1... al = b1... bl。如果l = t，则m < n且m ≤ p。此外，要么b1... br < c1... cr，要么b1... br = c1... cr 且 n < p。在前一种情况下，如果r > l，则Since p > m, we have a1... am < c1... cp, whereas if r = l, then a1... al < c1... cl. In the latter case, a1... as = c1... cs and m < p, so again a1... am < c1... cp. If l < t, then we must have b1... bl < c1... cl, whence a1... al < c1... cl.**\n",
        "answer_symbols": [
            "<",
            "=",
            "min",
            "≤"
        ]
    },
    "9.6 39": {
        "question": "假设 (S, ≤1) 和 (T, ≤2) 是偏序集。证明 (S × T, ≤) 也是偏序集，其中 (s, t) ≤ (u, v) 当且仅当 s ≤1 u 且 t ≤2 v。",
        "answer": "Because (s, t) ≤ (s, t), ≤ is reflexive. If (s, t) ≤ (u, v) and (u, v) ≤ (s, t), then s ≤ u ≤ s and t ≤ v ≤ t; hence, s = u and t = v. Hence, ≤ is antisymmetric. Suppose that (s, t) ≤ (u, v) ≤ (w, x). Then s ≤ u, t ≤ v, u ≤ w, and v ≤ x. It follows that s ≤ w and t ≤ x. Hence, (s, t) ≤ (w, x). Hence, ≤ is transitive.",
        "answer_symbols": [
            "=",
            "≤",
            "(",
            ")",
            "→",
            "∴"
        ]
    },
    "9.6 40 a)": {
        "question": "证明：如果偏序集存在最大元，恰好存在一个最大元。",
        "answer": "If x and y are both greatest elements, then by definition, x ≤ y and y ≤ x, whence x = y.",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "9.6 40 b)": {
        "question": "证明：如果偏序集存在最小元，恰好存在一个最小元。",
        "answer": "This is dual to part (a). If x and y are both least elements, then by definition, x ≤ y and y ≤ x, whence x = y.",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "9.6 42 a)": {
        "question": "证明：如果偏序集的子集存在最小上界，则是唯一的。",
        "answer": "If x and y are both least upper bounds, then by definition, x ≤ y and y ≤ x, whence x = y.",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "9.6 42 b)": {
        "question": "证明：如果偏序集的子集存在最大下界，则是唯一的。",
        "answer": "This is dual to part (a). If x and y are both greatest lower bounds, then by definition, x ≤ y and y ≤ x, whence x = y.",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "9.6 44 a)": {
        "question": "确定下面的偏序集是否为格。（a）(1, 3, 6, 9, 12), |",
        "answer": "This is not a lattice, since the elements 6 and 9 have no upper bound (no element in our set is a multiple of both of them).",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "9.6 44 b)": {
        "question": "确定下面的偏序集是否为格。（b）(1, 5, 25, 125), |",
        "answer": "This is a lattice; in fact, it is a linear order, since each element in the list divides the next one. The least upper bound of two numbers in the list is the larger, and the greatest lower bound is the smaller.\n",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "9.6 44 c)": {
        "question": "确定下面的偏序集是否为格。（c）(Z, ≥)",
        "answer": "Again, this is a lattice because it is a linear order. The least upper bound of two numbers in the list is the smaller number (since here “greater” really means “less”!), and the greatest lower bound is the larger of the two numbers.\n",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "9.6 44 d)": {
        "question": "确定下面的偏序集是否为格。（d）(P(S), ⊆)，其中 P(S) 是集合 S 的幂集",
        "answer": "This is similar to Example 24, with the roles of subset and superset reversed. Here the g.l.b. of two subsets A and B is A ∪ B, and their l.u.b. is A ∩ B.\n",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "9.6 45": {
        "question": "证明：一个格的每个有限非空子集有最小上界和最大下界。",
        "answer": "Use mathematical induction. Let P(n) be “Every subset with n elements from a lattice has a least upper bound and a greatest lower bound.” Basis step: P(1) is true because the least upper bound and greatest lower bound of {x} are both x. Inductive step: Assume that P(k) is true. Let S be a set with k + 1 elements. Let x ∈ S and S' = S − {x}. Because S' has k elements, by the inductive hypothesis, it has a least upper bound y and a greatest lower bound a. Now because we are in a lattice, there are elements z = lub(x, y) and b = glb(x, a). We are done if we can show that z is the least upper bound of S and b is the greatest lower bound of S. To show that z is the least upper bound of S, first note that if w ∈ S, then w = x or w ∈ S'. If w = x then w ≤ z because z is the least upper bound of x and y. If w ∈ S', then w ≤ z because w ≤ y, which is true because y is the least upper bound of S', and y ≤ z, which is true because z = lub(x, y). To see that z is the least upper bound of S, suppose that u is an upper bound of S. Note that such an element u must be an upper bound of x and y, but because z = lub(x, y), it follows that z ≤ u. We omit the similar argument that b is the greatest lower bound of S.",
        "answer_symbols": [
            "=",
            "≤",
            "∈",
            "−",
            "∪",
            "∩",
            "∨",
            "∧",
            "→",
            "∴"
        ]
    },
    "9.6 46": {
        "question": "证明：如果偏序集 (S, R) 是格，那么对偶偏序集 (S, R^⁻¹) 也是格。",
        "answer": "By the duality in the definitions, the greatest lower bound of two elements of S under R is their least upper bound under R^⁻¹, and their least upper bound under R is their greatest lower bound under R^⁻¹. Therefore, if (S, R) is a lattice (i.e., all the l.u.b.’s and g.l.b.’s exist), then so is (S, R^⁻¹).\n",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "9.6 48": {
        "question": "证明：安全类别 (A, C) 的集合 S 是一个格，其中 A 是表示权限级别的正整数，C 是有穷的种类集的子集，并且 (A₁, C₁) ≤ (A₂, C₂) 当且仅当 A₁ ≤ A₂ 且 C₁ ⊆ C₂。[提示：首先证明 (S, ≤) 是一个偏序集，然后证明 (A₁, C₁) 和 (A₂, C₂) 的最小上界和最大下界分别是 (max(A₁, A₂), C₁ ∪ C₂) 和 (min(A₁, A₂), C₁ ∩ C₂)。]",
        "answer": "We need to verify the various defining properties of a lattice. First, we need to show that S is a poset under the given ≤ relation. Clearly (A, C) ≤ (A, C), since A ≤ A and C ⊆ C; thus we have established reflexivity.\nFor antisymmetry, suppose that (A1, C1) ≤ (A2, C2) and (A2, C2) ≤ (A1, C1). This means that A1 ≤ A2, C1 ⊆ C2, A2 ≤ A1, and C2 ⊆ C1. By the properties of ≤ and ⊆ it immediately follows that A1 = A2 and C1 = C2, so (A1, C1) = (A2, C2). Transitivity is proved in a similar way, using the transitivity of ≤ and ⊆. Second, we need to show that greatest lower bounds and least upper bounds exist. Suppose that (A1, C1) and (A2, C2) are two elements of S; we claim that (min(A1, A2), C1 ∩ C2) is their greatest lower bound. Clearly min(A1, A2) ≤ A1 and min(A1, A2) ≤ A2; and C1 ∩ C2 ⊆ C1 and C1 ∩ C2 ⊆ C2. Therefore (min(A1, A2), C1 ∩ C2) ≤ (A1, C1) and (min(A1, A2), C1 ∩ C2) ≤ (A2, C2), so this is a lower bound. On the other hand, if (A, C) is any lower bound, then A ≤ A1, A ≤ A2, C ⊆ C1, and C ⊆ C2. It follows from the properties of ≤ and ⊆ that A ≤ min(A1, A2) and C ⊆ C1 ∩ C2. Therefore (A, C) ≤ (min(A1, A2), C1 ∩ C2).\nThis means that (min(A1, A2), C1 ∩ C2) is the greatest lower bound. The proof that (max(A1, A2), C1 ∪ C2) is the least upper bound is exactly dual to this argument.",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "9.6 49": {
        "question": "证明：一个集合 S 上的所有划分的集合与关系 ≤ 构成一个格，其中如果划分 P₁ 是划分 P₂ 的加细，则 P₁ ≤ P₂ (见 9.5 节练习 49 前面的说明)。",
        "answer": "Let P be the set of all partitions of a set S with P₁ ≤ P₂ if P₁ is a refinement of P₂, that is, if every set in P₁ is a subset of a set in P₂. First, we show that (P, ≤) is a poset. Because P ≤ P for every partition P, ≤ is reflexive. Now suppose that P₁ ≤ P₂ and P₂ ≤ P₁. Let T ∈ P₁. Because P₁ ≤ P₂, there is a set T' ∈ P₂ such that T ⊆ T'. Because P₂ ≤ P₁ there is a set T'' ∈ P₁ such that T' ⊆ T''. It follows that T ⊆ T''. But because P₁ is a partition, T = T'', which implies that T = T' because T ⊆ T' ⊆ T''. Thus, T ∈ P₂. By reversing the roles of P₁ and P₂ it follows that every set in P₂ is also in P₁. Hence, P₁ = P₂ and ≤ is antisymmetric. Next, suppose that P₁ ≤ P₂ and P₂ ≤ P₃. Let T ∈ P₁. Then there is a set T' ∈ P₂ such that T ⊆ T'. Because P₂ ≤ P₃ there is a set T'' ∈ P₃ such that T' ⊆ T''. This means that T ⊆ T''. Hence, P₁ ≤ P₃. It follows that ≤ is transitive. The greatest lower bound of the partitions P₁ and P₂ is the partition P whose subsets are the nonempty sets of the form T₁ ∩ T₂ where T₁ ∈ P₁ and T₂ ∈ P₂. We omit the justification of this statement here. The least upper bound of the partitions P₁ and P₂ is the partition that corresponds to the equivalence relation in which x ∈ S is related to y ∈ S if there is a sequence x = x₀, x₁, x₂, ..., xₙ = y for some nonnegative integer n such that for each i from 1 to n, xᵢ₋₁ and xᵢ are in the same element of P₁ or of P₂. We omit the details that this is an equivalence relation and the details of the proof that this is.",
        "answer_symbols": [
            "=",
            "≤",
            "∈",
            "⊆",
            "∩",
            "∪",
            "→",
            "∴"
        ]
    },
    "9.6 50": {
        "question": "证明：每个全序集都是一个格。",
        "answer": "This issue was already dealt with in our solution to Exercise 44, parts (b) and (c). If (S, ≤) is a total (linear) order, then the least upper bound of two elements is the larger one, and their greatest lower bound is the smaller.",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "9.6 51": {
        "question": "证明：每个有限格都有一个最小元和一个最大元。",
        "answer": "根据练习 45，整个有限格有一个最小上界和一个最大下界。根据定义，这些元素分别是最大和最小元素。",
        "answer_symbols": []
    },
    "9.6 52 a)": {
        "question": "给出一个无限格的例子，使得（a）既没有最小元也没有最大元。",
        "answer": "(Z, ≤)",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "9.6 52 b)": {
        "question": "给出一个无限格的例子，使得（b）有一个最小元但没有最大元。",
        "answer": "(Z^⁺, ≤)",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "9.6 52 c)": {
        "question": "给出一个无限格的例子，使得（c）有一个最大元但没有最小元。",
        "answer": "(Z^⁻, ≤), where Z^⁻ is the set of negative integers",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "9.6 52 d)": {
        "question": "给出一个无限格的例子，使得（d）有一个最小元也有一个最大元。",
        "answer": "({1}, ≤).",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "9.6 53": {
        "question": "验证 (Z+ × Z+, ≦) 是一个良序集，其中 ≦ 是例 8 中所声明的字典顺序。",
        "answer": "Z+ × Z+ 的子集的最小元素是具有最小可能第一坐标的那对数，如果有多个这样的对数，则是其中第二坐标最小的那个对数。",
        "answer_symbols": [
            "×"
        ]
    },
    "9.6 54 a)": {
        "question": "确定下述每个偏序集是否为良序的。（a）(S, ≦)，其中 S = {10, 11, 12, …}",
        "answer": "这是良序的，因为任何非空子集中的最小元素是它的最小元素。",
        "answer_symbols": [
            "∈"
        ]
    },
    "9.6 54 b)": {
        "question": "确定下述每个偏序集是否为良序的。（b）(Q ∩ [0, 1], ≦) (0 和 1 之间的有理数集合，包含 0 和 1)",
        "answer": "这不是良序的。例如，集合 {1/n | n 属于 N} 不包含最小元素。",
        "answer_symbols": [
            "∈"
        ]
    },
    "9.6 54 c)": {
        "question": "确定下述每个偏序集是否为良序的。（c）(S, ≦)，S 是分母不超过 3 的正有理数集合",
        "answer": "注意 S = {1/2, 1, 3/2, 2, 5/2, ...}。这是良序的，因为任何非空子集中的最小元素是它的最小元素。",
        "answer_symbols": [
            "=",
            "∈"
        ]
    },
    "9.6 54 d)": {
        "question": "确定下述每个偏序集是否为良序的。（d）(Z-, ≧)，其中 Z- 是负整数的集合",
        "answer": "这是良序的，因为它具有与正整数在 ≤ 下相同的结构，因为 x ≥ y 当且仅当 -x ≤ -y。因此，任何非空子集中的最小元素是它的最大元素。",
        "answer_symbols": [
            "≤",
            "≥",
            "∈"
        ]
    },
    "9.6 55": {
        "question": "证明：偏序集 (Z, ≦)（其中 x < y 当且仅当 |x| < |y|）是良基的，但不是全序集。",
        "answer": "如果 x 是这个偏序集的一个递减序列中的整数，那么在 x 之后最多可以有 |x| 个元素，即绝对值为 |x| - 1, |x| - 2, ..., 1, 0 的整数。因此不可能存在无限递减序列。这不是一个全序集，因为例如 5 和 -5 是不可比较的。",
        "answer_symbols": [
            "|",
            "-",
            "..."
        ]
    },
    "9.6 56": {
        "question": "证明：至少有两个可比元素的稠密偏序集不是良基的。",
        "answer": "设 x0 和 x1 是密集偏序集中的两个元素，有 x0 ≺ x1（由给定条件保证）。根据密度，存在一个元素 x2 位于 x0 和 x1 之间，即 x0 ≺ x2 ≺ x1。再次根据密度，存在一个元素 x3 位于 x0 和 x2 之间，即 x0 ≺ x3 ≺ x2。我们继续这样做，产生了一个无限递减序列：... ≺ x4 ≺ x3 ≺ x2 ≺ x1。因此该偏序集不是良基的。",
        "answer_symbols": [
            "≺"
        ]
    },
    "9.6 57": {
        "question": "证明：有理数和通常的“小于或等于”关系构成的偏序集 (Q, ≦) 是稠密偏序集。",
        "answer": "要找出两个有理数中较大的那个，将它们写成具有正公共分母的形式并比较分子。要证明这个集合是稠密的，假设 x < y 是两个有理数。那么它们的平均数，即 (x + y) / 2，是一个介于它们之间的有理数。",
        "answer_symbols": [
            "<",
            "+",
            "/",
            "(",
            ")"
        ]
    },
    "9.6 58": {
        "question": "证明：小写英文字母的字符串的集合以及定义在其上的字典顺序既不是良基的，也不是稠密的。",
        "answer": "由于存在无限递减序列 ... ≺ aaab ≺ aab ≺ ab ≺ b，所以它不是良基的。它也不是密集的，因为在这种顺序下 a 和 aa 之间没有元素。",
        "answer_symbols": [
            "≺"
        ]
    },
    "9.6 59": {
        "question": "证明：偏序集是良序的，当且仅当它是全序的并且是良基的。",
        "answer": "设 (S, ≤) 是一个偏序集。只需证明每个非空子集包含一个最小元素当且仅当 S 中没有无限递减序列（即 a1, a2, a3, ...，其中 ai+1 < ai 对所有 i 成立）。无限递减序列显然没有最小元素。相反地，设 A 是 S 的任何非空子集且没有最小元素。因为 A 非空，选择 a1 属于 A。因为 a1 不是 A 的最小元素，选择 a2 属于 A 使得 a2 < a1。因为 a2 不是 A 的最小元素，选择 a3 属于 A 使得 a3 < a2。继续这种方式，产生 S 中的一个无限递减序列。",
        "answer_symbols": [
            "≤",
            "<",
            "..."
        ]
    },
    "9.6 60": {
        "question": "证明：一个有穷非空偏序集有一个极大元。",
        "answer": "这是引理1的对偶。我们可以简单地复制证明，将每个“极小”改为“极大”，并反转每个不等式。",
        "answer_symbols": [
            "≺"
        ]
    },
    "9.6 61": {
        "question": "求一个全序，使得它与练习 32 中的哈塞图所表示的偏序集相容。",
        "answer": "a <t b <t c <t d <t e <t f <t g <t h <t i <t j <t k <t l <t m",
        "answer_symbols": [
            "<t"
        ]
    },
    "9.6 62": {
        "question": "求一个与集合 {1, 2, 3, 6, 8, 12, 24, 36} 上的整除关系相容的全序。",
        "answer": "由于较大的数永远不能除以较小的数，“小于等于”关系在任何集合上都是可除性关系的相容全序。这给出了 1 ≺t 2 ≺t 3 ≺t 6 ≺t 8 ≺t 12 ≺t 24 ≺t 36。",
        "answer_symbols": [
            "≺t"
        ]
    },
    "9.6 63": {
        "question": "求出所有与例 26 中的偏序集 ((1, 2, 4, 5, 12, 20), | |) 相容的全序。",
        "answer": "1 < 5 < 2 < 4 < 12 < 20, 1 < 2 < 5 < 4 < 12 < 20, 1 < 2 < 4 < 5 < 12 < 20, 1 < 2 < 4 < 12 < 5 < 20, 1 < 5 < 2 < 4 < 20 < 12, 1 < 2 < 5 < 4 < 20 < 12, 1 < 2 < 4 < 5 < 20 < 12",
        "answer_symbols": [
            "<"
        ]
    },
    "9.6 64": {
        "question": "求出所有与练习 27 中的哈塞图表示的偏序集相容的全序。",
        "answer": "显然 g 必须放在中间，{a, b, c} 的任意六个排列在 g 之前，{d, e, f} 的任意六个排列在 g 之后。因此，这个偏序集有 36 种相容的全序，如 a ≺ b ≺ c ≺ g ≺ d ≺ e ≺ f 和 b ≺ a ≺ c ≺ g ≺ f ≺ e ≺ d。",
        "answer_symbols": [
            "≺"
        ]
    },
    "9.6 65": {
        "question": "求出完成例 27 中的开发项目的任务的所有可能的顺序。",
        "answer": "A < C < E < B < D < F < G, A < E < C < B < D < F < G, C < A < E < B < D < F < G, C < E < A < B < D < F < G, E < A < C < B < D < F < G, E < C < A < B < D < F < G, A < C < B < E < D < F < G, C < A < B < E < D < F < G, A < C < B < D < E < F < G, C < A < B < D < E < F < G, A < C < E < B < F < D < G, A < E < C < B < F < D < G, C < A < E < B < F < D < G, C < E < A < B < F < D < G, E < A < C < B < F < D < G, E < C < A < B < F < D < G, A < C < B < E < F < D < G, C < A < B < E < F < D < G",
        "answer_symbols": [
            "<"
        ]
    },
    "9.6 66": {
        "question": "如果表示建筑一座房子所需任务的哈塞图如下图所示，通过指定这些任务的顺序来安排它们。",
        "answer": "这里有许多相容的全序。我们只需要从底部开始。一个答案是 基础 ≺ 框架 ≺ 屋顶 ≺ 外墙 ≺ 布线 ≺ 给排水 ≺ 地板 ≺ 墙板 ≺ 外墙涂料 ≺ 内墙涂料 ≺ 地毯 ≺ 室内装置 ≺ 室外装置 ≺ 完成。",
        "answer_symbols": [
            "≺"
        ]
    },
    "9.6 67": {
        "question": "如果关于一个软件项目的任务的哈塞图如下图所示，给出这个软件项目的任务的完成顺序。",
        "answer": "确定用户需求 < 编写功能需求 < 设置测试站点 < 开发系统需求 < 编写文档 < 开发模块 A < 开发模块 B < 开发模块 C < 集成模块 < α 测试 < β 测试 < 完成",
        "answer_symbols": [
            "<"
        ]
    },
    "9 Supplementary Exercises 13": {
        "question": "证明：一个关系的对称闭包的自反闭包和它的自反闭包的对称闭包是相同的。",
        "answer": "(ε ∪ R)^-1 = ε^-1 ∪ R^-1 = ε ∪ R^-1",
        "answer_symbols": [
            "∪",
            "^",
            "="
        ]
    },
    "9 Supplementary Exercises 14 a)": {
        "question": "设 R 是定义在所有数学家的集合上的关系，R 包含有序对 (a, b) 当且仅当 a 与 b 合写了一篇论文。描述关系 R^²。",
        "answer": "如果每个数学家都与某个数学家 c 合写过论文，则这两个数学家在 R^² 下相关。",
        "answer_symbols": [
            "²"
        ]
    },
    "9 Supplementary Exercises 14 b)": {
        "question": "设 R 是定义在所有数学家的集合上的关系，R 包含有序对 (a, b) 当且仅当 a 与 b 合写了一篇论文。描述关系 R*。",
        "answer": "如果存在一个有限的数学家序列 a = c₀, c₁, c₂, ..., cₘ−₁, cₘ = b，其中 m ≥ 1，并且对于从 1 到 m 的每个 i，数学家 cᵢ 都与数学家 cᵢ−₁ 合写过论文，则这两个数学家在 R* 下相关。",
        "answer_symbols": [
            "=",
            "≥",
            "…",
            "−",
            "*"
        ]
    },
    "9 Supplementary Exercises 15": {
        "question": "解释怎样用定义在集合 A_1 和 A_2 上的偏序定义在集合 A_1 × A_2 上的偏序。",
        "answer": "a) R = {(a, b), (a, c)}。R 的对称闭包的传递闭包是 {(a, a), (a, b), (a, c), (b, a), (b, b), (b, c), (c, a), (c, b), (c, c)}，与 R 的传递闭包的对称闭包 {(a, b), (a, c), (b, a), (c, a)} 不同。b) 假设 (a, b) 在 R 的传递闭包的对称闭包中。我们必须证明 (a, b) 在 R 的对称闭包的传递闭包中。我们知道 (a, b) 和 (b, a) 至少有一个在 R 的传递闭包中。因此，要么 R 中有一条从 a 到 b 的路径，要么 R 中有一条从 b 到 a 的路径（或两者都有）。在前一种情况下，R 的对称闭包中有一条从 a 到 b 的路径。在后一种情况下，我们可以通过反转从 b 到 a 的路径中的所有边的方向来形成一条从 a 到 b 的路径。因此，(a, b) 在 R 的对称闭包的传递闭包中。",
        "answer_symbols": [
            "{",
            "}",
            "∈",
            "∪",
            "∩",
            "→",
            "¬",
            "∨",
            "∧",
            "⇒"
        ]
    },
    "9 Supplementary Exercises 16 a)": {
        "question": "设 S 是一个计算机问题的子程序的集合。定义关系 R，如果在执行子程序 P 调用子程序 Q，那么 P R Q。描述 R 的传递闭包。",
        "answer": "设 P 和 Q 是子程序。那么当且仅当在 P 的活动调用期间的某个时刻，Q 可能被调用时，P 在 R 的传递闭包下与 Q 相关。",
        "answer_symbols": []
    },
    "9 Supplementary Exercises 16 b)": {
        "question": "对于哪些子程序 P，(P, P) 属于 R 的传递闭包？",
        "answer": "这样的例程通常称为递归的——在 P 仍然活动时，P 可能再次被调用。",
        "answer_symbols": []
    },
    "9 Supplementary Exercises 20 a)": {
        "question": "下面的哪些关系是定义在所有人的集合上的等价关系？(x, y) | x 与 y 有同样的星座",
        "answer": "根据第 9.5 节的练习 9，这是一个等价关系，设 f(x) 是 x 出生时的星座。",
        "answer_symbols": []
    },
    "9 Supplementary Exercises 20 b)": {
        "question": "下面的哪些关系是定义在所有人的集合上的等价关系？(x, y) | x 与 y 出生在同一年",
        "answer": "根据第 9.5 节的练习 9，这是一个等价关系，设 f(x) 是 x 出生的年份。",
        "answer_symbols": []
    },
    "9 Supplementary Exercises 20 c)": {
        "question": "下面的哪些关系是定义在所有人的集合上的等价关系？(x, y) | x 与 y 曾在同一城市",
        "answer": "这不是一个等价关系（它不是传递的）。",
        "answer_symbols": []
    },
    "9 Supplementary Exercises 2 a)": {
        "question": "构造集合 {a, b, c, d} 上的关系，使得它是自反的、对称的，但不是传递的。",
        "answer": "{(a, a), (b, b), (c, c), (a, b), (b, a), (b, c), (c, b), (d, d)}",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "9 Supplementary Exercises 2 b)": {
        "question": "构造集合 {a, b, c, d} 上的关系，使得它是反自反的、对称的和传递的。",
        "answer": "空集",
        "answer_symbols": []
    },
    "9 Supplementary Exercises 2 c)": {
        "question": "构造集合 {a, b, c, d} 上的关系，使得它是反自反的、反对称的，但不是传递的。",
        "answer": "{(a, b), (b, c)}",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "9 Supplementary Exercises 2 d)": {
        "question": "构造集合 {a, b, c, d} 上的关系，使得它是自反的，既不是对称的也不是反对称的，是传递的。",
        "answer": "{(a, a), (b, b), (c, c), (a, b), (b, a), (c, a), (c, b), (d, d)}",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "9 Supplementary Exercises 2 e)": {
        "question": "构造集合 {a, b, c, d} 上的关系，使得它是既不是自反的、反自反的、对称的和反对称的，也不是传递的。",
        "answer": "{(a, b), (b, a), (c, c), (c, a)}",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "9 Supplementary Exercises 3": {
        "question": "Z × Z 上的关系 R 定义如下：(a, b) R (c, d) 当且仅当 a + d = b + c。证明：R 是等价关系。",
        "answer": "((a, b), (a, b)) 属于 R 因为 a + b = a + b。因此，R 是自反的。如果 ((a, b), (c, d)) 属于 R，则 a + d = b + c，因此 c + b = d + a。于是 ((c, d), (a, b)) 属于 R。因此，R 是对称的。假设 ((a, b), (c, d)) 和 ((c, d), (e, f)) 属于 R。则 a + d = b + c 且 c + f = d + e。将这两个等式相加并从两边减去 c + d 得到 a + f = b + e。因此，((a, b), (e, f)) 属于 R。因此，R 是传递的。",
        "answer_symbols": [
            "+",
            "=",
            "∈",
            "∧",
            "∨",
            "¬",
            "⇒"
        ]
    },
    "9 Supplementary Exercises 4": {
        "question": "证明：一个反对称关系的子集也是一个反对称关系。",
        "answer": "假设 R1 ⊆ R2 并且 R2 是反对称的。我们需要证明 R1 也是反对称的。设 (a, b) ∈ R1 且 (b, a) ∈ R1。由于这两对也都在 R2 中，我们知道 a = b，如所需。",
        "answer_symbols": [
            "⊆",
            "∈",
            "="
        ]
    },
    "9 Supplementary Exercises 5": {
        "question": "设 R 是定义在集合 A 上的自反关系，证明：R ⊆ R^²。",
        "answer": "假设 (a, b) 属于 R。因为 (b, b) 属于 R，所以 (a, b) 属于 R^2。",
        "answer_symbols": [
            "∈",
            "^"
        ]
    },
    "9 Supplementary Exercises 6": {
        "question": "假设 R₁ 和 R₂ 是定义在集合 A 上的自反关系，证明：R₁ ⊕ R₂ 是反自反的。",
        "answer": "由于 (a, a) ∈ R1 且 (a, a) ∈ R2 对所有 a ∈ A 成立，因此 (a, a) ∉ R1 ⊕ R2 对所有 a ∈ A 成立。",
        "answer_symbols": [
            "∈",
            "∉",
            "⊕"
        ]
    },
    "9 Supplementary Exercises 7": {
        "question": "假设 R₁ 和 R₂ 是定义在集合 A 上的自反关系，R₁ ∩ R₂ 也是自反的吗？R₁ ∪ R₂ 也是自反的吗？",
        "answer": "是，是",
        "answer_symbols": []
    },
    "9 Supplementary Exercises 8": {
        "question": "假设 R 是定义在集合 A 上的对称关系，R̄ 也是对称的吗？",
        "answer": "在这个假设下，R 也必须是对称的，因为如果 (a, b) ∈ R，则 (a, b) ∉ R，从而 (b, a) 也不能在 R 中（由 R 的对称性）；换句话说，(b, a) 也在 R 中。",
        "answer_symbols": [
            "∈",
            "∉"
        ]
    },
    "9 Supplementary Exercises 9": {
        "question": "设 R₁ 和 R₂ 是定义在集合 A 上的对称关系，R₁ ∩ R₂ 也是对称的吗？R₁ ∪ R₂ 也是对称的吗？",
        "answer": "是，是",
        "answer_symbols": []
    },
    "9 Supplementary Exercises 10": {
        "question": "一个关系 R 称为循环的，如果 a R b 和 b R c 蕴涵 c R a。证明：R 是自反的和循环的，当且仅当它是等价关系。",
        "answer": "首先假设 R 是自反的和循环的。我们需要证明 R 是对称的和传递的。设 (a, b) ∈ R。由于 (b, b) ∈ R，根据循环性，(b, a) ∈ R；这证明了对称性。现在如果 (a, b) ∈ R 且 (b, c) ∈ R，则根据循环性 (c, a) ∈ R，再根据对称性 (a, c) ∈ R；因此 R 是传递的。反之，传递性和对称性立即推出循环性，因此每个等价关系都是自反的和循环的。",
        "answer_symbols": [
            "∈",
            "∧",
            "→"
        ]
    },
    "9 Supplementary Exercises 11": {
        "question": "证明：一个 n 元关系的主键也是这个关系的任何投影的主键，其中这个投影包含这个关键字作为它的一个域。",
        "answer": "投影中有相同键的两条记录在原始数据中也有相同的键。",
        "answer_symbols": []
    },
    "9 Supplementary Exercises 12": {
        "question": "一个 n 元关系的主键也是由这个关系与第二个关系的连接而得到的较大的关系的主键吗？",
        "answer": "第一个关系中的主键不必是连接后的主键。假设第一个关系包含对 (John, boy) 和 (Mary, girl)，第二个关系包含对 (boy, vain)，(girl, athletic)，和 (girl, smart)。显然，Name 是第一个关系的主键。如果我们以 Sex 列进行连接，则我们得到包含对 (John, boy, vain)，(Mary, girl, athletic)，和 (Mary, girl, smart) 的关系；在这个关系中，Name 不是主键。",
        "answer_symbols": []
    },
    "9 Supplementary Exercises 14 c)": {
        "question": "如果一个数学家与多产的匈牙利数学家保罗·埃德斯合写了一篇论文，那么这个数学家的埃德斯数是 1。如果这个数学家没有与埃德斯合写一篇论文，但是与某个与埃德斯合写过论文的人合写了一篇论文，那么这个数学家的埃德斯数是 2，以此类推（埃德斯本人的埃德斯数是 0）。用 R 中路径的概念给出埃德斯数的定义。",
        "answer": "a 的 Erdős 数是从 a 到 Erdős 的最短路径的长度（如果存在这样的路径）。有些数学家没有 Erdős 数。",
        "answer_symbols": []
    },
    "9 Supplementary Exercises 16 c)": {
        "question": "描述 R 的传递闭包的自反闭包。",
        "answer": "任何关系的传递闭包的自反闭包就是传递闭包（见部分 (a)）加上所有循环。",
        "answer_symbols": []
    },
    "9 Supplementary Exercises 17": {
        "question": "假设 R 和 S 是定义在集合 A 上的关系，R ⊆ S，且 R 和 S 的关于性质 P 的闭包都存在。证明 R 关于 P 的闭包是 S 关于 P 的闭包的子集。",
        "answer": "具有属性 P 的 S 的闭包是一个具有属性 P 并且包含 R 的关系，因为 R ⊆ S。因此，具有属性 P 的 S 的闭包包含具有属性 P 的 R 的闭包。",
        "answer_symbols": [
            "⊆"
        ]
    },
    "9 Supplementary Exercises 18": {
        "question": "证明：两个关系的并集的对称闭包是它们的对称闭包的并集。",
        "answer": "我们可以符号化地证明这一点，因为一个关系的对称闭包是该关系及其逆的并集。因此我们有 (R ∪ S) ∪ (R ∪ S)^−1 = R ∪ S ∪ R^−1 ∪ S^−1 = (R ∪ R^−1) ∪ (S ∪ S^−1)。",
        "answer_symbols": [
            "∪",
            "^",
            "−",
            "="
        ]
    },
    "9 Supplementary Exercises 19": {
        "question": "设计一个基于内部顶点概念的算法，求有向图中两个顶点之间的最长路径的长度，或确定在这些顶点之间存在任意长度的路径。",
        "answer": "使用 Warshall 算法的基本思想，但令 w[k]_ij 等于从 v_i 到 v_j 使用下标不超过 k 的内部顶点的最长路径的长度，如果没有这样的路径，则等于 -1。为了从 W_(k-1) 的条目中找到 w[k]_ij，确定每对 (i, j) 是否存在从 v_i 到 v_k 和从 v_k 到 v_j 的路径，这些路径不使用标号大于 k 的顶点。如果 w[k-1]_ik 或 w[k-1]_kj 为 -1，则这样的路径对不存在，因此设置 w[k]_ij = w[k-1]_ij。如果存在这样的路径对，则有两种可能性。如果 w[k-1]_kk > 0，则从 v_i 到 v_j 存在任意长的路径，因此设置 w[k]_ij = ∞。如果 w[k-1]_kk = 0，则设置 w[k-1]_ij = max(w[k-1]_ij, w[k-1]_ik + w[k-1]_kj)。（初始时取 W0 = M_R。）",
        "answer_symbols": [
            "=",
            ">",
            "<",
            "∞",
            "max",
            "(",
            ")",
            "+",
            "¬",
            "∨",
            "∧",
            "⇒"
        ]
    },
    "9 Supplementary Exercises 21": {
        "question": "有多少个定义在 5 个元素集合上的不同的等价关系，其中恰有 3 个不同的等价类？",
        "answer": "25",
        "answer_symbols": []
    },
    "9 Supplementary Exercises 22": {
        "question": "证明：(x, y) | x - y ∈ Q 是定义在实数集上的等价关系，其中 Q 是有理数集合。[1]、[1/2] 和 [π] 是什么？",
        "answer": "这个关系是自反的，因为 x - x = 0 属于 Q。为了证明它是对称的，假设 x - y 属于 Q。那么 y - x = -(x - y) 也是有理数。对于传递性，如果 x - y 属于 Q 且 y - z 属于 Q，那么它们的和，即 x - z，也是有理数（有理数在加法下封闭）。1 和 1/2 的等价类都是有理数集。π 的等价类是有理数与 π 之差的实数集合；换句话说，它是 {π + r | r 属于 Q}。",
        "answer_symbols": [
            "-",
            "=",
            "∈",
            "+",
            "|"
        ]
    },
    "9 Supplementary Exercises 23": {
        "question": "设 P₁ = {A₁, A₂, …, Aₘ} 和 P₂ = {B₁, B₂, …, Bₙ} 都是集合 S 的划分。证明：形如 Aᵢ ∩ Bⱼ 的非空子集是 S 的划分，且是 P₁ 和 P₂ 的加细。",
        "answer": "因为 A_i ∩ B_j 是 A_i 和 B_j 的子集，所以子集集合是给定划分的细化。必须证明它是一个划分。根据构造，这些集合中的每一个都是非空的。为了看到它们的并集是 S，假设 s 属于 S。因为 P1 和 P2 是 S 的划分，存在集合 A_i 和 B_j 使得 s 属于 A_i 且 s 属于 B_j。因此 s 属于 A_i ∩ B_j。因此，这些集合的并集是 S。为了看到它们是两两不相交的，注意除非 i = i' 且 j = j'，(A_i ∩ B_j) ∩ (A_i' ∩ B_j') = (A_i ∩ A_i') ∩ (B_j ∩ B_j') = ∅。",
        "answer_symbols": [
            "∩",
            "∪",
            "∅"
        ]
    },
    "9 Supplementary Exercises 24": {
        "question": "证明：关系 R 的自反闭包的对称闭包的传递闭包是包含 R 的最小的等价关系。",
        "answer": "设 S 是 R 的自反闭包的对称闭包的传递闭包。那么根据第 9.4 节的练习 23，S 是对称的。由于它显然是传递的和自反的，因此 S 是一个等价关系。此外，为了确保自反性、对称性和传递性而添加到 R 中的每个元素都被迫添加进来；因此 S 是包含 R 的最小等价关系。",
        "answer_symbols": []
    },
    "9 Supplementary Exercises 25": {
        "question": "设 R(S) 是定义在集合 S 上的所有关系的集合。如下定义 R(S) 上的关系 ≤，如果 R₁⊆R₂ 则 R₁≤R₂，这里 R₁ 和 R₂ 是定义在 S 上的关系。证明：(R(S), ≤) 是偏序集。",
        "answer": "子集关系是任何集合集合上的偏序关系，因为它具有自反性、反对称性和传递性。这里的集合集合是 R(S)。",
        "answer_symbols": [
            "⊆",
            "≤",
            "¬",
            "∨",
            "∧",
            "⇒"
        ]
    },
    "9 Supplementary Exercises 26": {
        "question": "设 P(S) 是集合 S 上的所有划分的集合。如下定义 P(S) 上的关系 ≤，如果 P₁ 是 P₂ 的加细，则 P₁≤P₂（见 9.5 节练习 49）。证明：(P(S), ≤) 是偏序集。",
        "answer": "这是因为两个划分在细化关系下相关当且仅当它们对应的等价关系在 ⊆ 关系下相关，再加上 ⊆ 是每个集合集合上的偏序关系。",
        "answer_symbols": [
            "⊆"
        ]
    },
    "9 Supplementary Exercises 27": {
        "question": "下图为烹调中餐任务的哈塞图，安排烹调中餐所需要的任务的顺序。",
        "answer": "找到食谱 < 购买",
        "answer_symbols": [
            "<"
        ]
    },
    "9 Supplementary Exercises 28": {
        "question": "找出 9.6 节练习 25~27 的哈塞图所表示的偏序集中所有的链.",
        "answer": "链的一个子集仍然是一个链，所以我们只列出最大的链。a) {a, b, c} 和 {a, b, d} b) {a, b, e}, {a, b, d}, 和 {a, c, d} c) 在这种情况下有 9 个最大链，每个链由顶部一行的一个元素、中间的一个元素和底部一行的一个元素组成。",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "9 Supplementary Exercises 30": {
        "question": "找出 9.6 节练习 32 的哈塞图所表示的偏序集中具有最多元素的一条反链.",
        "answer": "顶点排列在三列中。同一列中的每对顶点显然是可比较的。因此最大的反链最多可以有三个元素。一个这样的反链是 {a, b, c}。",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "9 Supplementary Exercises 31": {
        "question": "证明：在一个有穷偏序集 (S, ≤) 中的每条极大链都包含 S 的一个极小元。（一条极大链是一条链，但不是一条更大的链的子链。）",
        "answer": "设 (S, ≼) 是一个有限偏序集，A 是一个极大链。因为 (A, ≼) 也是一个偏序集，它必须有一个最小元 m。假设 m 不是 S 中的最小元。那么 S 中会有一个元素 a 使得 a ≺ m。然而，这将使集合 A ∪ {a} 成为比 A 更大的链。为了证明这一点，我们必须证明 a 与 A 中的每个元素都是可比较的。因为 m 与 A 中的每个元素都是可比较的，并且 m 是最小的，所以当 x 属于 A 且 x ≠ m 时，m ≺ x。因为 a ≺ m 且 m ≺ x，传递律表明对于 A 中的每个元素 a ≺ x",
        "answer_symbols": [
            "(",
            ")",
            "≺",
            "∪",
            "≠",
            "∈",
            "→"
        ]
    },
    "9 Supplementary Exercises 32": {
        "question": "证明：一个偏序集可以被分成 k 条链，其中 k 是这个偏序集中具有最多元素的一条反链的元素个数.",
        "answer": "这个结果被称为 Dilworth 定理。有关证明，请参见例如 Béla Bollobás 的《图论》（Springer-Verlag, 1979 年）第 58 页。",
        "answer_symbols": []
    },
    "9 Supplementary Exercises 33": {
        "question": "证明：在任意一组 mn+1 个人中要么存在一个 m+1 个人的列表，其中每个人（除了第一个人以外）都是表中前一个人的后代；要么存在 n+1 个人，其中没有一个人是其他 n 个人中任何一个人的后代。[提示：用练习 32。]",
        "answer": "设 a Rb 表示 a 是 b 的后代。由习题 32 可知，如果不存在 n+1 个互不为后代的人（一个反链），则 k ≤ n，因此集合可以划分为 k ≤ n 条链。根据抽屉原理，至少有一条链包含至少 m+1 个人",
        "answer_symbols": [
            "R",
            "≤",
            "+",
            "∈",
            "→"
        ]
    },
    "9 Supplementary Exercises 34": {
        "question": "证明：对于良基归纳原理不需要单独的基础情况，就是说，如果 ∀x (∀y(y < x → P(y)) → P(x))，那么 P(u) 对于 S 中所有的极小元 u 为真.",
        "answer": "设 x 是集合 S 中的最小元素。那么假设 ∀y(y ≺ x → P(y)) 是空洞成立的，所以结论 P(x) 是正确的，这就是我们想要证明的。",
        "answer_symbols": [
            "∀",
            "(",
            ")",
            "≺",
            "→",
            "P",
            "x"
        ]
    },
    "9 Supplementary Exercises 35": {
        "question": "证明：良基归纳原理是有效的.",
        "answer": "我们通过反证法证明，如果 S 没有无限递减序列并且 ∀x({∀y[y ≺ x → P(y)]} → P(x))，那么对于所有 x ∈ S，P(x) 都为真。如果并非对所有 x ∈ S，P(x) 都为真，设 x1 是 S 的一个元素，使得 P(x1) 不为真。然后根据已给出的条件语句，必定有 ∀y[y ≺ x1 → P(y)] 不为真。这意味着存在某个 x2 使得 x2 ≺ x1 且 P(x2) 不为真。再次调用条件语句，我们得到一个 x3 使得 x3 ≺ x2 且 P(x3) 不为真，依此类推。这与我们的偏序集的良好性矛盾。因此，对于所有 x ∈ S，P(x) 都为真",
        "answer_symbols": [
            "∀",
            "→",
            "≺",
            "∈",
            "∧",
            "¬",
            "∃",
            "…"
        ]
    },
    "9 Supplementary Exercises 36": {
        "question": "设 R 是定义在从 Z+ 到 Z+ 的所有函数的关系，使得 (f, g) 属于 R 当且仅当 f 是 O(g)。证明：R 是拟序的.",
        "answer": "自反性是指 f 是 O(f)。这是通过在大 O 关系的定义中取 C = 1 和 k = 1 来简单得出的。传递性已在第 3.2 节的练习 17 中证明。",
        "answer_symbols": [
            "O",
            "f",
            "=",
            "C",
            "k"
        ]
    },
    "9 Supplementary Exercises 37": {
        "question": "设 R 是定义在 A 上的拟序。证明：R ∩ R-1 是等价关系.",
        "answer": "假设 R 是一个拟序。因为 R 是自反的，如果 a ∈ A，则 (a, a) ∈ R。这表明 (a, a) ∈ R^(-1)。因此，a ∈ R ∩ R^(-1)。由此可知 R ∩ R^(-1) 是自反的。R ∩ R^(-1) 对任何关系 R 都是对称的，因为对于任何关系 R，如果 (a, b) ∈ R，则 (b, a) ∈ R^(-1)，反之亦然。为了证明 R ∩ R^(-1) 是传递的，假设 (a, b) ∈ R ∩ R^(-1) 且 (b, c) ∈ R ∩ R^(-1)。因为 (a, b) ∈ R 且 (b, c) ∈ R，(a, c) ∈ R，因为 R 是传递的。类似地，因为 (a, b) ∈ R^(-1) 且 (b, c) ∈ R^(-1)，(b, a) ∈ R 且 (c, b) ∈ R，所以 (c, a) ∈ R 且 (a, c) ∈ R^(-1)。因此，(a, c) ∈ R ∩ R^(-1)。由此可知 R ∩ R^(-1) 是一个等价关系",
        "answer_symbols": [
            "∈",
            "∩",
            "^",
            "→",
            "¬",
            "∀",
            "∃",
            "…"
        ]
    },
    "9 Supplementary Exercises 38": {
        "question": "设 R 是拟序，S 是定义在 R ∩ R-1 的等价类的集合上的关系，C 和 D 是 R 的等价类，(C, D) 属于 S，当且仅当存在元素 c 属于 C，d 属于 D，使得 (c, d) 属于 R。证明 S 是偏序.",
        "answer": "已经在练习 37 中证明了当 R 是集合 A 上的拟序时，R ∩ R^-1 是等价关系。因此，谈论 R ∩ R^-1 的等价类是有意义的，并且关系 S 从其语法上是明确定义的。为了证明 S 是偏序关系，我们必须证明它是自反的、反对称的和传递的。对于第一个，我们需要证明 (C, C) 属于 S，这意味着存在元素 c ∈ C 和 d ∈ C 使得 (c, d) 属于 R。根据等价类的定义，C 不为空，所以设 c 是 C 的任意元素，令 d = c。那么 (c, c) 属于 R，因为 R 是自反的。接下来，对于反对称性，假设 (C, D) 和 (D, C) 都属于 S；我们必须证明 C = D。我们知道 (c, d) 属于 R，其中 c ∈ C 且 d ∈ D；并且 (d', c') 属于 R，其中 d' ∈ D 且 c' ∈ C。如果我们能证明 (c, d) 也属于 R^-1，那么我们将知道 c 和 d 属于 R ∩ R^-1 的同一个等价类，因此 C = D。为此，我们需要证明 (d, c) 属于 R。由于 d 和 d' 属于同一个等价类，我们知道 (d, d') 属于 R；我们已经提到 (d', c') 属于 R；并且由于 c' 和 c 属于同一个等价类，我们知道 (c', c) 属于 R。应用 R 的传递性三次，我们得出 (d, c) 属于 R，如我们所愿。最后，为了证明 S 的传递性，我们必须证明如果 (C, D) 属于 S 且 (D, E) 属于 S，那么 (C, E) 属于 S。假设告诉我们 (c, d) 属于 R，其中 c ∈ C 且 d ∈ D，以及 (d', e) 属于 R，其中 d' ∈ D 且 e ∈ E。与前一段类似，我们知道 (d, d') 属于 R。因此通过 R 的传递性（三次），(c, e) 属于 R，我们的证明完成。",
        "answer_symbols": [
            "∩",
            "^",
            "-",
            "∈",
            "(",
            ")",
            "R",
            "S",
            "C",
            "D",
            "E",
            "c",
            "d",
            "d'",
            "c'",
            "=",
            "→"
        ]
    },
    "9 Supplementary Exercises 39 a)": {
        "question": "证明下面的性质对格 L 的所有元素 x、y、z 成立：x ∧ y = y ∧ x，x ∨ y = y ∨ x（交换律）",
        "answer": "因为 glb(x, y) = glb(y, x) 且 lub(x, y) = lub(y, x)，所以 x ∧ y = y ∧ x 且 x ∨ y = y ∨ x",
        "answer_symbols": [
            "=",
            "∧",
            "∨"
        ]
    },
    "9 Supplementary Exercises 39 b)": {
        "question": "证明下面的性质对格 L 的所有元素 x、y、z 成立：(x ∧ y) ∧ z = x ∧ (y ∧ z)，(x ∨ y) ∨ z = x ∨ (y ∨ z)（结合律）",
        "answer": "根据定义，(x ∧ y) ∧ z 是 x、y 和 z 的一个下界，且大于其他所有下界。因为 x、y 和 z 的角色是可互换的，x ∧ (y ∧ z) 是相同的元素。类似地，(x ∨ y) ∨ z 是 x、y 和 z 的一个上界，且小于其他所有上界。因为 x、y 和 z 的角色是可互换的，x ∨ (y ∨ z) 是相同的元素",
        "answer_symbols": [
            "∧",
            "∨",
            "(",
            ")",
            ","
        ]
    },
    "9 Supplementary Exercises 39 c)": {
        "question": "证明下面的性质对格 L 的所有元素 x、y、z 成立：x ∧ (x ∨ y) = x，x ∨ (x ∧ y) = x（吸收律）",
        "answer": "为了证明 x ∧ (x ∨ y) = x，只需证明 x 是 x 和 x ∨ y 的最大下界。注意 x 是 x 的下界，因为 x ∨ y 按定义大于 x，x 也是它的下界。因此，x 是一个下界。但 x 的任何下界都必须小于 x，所以 x 是最大下界。第二个陈述是第一个的对偶；省略其证明",
        "answer_symbols": [
            "∧",
            "∨",
            "=",
            "<",
            "→"
        ]
    },
    "9 Supplementary Exercises 39 d)": {
        "question": "证明下面的性质对格 L 的所有元素 x、y、z 成立：x ∧ x = x，x ∨ x = x（幂等律）",
        "answer": "x 是自身的下界和上界，且是最大的和最小的这种界限",
        "answer_symbols": [
            "∧",
            "∨",
            "∈",
            "→"
        ]
    },
    "9 Supplementary Exercises 40": {
        "question": "证明：如果 x 和 y 是格的元素，那么 x ∨ y = y 当且仅当 x ∧ y = x.",
        "answer": "这基本上是从练习 39 的 (c) 部分直接得出的。假设 x ∨ y = y。那么根据第一条吸收律，x = x ∧ (x ∨ y) = x ∧ y。相反，如果 x ∧ y = x，那么根据第二条吸收律（交换 x 和 y 的角色），y = y ∨ (x ∧ y) = y ∨ x。（当然，我们也在使用交换律。）",
        "answer_symbols": [
            "∨",
            "∧",
            "x",
            "y",
            "="
        ]
    },
    "9 Supplementary Exercises 41 a)": {
        "question": "证明：如果 L 是具有上界 1 和下界 0 的有界格，那么对于 x ∈ L 的所有元素，具有下面的性质：x ∨ 1 = 1",
        "answer": "因为 1 是唯一大于或等于 1 的元素，它是 1 的唯一上界，因此也是 x 和 1 的最小上界的唯一可能值",
        "answer_symbols": [
            "=",
            "∨",
            "∧"
        ]
    },
    "9 Supplementary Exercises 41 b)": {
        "question": "证明：如果 L 是具有上界 1 和下界 0 的有界格，那么对于 x ∈ L 的所有元素，具有下面的性质：x ∧ 1 = x",
        "answer": "因为 x ≼ 1，x 是 x 和 1 的一个下界，且没有其他下界可以大于 x，所以 x ∧ 1 = x",
        "answer_symbols": [
            "∧",
            "≺",
            "="
        ]
    },
    "9 Supplementary Exercises 41 c)": {
        "question": "证明：如果 L 是具有上界 1 和下界 0 的有界格，那么对于 x ∈ L 的所有元素，具有下面的性质：x ∨ 0 = x",
        "answer": "因为 0 ≼ x，x 是 x 和 0 的一个上界，且没有其他上界可以小于 x，所以 x ∨ 0 = x",
        "answer_symbols": [
            "∨",
            "≺",
            "="
        ]
    },
    "9 Supplementary Exercises 41 d)": {
        "question": "证明：如果 L 是具有上界 1 和下界 0 的有界格，那么对于 x ∈ L 的所有元素，具有下面的性质：x ∧ 0 = 0",
        "answer": "因为 0 是唯一小于或等于 0 的元素，它是 0 的唯一下界，因此也是 x 和 0 的最大下界的唯一可能值",
        "answer_symbols": [
            "∧",
            "∨",
            "≺",
            "="
        ]
    },
    "9 Supplementary Exercises 42": {
        "question": "证明：每个有限格是有界的.",
        "answer": "根据第 9.6 节的练习 51，每个有限格都有最小元和最大元。这些元素就是本练习前言中讨论的 0 和 1。",
        "answer_symbols": [
            "0",
            "1"
        ]
    },
    "9 Supplementary Exercises 43": {
        "question": "给出一个不是分配格的例子.",
        "answer": "L = (S, ⊆) 其中 S = {∅, {1}, {2}, {3}, {1, 2}, {2, 3}, {1, 2, 3}}",
        "answer_symbols": [
            "⊆",
            "=",
            "{",
            "}",
            "∅"
        ]
    },
    "9 Supplementary Exercises 44": {
        "question": "证明：格 (P(S), ⊆) 是可分配的，其中 P(S) 是有穷集 S 的幂集.",
        "answer": "我们在第 9.6 节的示例 24 中了解到这个格中的交和并分别是 ∩ 和 ∪。我们从第 2.2 节（见表 1）知道这些运算互为分配。没有什么更多的需要证明的。",
        "answer_symbols": [
            "∩",
            "∪"
        ]
    },
    "9 Supplementary Exercises 45": {
        "question": "格 (Z+, |) 是可分配的吗？",
        "answer": "是",
        "answer_symbols": []
    },
    "9 Supplementary Exercises 46": {
        "question": "给出一个有限格的例子，其中至少有 1 个元素有多个补元且至少有 1 个元素没有补元.",
        "answer": "这是一个例子。读者应该画出哈斯图以便更直观地看到它。格中的元素是 0, 1, a, b, c, d 和 e。关系是 0 前面的所有其他元素；所有其他元素前面都是 1；b, d 和 e 前面都是 c；b 前面是 a。那么 d 和 e 都是 a 的补元，但 b 没有补元（因为除非 x = 1，否则 b ∨ x ≠ 1）。",
        "answer_symbols": [
            "∨",
            "1",
            "0",
            "e",
            "a",
            "d",
            "b",
            "≠",
            "c"
        ]
    },
    "9 Supplementary Exercises 47": {
        "question": "证明：格 (P(S), ⊆) 是有补格，其中 P(S) 是有穷集 S 的幂集.",
        "answer": "子集 X ⊆ S 的补集是其补集 S - X。要证明这一点，注意 X ∨ (S - X) = 1 且 X ∧ (S - X) = 0，因为 X ∪ (S - X) = S 且 X ∩ (S - X) = ∅",
        "answer_symbols": [
            "⊆",
            "∨",
            "∧",
            "∪",
            "∩",
            "∅",
            "-",
            "="
        ]
    },
    "9 Supplementary Exercises 48": {
        "question": "证明：如果 L 是有限分配格，那么 L 中的元素至多有 1 个补元.",
        "answer": "This can be proved by playing around with the symbolism. Suppose that a and b are both complements of x. This means that x ∨ a = 1, x ∧ a = 0, x ∨ b = 1, and x ∧ b = 0. Now using the various identities in Exercises 39 and 41 and the preamble to Exercise 43, we have a = a ∧ 1 = a ∧ (x ∨ b) = (a ∧ x) ∨ (a ∧ b) = 0 ∨ (a ∧ b) = a ∧ b. By the same argument, we can also show that b = a ∧ b. By transitivity of equality, it follows that a = b.",
        "answer_symbols": [
            "∨",
            "∧",
            "=",
            "≠"
        ]
    },
    "9 Supplementary Exercises 49": {
        "question": "证明：1.8 节例 12 中所描述的贪食游戏将曲奇饼摆放在 m × n 的矩形网格中，与偏序集 (S, ≤) 上的贪食游戏相同，其中 S 是所有能被 p^(m-1) q^(n-1) 整除的正整数集合，这里 p 和 q 是两个不同的素数.",
        "answer": "将矩形网格视为矩阵中的元素。因此我们从上到下编号，然后在其中从左到右编号。偏序关系是 (a, b) ≼ (c, d) 当且仅当 a ≤ c 且 b ≤ d。注意 (1, 1) 是该关系下的最小元素。第一章中解释的 Chomp 规则与这里的前言所述规则一致。但现在我们可以将点 (a, b) 与自然数 p^(a-1) * q^(b-1) 识别为所有 1 ≤ a ≤ m 和 1 ≤ b ≤ n 的 a 和 b。这将矩形网格中的点与本练习中的集合 S 识别为相同的，并且上述描述的偏序关系与除法关系相同，因为 p^(a-1) * q^(b-1) | p^(c-1) * q^(d-1) 当且仅当左边 p 的指数不超过右边 p 的指数，q 也类似",
        "answer_symbols": [
            "⊆",
            ")",
            "(",
            "∧",
            "*",
            "≼",
            "∈",
            "→",
            "∃",
            "∀",
            "∨",
            "…",
            "≤",
            "^"
        ]
    },
    "9 Supplementary Exercises 50": {
        "question": "证明：如果 (S, ≤) 有最大元 b，那么在这个偏序集上存在一个贪食游戏的获胜策略。[提示：推广 1.8 节例 12 中的结论。]",
        "answer": "Actually all finite games have a winning strategy for one player or the other; one can see this by writing down the game tree and analyzing it from the bottom up, as shown in Section 11.2. What we can show in this case is that the player who goes first has a winning strategy. We give a proof by contradiction. By the remark above, if the first player does not have a winning strategy, then the second player does. In particular, the second player has a winning response and strategy if the first player chooses b as her first move. Suppose that c is the first move of that winning strategy of the second player. But because c ≤ b, if the first player makes the move c at her first turn, then play can proceed exactly as if the first player had chosen b and then the second player had chosen c (because element b would be removed anyway when c is chosen). Thus the first player can win by adopting the strategy that the second player would have adopted. This is a contradiction, because it is impossible for both players to have a winning strategy. Therefore we can conclude that our assumption that the first player does not have a winning strategy is wrong, and therefore the first player does have a winning strategy.",
        "answer_symbols": [
            "≤"
        ]
    },
    "10.1 1 c)": {
        "question": "航班从纽华克到底特律、2个航班从底特律到纽华克、3个航班从纽华克到华盛顿、2个航班从华盛顿到纽华克、1个航班从华盛顿到迈阿密，其中 c) 对城市之间的每个航班(任何方向)来说，在表示城市的顶点之间有边，并且增加一个环，表示从迈阿密起飞和降落的特殊的观光旅行。",
        "answer": "底特律 波士顿 纽瓦克 迈阿密 华盛顿",
        "answer_symbols": []
    },
    "10.1 1 d)": {
        "question": "航班从纽华克到底特律、2个航班从底特律到纽华克、3个航班从纽华克到华盛顿、2个航班从华盛顿到纽华克、1个航班从华盛顿到迈阿密，其中 d) 从表示航班出发城市的顶点到表示航班终止城市的顶点之间有边。",
        "answer": "底特律 波士顿 纽瓦克 迈阿密 华盛顿",
        "answer_symbols": []
    },
    "10.1 1 e)": {
        "question": "航班从纽华克到底特律、2个航班从底特律到纽华克、3个航班从纽华克到华盛顿、2个航班从华盛顿到纽华克、1个航班从华盛顿到迈阿密，其中 e) 对每个航班，从表示出发城市的顶点到表示终止城市的顶点之间有边。",
        "answer": "底特律 波士顿 纽瓦克 迈阿密 华盛顿",
        "answer_symbols": []
    },
    "10.1 2 a)": {
        "question": "用什么类型的图(根据表1)来为大城市之间高速公路系统建模，其中 a) 若在城市之间有州际高速公路，则在表示城市的顶点之间有边。",
        "answer": "由于没有平行边或环，并且边是无向的，因此可以使用简单图作为模型。",
        "answer_symbols": []
    },
    "10.1 2 b)": {
        "question": "用什么类型的图(根据表1)来为大城市之间高速公路系统建模，其中 b) 对城市之间每条州际高速公路，在表示城市的顶点之间有边。",
        "answer": "原则上需要一个多重图，因为同一对城市之间可能有多个州际高速公路。",
        "answer_symbols": []
    },
    "10.1 2 c)": {
        "question": "用什么类型的图(根据表1)来为大城市之间高速公路系统建模，其中 c) 对城市之间每条州际高速公路，在表示城市的顶点之间有边；若有环城州际高速公路，则在表示该城的顶点上有环。",
        "answer": "需要一个伪图，以允许存在环。",
        "answer_symbols": []
    },
    "10.1 10": {
        "question": "练习3~9中的每个无向图不是简单图，找出使它变成简单图的可删除的边的集合。",
        "answer": "练习3中的图是简单的。练习4中的多重图可以通过删除a和b之间的任意一条边，以及b和d之间的两条边来简化为简单图。练习5中的伪图可以通过删除三个环和每对平行边中的一条边来简化为简单图。练习6中的多重图可以通过删除a和c之间的任意一条边，以及b和d之间的一条边来简化为简单图。其他三个不是无向图。（当然，删除所给答案的任何超集也是有效的答案；特别是，我们可以删除所有边。）",
        "answer_symbols": []
    },
    "10.1 11": {
        "question": "设G是简单图。R是G的顶点集上的关系，uRv当且仅当G中有与(u, v)相关联的边。证明：关系R是定义在G上的对称的和反自反的关系。",
        "answer": "如果 uRv，则存在与 {u, v} 相关的边。但 {u, v} = {v, u}，因此这条边也与 {v, u} 相关，因此 vRu。因此，根据定义，R 是对称关系。简单图不允许自环；因此，uRu 从不成立，所以根据定义 R 是反自反的。",
        "answer_symbols": [
            "{",
            "}",
            "="
        ]
    },
    "10.1 12": {
        "question": "设G是无向图，且其每个顶点上均有环。R是G的顶点集上的关系，uRv当且仅当G中有与(u, v)相关联的边。证明关系R是定义在G上的对称的和反自反的关系。",
        "answer": "如果u R v，则顶点u和v之间有一条边，由于图是无向的，这也是一条连接顶点v和u的边。这意味着v R u。因此关系是对称的。由于环确保了每个顶点u都有u R u，所以关系是自反的。",
        "answer_symbols": [
            "R",
            "→"
        ]
    },
    "10.1 13 a)": {
        "question": "集合A1, A2, ..., An的交图是这样的图，用顶点表示每个集合，若两个集合有非空交集，则有一条边连接代表这两个集合的顶点。构造下列集合的交图。 a) A1 = {0, 2, 4, 6, 8}, A2 = {0, 1, 2, 3, 4} A3 = {1, 3, 5, 7, 9}, A4 = {5, 6, 7, 8, 9} A5 = {0, 1, 8, 9}",
        "answer": "A1 A5 A3 A4 A2",
        "answer_symbols": []
    },
    "10.1 13 b)": {
        "question": "集合A1, A2, ..., An的交图是这样的图，用顶点表示每个集合，若两个集合有非空交集，则有一条边连接代表这两个集合的顶点。构造下列集合的交图。 b) A1 = {..., -4, -3, -2, -1, 0} A2 = {..., -2, -1, 0, 1, 2, ...} A3 = {..., -6, -4, -2, 0, 2, 4, 6, ...} A4 = {..., -5, -3, -1, 1, 3, 5, ...} A5 = {..., -6, -3, 0, 3, 6, ...}",
        "answer": "A1 A5 A3 A4 A2",
        "answer_symbols": []
    },
    "10.1 13 c)": {
        "question": "集合A1, A2, ..., An的交图是这样的图，用顶点表示每个集合，若两个集合有非空交集，则有一条边连接代表这两个集合的顶点。构造下列集合的交图。 c) A1 = {x | x < 0}, A2 = {x | -1 < x < 0} A3 = {x | 0 < x < 1}, A4 = {x | -1 < x < 1} A5 = {x | x > -1}, A6 = R",
        "answer": "A3 A6 A4 A5 A1 A2",
        "answer_symbols": []
    },
    "10.1 14": {
        "question": "用图11中的栖息地重叠图来确定与鹰竞争的物种。",
        "answer": "由于从鹰到乌鸦、猫头鹰和浣熊有边，图告诉我们鹰与这三种动物竞争。",
        "answer_symbols": [
            "→"
        ]
    },
    "10.1 15": {
        "question": "构造6种鸟的栖息地重叠图，其中隐士鸫与旅鸫以及蓝松鸦竞争、旅鸫也与嘲鸫竞争、嘲鸫也与蓝",
        "answer": "赫米特画眉 鸟 知更鸟 啄木鸟 山雀 模仿鸟 蓝鸟",
        "answer_symbols": []
    },
    "10.1 16": {
        "question": "画出相识关系图，表示 Tom 与 Patricia、Tom 与 Hope、Tom 与 Sandy、Tom 与 Amy、Tom 与 Marika、Jeff 与 Patricia、Jeff 与 Mary、Patricia 与 Hope、Amy 与 Hope 以及 Amy 与 Marika 互相认识，但是除了上述以外，其他人之间互相不认识。",
        "answer": "每个人用一个顶点表示，两个顶点之间有一条边当且仅当这两个人相识。",
        "answer_symbols": [
            "→"
        ]
    },
    "10.1 17": {
        "question": "可用图来表示两个人是否生活在同一时代。画出这样的图来表示本书前 5 章里有生平介绍的在 1900 年以前去世的属于同一时代的数学家和计算机科学家。（如果在同一年里两个人都在世，就假设他们生活在同一时代。）",
        "answer": "拉梅 高斯 斯特林 道奇森 布尔 洛夫莱斯 德摩根 费马 梅森 笛卡尔 哥德巴赫 贝祖 亚里士多德 欧几里得 埃拉托色尼 斐波那契 马罗利科 阿尔-花剌子米",
        "answer_symbols": []
    },
    "10.1 18": {
        "question": "在例 2 的影响图里谁影响 Fred？Fred 影响谁？",
        "answer": "Fred影响Brian，因为有一条从Fred到Brian的边。Yvonne和Deborah影响Fred，因为有一条从这两个顶点到Fred的边。",
        "answer_symbols": [
            "→"
        ]
    },
    "10.1 19": {
        "question": "构造公司董事会成员的影响图，主席影响研发总监、市场总监和营运总监；研发总监影响营运总监；市场总监影响营运总监；无人影响首席财务官或受其影响。",
        "answer": "总裁 首席财务官 运营总监 研发总监 市场营销总监",
        "answer_symbols": []
    },
    "10.1 20": {
        "question": "在图 13 表示的循环赛里，队 4 击败哪些其他队？哪些队击败队 4？",
        "answer": "四号队击败了从四号队有边指向的顶点，即只有三号队。其他队伍——一号队、二号队、五号队和六号队——都击败了四号队，因为有一条从它们到四号队的边。",
        "answer_symbols": [
            "→"
        ]
    },
    "10.1 21": {
        "question": "在循环赛里，老虎队击败蓝松鸦队、红衣主教队和北美金莺队，蓝松鸦队击败红衣主教队和北美金莺队，红衣主教队击败北美金莺队，用有向图为这样的结果建模。",
        "answer": "老虎 蓝鸟 金莺 红雀",
        "answer_symbols": []
    },
    "10.1 22": {
        "question": "画出 7 个电话号码 555-0011、555-1221、555-1333、555-8888、555-2222、555-0091 以及 555-1200 的呼叫图，假设从 555-0011 到 555-8888 有 3 次呼叫，从 555-8888 到 555-0011 有 2 次呼叫，从 555-2222 到 555-0091 有 2 次呼叫，从 555-1221 到其他每个号码都有 2 次呼叫，从 555-1333 到 555-0011、555-1221 和 555-1200 各有 1 次呼叫。",
        "answer": "This is a directed multigraph with one edge from a to b for each call made by a to b. Rather than draw the parallel edges with parallel lines, we have indicated what is intended by writing a numeral on the edge to indicate how many calls were made, if it was more than one.",
        "answer_symbols": [
            "→",
            "∥"
        ]
    },
    "10.1 23": {
        "question": "解释如何用 1 月份和 2 月份的电话呼叫图来确定改变了电话号码的人的新电话号码。",
        "answer": "我们在二月份的通话图中找到一月份通话图中不存在的电话号码，反之亦然。对于每个找到的号码，我们使用通话图中的边制作一个列表，列出它们拨打或被拨打的号码。我们检查这些列表，以发现二月份的新电话号码与一月份已失效的电话号码具有相似的通话模式。",
        "answer_symbols": []
    },
    "10.1 24 a)": {
        "question": "解释如何用图为网络中的电子邮件信息建模。用有向边还是无向边？是否允许多重边？是否允许自环？",
        "answer": "We can have a vertex for each mailbox or e-mail address in the network, with a directed edge between two vertices if a message is sent from the tail of the edge to the head.",
        "answer_symbols": [
            "→"
        ]
    },
    "10.1 24 b)": {
        "question": "描述为网络里具体某一周内发送的电子邮件建模的图。",
        "answer": "As in part (a), we use a directed edge for each message sent during the week.",
        "answer_symbols": [
            "→"
        ]
    },
    "10.1 25": {
        "question": "如何用表示网络里发送电子邮件的图来找出最近改变了原来电子邮件地址的人？",
        "answer": "我们使用电子邮件地址作为顶点的图模型，每发送一条消息，就从发件人的电子邮件地址到收件人的电子邮件地址添加一条边。对于每个电子邮件地址，我们可以制作一个列表，列出他们发送消息的其他地址和接收消息的其他地址。如果两个电子邮件地址几乎有相同的模式，我们得出结论，这些地址可能属于同一人。",
        "answer_symbols": []
    },
    "10.1 26": {
        "question": "如何用表示网络里发送电子邮件的图来找出电子邮件的地址表，该地址表用来发送同样的消息给许多不同的电子邮件地址。",
        "answer": "Vertices with thousands or millions of edges going out from them could be the senders of such mass mailings. The collection of heads of these edges would be the mailing lists themselves.",
        "answer_symbols": [
            "→"
        ]
    },
    "10.1 27": {
        "question": "描述一个图模型，它表示在某个聚会上每个人是否知道另一个人的名字。图中的边应该是有向的还是无向的？是否应该允许多重边？是否应该允许环？",
        "answer": "顶点是课程；边是有向的；边 uv 表示课程 u 是课程 v 的先修课；没有先修课的课程是入度为 0 的顶点；不是任何其他课程先修课的课程是出度为 0 的顶点。",
        "answer_symbols": [
            "→",
            "0"
        ]
    },
    "10.1 28": {
        "question": "描述一个图模型，它表示一个大城市的地铁系统。图中的边应该是有向的还是无向的？是否应该允许多重边？是否应该允许环？",
        "answer": "We make the subway stations the vertices, with an edge from station u to station v if there is a train going from u to v without stopping. It is quite possible that some segments are one-way, so we should use directed edges. (If there are no one-way segments, then we could use undirected edges.) There would be no need for multiple edges, unless we had two kinds of edges, maybe with different colors, to represent local and express trains. In that case, there could be parallel edges of different colors between the same vertices, because both a local and an express train might travel the same segment. There would be no point in having loops, because no passenger would want to travel from a station back to the same station without stopping.",
        "answer_symbols": [
            "→",
            "∥",
            "¬"
        ]
    },
    "10.1 29": {
        "question": "对于大学中的每一门课程，可能存在 1 门或多门先修课。如何使用图进行建模，表示课程以及哪些课程是其他课程的先修课程？图中的边应该是有向的还是无向的？在该图中，如何发现没有先修课程的课程以及不是任何一门课程的先修课程的课程？",
        "answer": "顶点集是一组人，如果两人曾经结婚，则两个顶点之间有一条边相连。忽略复杂情况，这个图具有两种类型的顶点（男性和女性），每条边连接的是不同类型的顶点。",
        "answer_symbols": []
    },
    "10.1 30": {
        "question": "描述一种表示电影评论家的积极建议的图模型，用顶点表示这些评论以及正在放映的电影。",
        "answer": "A bipartite graph (this terminology is introduced in the next section) works well here. There are two types of vertices—one type representing the critics and one type representing the movies. There is an edge between vertex c (a critic vertex) and vertex m (a movie vertex) if and only if the critic represented by c has positively recommended the movie represented by m. There are no edges between critic vertices and there are no edges between movie vertices.",
        "answer_symbols": [
            "→"
        ]
    },
    "10.1 31": {
        "question": "描述一种表示传统婚姻的图模型。这个图有什么特殊性质？",
        "answer": "用顶点表示群体中的人。对于每一对顶点，在图中添加一条有向边。将从表示 A 的顶点到表示 B 的顶点的边标记为 +（加号）如果 A 喜欢 B，标记为 -（减号）如果 A 不喜欢 B，标记为 0 如果 A 对 B 持中立态度。",
        "answer_symbols": [
            "→",
            "+",
            "-",
            "0"
        ]
    },
    "10.1 32": {
        "question": "在例 8 的程序中，执行 S₆ 之前必须执行哪些语句？（使用图 10 的优先图。）",
        "answer": "The model says that the statements for which there are edges to S6 must be executed before S6, namely the statements S1, S2, S3, and S4.",
        "answer_symbols": [
            "→"
        ]
    },
    "10.1 34": {
        "question": "描述一种基于图的离散结构，用它来为航空公司的航线和航班时间建模。[提示：给一个有向图添加结构。]",
        "answer": "The vertices in the directed graph represent cities. Whenever there is a nonstop flight from city A to city B, we put a directed edge into our directed graph from vertex A to vertex B, and furthermore we label that edge with the flight time. Let us see how to incorporate this into the mathematical definition. Let us call such a thing a directed graph with weighted edges. It is defined to be a triple (V, E, W), where (V, E) is a directed graph (i.e., V is a set of vertices and E is a set of ordered pairs of elements of V) and W is a function from E to the set of nonnegative real numbers. Here we are simply thinking of W(e) as the weight of edge e, which in this case is the flight time.",
        "answer_symbols": [
            "→",
            "(",
            ")",
            "∈",
            "×",
            "→",
            "W"
        ]
    },
    "10.1 36": {
        "question": "描述一个图模型，它能在一个简单图中表示两个人之间所有形式的电子通信。这需要哪种图？",
        "answer": "We can let the vertices represent people; an edge from u to v would indicate that u can send a message to v. We would need a directed multigraph in which the edges have labels, where the label on each edge indicates the form of communication (cell phone audio, text messaging, and so on).",
        "answer_symbols": [
            "→",
            "∥"
        ]
    },
    "10.2 1": {
        "question": "求所给无向图的顶点数、边数以及每个顶点的度。指出所有的孤立点和悬挂点。",
        "answer": "v = 6; e = 6; deg(a) = 2, deg(b) = 4, deg(c) = 1, deg(d) = 0, deg(e) = 2, deg(f) = 3; c 是悬挂点；d 是孤立点。",
        "answer_symbols": [
            "=",
            "(",
            ")",
            ","
        ]
    },
    "10.2 2": {
        "question": "求所给无向图的顶点数、边数以及每个顶点的度。指出所有的孤立点和悬挂点。",
        "answer": "在这个伪图中有5个顶点和13条边。顶点a的度为6，因为除了与a相连的4条非环边外，还有一个环为度贡献了2。其他顶点的度分别为deg(b)= 6, deg(c)= 6, deg(d)= 5, 和 deg(e)= 3。这个伪图中没有悬挂顶点或孤立顶点。\n",
        "answer_symbols": []
    },
    "10.2 3": {
        "question": "求所给无向图的顶点数、边数以及每个顶点的度。指出所有的孤立点和悬挂点。",
        "answer": "v = 9; e = 12; deg(a) = 3, deg(b) = 2, deg(c) = 4, deg(d) = 0, deg(e) = 6, deg(f) = 0; deg(g) = 4; deg(h) = 2; deg(i) = 3; d 和 f 是孤立点。",
        "answer_symbols": [
            "=",
            "(",
            ")",
            ","
        ]
    },
    "10.2 4": {
        "question": "求练习 1 3 中每个图的顶点的度之和，并验证它等于图中边数的 2 倍。",
        "answer": "对于练习1中的图，总和为2+4+1+0+2+3= 12= 2*6；有6条边。对于练习2中的伪图，总和为6+ 6+ 6+ 5+ 3= 26= 2*13；有13条边。对于练习3中的伪图，总和为3+ 2+ 4+ 0+ 6+ 0+ 4+ 2+ 3= 24= 2 * 12；有12条边。\n",
        "answer_symbols": []
    },
    "10.2 5": {
        "question": "是否存在一个有 15 个顶点而且每个顶点的度都为 5 的简单图？",
        "answer": "否",
        "answer_symbols": []
    },
    "10.2 6": {
        "question": "证明：在一次聚会上全体人员的握手次数之和是偶数。假设无人自己与自己握手。",
        "answer": "通过让图的顶点表示聚会中的人，并在两个人之间画一条边来建模此问题，如果他们握手。那么每个顶点的度就是该顶点代表的人握手的人数。根据定理1，度的总和是偶数（它是2e）。",
        "answer_symbols": []
    },
    "10.2 7": {
        "question": "对给定的有向多重图，确定顶点数和边数，并求出每个顶点的人度和出度。",
        "answer": "v = 4; e = 7; deg-(a) = 3, deg-(b) = 1, deg-(c) = 2, deg-(d) = 1, deg+(a) = 1, deg+(b) = 2, deg+(c) = 1, deg+(d) = 3",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "-",
            "+"
        ]
    },
    "10.2 8": {
        "question": "对给定的有向多重图，确定顶点数和边数，并求出每个顶点的人度和出度。",
        "answer": "在这个有向多重图中有4个顶点和8条边。度分别为deg-(a)= 2, deg+(a)= 2, deg-(b)= 3, deg+(b)= 4, deg-(c)= 2, deg+(c)= 1, deg-(d)= 1, 和 deg+(d)= 1。",
        "answer_symbols": []
    },
    "10.2 9": {
        "question": "对给定的有向多重图，确定顶点数和边数，并求出每个顶点的人度和出度。",
        "answer": "5 个顶点，13 条边；deg-(a) = 6, deg+(a) = 1, deg-(b) = 1, deg+(b) = 5, deg-(c) = 2, deg+(c) = 5, deg-(d) = 4, deg+(d) = 2, deg-(e) = 0, deg+(e) = 0",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "-",
            "+"
        ]
    },
    "10.2 10": {
        "question": "对练习 7 9 中的每个图，直接确定每个顶点的人度之和与出度之和。证明：它们都等于图中的边数。",
        "answer": "对于练习7，入度之和为3+1+2+1= 7，出度之和为1+2+1+3= 7；有7条边。对于练习8，入度之和为2+3+2+1= 8，出度之和为2+ 4+ 1+ 1= 8；有8条边。对于练习9，入度之和为6+ 1+ 2+ 4+ 0= 13，出度之和为1+ 5+ 5+ 2+ 0= 13；有13条边。",
        "answer_symbols": []
    },
    "10.2 11": {
        "question": "构造图 2 中带有向边的图的基本无向图。",
        "answer": "a b c\nf d e",
        "answer_symbols": []
    },
    "10.2 12": {
        "question": "在相识关系图中（其中顶点表示世界上所有的人），顶点的度表示什么？在这个图中，一个顶点的邻居表示什么？孤立点和悬挂点表示什么？在一项研究中，估计在这个图中顶点的平均度是 1000。就这个模型而言，这意味着什么？",
        "answer": "由于从一个人到他/她的每个熟人之间有一条边，因此v的度就是v认识的人数。孤立顶点是一个不认识任何人的顶点，而悬挂顶点是一个只认识一个人的顶点（很可能没有或很少有这样的顶点）。如果平均度为1000，那么平均每个人认识1000个人。",
        "answer_symbols": []
    },
    "10.2 13": {
        "question": "在学术合作图中，顶点的度表示什么？一个顶点的邻居表示什么？孤立点和悬挂点表示什么？",
        "answer": "该人的合作者数量；该人的合作者；一个没有合作者的人；只有一个合作者的人",
        "answer_symbols": []
    },
    "10.2 14": {
        "question": "在好莱坞图里，顶点的度表示什么？一个顶点的邻居表示什么？孤立点和悬挂点表示什么？",
        "answer": "由于从一个人到他/她共演过的每个其他演员之间有一条边，因此v的度就是这个人共演过的其他演员人数。v的邻域是与v共演的演员集合。孤立顶点是一个只出现在自己是唯一演员的电影中的人，而悬挂顶点是一个只与一个其他演员共演过电影的人（很可能没有或很少有这样的顶点）。",
        "answer_symbols": []
    },
    "10.2 15": {
        "question": "在 10.1 节例 4 所描述的电话呼叫图中，顶点的人度和出度表示什么？在这个图的无向图版本中，顶点的度表示什么？",
        "answer": "在有向图中，deg-(v) = v 接收的电话数量，deg+(v) = v 发出的电话数量；在无向图中，deg(v) 是 v 收发的电话总数。",
        "answer_symbols": [
            "-",
            "+",
            "="
        ]
    },
    "10.2 19": {
        "question": "利用练习 18 证明：在一个小组中，至少有两个人具有相同的朋友数。",
        "answer": "在无向图模型中，顶点是群体中的人，两个顶点相邻表示这两个人是朋友，顶点的度数是该人在群体中的朋友数量。由练习 18 可知，有两个顶点的度数相同，这意味着群体中有两个人在群体中的朋友数量相同。",
        "answer_symbols": [
            "="
        ]
    },
    "10.2 16": {
        "question": "在 10.1 节例 5 所描述的网络图中，顶点的人度和出度表示什么？",
        "answer": "由于从一个页面到它链接的每个页面之间有一条边，因此顶点的出度就是该页面上的链接数，而顶点的入度就是有链接指向它的其他页面数。",
        "answer_symbols": []
    },
    "10.2 17": {
        "question": "在为循环赛建模的有向图中，顶点的人度和出度表示什么？",
        "answer": "(deg+(v), deg-(v)) 是 v 的胜负记录。",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "-"
        ]
    },
    "10.2 18": {
        "question": "证明：在至少含有两个顶点的简单图中，一定有两个顶点的度相同。",
        "answer": "这基本上与第6.2节中的练习40相同，其中图模型化了聚会上人们“相互认识”的关系。参见该练习的解答。一个人认识的人数就是对应顶点在图中的度。",
        "answer_symbols": []
    },
    "10.2 20 a)": {
        "question": "画出 K7。",
        "answer": "这个图有7个顶点，每对不同的顶点之间都有一条边。",
        "answer_symbols": []
    },
    "10.2 20 b)": {
        "question": "画出 K1,8。",
        "answer": "This graph is the complete bipartite graph on parts of size 1 and 8; we have put the part of size 1 in the middle.",
        "answer_symbols": []
    },
    "10.2 20 c)": {
        "question": "画出 K4,4。",
        "answer": "This is the complete bipartite graph with 4 vertices in each part.",
        "answer_symbols": []
    },
    "10.2 20 d)": {
        "question": "画出 C7。",
        "answer": "This is the 7-cycle.",
        "answer_symbols": []
    },
    "10.2 20 e)": {
        "question": "画出 W7。",
        "answer": "The 7-wheel is the 7-cycle with an extra vertex joined to the other 7 vertices. Warning: Some texts call this W8, to have the consistent notation that the subscript in the name of a graph should be the number of vertices in that graph.",
        "answer_symbols": []
    },
    "10.2 20 f)": {
        "question": "画出 Q4。",
        "answer": "We take two copies of Q3 and join corresponding vertices.",
        "answer_symbols": []
    },
    "10.2 21": {
        "question": "判断图是否为二分图。",
        "answer": "二部图",
        "answer_symbols": []
    },
    "10.2 22": {
        "question": "判断图是否为二分图。",
        "answer": "This graph is bipartite, with bipartition {a, c} and {b, d, e}. In fact, this is the complete bipartite graph K2,3. If this graph were missing the edge between a and d, then it would still be bipartite on the same sets, but not a complete bipartite graph.",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "10.2 23": {
        "question": "判断图是否为二分图。",
        "answer": "非二部图",
        "answer_symbols": []
    },
    "10.2 24": {
        "question": "判断图是否为二分图。",
        "answer": "This is the complete bipartite graph K2,4. The vertices in the part of size 2 are c and f, and the vertices in the part of size 4 are a, b, d, and e.",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "10.2 25": {
        "question": "判断图是否为二分图。",
        "answer": "非二部图",
        "answer_symbols": []
    },
    "10.2 26 a)": {
        "question": "对哪些 n 值来说，K_n 是二分图？",
        "answer": "By the definition given in the text, K1 does not have enough vertices to be bipartite (the sets in a partition have to be nonempty). Clearly K2 is bipartite. There is a triangle in Kn for n > 2, so those complete graphs are not bipartite.",
        "answer_symbols": [
            "K",
            "(",
            ">",
            "{",
            ",",
            "}",
            ")"
        ]
    },
    "10.2 27": {
        "question": "设一个大学工程学院的计算机机支撑小组有 4 个员工。每个员工被分配支持 4 个不同的领域之一：硬件、软件、网络和无线。假设 Ping 能够胜任支持硬件、网络和无线；Quiggle 能够胜任支持软件和网络；Ruiz 能够胜任支持网络和无线；Sitea 能够胜任支持硬件和软件。",
        "answer": "a) 部分 {h, s, n, w} 和 {P, Q, R, S}，E = {{P, n}, {P, w}, {Q, s}, {Q, n}, {R, n}, {R, w}, {S, h}, {S, s}} b) 有。c) {Pw, Qs, Rn, Sh} 其中之一",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "10.2 29": {
        "question": "使用霍尔定理证明：不存在岛上年轻男子和年轻女子的匹配使得每一个年轻男子都能和他想娶的年轻女子进行匹配。",
        "answer": "只有 Barry 愿意娶 Uma 和 Xia。",
        "answer_symbols": []
    },
    "10.2 31": {
        "question": "设存在一个整数 k，使得在一个荒岛上的每个男人都愿意娶该岛上的女人恰好是 k 个，而且该岛上的每一个女人都愿意嫁给的男人也恰好是 k 个。同时假设一个男人愿意娶一个女人当且仅当这个女人愿意嫁给他。证明：可能存在岛上男人和女人的匹配，使得每一个人都能和其愿意嫁娶的人进行匹配。",
        "answer": "用无向二部图建模，顶点间有边表示男女愿意结婚。根据霍尔定理，只需证明对于任意一组女性 S，愿意与她们结婚的男性集合 N(S) 的基数至少为 |S|。设 m 是 S 和 N(S) 之间的边数。由于 S 中的每个顶点的度数为 k，因此 m = k|S|。因为这些边与 N(S) 相连，所以 m ≤ k|N(S)|。因此 k|S| ≤ k|N(S)|，所以 |N(S)| ≥ |S|。",
        "answer_symbols": [
            "{",
            "}",
            "|",
            "=",
            "<=",
            "≥"
        ]
    },
    "10.2 38": {
        "question": "二分图 K_m,n 的度序列是什么（其中 m, n 是正整数）？并解释你的答案。",
        "answer": "Assume that m ≥ n. Then each of the n vertices in one part has degree m, and each of the m vertices in the other part has degree n. Thus the degree sequence is m, m, …, m, n, n, …, n, where the sequence contains n copies of m and m copies of n. We put the m's first because we assumed that m ≥ n. If n ≥ m, then of course we would put the m copies of n first. If m = n, this would mean a total of 2n copies of n.",
        "answer_symbols": [
            "≥",
            "=",
            "…"
        ]
    },
    "10.2 39": {
        "question": "图 K_n 的度序列是什么（其中 n 是正整数）？并解释你的答案。",
        "answer": "每个顶点都与其他 n - 1 个顶点相邻，因此度序列是 n - 1, n - 1,..., n - 1（n 项）。",
        "answer_symbols": [
            "-",
            ","
        ]
    },
    "10.2 40": {
        "question": "若图的度序列是 4, 3, 3, 2, 2，则它有多少条边？画出这样的图。",
        "answer": "The 4-wheel (see Figure 5) with one edge along the rim deleted is such a graph. It has (4 + 3 + 3 + 2 + 2) / 2 = 7 edges.",
        "answer_symbols": [
            "+",
            "/",
            "="
        ]
    },
    "10.2 41": {
        "question": "若图的度序列是 5, 2, 2, 2, 1，则它有多少条边？画出这样的图。",
        "answer": "7",
        "answer_symbols": []
    },
    "10.2 42 a)": {
        "question": "判断下列序列是否是成图的。如果是，请画出一个图使其具有给定的度序列。5, 4, 3, 2, 1, 0",
        "answer": "Since the number of odd-degree vertices has to be even, no graph exists with these degrees. Another reason no such graph exists is that the vertex of degree 0 would have to be isolated but the vertex of degree 5 would have to be adjacent to every other vertex, and these two statements are contradictory.",
        "answer_symbols": []
    },
    "10.2 42 b)": {
        "question": "判断下列序列是否是成图的。如果是，请画出一个图使其具有给定的度序列。6, 5, 4, 3, 2, 1",
        "answer": "Since the number of odd-degree vertices has to be even, no graph exists with these degrees. Another reason no such graph exists is that the degree of a vertex in a simple graph is at most 1 less than the number of vertices.",
        "answer_symbols": []
    },
    "10.2 42 c)": {
        "question": "判断下列序列是否是成图的。如果是，请画出一个图使其具有给定的度序列。2, 2, 2, 2, 2",
        "answer": "A 6-cycle is such a graph. (See picture below.)",
        "answer_symbols": []
    },
    "10.2 42 d)": {
        "question": "判断下列序列是否是成图的。如果是，请画出一个图使其具有给定的度序列。3, 3, 3, 2, 2, 2",
        "answer": "Since the number of odd-degree vertices has to be even, no graph exists with these degrees.",
        "answer_symbols": []
    },
    "10.2 42 e)": {
        "question": "判断下列序列是否是成图的。如果是，请画出一个图使其具有给定的度序列。3, 3, 2, 2, 2, 2",
        "answer": "A 6-cycle with one of its diagonals added is such a graph. (See picture below.)",
        "answer_symbols": []
    },
    "10.2 42 f)": {
        "question": "判断下列序列是否是成图的。如果是，请画出一个图使其具有给定的度序列。1, 1, 1, 1, 1, 1",
        "answer": "A graph consisting of three edges with no common vertices is such a graph. (See picture below.)",
        "answer_symbols": []
    },
    "10.2 42 g)": {
        "question": "判断下列序列是否是成图的。如果是，请画出一个图使其具有给定的度序列。5, 3, 3, 3, 3",
        "answer": "The 5-wheel is such a graph. (See picture below.)",
        "answer_symbols": []
    },
    "10.2 42 h)": {
        "question": "判断下列序列是否是成图的。如果是，请画出一个图使其具有给定的度序列。5, 5, 4, 3, 2, 1",
        "answer": "Each of the vertices of degree 5 is adjacent to all the other vertices. Thus there can be no vertex of degree 1. So no such graph exists.",
        "answer_symbols": []
    },
    "10.2 44": {
        "question": "设 d_1, d_2, …, d_n 是成图序列。证明：存在顶点为 v_1, v_2, …, v_n 的简单图，使得对于 i=1, 2, …, n, deg(v_i)=d_i，且 v_i 与 v_i, …, v_i+1 相邻。",
        "answer": "Since isolated vertices play no essential role, we can assume that d_n > 0. The sequence is graphic, so there is some simple graph G such that the degrees of the vertices are d_1, d_2, …, d_n. Without loss of generality, we can label the vertices of our graph so that d(v_i) = d_i. Among all such graphs, choose G to be one in which v_1 is adjacent to as many of v_2, v_3, …, v_{d_1+1} as possible. (The worst case might be that v_1 is not adjacent to any of these vertices.) If v_1 is adjacent to all of them, then we are done. We will show that if there is a vertex among v_2, v_3, …, v_{d_1+1} that v_1 is not adjacent to, then we can find another graph with d(v_i) = d_i and having v_1 adjacent to one more of the vertices v_2, v_3, …, v_{d_1+1} than is true for G. This is a contradiction to the choice of G, and hence we will have shown that G satisfies the desired condition. Under this assumption, then, let u be a vertex among v_2, v_3, …, v_{d_1+1} that v_1 is not adjacent to, and let w be a vertex not among v_2, v_3, …, v_{d_1+1} that v_1 is adjacent to; such a vertex w has to exist because d(v_1) = d_1. Because the degree sequence is listed in nonincreasing order, we have d(u) ≥ d(w). Consider all the vertices that are adjacent to u. It cannot be the case that w is adjacent to each of them, because then w would have a higher degree than u (because w is adjacent to v_1 as well, but u is not). Therefore there is some vertex x such that edge ux is present but edge xw is not present. Note also that edge v_1w is present but edge v_1u is not present. Now construct the graph G' to be the same as G except that edges ux and v_1w are removed and edges xw and v_1u are added. The degrees of all vertices are unchanged, but this graph has v_1 adjacent to more of the vertices among v_2, v_3, …, v_{d_1+1} than is the case in G. That gives the desired contradiction, and our proof is complete.",
        "answer_symbols": [
            "=",
            ">",
            "≥",
            "…",
            "≠"
        ]
    },
    "10.2 45": {
        "question": "证明：一个由非负整数按非递增排列的序列 d_1, d_2, …, d_n 是成图序列当且仅当把序列 d_2-1, …, d_d_i+1-1, d_d_i+2, …, d_n 中的元素重新排序为非递增而得到的序列是成图序列。",
        "answer": "首先，假设 d1, d2,..., dn 是图形化的。我们必须证明当将其按非递增顺序排列时，项为 d2-1, d3-1,..., dd1+1-1, dd1+2, dd1+3,..., dn 的序列也是图形化的。在练习 44 中证明了如果原始序列是图形化的，那么实际上存在一个具有此度序列的图，其中度数为 d1 的顶点与度数为 d2, d3,..., dd1+1 的顶点相邻。从这个图中移除最高度数的顶点（d1）。得到的图具有所需的度序列。反之，假设 d1, d2,..., dn 是非递增序列，使得序列",
        "answer_symbols": [
            "-",
            ","
        ]
    },
    "10.2 46": {
        "question": "运用练习 45 的结论构造一个递归算法来判断一个非递增的正整数序列是否为成图序列。",
        "answer": "Given a sequence d_1, d_2, …, d_n, if n = 2, then the sequence is graphic if and only if d_1 = d_2 = 1 (the graph consists of one edge)—this is one base case. Otherwise, if n < d_1 + 1, then the sequence is not graphic—this is another base case.",
        "answer_symbols": [
            "…",
            "=",
            "+",
            "<"
        ]
    },
    "10.2 47": {
        "question": "证明：每个非负整数构成的非递增序列，如果其和为偶数，则都是某个伪图的度序列。伪图是允许有环的无向图。[提示：首先通过给每个顶点添加尽可能多的环来构造一个图，然后添加一些边连接度为奇数的顶点。解释为什么这种构造方法能够证明此问题。]",
        "answer": "设 d1, d2,..., dn 是一个非递增的非负整数序列，其和为偶数。构造一个图如下：取顶点 v1, v2,..., vn 并在顶点 vi 上放置 ⌊di/2⌋ 个环，对于 i = 1, 2,..., n。对于每个 i，顶点 vi 现在的度数要么是 di 要么是 di - 1。因为原始总和是偶数，所以度数为 di - 1 的顶点数量是偶数。任意配对它们，并在每对顶点之间插入一条边。",
        "answer_symbols": [
            "⌊",
            "⌋",
            "/",
            "-",
            "∈"
        ]
    },
    "10.2 48": {
        "question": "至少带有 1 个顶点的 K_2 的子图有多少个？",
        "answer": "We list the subgraphs: the subgraph consisting of K2 itself, the subgraph consisting of two vertices and no edges, and the two subgraphs each consisting of one vertex. Therefore, the answer is 4.",
        "answer_symbols": []
    },
    "10.2 49": {
        "question": "至少带有 1 个顶点的 K_3 的子图有多少个？",
        "answer": "| ac db|ac db|ac db|ac db| | ---|---|---|---| | ac db|ac db|ac db|ac db| | acb|acb|acb|acb| | adb|adb|adb|adb| | ac d|ac d|ac d|ac d| | c db|a b|a b|ac| | ac|ad|ad|cb| | db|c d|a|b|",
        "answer_symbols": [
            "|",
            "-",
            "+",
            "=",
            "(",
            ")",
            ","
        ]
    },
    "10.2 50": {
        "question": "至少带有 1 个顶点的 W_3 的子图有多少个？",
        "answer": "We need to count systematically. First, note that W3 is the same as K4, which we will consider as K4 for simplicity. We will count the subgraphs based on the number of vertices they contain. Clearly, there are 4 subgraphs consisting of only one vertex. If a subgraph contains two vertices, there are C(4, 2) = 6 ways to choose the vertices, and in each case, there are 2 ways to decide whether to include the edge connecting them. This gives us 6 * 2 = 12 subgraphs with two vertices. If a subgraph contains three vertices, there are C(4, 3) = 4 ways to choose the vertices, and in each case, there are 2^3 = 8 ways to decide whether to include the edges connecting pairs of vertices. This gives us 4 * 8 = 32 subgraphs with three vertices. Finally, the subgraph containing all four vertices. There are 2^6 = 64 ways to decide which edges to include. Therefore, our answer is 4 + 12 + 32 + 64 = 112.",
        "answer_symbols": [
            "=",
            "*",
            "^",
            "(",
            ")",
            "C",
            "+",
            "…"
        ]
    },
    "10.2 51": {
        "question": "画出下图的所有子图。",
        "answer": "| ac db|ac db|ac db|ac db| | ---|---|---|---| | ac db|ac db|ac db|ac db| | acb|acb|acb|acb| | adb|adb|adb|adb| | ac d|ac d|ac d|ac d| | c db|a b|a b|ac| | ac|ad|ad|cb| | db|c d|a|b|",
        "answer_symbols": [
            "|",
            "-",
            "+",
            "=",
            "(",
            ")",
            ","
        ]
    },
    "10.2 52 a)": {
        "question": "设 G 是带有 v 个顶点和 e 条边的图。设 M 是 G 的顶点的最大度，m 是 G 的顶点的最小度。证明：2e/v ≥ m",
        "answer": "We want to prove 2e >= vm. According to Theorem 1, we know that 2e is the sum of the degrees of the vertices. This cannot be less than the total of m for each vertex, because each degree is at least m.",
        "answer_symbols": [
            ">=",
            "2",
            "e",
            "v",
            "m",
            "∑"
        ]
    },
    "10.2 52 b)": {
        "question": "设 G 是带有 v 个顶点和 e 条边的图。设 M 是 G 的顶点的最大度，m 是 G 的顶点的最小度。证明：2e/v ≤ M",
        "answer": "We want to prove 2e <= vM. According to Theorem 1, we know that 2e is the sum of the degrees of the vertices. This cannot be greater than the total of M for each vertex, because each degree is at most M.",
        "answer_symbols": [
            "<=",
            "2",
            "e",
            "v",
            "M",
            "∑"
        ]
    },
    "10.2 53 a)": {
        "question": "对哪些 n 值来说，下列图是正则图？K_n",
        "answer": "对于所有 n|d ≥ 1",
        "answer_symbols": [
            "≥",
            "|"
        ]
    },
    "10.2 53 b)": {
        "question": "对哪些 n 值来说，下列图是正则图？C_n",
        "answer": "对于所有 n ≥ 3",
        "answer_symbols": [
            "≥"
        ]
    },
    "10.2 53 c)": {
        "question": "对哪些 n 值来说，下列图是正则图？W_n",
        "answer": "对于 n|或所有 n ≥ 3",
        "answer_symbols": [
            "≥",
            "|"
        ]
    },
    "10.2 53 d)": {
        "question": "对哪些 n 值来说，下列图是正则图？Q_n",
        "answer": "对于 n|所有 n ≥ 0",
        "answer_symbols": [
            "≥",
            "|"
        ]
    },
    "10.2 54": {
        "question": "对哪些 m 和 n 的值来说，K_m,n 是正则图？",
        "answer": "Since the vertices in one part have degree m and the vertices in the other part have degree n, we conclude that Km,n is regular if and only if m = n.",
        "answer_symbols": [
            "=",
            "K",
            "m",
            "n",
            "…"
        ]
    },
    "10.2 55": {
        "question": "度都为 4 而且带有 10 条边的正则图有多少个顶点？",
        "answer": "5",
        "answer_symbols": []
    },
    "10.2 59 a)": {
        "question": "简单图 G 的补图 G 与 G 有相同的顶点。两个顶点在 G 中相邻，当且仅当它们在 G 中不相邻。画出下列各图。K_n",
        "answer": "具有 n 个顶点且没有边的图",
        "answer_symbols": []
    },
    "10.2 59 b)": {
        "question": "简单图 G 的补图 G 与 G 有相同的顶点。两个顶点在 G 中相邻，当且仅当它们在 G 中不相邻。画出下列各图。K_m,n",
        "answer": "Km 和 Kn 的不相交并集",
        "answer_symbols": [
            "∪"
        ]
    },
    "10.2 59 c)": {
        "question": "简单图 G 的补图 G 与 G 有相同的顶点。两个顶点在 G 中相邻，当且仅当它们在 G 中不相邻。画出下列各图。C_n",
        "answer": "具有顶点 {v1,..., vn} 的图，vi 和 vj 之间有一条边除非 i ≡ j ± 1(mod n)",
        "answer_symbols": [
            "≡",
            "±",
            "(",
            ")",
            ","
        ]
    },
    "10.2 59 d)": {
        "question": "简单图 G 的补图 G 与 G 有相同的顶点。两个顶点在 G 中相邻，当且仅当它们在 G 中不相邻。画出下列各图。Q_n",
        "answer": "顶点由长度为 n 的位串表示的图，如果两个顶点对应的位串在超过一位上不同，则它们之间有一条边",
        "answer_symbols": []
    },
    "10.2 60": {
        "question": "若 G 是有 15 条边的简单图且 G 有 13 条边，则 G 有多少个顶点？",
        "answer": "The given information tells us that G ∪ G has 28 edges. However, G ∪ G is the complete graph on the n vertices of G. Since this graph has n(n - 1)/2 edges, we need to solve n(n - 1)/2 = 28. Therefore, n = 8.",
        "answer_symbols": [
            "∪",
            "G",
            "=",
            "n",
            "(",
            ")",
            "-",
            "/",
            "…"
        ]
    },
    "10.2 61": {
        "question": "若简单图 G 有 v 个顶点和 e 条边，则 G 有多少条边？",
        "answer": "v(v - 1)/2 - e",
        "answer_symbols": [
            "-",
            "+",
            "(",
            ")",
            "/"
        ]
    },
    "10.2 62": {
        "question": "若简单图 G 的度序列为 4, 3, 3, 2, 2。求 G 的度序列。",
        "answer": "According to Exercise 63, we see that the degree sequence is obtained by subtracting these numbers from 4 (the number of vertices) and reversing the order. We get 2, 2, 1, 1, 0.",
        "answer_symbols": [
            "-",
            "…"
        ]
    },
    "10.2 63": {
        "question": "若简单图 G 的度序列为 d_1, d_2, ..., d_n。求 G 的度序列。",
        "answer": "n - 1 - dn, n - 1 - dn-1,..., n - 1 - d2, n - 1 - d1",
        "answer_symbols": [
            "-",
            ",",
            "..."
        ]
    },
    "10.2 64": {
        "question": "证明：若 G 是有 v 个顶点和 e 条边的二分简单图，则 e ≤ v^²/4。",
        "answer": "Assume the part sizes are k and v - k. Then the maximum number of edges the graph can have is k(v - k) (an edge between every pair of vertices in different parts). By algebra or calculus, we know that the function f(k) = k(v - k) reaches its maximum at k = v/2, giving f(k) = v^2/4. Therefore, there are at most v^2/4 edges.",
        "answer_symbols": [
            "-",
            "(",
            ")",
            "*",
            "^",
            "/",
            "f",
            "k",
            "v",
            "…"
        ]
    },
    "10.2 65": {
        "question": "证明：若 G 是有 n 个顶点的简单图，则 G 和 G 的并图是 K_n。",
        "answer": "G 和 G 的并集在每对 n 个顶点之间都有一条边。因此，这个并集是 Kn。",
        "answer_symbols": [
            "∪"
        ]
    },
    "10.2 66": {
        "question": "描述判定图是否为二分图的算法。可基于事实：一个图是二分图当且仅当可以用两种不同的颜色为它的顶点着色使得没有着相同颜色的两个顶点是相邻的。",
        "answer": "We start by coloring any vertex red. Then we color all the vertices adjacent to this vertex blue. Then we color all the vertices adjacent to blue vertices red, then color all the vertices adjacent to red vertices blue, and so on. If we ever are in the position of trying to color a vertex with the color opposite to the color it already has, then we stop and know that the graph is not bipartite. If the process terminates (successfully) before all the vertices have been colored, then we color some uncolored vertex red (it will necessarily not be adjacent to any vertices we have already colored) and begin the process again. Eventually we will have either colored all the vertices (producing the bipartition) or stopped and decided that the graph is not bipartite.",
        "answer_symbols": [
            "-",
            "…"
        ]
    },
    "10.2 67": {
        "question": "画出 10.1 节练习 7～9 中每个图的逆图。",
        "answer": "练习 7: b c d e a 练习 8: a e d c b 练习 9: b c d e f a",
        "answer_symbols": []
    },
    "10.2 68": {
        "question": "证明：当 G 是有向图时，有 (G^rev)^rev = G。",
        "answer": "Obviously (Gc)c and G have the same vertex set, so we need only show that they have the same directed edges. But this is clear, since an edge (u, v) is in (Gc)c if and only if the edge (v, u) is in Gc if and only if the edge (u, v) is in G.",
        "answer_symbols": [
            "-",
            "…"
        ]
    },
    "10.2 69": {
        "question": "证明：图 G 是它自身的逆图，当且仅当 G 所关联的关系（参见 9.3 节）是对称的。",
        "answer": "有向图 G=(V, E) 是自身的逆图当且仅当它满足条件 (u, v) ∈ E 当且仅当 (v, u) ∈ E。但这正是关联关系必须满足的对称性条件。",
        "answer_symbols": [
            "∈",
            "(",
            ")",
            "→",
            "↔"
        ]
    },
    "10.2 70": {
        "question": "证明：如果一个二分图 G=(V, E) 对于某个正整数 n 是 n 正则的（参见习题 53 的定义），且 (V_1, V_2) 是 V 的一个二部划分，则 |V_1| = |V_2|。也就是说，证明：n 正则二分图的顶点集的二部划分得到的两个顶点集一定包含相同个数的顶点。",
        "answer": "Let |V1| = n1 and |V2| = n2. Then the number of endpoints of edges in V1 is n · n1, and the number of endpoints of edges in V2 is n · n2. Since every edge must have one endpoint in each part, these two expressions must be equal, and it follows (because n ≠ 0) that n1 = n2, as desired.",
        "answer_symbols": [
            "-",
            "…"
        ]
    },
    "10.3 1": {
        "question": "用邻接表表示给定的图。",
        "answer": "邻接顶点 顶点\na b, c, d b a, d c a, d d a, b, c",
        "answer_symbols": []
    },
    "10.3 2": {
        "question": "用邻接表表示给定的图。",
        "answer": "This is similar to Exercise 1. The list is as follows.\n- Vertex: a\n  - Adjacent vertices: b, d\n- Vertex: b\n  - Adjacent vertices: a, d, e\n- Vertex: c\n  - Adjacent vertices: d, e\n- Vertex: d\n  - Adjacent vertices: a, b, c\n- Vertex: e\n  - Adjacent vertices: b, c",
        "answer_symbols": [
            "-",
            "…"
        ]
    },
    "10.3 3": {
        "question": "用邻接表表示给定的图。",
        "answer": "邻接顶点 顶点 a a, b, c, d b d c a, b d b, c, d",
        "answer_symbols": []
    },
    "10.3 4": {
        "question": "用邻接表表示给定的图。",
        "answer": "This is similar to Exercise 3. The list is as follows.\n- Initial vertex: a\n  - Terminal vertices: b, d\n- Initial vertex: b\n  - Terminal vertices: a, c, d, e\n- Initial vertex: c\n  - Terminal vertices: b, c\n- Initial vertex: d\n  - Terminal vertices: a, e\n- Initial vertex: e\n  - Terminal vertices: c, e",
        "answer_symbols": [
            "-",
            "…"
        ]
    },
    "10.3 5": {
        "question": "用邻接矩阵表示练习 1 的图。",
        "answer": "[0 1 1 1 1 0 0 1 1 0 0 1 1 1 1 0]1 1 1 0 0 0 1 1 0 0 0 1 1 1]",
        "answer_symbols": []
    },
    "10.3 6": {
        "question": "用邻接矩阵表示练习 2 的图。",
        "answer": "这个题目类似于练习5。顶点假定按字母顺序排列。[ 0 1 0 1 0 1 0 0 1 1 0 0 0 1 1 1 1 1 1 0 0 1 1 0 0 ]",
        "answer_symbols": [
            "[",
            "]",
            "0",
            "1"
        ]
    },
    "10.3 8": {
        "question": "用邻接矩阵表示练习 4 的图。",
        "answer": "这个题目类似于练习7。[ 0 1 0 1 0 1 0 1 1 1 0 1 0 1 1 1 1 1 0 0 0 1 1 0 1 ]",
        "answer_symbols": [
            "[",
            "]",
            "0",
            "1"
        ]
    },
    "10.3 9 a)": {
        "question": "用邻接矩阵表示下列每一个图。（a）K₄",
        "answer": "[0 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0]",
        "answer_symbols": []
    },
    "10.3 9 b)": {
        "question": "用邻接矩阵表示下列每一个图。（b）K₁,₄",
        "answer": "[ 0 1 1 1 1 ; 1 0 0 0 0 ; 1 0 0 0 0 ; 1 0 0 0 0 ; 1 0 0 0 0 ]",
        "answer_symbols": []
    },
    "10.3 9 c)": {
        "question": "用邻接矩阵表示下列每一个图。（c）K₂,₃",
        "answer": "[ 0 0 1 1 1 ; 0 0 1 1 1 ; 1 1 0 0 0 ; 1 1 0 0 0 ; 1 1 0 0 0 ]",
        "answer_symbols": []
    },
    "10.3 9 d)": {
        "question": "用邻接矩阵表示下列每一个图。（d）C₄",
        "answer": "[ 0 1 0 1 ; 1 0 1 0 ; 1 0 1 0 ; 1 0 1 0 ]",
        "answer_symbols": []
    },
    "10.3 9 e)": {
        "question": "用邻接矩阵表示下列每一个图。（e）W₄",
        "answer": "[ 0 1 0 1 1 ; 1 0 1 0 1 ; 0 1 0 1 1 ; 1 0 1 0 1 ; 1 1 1 1 0 ]",
        "answer_symbols": []
    },
    "10.3 9 f)": {
        "question": "用邻接矩阵表示下列每一个图。（f）Q₃",
        "answer": "[ 0 1 1 0 1 0 0 0 1 0 0 ; 1 0 1 0 0 1 0 0 1 0 0 ; 1 0 1 0 0 1 0 0 1 0 0 ; 0 1 0 1 0 0 1 0 0 1 0 ; 1 0 0 1 0 0 1 0 0 1 0 ; 0 1 0 0 1 0 0 1 0 0 1 ; 0 0 1 0 0 1 0 0 1 0 0 ; 0 0 0 1 0 0 1 0 0 1 0 ; 1 0 0 1 0 0 1 0 0 1 0 ; 0 0 1 0 0 1 0 0 1 0 0 ; 0 0 0 1 0 0 1 0 0 1 0 ]",
        "answer_symbols": []
    },
    "10.3 10": {
        "question": "画出给定邻接矩阵表示的图。[[0, 1, 0], [1, 0, 1], [0, 1, 0]]",
        "answer": "这个图有三个顶点，并且是无向图，因为矩阵是对称的。",
        "answer_symbols": []
    },
    "10.3 11": {
        "question": "画出给定邻接矩阵表示的图。[[0, 0, 1, 1], [0, 0, 1, 0], [1, 1, 0, 1], [1, 0, 1, 0]]",
        "answer": "d b a c",
        "answer_symbols": []
    },
    "10.3 12": {
        "question": "画出给定邻接矩阵表示的图。[[1, 1, 1, 0], [0, 0, 1, 0], [1, 0, 1, 0], [1, 1, 0, 0]]",
        "answer": "这个图是有向图，因为矩阵不是对称的。",
        "answer_symbols": []
    },
    "10.3 13": {
        "question": "用邻接矩阵表示给定的图。",
        "answer": "[ 0 0 1 0 ; 0 1 2 1 ; 0 1 0 2 ; 1 0 0 0 ]",
        "answer_symbols": [
            "[",
            "]",
            ";"
        ]
    },
    "10.3 14": {
        "question": "用邻接矩阵表示给定的图。",
        "answer": "这个题目类似于练习13。[ 0 3 0 1 3 0 1 0 0 1 0 3 1 0 3 0 ]",
        "answer_symbols": [
            "[",
            "]",
            "0",
            "1",
            "3"
        ]
    },
    "10.3 15": {
        "question": "用邻接矩阵表示给定的图。",
        "answer": "[ 1 0 2 1 ; 0 1 1 2 ; 2 1 1 0 ; 1 2 0 1 ]",
        "answer_symbols": [
            "[",
            "]",
            ";"
        ]
    },
    "10.3 16": {
        "question": "画出给定邻接矩阵所表示的无向图。[[1, 3, 2], [3, 0, 4], [2, 4, 0]]",
        "answer": "由于数字大于1，这个图需要多条边。",
        "answer_symbols": []
    },
    "10.3 17": {
        "question": "画出给定邻接矩阵所表示的无向图。[[1, 2, 0, 1], [2, 0, 3, 0], [0, 3, 1, 1], [1, 0, 1, 0]]",
        "answer": "a b d c",
        "answer_symbols": []
    },
    "10.3 18": {
        "question": "画出给定邻接矩阵所表示的无向图。[[0, 1, 3, 0, 4], [1, 2, 1, 3, 0], [3, 1, 1, 0, 1], [0, 3, 0, 0, 2], [4, 0, 1, 2, 3]]",
        "answer": "这个题目类似于练习16。",
        "answer_symbols": []
    },
    "10.3 19": {
        "question": "按照顶点的字典顺序，求给定有向多重图的邻接矩阵。",
        "answer": "[ 0 1 0 0 ; 1 1 0 1 ; 1 1 1 0 ; 0 0 0 0 ]",
        "answer_symbols": [
            "[",
            "]",
            ";"
        ]
    },
    "10.3 20": {
        "question": "按照顶点的字典顺序，求给定有向多重图的邻接矩阵。",
        "answer": "这个题目类似于练习19。[ 1 1 1 1 1 0 1 1 1 1 1 0 1 1 0 1 ]",
        "answer_symbols": [
            "[",
            "]",
            "0",
            "1"
        ]
    },
    "10.3 21": {
        "question": "按照顶点的字典顺序，求给定有向多重图的邻接矩阵。",
        "answer": "[ 1 1 2 1 ; 0 0 2 0 ; 1 1 0 2 ; 1 0 0 0 ]",
        "answer_symbols": [
            "[",
            "]",
            ";"
        ]
    },
    "10.3 22": {
        "question": "画出给定邻接矩阵表示的图。[[1, 0, 1], [0, 0, 1], [1, 1, 1]]",
        "answer": "This matrix is symmetric, so we can take the graph to be undirected. No parallel edges are present, since no entries exceed 1.",
        "answer_symbols": [
            "="
        ]
    },
    "10.3 23": {
        "question": "画出给定邻接矩阵表示的图。[[1, 2, 1], [2, 0, 0], [0, 2, 2]]",
        "answer": "a c b",
        "answer_symbols": []
    },
    "10.3 24": {
        "question": "画出给定邻接矩阵表示的图。[[0, 2, 3, 0], [1, 2, 2, 1], [2, 1, 1, 0], [1, 0, 0, 2]]",
        "answer": "This is the adjacency matrix of a directed multigraph, because the matrix is not symmetric and it contains entries greater than 1.",
        "answer_symbols": [
            ">"
        ]
    },
    "10.3 25": {
        "question": "每一个对称的和对角线全为 0 的 0-1 方阵是否都是简单图的邻接矩阵？",
        "answer": "是",
        "answer_symbols": []
    },
    "10.3 26": {
        "question": "用关联矩阵表示练习 1 和练习 2 中的图。",
        "answer": "Each column represents an edge; the two 1’s in the column are in the rows for the endpoints of the edge.",
        "answer_symbols": [
            "1"
        ]
    },
    "10.3 27": {
        "question": "用关联矩阵表示练习 13～15 中的图。",
        "answer": "练习13: [ 1 0 0 0 ; 0 0 1 1 ; 1 0 1 0 ; 0 1 0 0 ; 1 1 1 0 ]\n练习14: [ 1 1 1 1 ; 0 0 0 0 ; 1 1 0 1 ; 0 0 0 0 ; 0 0 0 1 ; 1 1 1 0 ; 0 0 1 0 ; 1 1 1 0 ]\n练习15: [ 1 1 1 1 ; 0 0 0 0 ; 0 0 0 0 ; 0 0 1 1 ; 1 1 0 0 ; 0 1 1 0 ; 0 0 1 0 ; 0 0 0 1 ; 0 0 1 1 ; 0 1 0 0 ; 1 1 0 1 ]\n ",
        "answer_symbols": [
            "[",
            "]",
            ";"
        ]
    },
    "10.3 28": {
        "question": "无向图的邻接矩阵的一行中的各项之和是什么？对有向图来说呢？",
        "answer": "For an undirected graph, the sum of the entries in the i-th row is the same as the corresponding column sum, namely the number of edges incident to the vertex i, which is the same as the degree of i minus the number of loops at i (since each loop contributes 2 toward the degree count). For a directed graph, the sum of the entries in the i-th row is the number of edges that have i as their initial vertex, i.e., the out-degree of i.",
        "answer_symbols": [
            "-",
            "+",
            "="
        ]
    },
    "10.3 29": {
        "question": "无向图的邻接矩阵的一列中的各项之和是什么？对有向图来说呢？",
        "answer": "deg(v)-v上的环的数量；deg-(v)",
        "answer_symbols": [
            "-",
            ";"
        ]
    },
    "10.3 30": {
        "question": "无向图的关联矩阵的一行中的各项之和是什么？",
        "answer": "The sum of the entries in the i-th row of the incidence matrix is the number of edges incident to vertex i, since there is one column with a 1 in row i for each such edge.",
        "answer_symbols": [
            "1"
        ]
    },
    "10.3 31": {
        "question": "无向图的关联矩阵的一列中的各项之和是什么？",
        "answer": "如果e不是环，则为2；如果e是环，则为1",
        "answer_symbols": [
            ";",
            "="
        ]
    },
    "10.3 32 a)": {
        "question": "求下列每个图的邻接矩阵。 a) K_n",
        "answer": "This is just the matrix that has 0’s on the main diagonal and 1’s elsewhere, namely",
        "answer_symbols": [
            "0",
            "1"
        ]
    },
    "10.3 32 b)": {
        "question": "求下列每个图的邻接矩阵。 b) C_n",
        "answer": "We label the vertices so that the cycle goes v1, v2, ..., vn, v1. Then the matrix has 1’s on the diagonals just above and below the main diagonal and in positions (1, n) and (n, 1), and 0’s elsewhere:",
        "answer_symbols": [
            "1",
            "0"
        ]
    },
    "10.3 32 c)": {
        "question": "求下列每个图的邻接矩阵。 c) W_n",
        "answer": "This matrix is the same as the answer in part (b), except that we add one row and column for the vertex.在轮子中间；在我们的矩阵中，它是最后一行和列：\n[0 1 0... 0 1 1\n1 0 1... 0 0 1\n0 1 0... 0 0 1\n.....................\n0 0 0... 0 1 1\n1 0 0... 1 0 1\n1 1 1... 1 1 0]",
        "answer_symbols": []
    },
    "10.3 32 d)": {
        "question": "求下列每个图的邻接矩阵。 d) K_m,n",
        "answer": "由于前m个顶点与前m个顶点不相邻但与所有后n个顶点相邻，反之亦然，这个矩阵分为四部分：[0... 0 1... 1 1... 1 0... 0 0... 0 1... 1 1... 1 0... 0]",
        "answer_symbols": [
            "[",
            "]",
            "..."
        ]
    },
    "10.3 32 e)": {
        "question": "求下列每个图的邻接矩阵。 e) Q_n",
        "answer": "显示这些矩阵并不方便。相反，我们将给出一个递归定义。设Qn是图Qn的邻接矩阵。则 Q1 = [0 1 1 0] 且 Qn+1 = [Qn In In Qn]，其中In是单位矩阵（因为两个n立方体的对应顶点在(n+1)-立方体中由边连接）。",
        "answer_symbols": [
            "=",
            "[",
            "]",
            "+",
            "1",
            "0",
            "n",
            "I",
            "Q"
        ]
    },
    "10.3 34": {
        "question": "判定所给定的一对图是否同构。构造一个同构或给出不存在同构的严格证明。 u_1 u_2 u_3 u_4 u_5 v_1 v_2 v_3 v_4 v_5",
        "answer": "这些图是同构的，因为每个都是五个顶点的路径。一个同构是f(u1) = v1, f(u2) = v2, f(u3) = v4, f(u4) = v5, 和 f(u5) = v3。",
        "answer_symbols": [
            "=",
            "(",
            ")",
            ","
        ]
    },
    "10.3 35": {
        "question": "判定所给定的一对图是否同构。构造一个同构或给出不存在同构的严格证明。 u_1 u_2 u_3 u_4 u_5 v_1 v_2 v_3 v_4 v_5",
        "answer": "同构",
        "answer_symbols": []
    },
    "10.3 36": {
        "question": "判定所给定的一对图是否同构。构造一个同构或给出不存在同构的严格证明。 u_1 u_2 u_3 u_4 u_5 v_1 v_2 v_3 v_4 v_5",
        "answer": "这些图不是同构的。第二个有一个度为4的顶点，而第一个没有。",
        "answer_symbols": []
    },
    "10.3 37": {
        "question": "判定所给定的一对图是否同构。构造一个同构或给出不存在同构的严格证明。 u_1 u_2 u_3 u_4 u_5 v_1 v_2 v_3 v_4 v_5",
        "answer": "同构",
        "answer_symbols": []
    },
    "10.3 38": {
        "question": "判定所给定的一对图是否同构。构造一个同构或给出不存在同构的严格证明。 u_1 u_2 u_3 u_4 u_5 v_1 v_2 v_3 v_4 v_5",
        "answer": "这两个图是同构的。每个都由K4加上一个与K4中的两个顶点相邻的第五个顶点组成。许多同构都是可能的。其中一个同构是f(u1) = v1, f(u2) = v3, f(u3) = v2, f(u4) = v5, 和 f(u5) = v4。",
        "answer_symbols": [
            "=",
            "(",
            ")",
            ","
        ]
    },
    "10.3 39": {
        "question": "判定所给定的一对图是否同构。构造一个同构或给出不存在同构的严格证明。 u_1 u_2 u_3 u_4 u_5 v_1 v_2 v_3 v_4 v_5",
        "answer": "同构",
        "answer_symbols": []
    },
    "10.3 33 a)": {
        "question": "求练习 32a～d 中的图的关联矩阵。 a) K_n",
        "answer": "[ 1 1 … 1 0 … 0 ; 1 0 … 0 1 … 0 ; 0 1 … 0 1 … 0 ; ... ... ... ... ... ; 0 0 … 0 0 … 1 ; 0 0 … 1 0 … 1 ]",
        "answer_symbols": [
            "[",
            "]",
            ";",
            "..."
        ]
    },
    "10.3 33 b)": {
        "question": "求练习 32a～d 中的图的关联矩阵。 b) C_n",
        "answer": "[ 1 0 … 0 1 1 ; 1 … 0 0 0 ; 1 … 0 0 ; ... ... ... ... ; 0 0 … 1 0 ; 0 0 … 1 1 ]",
        "answer_symbols": [
            "[",
            "]",
            ";",
            "..."
        ]
    },
    "10.3 33 c)": {
        "question": "求练习 32a～d 中的图的关联矩阵。 c) W_n",
        "answer": "[ 0 0 … 0 1 1 … 1 1 0 … 0 B 0 1 … 0 ... ... ... ... 0 0 … 1 ]",
        "answer_symbols": [
            "[",
            "]",
            ";",
            "...",
            "B"
        ]
    },
    "10.3 33 d)": {
        "question": "求练习 32a～d 中的图的关联矩阵。 d) K_m,n",
        "answer": "[ 1 1 … 1 0 … 0 0 0 … 0 1 … 0 ... ... ... ... ... 0 0 … 0 0 … 1 1 0 … 0 1 … 0 0 1 … 0 0 … 1 ... ... ... ... ... 0 0 … 1 0 … 0 ]",
        "answer_symbols": [
            "[",
            "]",
            ";",
            "..."
        ]
    },
    "10.3 40": {
        "question": "u1 u2\n \\ /\n u6\n / \\\nu5 u4",
        "answer": "这些图不是同构的——顶点的度数不同（右边的图有一个度为4的顶点，左边的图缺少这个顶点）。",
        "answer_symbols": []
    },
    "10.3 41": {
        "question": "u1 u2 u3 u5 u6 u8\n \\ | | | |\n u4 u7",
        "answer": "不同构",
        "answer_symbols": []
    },
    "10.3 42": {
        "question": "v1 v2 v4 v5 v6 v8\n \\ | | | |\n v3 v7",
        "answer": "这些图不是同构的。在第一个图中，度为4的顶点是相邻的。这在第二个图中不是真的。",
        "answer_symbols": []
    },
    "10.3 43": {
        "question": "u1 u2\n \\ /\n u9\n / \\\nu10 u8\n \\ /\n u7\n / \\\nu6 u5",
        "answer": "同构",
        "answer_symbols": []
    },
    "10.3 44": {
        "question": "u1 u2\n \\ /\n u8\n / \\\nu7 u6\n \\ /\n u5\n / \\\nu4 u3",
        "answer": "表明这些图不是同构的最简单方法是看它们的补图。左边的图的补图由两个4-圈组成。右边的图的补图是一个8-圈。由于补图不是同构的，因此这些图也不是同构的。",
        "answer_symbols": []
    },
    "10.3 45": {
        "question": "证明：简单图的同构关系是等价关系。",
        "answer": "G通过恒等函数与其自身同构，因此同构具有自反性。假设G与H同构。那么存在一个从G到H的一一对应关系f，该关系保持相邻性和非相邻性。由此可得f^-1是从H到G的一一对应关系，该关系保持相邻性和非相邻性。因此，同构具有对称性。如果G与H同构且H与K同构，那么存在从G到H和从H到K的一一对应关系f和g，这些关系保持相邻性和非相邻性。由此可得g◦f是从G到K的一一对应关系，该关系保持相邻性和非相邻性。因此，同构具有传递性。",
        "answer_symbols": [
            "-",
            "^",
            "◦"
        ]
    },
    "10.3 46": {
        "question": "设 G 和 H 是同构的简单图。证明：它们的补图 G 和 H 也是同构的。",
        "answer": "这直接来自定义，因为一条边在G中当且仅当它不在G中，当且仅当相应的边不在H中，当且仅当相应的边在H中。",
        "answer_symbols": []
    },
    "10.3 47": {
        "question": "描述对应于孤立点的图的邻接矩阵的行和列。",
        "answer": "全零",
        "answer_symbols": []
    },
    "10.3 48": {
        "question": "描述对应于孤立点的图的关联矩阵的行。",
        "answer": "孤立顶点没有关联的边，因此该行全为0。",
        "answer_symbols": []
    },
    "10.3 49": {
        "question": "证明：可以对具有 2 个以上顶点的二分图的顶点排序，使得其邻接矩阵形如下图所示的四项都是矩形块。\n[ 0 A ]\n[ B 0 ]",
        "answer": "按顺序标记顶点，使得顶点集划分中的第一个集合中的所有顶点都排在前面。因为同一个集合中的顶点之间没有边连接，所以矩阵具有所需的形状。",
        "answer_symbols": []
    },
    "10.3 50": {
        "question": "证明：右图是自补图。",
        "answer": "The complementary graph consists of edges {a, c}, {c, d}, and {d, b}; it is clearly isomorphic to the original graph (send d to a, a to c, b to d, and c to b).",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "10.3 51": {
        "question": "求具有 5 个顶点的自补简单图。",
        "answer": "C5",
        "answer_symbols": []
    },
    "10.3 52": {
        "question": "证明：若 G 是具有 n 个顶点的自补简单图，则 n≡0 或 1(mod 4)。",
        "answer": "If G is self-complementary, then the number of edges of G must equal the number of edges of G. But the sum of these two numbers is n(n − 1)/2, where n is the number of vertices of G, since the union of the two graphs is K_n. Therefore the number of edges of G must be n(n−1)/4. Since this number must be an integer, a look at the four cases shows that n may be congruent to either 0 or 1, but not congruent to either 2 or 3, modulo 4.",
        "answer_symbols": [
            "=",
            "−",
            "/",
            "(",
            ")",
            "∪",
            "∈",
            "≡",
            "mod"
        ]
    },
    "10.3 53": {
        "question": "对哪些整数 n，C_n 是自补图？",
        "answer": "n=5仅",
        "answer_symbols": [
            "="
        ]
    },
    "10.3 55": {
        "question": "具有 5 个顶点和 3 条边的非同构的简单图有多少个？",
        "answer": "4",
        "answer_symbols": []
    },
    "10.3 56": {
        "question": "具有 6 个顶点和 4 条边的非同构的简单图有多少个？",
        "answer": "There are 9 such graphs. Let us first look at the graphs that have a cycle in them. There is only 1 with a 4-cycle. There are 2 with a triangle, since the fourth edge can either be incident to the triangle or not. If there are no cycles, then the edges may all be in one connected component (see Section 10.4), in which case there are 3 possibilities (a path of length four, a path of length three with an edge incident to one of the middle vertices on the path, and a star). Otherwise, there are two components, which are necessarily either two paths of length two, a path of length three plus a single edge, or a star with three edges plus a single edge (3 possibilities in this case as well).",
        "answer_symbols": [
            "−",
            "∈"
        ]
    },
    "10.3 57 a)": {
        "question": "具有下列邻接矩阵的简单图是否同构？[0 0 1, 0 0 1, 1 1 0], [0 1 1, 1 0 0, 1 0 0]",
        "answer": "是",
        "answer_symbols": []
    },
    "10.3 57 b)": {
        "question": "具有下列邻接矩阵的简单图是否同构？[0 1 0 1, 1 0 0 1, 0 0 0 1, 1 1 1 0], [0 1 1 1, 1 0 0 1, 1 0 0 1, 1 1 1 0]",
        "answer": "否",
        "answer_symbols": []
    },
    "10.3 57 c)": {
        "question": "具有下列邻接矩阵的简单图是否同构？[0 1 1 0, 1 0 0 1, 1 0 0 1, 0 1 1 0], [0 1 0 1, 1 0 0 1, 0 0 0 1, 1 1 1 0]",
        "answer": "否",
        "answer_symbols": []
    },
    "10.3 58 a)": {
        "question": "判定具有下列关联矩阵的无环图是否同构。[1 0 1, 0 1 1, 1 1 0], [1 1 0, 1 0 1, 0 1 1]",
        "answer": "These graphs are both K_3, so they are isomorphic. ",
        "answer_symbols": [
            "∈",
            "K"
        ]
    },
    "10.3 58 b)": {
        "question": "判定具有下列关联矩阵的无环图是否同构。[1 1 0 0, 1 0 1 0, 0 1 0 1, 0 0 1 1], [0 1 0 0, 1 0 1 0, 0 1 1 0, 0 0 1 1]",
        "answer": "These are both simple graphs with 4 vertices and 5 edges. Up to isomorphism there is only one such graph (its complement is a single edge), so the graphs have to be isomorphic.",
        "answer_symbols": [
            "∈",
            "K"
        ]
    },
    "10.3 59": {
        "question": "把简单图的同构定义推广到包含环和多重边的无向图。",
        "answer": "G=(V1, E1)与H=(V2, E2)同构当且仅当存在从V1到V2的函数f和从E1到E2的函数g，每个都是一个一一对应，并且对于E1中的每条边e，g(e)的端点是f(v)和f(w)，其中v和w是e的端点。",
        "answer_symbols": [
            "(",
            ")",
            "=",
            "→",
            "∈"
        ]
    },
    "10.3 60": {
        "question": "定义有向图的同构。",
        "answer": "We need only modify the definition of isomorphism of simple graphs slightly. The directed graphs G1 = (V1, E1) and G2 = (V2, E2) are isomorphic if there is a one-to-one and onto function f: V1 → V2 such that for all pairs of vertices a and b in V1, (a, b) ∈ E1 if and only if (f(a), f(b)) ∈ E2.",
        "answer_symbols": [
            "=",
            "→",
            "∈",
            "(",
            ")",
            "∀",
            "∧",
            "∨"
        ]
    },
    "10.3 61": {
        "question": "判定所给定的一对有向图是否同构（参见练习 60）。u1 → u2, ↓, u3 → u4；v1 → v2, ↓, v3 → v4",
        "answer": "Yes",
        "answer_symbols": []
    },
    "10.3 62": {
        "question": "判定所给定的一对有向图是否同构（参见练习 60）。u1 → u2, ↓, u3 → u4；v1 → v2, ↓, v3 → v4",
        "answer": "These two graphs are not isomorphic. In the first there is no edge from the unique vertex of in-degree 0 (u1) to the unique vertex of out-degree 0 (u2), whereas in the second graph there is such an edge, namely v3v4.",
        "answer_symbols": [
            "∈",
            "→",
            "(",
            ")",
            "¬"
        ]
    },
    "10.3 63": {
        "question": "判定所给定的一对有向图是否同构（参见练习 60）。u1 → u2, ↓, u3 → u4；v1 → v2, ↓, v3 → v4",
        "answer": "Yes",
        "answer_symbols": []
    },
    "10.3 64": {
        "question": "判定所给定的一对有向图是否同构（参见练习 60）。u1 → u2, ↓, u3 → u4；v1 → v2, ↓, v3 → v4",
        "answer": "We claim that the digraphs are isomorphic. To discover an isomorphism, we first note that vertices u1, u2, and u3 in the first digraph are independent (i.e., have no edges joining them), as are u4, u5, and u6. Therefore these two groups of vertices will have to correspond to similar groups in the second digraph, namely v1, v3, and v5, and v2, v4, and v6, in some order. Furthermore, u3 is the only vertex among one of these groups of u’s to be the only one in the group with out-degree 2, so it must correspond to v6, the vertex with the similar property in the other digraph; and in the same manner, u4 must correspond to v5. Now it is an easy matter, by looking at where the edges lead, to see that the isomorphism (if there is one) must also pair up u1 with v2; u2 with v4; u5 with v1; and u6 with v3. Finally, we easily verify that this indeed gives an isomorphism—each directed edge in the first digraph is present precisely when the corresponding directed edge is present in the second digraph.",
        "answer_symbols": [
            "∈",
            "∧",
            "∨",
            "(",
            "∀",
            "→",
            ")"
        ]
    },
    "10.3 65": {
        "question": "证明：若 G 和 H 是同构的有向图，则 G 和 H 的逆图也是同构的。",
        "answer": "If f is an isomorphism from a directed graph G to a directed graph H, then f is also an isomorphism from Gconv to H conv. To see this note that (u, v) is an edge of Gconv if and only if (v, u) is an edge of G if and only if (f(v), f(u)) is an edge of H if and only if (f(u), f(v)) is an edge of H conv.",
        "answer_symbols": []
    },
    "10.3 66": {
        "question": "证明：一个图是二分图这一属性是同构的不变量。",
        "answer": "要证明二分图的性质是一个同构不变量，我们需要证明如果G是二分图且G与H同构（假设通过函数f），则H也是二分图。设V1和V2是G的二分集。那么我们声称f(V1)—即V1中顶点在f下的像—和f(V2)—即V2中顶点在f下的像—形成H的一个二分集。确实，由于f必须保持不相邻的性质，因为V1中没有两个顶点相邻，所以f(V1)中也没有两个顶点相邻，对于V2同样如此。",
        "answer_symbols": []
    },
    "10.3 68 a)": {
        "question": "具有 n 个顶点的非同构有向图有多少个？其中 n 是 2。",
        "answer": "有10个非同构的有向图，其中含有2个顶点。首先考虑一个顶点到另一个顶点没有边的情况。根据是否没有、有一个或两个环，这样的图有3种。类似地，在每个顶点之间有一条边的情况下也有3种图。最后，顶点之间恰好有一条边的图有4种，因为现在顶点是有区别的，并且每个顶点可以有或没有环。",
        "answer_symbols": []
    },
    "10.3 68 b)": {
        "question": "具有 n 个顶点的非同构有向图有多少个？其中 n 是 3。",
        "answer": "对于有3个顶点的有向图的数量进行详细讨论会相当长，所以我们只给出答案，即104。有关此问题（以及部分c）的一些有用图片可以在Frank Harary（Addison-Wesley, 1969）的《图论》附录中找到。",
        "answer_symbols": []
    },
    "10.3 68 c)": {
        "question": "具有 n 个顶点的非同构有向图有多少个？其中 n 是 4。",
        "answer": "答案是3069。",
        "answer_symbols": []
    },
    "10.3 70 a)": {
        "question": "表示具有 n 个顶点和 m 条边的简单图需要多少存储空间？其中分别利用 邻接表。",
        "answer": "我们需要为每个顶点创建一个邻接表，列表需要某种名称或标题；这需要n个存储位置。此外，每条边将出现两次，分别出现在其端点的列表中；这将需要2m个存储位置。因此总共需要n + 2m个位置。",
        "answer_symbols": [
            "+",
            "×"
        ]
    },
    "10.3 70 b)": {
        "question": "表示具有 n 个顶点和 m 条边的简单图需要多少存储空间？其中分别利用 邻接矩阵。",
        "answer": "邻接矩阵是一个n × n的矩阵，因此需要n^²位存储。",
        "answer_symbols": [
            "×",
            "^"
        ]
    },
    "10.3 70 c)": {
        "question": "表示具有 n 个顶点和 m 条边的简单图需要多少存储空间？其中分别利用 关联矩阵。",
        "answer": "关联矩阵是一个n × m的矩阵，因此需要nm位存储。",
        "answer_symbols": [
            "×"
        ]
    },
    "10.3 72": {
        "question": "设从 V1 到 V2 的函数 f 是从图 G1=(V1,E1) 到 G2=(V2,E2) 的同构。证明：按图中顶点的个数，按所需要的比较次数，可以在多项式时间复杂度内进行验证。",
        "answer": "假设给出了两个图的邻接矩阵。这使我们能够在常数时间内检查给定的一对顶点是否相邻。对于V1中的每一对顶点u和v，检查u和v在G1中是否相邻当且仅当f(u)和f(v)在G2中相邻。这对每对顶点需要O(1)次比较，对于具有n个顶点的图，总共有O(n^²)对顶点。",
        "answer_symbols": [
            "(",
            ")",
            "×",
            "∈",
            "→"
        ]
    },
    "10.4 2 a)": {
        "question": "下述每个顶点列表是否可以构成下图中的通路？哪些通路是简单的？哪些是回路？这些通路的长度是多少？a, b, e, c, b",
        "answer": "这是一条长度为4的路径，但不是回路，因为它结束于不同于起始顶点的顶点。它是简单的，因为没有重复的边。",
        "answer_symbols": []
    },
    "10.4 2 b)": {
        "question": "下述每个顶点列表是否可以构成下图中的通路？哪些通路是简单的？哪些是回路？这些通路的长度是多少？a, d, a, d, a",
        "answer": "这是一条长度为4的路径，它是一个回路。它不是简单的，因为它使用了一条边多次。",
        "answer_symbols": []
    },
    "10.4 2 c)": {
        "question": "下述每个顶点列表是否可以构成下图中的通路？哪些通路是简单的？哪些是回路？这些通路的长度是多少？a, d, b, e, a",
        "answer": "这不是一条路径，因为从d到b没有边。",
        "answer_symbols": []
    },
    "10.4 2 d)": {
        "question": "下述每个顶点列表是否可以构成下图中的通路？哪些通路是简单的？哪些是回路？这些通路的长度是多少？a, b, e, c, b, d, a",
        "answer": "这不是一条路径，因为从b到d没有边。",
        "answer_symbols": []
    },
    "10.4 4": {
        "question": "在练习 3～5 中，判定所给的图是否是连通的。",
        "answer": "这个图是连通的—很容易看到从每个顶点到其他每个顶点都有一条路径。",
        "answer_symbols": []
    },
    "10.4 6": {
        "question": "在练习 3～5 中，每个图各自有多少个连通分支？对每个图求出它的每个连通分支。",
        "answer": "练习3中的图有三个连通分支：看起来像∧的部分，看起来像∨的部分，以及孤立的顶点。练习4中的图是连通的，只有一个连通分支。练习5中的图有两个连通分支，每个都是三角形。",
        "answer_symbols": []
    },
    "10.4 8": {
        "question": "合作图的连通分支表示什么？",
        "answer": "合作图的一个连通分支表示一组人，对于他们中的任意两个人，我们可以找到一系列共同作品将一个人引向另一个人。“最大”的意思是没有其他人可以被添加到这组人中而不破坏这个性质。",
        "answer_symbols": []
    },
    "10.4 10": {
        "question": "在好莱坞图中，什么时候表示一个演员的顶点与表示凯文·培根的顶点是在同一个连通分支中？",
        "answer": "An actor is in the same connected component as Kevin Bacon if there is a path from that person to Bacon. This means that the actor was in a movie with someone who was in a movie with someone who... who was in a movie with Kevin Bacon. This includes Kevin Bacon, all actors who appeared in a movie with Kevin Bacon, all actors who appeared in movies with those people, and so on.",
        "answer_symbols": []
    },
    "10.4 12 a)": {
        "question": "判断下列各图是否是强连通的，如果不是，再判断是否是弱连通的。",
        "answer": "Notice that there is no path from f to a, so the graph is not strongly connected. However, the underlying undirected graph is clearly connected, so this graph is weakly connected.",
        "answer_symbols": []
    },
    "10.4 12 b)": {
        "question": "判断下列各图是否是强连通的，如果不是，再判断是否是弱连通的。",
        "answer": "Notice that the sequence a, b, c, d, e, f, a provides a path from every vertex to every other vertex, so this graph is strongly connected.",
        "answer_symbols": []
    },
    "10.4 12 c)": {
        "question": "判断下列各图是否是强连通的，如果不是，再判断是否是弱连通的。",
        "answer": "The underlying undirected graph is clearly not connected (one component consists of the triangle), so this graph is neither strongly nor weakly connected.",
        "answer_symbols": []
    },
    "10.4 14 a)": {
        "question": "求下列各图的强连通分支。",
        "answer": "The cycle baeb guarantees that these three vertices are in one strongly connected component. Since there is no path from c to any other vertex, and there is no path from any other vertex to d, these two vertices are in strong components by themselves. Therefore the strongly connected components are {a, b, e}, {c}, and {d}.",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "10.4 14 b)": {
        "question": "求下列各图的强连通分支。",
        "answer": "The cycle cdec guarantees that these three vertices are in one strongly connected component. The vertices a, b, and f are in strong components by themselves, since there are no paths both to and from each of these to every other vertex. Therefore the strongly connected components are {a}, {b}, {c, d, e}, and {f}.",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "10.4 24": {
        "question": "对练习 19 中的 n 值来说，求出 K_n 中任意两个相邻顶点之间长度为 n 的通路的数目。",
        "answer": "这类似于部分(b)，因此答案是3^4 = 81。",
        "answer_symbols": [
            "^"
        ]
    },
    "10.4 26 a)": {
        "question": "求出在图 1 中 c 和 d 之间具有如下长度的通路的数目：（a）2。",
        "answer": "最好的方法可能是写出这个图的邻接矩阵，然后计算它的幂。矩阵是\nA=\n[0 1 0 1 1\n0 1 0 1 0\n1 1 0 1 0\n1 0 1 1 0\n1 0 1 0 1]",
        "answer_symbols": [
            "^",
            "[",
            "]",
            "(",
            ")"
        ]
    },
    "10.4 26 b)": {
        "question": "求出在图 1 中 c 和 d 之间具有如下长度的通路的数目：（b）3。",
        "answer": "A^3的第(3, 4)个条目结果是8，因此有8条长度为3的路径。",
        "answer_symbols": [
            "^",
            "(",
            ")"
        ]
    },
    "10.4 26 c)": {
        "question": "求出在图 1 中 c 和 d 之间具有如下长度的通路的数目：（c）4。",
        "answer": "A^4的第(3, 4)个条目结果是10，因此有10条长度为4的路径。",
        "answer_symbols": [
            "^",
            "(",
            ")"
        ]
    },
    "10.4 26 d)": {
        "question": "求出在图 1 中 c 和 d 之间具有如下长度的通路的数目：（d）5。",
        "answer": "A^5的第(3, 4)个条目结果是73，因此有73条长度为5的路径。",
        "answer_symbols": [
            "^",
            "(",
            ")"
        ]
    },
    "10.4 26 e)": {
        "question": "求出在图 1 中 c 和 d 之间具有如下长度的通路的数目：（e）6。",
        "answer": "A^6的第(3, 4)个条目结果是160，因此有160条长度为6的路径。",
        "answer_symbols": [
            "^",
            "(",
            ")"
        ]
    },
    "10.4 26 f)": {
        "question": "求出在图 1 中 c 和 d 之间具有如下长度的通路的数目：（f）7。",
        "answer": "A^7的第(3, 4)个条目结果是739，因此有739条长度为7的路径。",
        "answer_symbols": [
            "^",
            "(",
            ")"
        ]
    },
    "10.4 28": {
        "question": "证明：带有 n 个顶点的连通图至少具有 n-1 条边。",
        "answer": "我们通过归纳法证明这一点。对于n=1，没有什么需要证明的。现在假设归纳假设成立，并设G是一个具有n+1个顶点且少于n条边的连通图，其中n ≥ 1。因为图G的顶点度数之和等于边数的两倍，我们知道度数之和小于2n，这小于2(n+1)。因此某些顶点的度数小于2。由于G是连通的，这个顶点不是孤立的，所以它的度数必须是1。移除这个顶点及其边。显然结果仍然是连通的，并且它有n个顶点且少于n - 1条边，这与归纳假设矛盾。因此该陈述对G成立，证明完成。",
        "answer_symbols": [
            "=",
            "<",
            "≥",
            "+",
            "-",
            "(",
            ")",
            "≤"
        ]
    },
    "10.4 30": {
        "question": "证明：在任何简单图中，任何度为奇数的顶点都与其他某些度为奇数的顶点之间有通路。",
        "answer": "设v是一个奇数度的顶点，H是包含v的G的分量。那么H本身就是一个图，所以它有偶数个奇数度的顶点。特别是，在H中还有一个奇数度的顶点w。根据连通性的定义，从v到w有一条路径。",
        "answer_symbols": []
    },
    "10.4 32": {
        "question": "在练习 31～33 中，求所给图的所有割点。",
        "answer": "顶点c和d是割点。移除任何一个都会创建一个有两个分量的图。移除任何其他顶点都不会使图不连通。",
        "answer_symbols": []
    },
    "10.4 34": {
        "question": "求练习 31～33 中图的所有割边。",
        "answer": "练习31中的图没有割边；任何边都可以被移除，结果仍然是连通的。对于练习32中的图，{c, d}是唯一的割边。练习33中的图有几个割边：{a, b}、{b, c}、{c, d}、{c, e}、{e, i}和{h, i}。",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "10.4 36": {
        "question": "证明：在连通简单图 G 中，顶点 c 是割点当且仅当存在着与 c 不同的顶点 u 和 v，并且在 u 和 v 之间的每一条通路都经过 c。",
        "answer": "首先我们证明如果c是一个割点，则存在顶点u和v，使得它们之间的每条路径都经过c。由于移除c增加了分量的数量，必须有两个顶点在移除c后的G中处于不同的分量中。那么这两点之间的每条路径都必须经过c。反之，如果u和v如所指定的那样，则它们必须在移除c后的图的不同分量中。因此移除c导致了至少两个分量，所以c是一个割点。",
        "answer_symbols": []
    },
    "10.4 38": {
        "question": "证明：简单图中的一条边是割边，当且仅当它不属于该图任何一条简单回路。",
        "answer": "First suppose that e = {u, v} is a cut edge. Every circuit containing e must contain a path from u to v in addition to just the edge e. Since there are no such paths if e is removed from the graph, every such path must contain e. Thus e appears twice in the circuit, so the circuit is not simple. Conversely, suppose that e is not a cut edge. Then in the graph with e deleted, u and v are still in the same component. Therefore, there is a simple path P from u to v in this deleted graph. The circuit consisting of P followed by e is a simple circuit containing e.",
        "answer_symbols": [
            "{",
            "}",
            "=",
            "→",
            "¬"
        ]
    },
    "10.4 40": {
        "question": "对 10.2 节练习 7~9 中的每个有向图，求其顶点基。",
        "answer": "In the directed graph in Exercise 7, there is a path from b to each of the other three vertices, so {b} is a vertex basis (and a smallest one). It is easy to see that {c} and {d} are also vertex bases, but a is not in any vertex basis. For the directed graph in Exercise 8, there is a path from b to each of a and c; on the other hand, d must clearly be in every vertex basis. Thus {b, d} is a smallest vertex basis. So are {a, d} and {c, d}. Every vertex basis for the directed graph in Exercise 9 must contain vertex e, since it has no incoming edges. On the other hand, from any other vertex, we can reach all the other vertices, so e together with any one of the other four vertices will form a vertex basis.",
        "answer_symbols": [
            "{",
            "}"
        ]
    },
    "10.4 42": {
        "question": "证明：若连通简单图 G 是图 G1 和 G2 的并图，则 G1 和 G2 至少具有 1 个公共的顶点。",
        "answer": "By definition of graph, both G1 and G2 are nonempty. If they have no common vertex, then there clearly can be no paths from v1 in G1 to v2 in G2. In that case, G would not be connected, contradicting the hypothesis.",
        "answer_symbols": []
    },
    "10.4 44": {
        "question": "用练习 43 证明：带有 n 个顶点和 k 个连通分支的简单图最多有 (n-k)(n-k+1)/2 条边。[提示：首先证明 ∑_{i=1}^{k} n_i^² ≤ n^² - (k-1)(2n-k) 其中 n_i 是第 i 个连通分支的顶点数。]",
        "answer": "First, we obtain the inequality given in the hint. We claim that the maximum value of the sum of n squared i, subject to the constraint that the sum of n i equals n, is obtained when one of the n i's is as large as possible, namely n - k + 1, and the remaining n i's (there are k - 1 of them) are all equal to 1. To justify this claim, suppose instead that two of the n i's were a and b, with a >= b >= 2. If we replace a by a + 1 and b by b - 1, then the constraint is still satisfied, and the sum of the squares has changed by (a + 1) squared + (b - 1) squared - a squared - b squared = 2(a - b) + 2 >= 2. Therefore, the maximum cannot be attained unless the n i's are as we claimed. Since there are only a finite number of possibilities for the distribution of the n i's, the arrangement we give must in fact yield the maximum. Therefore, the sum of n squared i <= (n - k + 1) squared + (k - 1) * 1 squared = n squared - (k - 1)(2n - k), as desired. Now by Exercise 43, the number of edges of the given graph does not exceed the sum of C(n i, 2) = the sum of (n squared i + n i) / 2 = ((the sum of n squared i) + n) / 2. Applying the inequality obtained above, we see that this does not exceed (n squared - (k - 1)(2n - k) + n) / 2, which after a little algebra is seen to equal (n - k)(n - k + 1) / 2. The upshot of all this is that the most edges are obtained if there is one component as large as possible, with all the other components consisting of isolated vertices.",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "*",
            "/",
            "<=",
            "(",
            ")",
            "[",
            "]",
            "^",
            "≥",
            "≤",
            "∑",
            "C"
        ]
    },
    "10.4 46": {
        "question": "当把图中的顶点都列出来，且每个连通分支中的顶点都连续地列出时，描述带有 n 个连通分支的图的邻接矩阵。",
        "answer": "Under these conditions, the matrix has a block structure, with all the 1's confined to small squares (of various sizes) along the main diagonal. The reason for this is that there are no edges between different components. See the picture for a schematic view. The only 1's occur inside the small submatrices (but not all the entries in these squares are 1's, of course).",
        "answer_symbols": []
    },
    "10.4 48 a)": {
        "question": "证明下列各图都没有割点。a) C_n，其中 n≥3。",
        "answer": "If any vertex is removed from Cn, the graph that remains is a connected graph, namely a path with n - 1 vertices.",
        "answer_symbols": [
            "-"
        ]
    },
    "10.4 48 b)": {
        "question": "证明下列各图都没有割点。b) W_n，其中 n≥3。",
        "answer": "If the central vertex is removed, the resulting graph is a cycle, which is connected. If a vertex on the cycle of Wn is removed, the resulting graph is connected because every remaining vertex on the cycle is joined to the central vertex.",
        "answer_symbols": []
    },
    "10.4 48 c)": {
        "question": "证明下列各图都没有割点。c) K_n,n，其中 m≥2 和 n≥2。",
        "answer": "Let v be a vertex in one part and w a vertex in the other part, after some vertex has been removed (these exist because m and n are both greater than 1). Then v and w are joined by an edge, and every other vertex is joined by an edge to either v or w, giving us a connected graph.",
        "answer_symbols": [
            ">",
            "1",
            "n",
            "→",
            "m",
            "v",
            "w"
        ]
    },
    "10.4 48 d)": {
        "question": "证明下列各图都没有割点。d) Q_n，其中 n≥2。",
        "answer": "我们可以使用数学归纳法，基于n-cubes的递归定义（参见第10.2节的示例8）。基础步骤是Q2，它与C4相同，我们在部分(a)中论证了它没有割点。假设归纳假设成立。设G为去掉一个顶点后的Q(k+1)。那么G由一个Qk的副本组成，这个副本显然是连通的；另一个去掉了一个顶点的Qk的副本，根据归纳假设也是连通的；并且至少有一条边连接这两个子图；因此G是连通的。",
        "answer_symbols": [
            "Q2",
            "Q(k+1)",
            "Qk",
            "→",
            "G",
            "G",
            "→",
            "G",
            "→",
            "G",
            "→",
            "G"
        ]
    },
    "10.4 50 a)": {
        "question": "对下列各图，求 κ(G)、λ(G) 和 min deg(v)，并判断 κ(G)≤λ(G)≤min deg(v) 中的两个不等式哪个更严格。a)",
        "answer": "去掉顶点b后留下两个组件，所以κ(G)= 1。去掉一条边不会断开图，但去掉边ab和eb会断开图，所以λ(G)= 2。最小度显然是2。因此只有κ(G)< λ(G)是严格的。",
        "answer_symbols": [
            "κ(G)",
            "λ(G)",
            "<"
        ]
    },
    "10.4 50 b)": {
        "question": "对下列各图，求 κ(G)、λ(G) 和 min deg(v)，并判断 κ(G)≤λ(G)≤min deg(v) 中的两个不等式哪个更严格。b)",
        "answer": "去掉顶点c后留下两个组件，所以κ(G)= 1。不难看出，去掉两条边不会断开图，但去掉与顶点a相邻的三条边，例如，确实会断开图。因此λ(G)= 3。由于最小度也是3，只有κ(G)< λ(G)是严格的不等式。",
        "answer_symbols": [
            "κ(G)",
            "λ(G)",
            "<"
        ]
    },
    "10.4 50 c)": {
        "question": "对下列各图，求 κ(G)、λ(G) 和 min deg(v)，并判断 κ(G)≤λ(G)≤min deg(v) 中的两个不等式哪个更严格。c)",
        "answer": "很容易看出，仅去掉一个顶点或一条边不会断开这个图，但去掉顶点a和k，或者去掉边ab和kl，确实会断开图。因此κ(G)= λ(G)= 2。由于最小度为3，只有不等式λ(G)< minv∈V deg(v)是严格的。",
        "answer_symbols": [
            "κ(G)",
            "λ(G)",
            "<"
        ]
    },
    "10.4 50 d)": {
        "question": "对下列各图，求 κ(G)、λ(G) 和 min deg(v)，并判断 κ(G)≤λ(G)≤min deg(v) 中的两个不等式哪个更严格。d)",
        "answer": "经过一点努力我们可以看到κ(G)= λ(G)= minv∈V deg(v)= 4，所以没有不等式是严格的。",
        "answer_symbols": [
            "κ(G)",
            "λ(G)",
            "minv∈V",
            "deg(v)"
        ]
    },
    "10.4 52 a)": {
        "question": "证明：若 G 是含有 n 个顶点的连通图，则 κ(G)=n-1 当且仅当 G=K_n。",
        "answer": "根据示例7之后的讨论，κ(Kn)= n - 1。相反，如果G是一个除了Kn之外有n个顶点的图，设u和v是G的两个非邻接顶点。那么去掉除了u和v之外的n - 2个顶点会使G断开，所以κ(G)< n - 1。",
        "answer_symbols": [
            "κ(Kn)",
            "n",
            "-",
            "1",
            "κ(G)",
            "<"
        ]
    },
    "10.4 52 b)": {
        "question": "证明：若 G 是含有 n 个顶点的连通图，则 λ(G)=n-1 当且仅当 G=K_n。",
        "answer": "由于κ(Kn) ≤ λ(Kn) ≤ minv∈Kn deg(v)（参见示例9之后的讨论），且外侧的数量都是n - 1，因此λ(Kn)= n - 1。相反，如果G不是Kn，那么它的最小度小于n - 1，因此它的边连通性也小于n - 1。",
        "answer_symbols": [
            "κ(Kn)",
            "λ(Kn)",
            "minv∈Kn",
            "deg(v)",
            "≤",
            "n",
            "-",
            "1",
            "λ(Kn)",
            "=",
            "n",
            "-",
            "1",
            "<"
        ]
    },
    "10.4 56": {
        "question": "解释如何用定理 2 求图中从顶点 v 到顶点 w 的最短通路的长度。",
        "answer": "最短路径的长度是最小的l，使得从v到w至少有一条长度为l的路径。因此我们可以通过依次计算A1, A2, A3,...，直到找到第一个l，使Al的(i, j)项不为0，其中v是第i个顶点，w是第j个顶点。",
        "answer_symbols": [
            "l",
            "v",
            "w",
            "→",
            "v",
            "w",
            "A1",
            "A2",
            "A3",
            "Al",
            "i",
            "j",
            "0"
        ]
    },
    "10.4 58": {
        "question": "用定理 2 求练习 2 中的有向图从 a 到 c 的最短通路的长度。",
        "answer": "首先我们写下该图的邻接矩阵，即A=[0 1 0 1 0 1 0 0 0 1 0 1 0 0 0 0]然后我们计算A2和A3，并查看每个的(1, 3)项。我们发现这些项分别是0和1。根据练习57给出的理由，我们得出最短路径的长度为3。",
        "answer_symbols": [
            "A",
            "[",
            "]",
            "0",
            "1",
            "A2",
            "A3",
            "1",
            "3",
            "0",
            "1",
            "3"
        ]
    },
    "10.4 59": {
        "question": "设 P₁ 和 P₂ 是简单图 G 中顶点 u 和 v 之间的没有相同边集的两条简单通路。证明：在 G 中存在简单回路。",
        "answer": "简单路径 P1 和 P2 分别为 u= x0, x1,..., xn= v 和 u= y0, y1,..., ym= v。这些路径从同一个顶点开始。由于路径不包含相同的边集，它们最终会分叉。如果它们仅在一个结束之后分叉，则另一条路径的其余部分是从 v 到 v 的简单环路。否则我们可以假设 x0= y0, x1= y1,..., xi= yi，但 xi+1 ≠ yi+1。为了形成我们的简单环路，我们沿着路径 yi, yi+1, yi+2，等等，直到它再次首次遇到 P1 上的一个顶点（可能最早是 yi+1，最晚是 ym）。一旦回到 P1，我们沿其继续前行——必要时向前或向后——返回到 xi。因为 xi= yi，这当然形成了一个环路。它必须是一个简单环路，因为 xk 或 yl 中的任何边都不能重复（假设 P1 和 P2 是简单的），并且 xk 中的任何边都不能等于我们使用的 yl 中的一条边，因为我们一碰到 P1 就放弃了 P2。",
        "answer_symbols": [
            "≠"
        ]
    },
    "10.4 60": {
        "question": "证明：长度为 k 的简单回路的存在性是一个图同构不变量，其中 k 是大于 2 的正整数。",
        "answer": "假设f是从图G到图H的同构。如果G有一个长度为k的简单回路，即u1, u2,..., uk, u1，那么我们声称f(u1), f(u2),..., f(uk), f(u1)是H中的一个简单回路。当然这是一个回路，因为G中的每条边uiui+1（以及uk u1）对应于H中的边f(ui)f(ui+1)（以及f(uk)f(u1)）。此外，由于在这个回路中G没有重复的边，当我们将G映射到H时也不会有重复的边。",
        "answer_symbols": [
            "f",
            "G",
            "H",
            "u1",
            "u2",
            "uk",
            "→",
            "f(u1)",
            "f(u2)",
            "f(uk)",
            "→",
            "f(ui)",
            "f(ui+1)",
            "f(uk)",
            "f(u1)",
            "→",
            "G",
            "H"
        ]
    },
    "10.4 61": {
        "question": "解释如何用定理 2 判定图是否是连通的。",
        "answer": "图 G 是连通的当且仅当 A + A^² + A^³ + ... + A^(n-1) 的每个非对角线元素都是正数，其中 A 是图 G 的邻接矩阵。",
        "answer_symbols": [
            "+",
            "^"
        ]
    },
    "10.4 62": {
        "question": "用练习 61 证明：图 2 中的图 G1 是连通的而图 G2 不是连通的。",
        "answer": "The adjacency matrix of G is as follows: A = [0 1 1 0 0 0; 0 1 0 1 0 0; 0 0 1 1 0 1; 0 0 0 1 0 1; 0 1 1 0 0 0; 1 0 1 0 1 0] We compute A^² and A^³, obtaining: A^² = [2 1 1 1 0 1; 0 1 2 1 1 0; 1 0 1 4 1 1; 1 1 1 1 1 3; 0 1 1 0 0 1; 0 1 1 0 1 3] A^³ = [2 3 5 2 1 2; 1 3 2 5 2 1; 2 1 5 5 4 6; 1 6 1 2 2 6; 2 3 5 1 1 1; 1 3 0 1 1 3] Already every off-diagonal entry in A^³ is nonzero, so we know that there is a path of length 3 between every pair of distinct vertices in this graph. Therefore, the graph G is connected.On the other hand, the adjacency matrix of H is as follows: A = [0 1 1 0 0 0; 1 0 0 0 0 0; 1 0 0 0 0 0; 0 0 0 0 1 1; 0 0 0 1 0 1; 0 0 0 1 1 0] We compute A^² through A^⁵, obtaining the following matrices: A^² = [2 0 0 0 0 0; 0 1 1 0 0 0; 0 1 1 0 0 0; 0 0 0 2 1 1; 0 0 0 1 2 1; 0 0 0 1 1 2] A^³ = [0 2 2 0 0 0; 2 0 0 0 0 0; 2 0 0 0 0 0; 0 0 0 2 3 3; 0 0 0 3 2 3; 0 0 0 3 3 2] A^⁴ = [4 0 0 0 0 0; 0 2 2 0 0 0; 0 2 2 0 0 0; 0 0 0 6 5 5; 0 0 0 5 6 5; 0 0 0 5 5 6] A^⁵ = [0 4 4 0 0 0; 4 0 0 0 0 0; 4 0 0 0 0 0; 0 0 0 10 11 11; 0 0 0 11 10 11; 0 0 0 11 11 10] If we compute the sum A + A^² + A^³ + A^⁴ + A^⁵, we obtain: [6 7 7 0 0 0; 7 3 3 0 0 0; 7 3 3 0 0 0; 0 0 0 20 21 21; 0 0 0 21 20 21; 0 0 0 21 21 20] There is a 0 in the (1, 4) position, telling us that there is no path of length at most 5 from vertex a to vertex d. Since the graph only has six vertices, this tells us that there is no path at all from a to d. Thus, the fact that there was a 0 as an off-diagonal entry in the sum told us that the graph was not connected.",
        "answer_symbols": [
            "=",
            "[",
            "]",
            ";",
            "²",
            "³"
        ]
    },
    "10.4 63": {
        "question": "证明：简单图 G 是二分图，当且仅当 G 没有包含奇数条边的回路。",
        "answer": "如果图是二部图，设其部分为 A 和 B，那么每条路径上的顶点必须交替位于 A 和 B 中。因此，从 A 开始的路径，在奇数步后将在 B 结束，在偶数步后将在 A 结束。因为环路在起点和终点处结束，长度必须是偶数。相反，假设所有环路都有偶数长度；我们必须证明图是二部图。我们可以假设图是连通的，因为如果不是，我们一次只处理一个连通分支。设 v 是图中的一个顶点，令 A 是所有从 v 出发有奇数长度路径到达的顶点集合，B 是所有从 v 出发有偶数长度路径到达的顶点集合。因为该连通分支是连通的，每个顶点都位于 A 或 B 中。没有顶点可以同时位于 A 和 B 中，因为如果有一个顶点这样做，那么从 v 沿着奇数长度路径到达该顶点然后沿着偶数长度路径返回 v 会产生一个奇数长度的环路，与假设矛盾。因此，顶点集被划分成两个集合。为了证明每条边的端点都在不同的部分中，假设 xy 是一条边，其中 x 属于 A。那么从 v 到 x 的奇数长度路径加上 xy 会产生一条从 v 到 y 的偶数长度路径，所以 y 属于 B。（同样地，如果 x 属于 B。）",
        "answer_symbols": []
    },
    "10.4 64 a)": {
        "question": "找出这个游戏所有的允许状态，其中不能出现在没有农夫的情况下，让狼和羊，或者羊和白菜在同一岸上。",
        "answer": "To proceed systematically, we list the states in order of decreasing population on the left shore. The allowable states are then:\n- (F W GC, Ø)\n- (F W G, C)\n- (F W C, G)\n- (F GC, W)\n- (F G, W C)\n- (W C, F G)\n- (C, F W G)\n- (G, F W C)\n- (W, F GC)\n- (Ø, F W GC)\n\nNotice that, for example, (GC, F W) and (W GC, F) are not allowed by the rules.",
        "answer_symbols": [
            "∃",
            "¬"
        ]
    },
    "10.4 64 b)": {
        "question": "构造一个图，使得图中的每一个顶点表示一个允许的状态，如果可以通过一次船的运输从一个状态转换到另一个状态，那么相应的顶点之间用一条边相连。",
        "answer": "The graph is as shown here. Notice that the boat can carry only the farmer and one other object, so the transitions are rather restricted.",
        "answer_symbols": [
            "∃",
            "¬"
        ]
    },
    "10.4 64 c)": {
        "question": "解释为什么找到一条从表示 (FGWC, ∅) 状态的顶点到表示 (∅, FGWC) 状态的顶点的通路，就能解决这个问题。",
        "answer": "The path in the graph corresponds to the moves in the solution.",
        "answer_symbols": [
            "∃",
            "¬"
        ]
    },
    "10.4 64 d)": {
        "question": "找出这个游戏的两个不同解，每个解都使用 7 次渡河。",
        "answer": "There are two simple paths from (F W GC, Ø) to (Ø, F W GC) that can be easily seen in the graph. One is:\n- (F W GC, Ø)\n- (W C, F G)\n- (F W C, G)\n- (W, F GC)\n- (F W G, C)\n- (G, F W C)\n- (F G, W C)\n- (Ø, F W GC)\n\nThe other is:\n- (F W GC, Ø)\n- (W C, F G)\n- (F W C, G)\n- (C, F W G)\n- (F GC, W)\n- (G, F W C)\n- (F G, W C)\n- (Ø, F W GC)",
        "answer_symbols": [
            "∃",
            "¬"
        ]
    },
    "10.4 64 e)": {
        "question": "假设每次农夫携带一个动物过河都要付 1 元的过路费，那么农夫应当采用哪一个解以使过路费最少。",
        "answer": "Both solutions cost $4.",
        "answer_symbols": [
            "∃",
            "¬"
        ]
    },
    "10.4 65": {
        "question": "参考练习 64，运用图模型和图中的通路，求解吃醋丈夫问题。两对已婚夫妇想要过河，他们只能找到一艘小船，小船一次只能运送一个或者两个人到对岸。每个丈夫都非常爱吃醋，不愿让自己的妻子和另外一位男士单独在船上或在岸上。这 4 个人要怎么做才能到达对岸？",
        "answer": "(H1 W1 H2 W2〈boat〉, ∅) → (H2 W2, H1 W1〈boat〉) → (H1 H2 W2〈boat〉, W1) → (W2, H1 W1 H2〈boat〉) → (H2 W2〈boat〉, H1 W1) → (∅, H1 W1 H2 W2〈boat〉)",
        "answer_symbols": [
            "→",
            "〈",
            "〉",
            "∅"
        ]
    },
    "10.4 66": {
        "question": "假设你有一个 3 加仑的壶和一个 5 加仑的壶，可以用水将它们灌满。你可以倒空任何一个壶，也可以把水从一个壶倒往另一个壶。运用一个有向图模型来说明，你可以最终使一个壶里恰好装 1 加仑的水。[提示：用有序对 (a, b) 表示每个壶里有多少水，然后用顶点来表示这个有序对。对可行的操作，在顶点之间添加相应的边。]",
        "answer": "If we use the ordered pair (a, b) to indicate that the three-gallon jug has a gallons in it and the five-gallon jug has b gallons in it, then we start with (0, 0) and can do the following things:\n- Fill a jug that is empty or partially empty (so that, for example, we can go from (0, 3) to (3, 3)).\n- Empty a jug.\n- Transfer some or all of the contents of a jug to the other jug, as long as we either completely empty the donor jug or completely fill the receiving jug.\n\nA simple solution to the puzzle uses this directed path:\n- (0, 0) → (3, 0) → (0, 3) → (3, 3) → (1, 5).",
        "answer_symbols": [
            "∃",
            "¬"
        ]
    },
    "10.5 9": {
        "question": "设除了哥尼斯堡的 7 座桥之外 (如图 1 所示), 还有另外 2 座桥。这些新桥分别连接区域 B 和 C 以及区域 B 和 D。是否有人能够经过这 9 座桥恰好一次并且回到出发点?",
        "answer": "不行，A 仍然有奇数度。",
        "answer_symbols": []
    },
    "10.5 10": {
        "question": "是否有人能够经过下图所示的所有桥恰好一次并且回到出发点?",
        "answer": "The graph model for this exercise is as shown here. Vertices a and b are the banks of the river, and vertices c and d are the islands. Each vertex has even degree, so the graph has an Euler circuit, such as:\n- a, c, b, a, d, c, a.\n\nTherefore, a walk of the type described is possible.",
        "answer_symbols": [
            "∃",
            "¬"
        ]
    },
    "10.5 11": {
        "question": "何时可以画出一个城市街道的中心线而不重复经过街道 (假设所有街道都是双向街道)?",
        "answer": "当以顶点表示交叉口、边表示街道的图有欧拉路径时",
        "answer_symbols": []
    },
    "10.5 12": {
        "question": "设计一个与算法 1 相似的过程, 它能够在多重图里构造欧拉通路。",
        "answer": "The algorithm is essentially the same as Algorithm 1. If there are no vertices of odd degree, then we simply use Algorithm 1, of course. If there are exactly two vertices of odd degree, then we begin constructing the initial path at one such vertex, and it will necessarily end at the other when it cannot be extended any further. Thereafter we follow Algorithm 1 exactly, splicing new circuits into the path we have constructed so far until no unused edges remain.",
        "answer_symbols": []
    },
    "10.5 16": {
        "question": "证明: 不带有孤立点的有向多重图具有欧拉回路, 当且仅当该图是弱连通的并且每个顶点的人度与出度都相等。",
        "answer": "First suppose that the directed multigraph has an Euler circuit. Since this circuit provides a path from every vertex to every other vertex, the graph must be strongly connected (and hence also weakly connected). Also, we can count the in-degrees and out-degrees of the vertices by following this circuit; as the circuit passes through a vertex, it adds one to the count of both the in-degree (as it comes in) and the out-degree (as it leaves). Therefore the two degrees are equal for each vertex. Conversely, suppose that the graph meets the conditions stated. Then we can proceed as in the proof of Theorem 1 and construct an Euler circuit.",
        "answer_symbols": [
            "→",
            "(",
            ")"
        ]
    },
    "10.5 17": {
        "question": "证明: 不带有孤立点的有向多重图具有欧拉通路而没有欧拉回路, 当且仅当该图是弱连通的并且存在两个顶点, 一个顶点的人度比出度大 1 而另外一个顶点的出度比人度大 1, 其余每个顶点的人度与出度都相等。",
        "answer": "如果存在欧拉路径，那么当我们跟随它时，除了起始和结束顶点外，每个顶点的入度和出度必须相等，因为在任何时候我们沿着一条边到达一个顶点时，我们会沿着另一条边离开它。起始顶点的出度必须比入度大 1，因为我们会使用一条从这个顶点出发的边，而每次再次访问它时，我们会使用一条进入它的边和一条离开它的边。同样，结束顶点的入度必须比出度大 1。因为擦除方向后的欧拉路径在基础无向图中产生了一条连接任意两个顶点的路径，所以图是弱连通的。相反，假设图满足所述的度条件。如果我们从出度不足的顶点添加一条边到入度不足的顶点，那么图中每个顶点的入度和出度都相等。因为图仍然是弱连通的，根据习题 16 这个新图有欧拉回路。现在删除添加的边以获得欧拉路径。",
        "answer_symbols": []
    },
    "10.5 13": {
        "question": "在练习 13 15 中, 判定是否可以用一枝铅笔连续移动, 不离开纸面并且不重复地画出所示的图形。",
        "answer": "可以",
        "answer_symbols": []
    },
    "10.5 14": {
        "question": "在练习 13 15 中, 判定是否可以用一枝铅笔连续移动, 不离开纸面并且不重复地画出所示的图形。",
        "answer": "See the comments in the solution to Exercise 13. This graph has exactly two vertices of odd degree; therefore it has an Euler path and can be so traced.",
        "answer_symbols": []
    },
    "10.5 15": {
        "question": "在练习 13 15 中, 判定是否可以用一枝铅笔连续移动, 不离开纸面并且不重复地画出所示的图形。",
        "answer": "不可以",
        "answer_symbols": []
    },
    "10.5 18": {
        "question": "在练习 18 23 中, 判断所示的有向图是否具有欧拉回路。若存在欧拉回路, 则构造一条欧拉回路。如果不存在欧拉回路, 就判断这个有向图是否具有欧拉通路。若存在欧拉通路, 则构造一条欧拉通路。",
        "answer": "For Exercises 18–23 we use the results of Exercises 16 and 17. This directed graph satisfies the condition of Exercise 17 but not that of Exercise 16. Therefore there is no Euler circuit. The Euler path must go from a to d. One such path is a, b, d, b, c, d, c, a, d.",
        "answer_symbols": []
    },
    "10.5 19": {
        "question": "在练习 18 23 中, 判断所示的有向图是否具有欧拉回路。若存在欧拉回路, 则构造一条欧拉回路。如果不存在欧拉回路, 就判断这个有向图是否具有欧拉通路。若存在欧拉通路, 则构造一条欧拉通路。",
        "answer": "都不是",
        "answer_symbols": []
    },
    "10.5 20": {
        "question": "在练习 18 23 中, 判断所示的有向图是否具有欧拉回路。若存在欧拉回路, 则构造一条欧拉回路。如果不存在欧拉回路, 就判断这个有向图是否具有欧拉通路。若存在欧拉通路, 则构造一条欧拉通路。",
        "answer": "The conditions of Exercise 16 are met, so there is an Euler circuit, which is perforce also an Euler path. One such path is a, d, b, d, e, b, e, c, b, a.",
        "answer_symbols": []
    },
    "10.5 21": {
        "question": "设计一个构造有向图中欧拉回路的算法。",
        "answer": "没有欧拉回路；a, d, e, d, b, a, e, c, e, b, c, b, e",
        "answer_symbols": []
    },
    "10.5 25": {
        "question": "设计一个构造有向图中欧拉通路的算法。",
        "answer": "跟随算法 1 的相同过程，注意遵循边的方向。",
        "answer_symbols": []
    },
    "10.5 27": {
        "question": "对哪些 n 值来说，练习 26 中的图具有欧拉通路而没有欧拉回路？",
        "answer": "a) n= 2 b) 无 c) 无 d) n= 1",
        "answer_symbols": [
            "="
        ]
    },
    "10.5 29": {
        "question": "当不重复任何部分地画出练习 1~7 中的每个图时，求出铅笔必须离开纸面的最少次数。",
        "answer": "习题 1：1 次；习题 2-7：0 次",
        "answer_symbols": []
    },
    "10.5 37": {
        "question": "练习 30 中的图有哈密顿通路吗？如果有，找到它。如果没有，给出理由证明不存在这样的通路。",
        "answer": "a, b, c, f, d, e 是哈密顿路径。",
        "answer_symbols": []
    },
    "10.5 38": {
        "question": "练习 31 中的图有哈密顿通路吗？如果有，找到它。如果没有，给出理由证明不存在这样的通路。",
        "answer": "This graph has the Hamilton path a, b, c, d, e.",
        "answer_symbols": []
    },
    "10.5 39": {
        "question": "练习 32 中的图有哈密顿通路吗？如果有，找到它。如果没有，给出理由证明不存在这样的通路。",
        "answer": "f, e, d, a, b, c 是哈密顿路径。",
        "answer_symbols": []
    },
    "10.5 40": {
        "question": "练习 33 中的图有哈密顿通路吗？如果有，找到它。如果没有，给出理由证明不存在这样的通路。",
        "answer": "This graph has no Hamilton path. There are three vertices of degree 1; each of them would have to be an end vertex of every Hamilton path. Since a path has only 2 ends, this is impossible.",
        "answer_symbols": []
    },
    "10.5 41": {
        "question": "练习 34 中的图有哈密顿通路吗？如果有，找到它。如果没有，给出理由证明不存在这样的通路。",
        "answer": "不存在哈密顿路径。有八个度为 2 的顶点，其中只有两个可以作为路径的端点。对于其他六个顶点，它们关联的两条边必须在路径中。不难看出，如果存在哈密顿路径，恰好有一个内角顶点必须是一个端点，而这不可能。",
        "answer_symbols": []
    },
    "10.5 42": {
        "question": "练习 35 中的图有哈密顿通路吗？如果有，找到它。如果没有，给出理由证明不存在这样的通路。",
        "answer": "It is easy to find the Hamilton path d, c, a, b, e here.",
        "answer_symbols": []
    },
    "10.5 30": {
        "question": "在练习 30~36 中，判断所给的图是否具有哈密顿回路。若有哈密顿回路，则求出这样一条回路。若没有哈密顿回路，则论证为什么不存在这样的回路。",
        "answer": "This graph can have no Hamilton circuit because of the cut edge {c, f}. Every simple circuit must be confined to one of the two components obtained by deleting this edge.",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "10.5 31": {
        "question": "在练习 30~36 中，判断所给的图是否具有哈密顿回路。若有哈密顿回路，则求出这样一条回路。若没有哈密顿回路，则论证为什么不存在这样的回路。",
        "answer": "a, b, c, d, e, a 是哈密顿回路。",
        "answer_symbols": []
    },
    "10.5 32": {
        "question": "在练习 30~36 中，判断所给的图是否具有哈密顿回路。若有哈密顿回路，则求出这样一条回路。若没有哈密顿回路，则论证为什么不存在这样的回路。",
        "answer": "As in Exercise 30, the cut edge ({e, f} in this case) prevents a Hamilton circuit.",
        "answer_symbols": [
            "{",
            "}"
        ]
    },
    "10.5 33": {
        "question": "在练习 30~36 中，判断所给的图是否具有哈密顿回路。若有哈密顿回路，则求出这样一条回路。若没有哈密顿回路，则论证为什么不存在这样的回路。",
        "answer": "不存在哈密顿回路，因为一旦所谓的回路到达 e 它将无处可去。",
        "answer_symbols": []
    },
    "10.5 34": {
        "question": "在练习 30~36 中，判断所给的图是否具有哈密顿回路。若有哈密顿回路，则求出这样一条回路。若没有哈密顿回路，则论证为什么不存在这样的回路。",
        "answer": "This graph has no Hamilton circuit. If it did, then certainly the circuit would have to contain edges {d, a} and {a, b}, since these are the only edges incident to vertex a. By the same reasoning, the circuit would have to contain the other six edges around the outside of the figure. These eight edges already complete a circuit, and this circuit omits the nine vertices on the inside. Therefore there is no Hamilton circuit.",
        "answer_symbols": [
            "{",
            "}"
        ]
    },
    "10.5 35": {
        "question": "在练习 30~36 中，判断所给的图是否具有哈密顿回路。若有哈密顿回路，则求出这样一条回路。若没有哈密顿回路，则论证为什么不存在这样的回路。",
        "answer": "不存在哈密顿回路，因为图中的每条边都关联一个度为 2 的顶点，因此必须在回路中。",
        "answer_symbols": []
    },
    "10.5 36": {
        "question": "在练习 30~36 中，判断所给的图是否具有哈密顿回路。若有哈密顿回路，则求出这样一条回路。若没有哈密顿回路，则论证为什么不存在这样的回路。",
        "answer": "It is easy to find a Hamilton circuit here, such as a, d, g, h, i, f, c, e, b, and back to a.",
        "answer_symbols": []
    },
    "10.5 43": {
        "question": "练习 36 中的图有哈密顿通路吗？如果有，找到它。如果没有，给出理由证明不存在这样的通路。",
        "answer": "a, b, c, f, i, h, g, d, e 是哈密顿路径。",
        "answer_symbols": []
    },
    "10.5 44 a)": {
        "question": "对哪些 n 值来说，练习 26 中的图具有哈密顿回路？",
        "answer": "Obviously K_n has a Hamilton circuit for all n ≥ 3 but not for n ≤ 2.",
        "answer_symbols": [
            "≥",
            "≤"
        ]
    },
    "10.5 44 b)": {
        "question": "对哪些 n 值来说，练习 26 中的图具有哈密顿回路？",
        "answer": "Obviously C_n has a Hamilton circuit for all n ≥ 3.",
        "answer_symbols": [
            "≥"
        ]
    },
    "10.5 44 c)": {
        "question": "对哪些 n 值来说，练习 26 中的图具有哈密顿回路？",
        "answer": "A Hamilton circuit for C_n can easily be extended to one for W_n by replacing one edge along the rim of the wheel by two edges, one going to the center and the other leading from the center. Therefore W_n has a Hamilton circuit for all n ≥ 3.",
        "answer_symbols": [
            "≥"
        ]
    },
    "10.5 44 d)": {
        "question": "对哪些 n 值来说，练习 26 中的图具有哈密顿回路？",
        "answer": "This is Exercise 49; see the solution given for it.",
        "answer_symbols": []
    },
    "10.5 45": {
        "question": "对哪些 m 和 n 值来说，完全二分图 K_m,n 具有哈密顿回路？",
        "answer": "m= n ≥ 2",
        "answer_symbols": [
            "=",
            "≥"
        ]
    },
    "10.5 46": {
        "question": "证明：右图所示的彼得森图没有哈密顿回路，但是通过删除一个顶点 v 和所有与 v 关联的边，得到的子图却有哈密顿回路。",
        "answer": "We do the easy part first, showing that the graph obtained by deleting a vertex from the Petersen graph has a Hamilton circuit. By symmetry, it makes no difference which vertex we delete, so assume that it is vertex j. Then a Hamilton circuit in what remains is a, e, d, i, g, b, c, h, f, a. Now we show that the entire graph has no Hamilton circuit. Assume that a Hamilton circuit exists. Not all the edges around the outside can be used, so without loss of generality assume that {c, d} is not used. Then {e, d}, {d, i}, {h, c}, and {b, c} must all be used. If {a, f} is not used, then {e, a}, {a, b}, {f, i}, and {f, h} must be used, forming a premature circuit. Therefore {a, f} is used. Without loss of generality we may assume that {e, a} is also used, and {a, b} is not used. Then {b, g} is also used, and {e, j} is not. But this requires {g, j} and {h, j} to be used, forming a premature circuit b, c, h, j, g, b. Hence no Hamilton circuit can exist in this graph.",
        "answer_symbols": [
            "{",
            "}"
        ]
    },
    "10.5 48": {
        "question": "能否找到一个带有 n 个顶点的简单图 (n≥3)，这个图没有哈密顿回路，但是这个图中每个顶点的度至少是 (n-1)/2？",
        "answer": "We want to look only at odd n, since if n is even, then being at least (n−1)/2 is the same as being at least n/2, in which case Dirac’s theorem would apply. One way to avoid having a Hamilton circuit is to have a cut vertex—a vertex whose removal disconnects the graph. The simplest example would be the “bow-tie” graph with five vertices (a, b, c, d, and e), where cut vertex c is adjacent to each of the other vertices, and the only other edges are ab and de. Every vertex has degree at least (5 − 1)/2 = 2, but there is no Hamilton circuit.",
        "answer_symbols": [
            "−",
            "/",
            "="
        ]
    },
    "10.5 49": {
        "question": "证明：当 n 是正整数时，存在 n 阶格雷码，或者等价地证明：n≥1 的 n 立方体 Q_n 总是具有哈密顿回路。[提示：用数学归纳法。证明如何从 n-1 阶格雷码产生 n 阶格雷码。]",
        "answer": "对于 n= 1 的结果是平凡的：代码是 0, 1。假设我们有一个 n 阶的格雷码。设 c1,..., ck, k= 2^n 为这样的码。那么 0c1,..., 0ck, 1ck,..., 1c1 是一个 (n+1) 阶的格雷码。",
        "answer_symbols": [
            "=",
            "^"
        ]
    },
    "10.5 50": {
        "question": "用 Fleury 算法找出在图 5 中图 G 的欧拉回路。",
        "answer": "Let us begin at vertex a and walk toward vertex b. Then the circuit begins a, b, c. At this point we must choose among three edges to continue the circuit. If we choose edge {c, f}, then we will have disconnected the graph that remains, so we must not choose this edge. Suppose instead that the circuit continues with edge {c, d}. Then the entire circuit is forced to be a, b, c, d, e, c, f, a.",
        "answer_symbols": [
            "{",
            "}"
        ]
    },
    "10.5 51": {
        "question": "用伪代码表达 Fleury 算法。",
        "answer": "算法 Fleury(G=(V, E): 所有顶点度数均为偶数的连通多重图，V={v1,..., vn}) v:= v1 回路:= v H:= G 当 H 有边时 e:= H 中第一个以 v 为端点的边（相对于 V 的列表），如果存在，则 e 不是 H 的割边，否则取 H 中第一个以 v 为端点的边 w:= e 的另一个端点 回路:= 回路加上 e, w v:= w H:= H - e 返回回路 {回路是一个欧拉回路}",
        "answer_symbols": [
            ":",
            ":=",
            "+",
            "-",
            "=",
            "∈"
        ]
    },
    "10.5 52": {
        "question": "证明：Fleury 算法总是产生一条欧拉回路。",
        "answer": "This proof is rather hard. See page 63 of Graph Theory with Applications by J. A. Bondy and U. S. R. Murty (American Elsevier, 1976).",
        "answer_symbols": []
    },
    "10.5 53": {
        "question": "给出 Fleury 算法的变种以产生欧拉通路。",
        "answer": "如果图G有一个欧拉回路，则它也有一个欧拉路径。如果不是这样，可以在两个奇度顶点之间添加一条边，并应用算法来获得一个欧拉回路。然后删除这条新边。",
        "answer_symbols": []
    },
    "10.5 55": {
        "question": "证明：带有奇数个顶点的二分图没有哈密顿回路。",
        "answer": "假设G = (V, E)是一个二分图，其中V = V1 ∪ V2，且V1 ∩ V2 = ∅，没有边连接V1中的顶点和V2中的顶点。假设G有一个哈密顿回路。这样的回路必须是以下形式：a1, b1, a2, b2, ..., ak, bk, a1，其中ai属于V1，bi属于V2，对于i = 1, 2, ..., k。因为哈密顿回路访问每个顶点恰好一次，除了v1（回路开始和结束的地方），图中的顶点数等于2k，这是一个偶数。因此，具有奇数个顶点的二分图不能有哈密顿回路。",
        "answer_symbols": [
            "=",
            "∪",
            "∩",
            "∈"
        ]
    },
    "10.5 56": {
        "question": "画出表示马在 3×3 棋盘上的合法移动的图。",
        "answer": "We draw a vertex for each 9 squares on the chessboard. Then we draw an edge from one vertex to each other vertex that can be reached by moving horizontally 2 units and vertically 1 unit or vice versa. The result is as shown in the figure.",
        "answer_symbols": [
            "→"
        ]
    },
    "10.5 57": {
        "question": "画出表示马在 3×4 棋盘上的合法移动的图。",
        "answer": "我们将3×4棋盘的方格表示如下：通过以下移动可以完成骑士巡游：8, 10, 1, 7, 9, 2, 11, 5, 3, 12, 6, 4。",
        "answer_symbols": []
    },
    "10.5 58 a)": {
        "question": "证明：求马在 m×n 棋盘上的周游等价于求表示马在该棋盘上合法移动的图的哈密顿通路。",
        "answer": "In a Hamilton path, we need to visit each vertex once along the edges. A knight's tour is exactly such a path, since we visit each square once and make legal moves.",
        "answer_symbols": [
            "→"
        ]
    },
    "10.5 58 b)": {
        "question": "证明：求马在 m×n 棋盘上的重返的周游等价于求所对应的图上的哈密顿回路。",
        "answer": "This is the same as part (a), except that a re-entering tour must return to its starting point, just as a Hamiltonian circuit must return to its starting point.",
        "answer_symbols": [
            "→"
        ]
    },
    "10.5 59": {
        "question": "证明：存在马在 3×4 棋盘上的周游。",
        "answer": "我们将4×4棋盘的方格表示如下：每个角落方格只有两个移动方向。如果我们包括所有边1–10, 1–7, 16–10, 和 16–7，回路会过早地闭合，所以至少有一条边必须缺失。不失一般性，假设路径从1–10, 10–16, 16–7开始。现在从方格3出发的唯一移动是到方格5, 10, 和 12，而方格10已经有两条入射边。因此，3–5和3–12必须在哈密顿回路中。同样，边8–2和8–15也必须在回路中。现在从方格9出发的唯一移动是到方格2, 7, 和 15。如果从方格9到方格2和15都有边，回路会过早地闭合。因此边9–7必须在回路中，使方格7达到其完整的边数。但现在方格14被迫连接到方格5和12，过早地闭合了回路（5–14–12–3–5）。这一矛盾表明，在4×4棋盘上没有骑士巡游。",
        "answer_symbols": [
            "-",
            "→"
        ]
    },
    "10.5 60": {
        "question": "证明：不存在马在 3×3 棋盘上的周游。",
        "answer": "On a 3 × 3 chessboard, the central vertex is isolated (see the solution to Exercise 56). In other words, no knight can move to or from the central square. Therefore, it is clearly impossible to have a knight's tour. However, there are tours of the other squares, as shown in the above figures.",
        "answer_symbols": [
            "×",
            "→"
        ]
    },
    "10.5 61": {
        "question": "证明：不存在马在 4×4 棋盘上的周游。",
        "answer": "因为m×n棋盘上有mn个方格，如果m和n都是奇数，则方格数是奇数。因为根据练习62，相应的图是二分图，根据练习55，它没有哈密顿回路。因此，没有重返骑士巡游。",
        "answer_symbols": [
            "×",
            "="
        ]
    },
    "10.5 54": {
        "question": "一个诊断消息可以在计算机网络上发出，以便在所有链路和所有设备上执行测试。为了测试所有的链路，应当使用什么类型的通路？为了测试所有的设备呢？",
        "answer": "An Euler path will cover every link, so it can be used to test the links. A Hamilton path will cover all the devices, so it can be used to test the devices.",
        "answer_symbols": []
    },
    "10.5 62": {
        "question": "证明：当 m 和 n 都是正整数时，表示马在 m × n 棋盘上的合法移动的图是二分图。",
        "answer": "Each square on the chessboard can be viewed as a pair of integers (x, y). Let A be the set of squares where x + y is odd, and B be the set of squares where x + y is even. This divides the vertex set of the graph representing the knight's legal moves on the chessboard into two parts. Now, each step of the knight changes the parity of x + y—either 1 + 2 = 3, 2 - 1 = 1, 1 - 2 = -1, or -1 - 2 = -3. Therefore, each edge in this graph connects a vertex in A to a vertex in B. Thus, this graph is bipartite.",
        "answer_symbols": [
            "+",
            "-",
            "=",
            "→"
        ]
    },
    "10.5 63": {
        "question": "证明：当 m 和 n 都是奇数时，不存在马在 m × n 棋盘上的重返的周游。[提示：利用练习 55、练习 58b 和练习 62。]",
        "answer": "如果G没有哈密顿回路，尽可能多地添加缺失的边，每次只添加一条边，以确保我们不会得到一个有哈密顿回路的图。这不可能无限期地进行下去，因为一旦通过添加所有缺失的边形成完全图，就会有一个哈密顿回路。每当过程停止时，我们得到了一个（必要不完全的）图H，具有所需的性质。在H中再加一条边。这会产生一个使用新增边的哈密顿回路。由这个回路去掉新增边形成的路径是H中的哈密顿路径。显然v1和vn在H中不相邻，因为H没有哈密顿回路。因此它们在G中也不相邻。但假设是在G中不相邻的顶点的度数之和至少为n。这个不等式可以改写为n - deg(vn) ≤ deg(v1)。但n - deg(vn)只是不与vn相邻的顶点数。因为vn后面没有顶点，vn不在S中。每个与v1相邻的deg(v1)个顶点都会产生S的一个元素，所以S包含deg(v1)个顶点。根据部分(c)，除vn外，最多有deg(v1)-1个顶点不与vn相邻，根据部分(d)，S中有deg(v1)个顶点，没有一个是vn。因此，S中至少有一个顶点与vn相邻。按照定义，如果vk是这个顶点，那么H包含边vkvn和v1vk+1，其中1 < k < n-1。现在v1, v2, ..., vk-1, vk, vn, vn-1, ..., vk+1, v1 是H中的一个哈密顿回路，这与H的构造相矛盾。因此，我们假设G原本没有哈密顿回路是错误的，我们的反证法证明完成。",
        "answer_symbols": [
            "-",
            "<",
            ">"
        ]
    },
    "10.5 64": {
        "question": "证明：存在马在 8 × 8 棋盘上的周游。[提示：你可以用沃恩斯道夫于 1823 年发明的下列方法来构造马的周游。从任意格子开始，然后总是移动到与最少数目没有用过的格子连接的一个格子上。虽然这个方法不能总是产生马的周游，但是它确实很有效。]",
        "answer": "After some trial and error, loosely following the hint, the following solution was produced. The numbers show the order in which the squares are traversed.",
        "answer_symbols": []
    },
    "10.5 66": {
        "question": "证明：求所有顶点的度都为偶数的连通图的欧拉回路的算法 1 的最坏情形计算复杂度是 O(m)，其中 m 是 G 中的边数。",
        "answer": "Suppose that G is a graph on n vertices randomly generated using edge probability p, and G' is a graph on n vertices randomly generated using edge probability p', where p < p'. Recall that this means that for G we go through all pairs of vertices and independently put an edge between them with probability p; and similarly for G'. We must show that G is no more likely to have property P than G' is. To see this, we will imagine a different way of forming G. First we generate a random graph G' using edge probability p'; then we go through the edges that are present, and independently erase each of them with probability 1 - (p/p'). Clearly, for an edge to end up in G, it must first get generated and then not get erased, which has probability p' * (p/p') = p; therefore this is a valid way to generate G. Now whenever G has property P, then so does G', since P is monotone increasing. Thus the probability that G has property P is no greater than the probability that G' does; in fact it will usually be less, since once a G' having property P is generated, it is possible that it will lose the property as edges are erased.",
        "answer_symbols": [
            "=",
            "(",
            "+",
            "<",
            "→",
            "*",
            ")",
            "-"
        ]
    },
    "10.6 1 a)": {
        "question": "对下列关于地铁系统的每个问题，描述一个可以用来解决这个问题的加权图模型。在两站之间旅行所需要的最短时间是什么？",
        "answer": "顶点是站点，边连接相邻站点，权重是旅行所需时间。",
        "answer_symbols": []
    },
    "10.6 1 b)": {
        "question": "对下列关于地铁系统的每个问题，描述一个可以用来解决这个问题的加权图模型。从一站到达另外一站所经过的最短距离是什么？",
        "answer": "与部分(a)相同，但权重是相邻站点之间的距离。",
        "answer_symbols": []
    },
    "10.6 1 c)": {
        "question": "对下列关于地铁系统的每个问题，描述一个可以用来解决这个问题的加权图模型。若把各站之间的票价求和就得总票价，则两站之间的最低票价是什么？",
        "answer": "与部分(a)相同，但权重是站点之间的票价。",
        "answer_symbols": []
    },
    "10.6 2": {
        "question": "求给定加权图在a与z之间的最短通路的长度。",
        "answer": "在练习5的解答中我们找到了一条最短路径。其长度为7。",
        "answer_symbols": []
    },
    "10.6 5": {
        "question": "求在练习2～4的每个加权图中，a与z之间的最短通路是什么？",
        "answer": "练习2: a, b, e, d, z; 练习3: a, c, d, e, g, z; 练习4: a, b, e, h, l, m, p, s, z",
        "answer_symbols": []
    },
    "10.6 8 a)": {
        "question": "在图1所示的航线系统中，求纽约与洛杉矶之间的最短通路（以英里表示）。",
        "answer": "直接路径是最短的。",
        "answer_symbols": []
    },
    "10.6 8 b)": {
        "question": "在图1所示的航线系统中，求波士顿与旧金山之间的最短通路（以英里表示）。",
        "answer": "经过芝加哥的路径是最短的。",
        "answer_symbols": []
    },
    "10.6 8 c)": {
        "question": "在图1所示的航线系统中，求达拉斯与丹佛之间的最短通路（以英里表示）。",
        "answer": "经过亚特兰大和芝加哥的路径是最短的。",
        "answer_symbols": []
    },
    "10.6 8 d)": {
        "question": "在图1所示的航线系统中，求迈阿密与洛杉矶之间的最短通路（以英里表示）。",
        "answer": "经过亚特兰大、芝加哥和丹佛的路径是最短的。",
        "answer_symbols": []
    },
    "10.6 10": {
        "question": "利用图1所示的票价，求连接练习8中成对城市之间的票价最低的航班组合。",
        "answer": "练习8的注释同样适用。",
        "answer_symbols": []
    },
    "10.6 11 a)": {
        "question": "在图2所示的通信网络里，求波士顿与洛杉矶之间的（距离）最短路线。",
        "answer": "经芝加哥",
        "answer_symbols": []
    },
    "10.6 11 b)": {
        "question": "在图2所示的通信网络里，求纽约与旧金山之间的（距离）最短路线。",
        "answer": "经芝加哥",
        "answer_symbols": []
    },
    "10.6 11 c)": {
        "question": "在图2所示的通信网络里，求达拉斯与旧金山之间的（距离）最短路线。",
        "answer": "经洛杉矶",
        "answer_symbols": []
    },
    "10.6 11 d)": {
        "question": "在图2所示的通信网络里，求丹佛与纽约之间的（距离）最短路线。",
        "answer": "经芝加哥",
        "answer_symbols": []
    },
    "10.6 12": {
        "question": "利用在图2给出的响应时间，求在练习11中成对的计算机中心之间响应时间最短的路线。",
        "answer": "练习8的注释同样适用。",
        "answer_symbols": []
    },
    "10.6 14": {
        "question": "解释把无向图中两个顶点之间边数最少的通路当做加权图中最短通路来求解的过程。",
        "answer": "在这里我们简单地将每条边的权重设为1。",
        "answer_symbols": []
    },
    "10.6 15": {
        "question": "扩展求加权简单连通图中两个顶点之间最短通路的迪克斯特拉算法，以便求出顶点a与图中其余每个顶点之间的最短通路的长度。",
        "answer": "当z被加入集合S时不要停止算法。",
        "answer_symbols": []
    },
    "10.6 16": {
        "question": "扩展求带权简单连通图中两个顶点之间最短通路的迪克斯特拉算法，以便构造出在这些顶点之间的最短通路。",
        "answer": "我们需要跟踪到目前为止已知的最短路径来自哪个顶点，以及该路径的长度。因此我们在算法中添加一个数组P，其中P(v)表示到v的最佳已知路径中的前一个顶点。我们修改算法1，使得当L通过语句L(v) := L(u) + w(u, v)更新时，我们也设置P(v) := u。一旦while循环终止，我们可以通过从z开始并跟随P中的指针来反向获得从a到z的最短路径。因此反向路径为z, P(z), P(P(z)), ..., P(P(...P(z)...)) = a。",
        "answer_symbols": [
            ":=",
            "+",
            "(",
            ")",
            ","
        ]
    },
    "10.6 17 a)": {
        "question": "在下图中的加权图说明新泽西的一些主要道路。图a说明这些道路上的城市之间的距离；图b说明通行费。利用这些道路，求在纽华克与卡姆登之间，以及在纽华克与五月角之间距离最短的路线。",
        "answer": "经伍德布里奇，经伍德布里奇和卡姆登",
        "answer_symbols": []
    },
    "10.6 17 b)": {
        "question": "在下图中的加权图说明新泽西的一些主要道路。图a说明这些道路上的城市之间的距离；图b说明通行费。利用这些道路，求在纽华克与卡姆登之间，以及在纽华克与五月角之间通行费最低的路线。",
        "answer": "经伍德布里奇，经伍德布里奇和卡姆登",
        "answer_symbols": []
    },
    "10.6 3": {
        "question": "求给定加权图在a与z之间的最短通路的长度。",
        "answer": "16",
        "answer_symbols": []
    },
    "10.6 4": {
        "question": "求给定加权图在a与z之间的最短通路的长度。",
        "answer": "在练习5的解答中我们找到了一条最短路径。其长度为16。",
        "answer_symbols": []
    },
    "10.6 18": {
        "question": "若各边的权都是不同的，则在加权图中两个顶点之间的最短通路是否唯一？",
        "answer": "最短路径不一定是唯一的。例如，我们可以有一个具有顶点a, b, c和d的图，边{a, b}的权重为3，{b, c}的权重为7，{a, d}的权重为4，{d, c}的权重为6。从a到c有两条最短路径。",
        "answer_symbols": [
            "{",
            "}",
            ",",
            "→"
        ]
    },
    "10.6 19": {
        "question": "哪些应用必须求出加权图中两个顶点之间的最长简单通路的长度？",
        "answer": "例如，观光旅游，街道清洁",
        "answer_symbols": []
    },
    "10.6 20": {
        "question": "什么是图 4 的加权图中 a 与 z 之间的最长简单通路的长度？在 c 与 z 之间呢？",
        "answer": "我们进行非正式分析。回想一下，简单路径不能重复使用任何边。此外，由于路径必须使用与a和z相邻的奇数条边，因此路径至少要省略两条边，每端一条。那么，尝试寻找最长路径时，我们能希望的最佳情况是路径省略了这两条最短的边——{a, c}和{e, z}。如果路径省略了这两条边，则还必须省略一条与c相邻的边，因为路径必须使用与c相邻的剩余三条边中的偶数条。我们能希望的最佳情况是路径省略了上述两条边和边{b, c}。由于2 + 1 < 4，这比另一种可能性（即省略边{a, b}而不是{a, c}）更好。最后，我们找到了一条仅省略这三条边的简单路径，即a, b, d, c, e, d, z，长度为35，因此我们得出结论，这是从a到z的最长简单路径。",
        "answer_symbols": [
            "{",
            "+",
            "<",
            "→",
            "}"
        ]
    },
    "10.6 21": {
        "question": "用弗洛伊德算法求图 4a 中加权图中所有顶点对之间的距离。",
        "answer": "a b c d e z \na 4 3 2 8 10 13\nb 3 2 1 5 7 10\nc 2 1 2 6 8 11\nd 8 5 6 4 2 5\ne 10 7 8 2 4 3\nz 13 10 11 5 3 6",
        "answer_symbols": []
    },
    "10.6 22": {
        "question": "证明：弗洛伊德算法确定加权简单图中所有顶点对之间的最短距离。",
        "answer": "A similar argument shows that the longest simple path from c to z is c, a, b, d, c, e, d, z.",
        "answer_symbols": []
    },
    "10.6 23": {
        "question": "给出弗洛伊德算法为了确定在带有 n 个顶点的加权简单图中所有顶点对之间的最短距离而使用的运算（比较和加法）次数的大 O 估计。",
        "answer": "O(n^3)",
        "answer_symbols": [
            "^"
        ]
    },
    "10.6 24": {
        "question": "证明：若边有负的权值，则迪克斯特拉算法或许不能给出正确答案。",
        "answer": "Consider the graph with vertices a, b, and z, where the weight of {a, z} is 2, the weight of {a, b} is 3, and the weight of {b, z} is -2. Then Dijkstra’s algorithm will decide that L(z) = 2 and stop, whereas the path a, b, z is shorter (has length 1).",
        "answer_symbols": [
            "=",
            "-",
            "<"
        ]
    },
    "10.6 25": {
        "question": "通过求出所有哈密顿回路的总权值并确定总权值最小的回路来解决下图的旅行商问题。",
        "answer": "a–c–b–d–a (or the same circuit starting at some other point and/or traversing the vertices in reverse order)",
        "answer_symbols": [
            "–"
        ]
    },
    "10.6 26": {
        "question": "通过求出所有哈密顿回路的总权值并确定总权值最小的回路来解决下图的旅行商问题。",
        "answer": "The following table shows the twelve different Hamilton circuits and their weights: a- b- c- d- e- a: 3 + 10 + 6 + 1 + 7 = 27, a- b- c- e- d- a: 3 + 10 + 5 + 1 + 4 = 23, a- b- d- c- e- a: 3 + 9 + 6 + 5 + 7 = 30, a- b- d- e- c- a: 3 + 9 + 1 + 5 + 8 = 26, a- b- e- c- d- a: 3 + 2 + 5 + 6 + 4 = 20, a- b- e- d- c- a: 3 + 2 + 1 + 6 + 8 = 20, a- c- b- d- e- a: 8 + 10 + 9 + 1 + 7 = 35, a- c- b- e- d- a: 8 + 10 + 2 + 1 + 4 = 25, a- c- d- b- e- a: 8 + 6 + 9 + 2 + 7 = 32, a- c- e- b- d- a: 8 + 5 + 2 + 9 + 4 = 28, a- d- b- c- e- a: 4 + 9 + 10 + 5 + 7 = 35, a- d- c- b- e- a: 4 + 6 + 10 + 2 + 7 = 29 Thus, we see that the circuits a- b- e- c- d- a and a- b- e- d- c- a (or the same circuits starting at some other point but traversing the vertices in the same or exactly opposite order) are the ones with minimum total weight.",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "10.6 27": {
        "question": "求访问下图中每个城市的机票总价最低的路线，其中边上的权值是在这两个城市之间的航班所提供的最低票价。",
        "answer": "San Francisco–Denver–Detroit–New York–Los Angeles–San Francisco (or the same circuit starting at some other point and/or traversing the vertices in reverse order)",
        "answer_symbols": [
            "–"
        ]
    },
    "10.6 28": {
        "question": "求访问下图中每个城市的机票总价最低的路线，其中边上的权值是在这两个城市之间的航班所提供的最低票价。",
        "answer": "The following table shows the twelve different Hamilton circuits and their weights, where we abbreviate the cities with the beginning letter of their name, except that New Orleans is O: S- B- N- O- P- S: 409 + 109 + 229 + 309 + 119 = 1175, S- B- N- P- O- S: 409 + 109 + 319 + 309 + 429 = 1575, S- B- O- N- P- S: 409 + 239 + 229 + 319 + 119 = 1315, S- B- O- P- N- S: 409 + 239 + 309 + 319 + 389 = 1665, S- B- P- N- O- S: 409 + 379 + 319 + 229 + 429 = 1765, S- B- P- O- N- S: 409 + 379 + 309 + 229 + 389 = 1715, S- N- B- O- P- S: 389 + 109 + 239 + 309 + 119 = 1165, S- N- B- P- O- S: 389 + 109 + 379 + 309 + 429 = 1615, S- N- O- B- P- S: 389 + 229 + 239 + 379 + 119 = 1355, S- N- P- B- O- S: 389 + 319 + 379 + 239 + 429 = 1755, S- O- B- N- P- S: 429 + 239 + 109 + 319 + 119 = 1215, S- O- N- B- P- S: 429 + 229 + 109 + 379 + 119 = 1265 As a check of our arithmetic, we can compute the total weight (price) of all the trips (it comes to 17580) and check that it is equal to 6 times the sum of the weights (which here is 2930), since each edge appears in six paths (and sure enough, 17580 = 6 * 2930). We see that the circuit S- N- B- O- P- S (or the same circuit starting at some other point but traversing the vertices in the same or exactly opposite order) is the one with minimum total weight, 1165.",
        "answer_symbols": [
            "*",
            "=",
            "+"
        ]
    },
    "10.6 29": {
        "question": "构造一个加权无向图，使得对于访问某些顶点超过一次的回路来说，访问每个顶点至少一次的回路的总权值是最小的。[提示：存在有3个顶点的例子。]",
        "answer": "Consider this graph:\na\nb c 100\n1 2\nThe circuit a-b-a-c-a visits each vertex at least once (and the vertex a twice) and has total weight 6. Every Hamilton circuit has total weight 103.",
        "answer_symbols": []
    },
    "10.6 31": {
        "question": "不含简单回路的加权有向图的最长通路问题是求图中的一个通路，该通路中边的权值之和是最大的。设计一个求解最长通路的算法。[提示：首先找到图中顶点的拓扑排序。]",
        "answer": "Let v1, v2, ..., vn be a topological ordering of the vertices of the given directed acyclic graph. Let w(i, j) be the weight of edge vi vj. Iteratively define P(i) with the intent that it will be the weight of a longest path ending at vi and C(i) with the intent that it will be the vertex preceding vi in some longest path: For i from 1 to n, let P(i) be the maximum of P(j) + w(j, i) over all j < i such that vj vi is an edge in the directed graph (and if such a j exists let C(i) be a value of j for which this maximum is achieved) and let P(i) = 0 if there are no such values of j. At the conclusion of this loop, a longest path can be found by choosing i that maximizes P(i) and following the C links back to the start of the path.",
        "answer_symbols": [
            "+",
            "<",
            "="
        ]
    },
    "10.7 1": {
        "question": "5 座房屋能否不带连接交叉地与两种设施相连接吗？",
        "answer": "Yes",
        "answer_symbols": []
    },
    "10.7 3": {
        "question": "不带任何交叉地画出给定的平面图。",
        "answer": "b\na d\nc\ne",
        "answer_symbols": []
    },
    "10.7 5": {
        "question": "在练习5～9中，判断所给的图是否是平面图。若是平面图，则画出它使得没有边交叉。",
        "answer": "No",
        "answer_symbols": []
    },
    "10.7 7": {
        "question": "在练习5～9中，判断所给的图是否是平面图。若是平面图，则画出它使得没有边交叉。",
        "answer": "Yes\na d\ne\nc f\nb",
        "answer_symbols": []
    },
    "10.7 9": {
        "question": "在练习5～9中，判断所给的图是否是平面图。若是平面图，则画出它使得没有边交叉。",
        "answer": "No",
        "answer_symbols": []
    },
    "10.7 11": {
        "question": "用类似于例3中给出的论证来证明：K₅是非平面图。",
        "answer": "A triangle is formed by the planar representation of the subgraph of K5 consisting of the edges connecting v1, v2, and v3. The vertex v4 must be placed either within the triangle or outside of it. We will consider only the case when v4 is inside the triangle; the other case is similar. Drawing the three edges from v1, v2, and v3 to v4 forms four regions. No matter which of these four regions v5 is in, it is possible to join it to only three, and not all four, of the other vertices.",
        "answer_symbols": []
    },
    "10.7 13": {
        "question": "假定一个连通平面图有6个顶点，每个顶点的度都为4。这个图的平面表示把平面分割成多少个面？",
        "answer": "8",
        "answer_symbols": []
    },
    "10.7 15": {
        "question": "证明推论3。",
        "answer": "Because there are no loops or multiple edges and no simple circuits of length 3, and the degree of the unbounded region is at least 4, each region has degree at least 4. Thus 2e >= 4r, or r <= e/2. But r = e - v + 2, so we have e - v + 2 <= e/2, which implies that e <= 2v - 4.",
        "answer_symbols": [
            ">=",
            "<=",
            "/"
        ]
    },
    "10.7 16": {
        "question": "假定一个连通的平面简单二分图有e条边和v个顶点。证明：若v≥3，则e≤2v-4。",
        "answer": "二分简单图没有长度为三的简单回路。因此，不等式由推论3得出。",
        "answer_symbols": []
    },
    "10.7 17": {
        "question": "假定一个带有e条边和v个顶点的连通平面简单图不包含长度为4或更短的回路。证明：若v≥4，则e≤(5/3)v-(10/3)。",
        "answer": "As in the argument in the proof of Corollary 1, we have 2e >= 5r and r = e - v + 2. Thus e - v + 2 <= 2e/5, which implies that e <= (5/3)v - (10/3).",
        "answer_symbols": [
            ">=",
            "<=",
            "/",
            "-"
        ]
    },
    "10.7 18": {
        "question": "假定一个平面图有k个连通分支、e条边和v个顶点。另外假定这个图的平面表示把平面分割成r个面。求用e、v和k所表示的r的公式。",
        "answer": "如果我们添加k-1条边，可以使图连通，不会创建新的区域，并且仍然避免边的交叉。对于这个新图，欧拉公式告诉我们v-(e+k-1)+r=2。这在代数上简化为r=e-v+k+1。",
        "answer_symbols": [
            "-",
            "+",
            "=",
            "-"
        ]
    },
    "10.7 20": {
        "question": "在练习20～22中，判断给定的图是否同胚于K₃,₃。",
        "answer": "该图与K3,3不同胚，因为通过重新路由a和h之间的边，我们可以看到它是平面的。",
        "answer_symbols": []
    },
    "10.7 21": {
        "question": "在练习20～22中，判断给定的图是否同胚于K₃,₃。",
        "answer": "Not homeomorphic to K3,3",
        "answer_symbols": []
    },
    "10.7 22": {
        "question": "在练习20～22中，判断给定的图是否同胚于K₃,₃。",
        "answer": "将每个度为二的顶点及其关联边替换为一条单边。然后结果是K3,3：部分是{a, e, i}和{c, g, k}。因此此图与K3,3同胚。",
        "answer_symbols": []
    },
    "10.8 1": {
        "question": "构造所示地图的对偶图。然后求给这个地图着色，使得相邻的两个区域都没有相同的颜色所需要的最少颜色数。",
        "answer": "Four colors\nA\nB\nD C E",
        "answer_symbols": []
    },
    "10.8 2": {
        "question": "构造所示地图的对偶图。然后求给这个地图着色，使得相邻的两个区域都没有相同的颜色所需要的最少颜色数。",
        "answer": "我们像练习 1 那样构造对偶图。与练习 1 一样，给这张地图着色所需的颜色数量与给其对偶图着色所需的颜色数量相同。显然两种颜色是必要且充分的：一种用于顶点（区域）A 和 C，另一种用于 B 和 D。",
        "answer_symbols": []
    },
    "10.8 3": {
        "question": "构造所示地图的对偶图。然后求给这个地图着色，使得相邻的两个区域都没有相同的颜色所需要的最少颜色数。",
        "answer": "Three colors\nA\nF B C\nD\nE",
        "answer_symbols": []
    },
    "10.8 4": {
        "question": "构造所示地图的对偶图。然后求给这个地图着色，使得相邻的两个区域都没有相同的颜色所需要的最少颜色数。",
        "answer": "我们像练习 1 那样构造对偶图。与练习 1 一样，给这张地图着色所需的颜色数量与给其对偶图着色所需的颜色数量相同。显然两种颜色是必要且充分的：一种用于顶点（区域）A、C 和 D，另一种用于 B、E 和 F。",
        "answer_symbols": []
    },
    "10.8 5": {
        "question": "求给定图的着色数。",
        "answer": "3",
        "answer_symbols": []
    },
    "10.8 6": {
        "question": "求给定图的着色数。",
        "answer": "由于存在一个三角形，至少需要 3 种颜色。为了证明 3 种颜色足够，我们可以交替使用红色和蓝色给外部的顶点着色，并将顶点 g 涂成绿色。",
        "answer_symbols": [
            "△"
        ]
    },
    "10.8 7": {
        "question": "求给定图的着色数。",
        "answer": "3",
        "answer_symbols": []
    },
    "10.8 8": {
        "question": "求给定图的着色数。",
        "answer": "由于存在一个三角形，至少需要 3 种颜色。用蓝色给 b 和 c 着色，用红色给 a 和 f 着色，用绿色给 d 和 e 着色，这表明 3 种颜色足够。",
        "answer_symbols": [
            "△"
        ]
    },
    "10.8 9": {
        "question": "求给定图的着色数。",
        "answer": "2",
        "answer_symbols": []
    },
    "10.8 12": {
        "question": "对练习 5 11 中的图，判定是否可能通过删除单个顶点和与所有与它关联的边来减少着色数。",
        "answer": "在练习 5 中，色数为 3，但如果移除顶点 a，则色数将降至 2。在练习 6 中，色数为 3，但如果移除顶点 g，则色数将降至 2。在练习 7 中，色数为 3，但如果移除顶点 b，则色数将降至 2。在练习 8 中，已经证明色数为 3。即使移除一个顶点，至少两个三角形 ace 和 bdf 中的一个必须保留，因为它们没有共享顶点。因此较小的图仍然会有色数 3。在练习 9 中，色数为 2。显然，不可能通过移除一个顶点将其降低到 1，因为至少还有一条边存在。在练习 10 中，已经证明色数为 4，并提供了一种着色方案。如果移除顶点 h 并重新将顶点 e 涂成红色，那么我们可以从该解决方案中消除黄色。因此我们将色数减少到 3。最后，在练习 11 中的图中，无论移除哪个顶点，仍然会有一个三角形，因此我们不能通过移除顶点将其色数降低到 3 以下。",
        "answer_symbols": [
            "△"
        ]
    },
    "10.8 13": {
        "question": "哪些图的着色数为 1?",
        "answer": "Graphs with no edges",
        "answer_symbols": []
    },
    "10.8 14": {
        "question": "为美国地图着色所需要的最少颜色数是什么? 不要考虑只在一个尖角处相触的相邻州。假定密歇根是一个区域。把表示阿拉斯加和夏威夷的顶点当做孤立点。",
        "answer": "由于地图是平面图，我们知道四种颜色足够。通过观察肯塔基州可以发现四种颜色是必要的。肯塔基州被田纳西州、密苏里州、伊利诺伊州、印第安纳州、俄亥俄州、西弗吉尼亚州和弗吉尼亚州包围；此外这些州形成一个 C7，每个州都与下一个相邻。因此至少需要三种颜色来给这七个州着色（见练习 16），然后还需要第四种颜色给肯塔基州。",
        "answer_symbols": [
            "C7"
        ]
    },
    "10.8 15": {
        "question": "W_n 的着色数是什么?",
        "answer": "3 if n is even, 4 if n is odd",
        "answer_symbols": [
            "if"
        ]
    },
    "10.8 16": {
        "question": "证明：具有包含奇数个顶点的回路的简单图不能用两种颜色来着色。",
        "answer": "设回路为 v1, v2, ..., vn, v1，其中 n 是奇数。假设两种颜色（红色和蓝色）足以给包含此回路的图着色。不失一般性，设 v1 的颜色为红色。那么 v2 必须是蓝色，v3 必须是红色，依此类推，直到最终 vn 必须是红色（因为 n 是奇数）。但这与 vn 与 v1 相邻矛盾。因此至少需要三种颜色。",
        "answer_symbols": [
            "v1",
            "v2",
            "vn",
            "...",
            "→"
        ]
    },
    "10.8 17": {
        "question": "假定除了科目 Math 115 与 CS 473, Math 116 与 CS 473, Math 195 与 CS 101, Math 195 与 CS 102, Math 115 与 Math 116, Math 115 与 Math 185, Math 185 与 Math 195 以外，其他任意两种科目，都有学生要参加这两种科目的考试，请使用最少个数的不同时间段来为 Math 115、Math 116、Math 185、Math 195、CS 101、CS 102、CS 273 和 CS 473 安排期末考试日程表。",
        "answer": "Period 1: Math 115, Math 185; period 2: Math 116, CS 473; period 3: Math 195, CS 101; period 4: CS 102; period 5: CS 273",
        "answer_symbols": []
    },
    "10.8 18": {
        "question": "假定当两家电视台相距 150 英里以内时，它们就不能使用相同的频道，那么对相对距离如下表所示的 6 家电视台来说，需要多少个不同的频道?",
        "answer": "我们画出一个图，其中两个顶点（表示位置）相邻当且仅当这些位置之间的距离在150英里以内。显然，三种颜色是必要的也是足够的来着色这个图，比如红色用于顶点4、2和6；蓝色用于3和5；黄色用于1。因此，三种频道是必要的也是足够的。",
        "answer_symbols": []
    },
    "10.8 19": {
        "question": "数学系有 6 个委员会，都是每月开一次会。假定委员会是 C_1 = {阿林豪斯, 布兰德, 沙斯拉夫斯基}, C_2 = {布兰德, 李, 罗森}, C_3 = {阿林豪斯, 罗森, 沙斯拉夫斯基}, C_4 = {李, 罗森, 沙斯拉夫斯基}, C_5 = {阿林豪斯, 布兰德} 和 C_6 = {布兰德, 罗森, 沙斯拉夫斯基}，那么怎样安排才能确保没有人同时参加两个会议。",
        "answer": "5",
        "answer_symbols": []
    },
    "10.8 20": {
        "question": "动物园想建立自然居住地，在里面展出动物。然而，有些动物一有机会就会吃掉另一些动物。如何用图模型和着色来确定所需要的不同居住地的数目，以及在这些居住地里的动物安排?",
        "answer": "我们让图的顶点代表动物，并且在两个顶点之间画一条边，如果它们所代表的动物由于饮食习惯不能处于同一栖息地。对这个图进行着色就相当于给栖息地分配颜色（颜色即为栖息地）。",
        "answer_symbols": []
    },
    "10.8 21": {
        "question": "求练习 5 11 中每个图的边着色数。",
        "answer": "Exercise 5: 3 Exercise 6: 6 Exercise 7: 3 Exercise 8: 4 Exercise 9: 3 Exercise 10: 6 Exercise 11: 4",
        "answer_symbols": []
    },
    "10.8 22": {
        "question": "设电路板上有 n 个器件，这些器件通过有色电线相连。要求连接同一器件的电线颜色不同，用表示电路板的图的边着色数来描述所需要的不同颜色的电线数。解释你的答案。",
        "answer": "我们用一个图来建模电路板：n个顶点对应n个设备，每对通过电线连接的设备之间有一条边。然后，对边进行着色就相当于对电线进行着色，给定的关于电线颜色的要求正好是对边着色的要求。因此，所需的颜色数量就是图的边色数。",
        "answer_symbols": [
            "n"
        ]
    },
    "10.8 24": {
        "question": "证明：一个图的边着色数至少与该图的顶点的最大度一样。",
        "answer": "如果有一个度为d的顶点，则有d条边与该公共顶点相连。因此，在任何边着色中，这些边都必须有不同的颜色，所以我们至少需要d种颜色。",
        "answer_symbols": [
            "d"
        ]
    },
    "10.8 25": {
        "question": "证明：若 G 是含有 n 个顶点的图，在对 G 的边着色中，不超过 n/2 的边可以着相同的颜色。",
        "answer": "Two edges that have the same color share no endpoints. Therefore, if more than n/2 edges were colored the same color, there would be at least one pair of edges sharing an endpoint, which contradicts the assumption.",
        "answer_symbols": [
            "/"
        ]
    },
    "10.8 26": {
        "question": "当 n 是正整数时，求 Kₙ 的边着色数。",
        "answer": "这实际上是一个安排循环赛的问题。设K_n的顶点为v1, v2, ..., v_n。这些是比赛中的选手。我们用颜色i的边连接两个顶点，如果这两个选手在第i轮比赛中相遇。首先假设n是偶数。将v_n放在圆心，其余顶点均匀分布在圆周上，如n=8所示。第一轮比赛使用边v_n v1, v2 v_(n-1), v3 v_(n-2), ..., v_(n/2) v_((n/2)+1)；这些边在图中显示，得到颜色1。对于第二轮，将此图顺时针旋转360/(n-1)度。因此，在第2轮中，配对是v_n v2, v1 v3, v4 v_(n-1), v5 v_(n-2), ...，依此类推。总共进行n-1轮。不难看出，K_n的每条边恰好出现在这些配对之一中。（事实上，除了径向边之外的边连接的是索引差为1, 2, ..., (n-2)/2模n-1的顶点。）因此，当n为偶数时，K_n的边色数为n-1。（我们无法做得更好，因为每种颜色最多可以有n/2条边，而总共需要(n-1)n/2条边。）对于奇数n（除了平凡情况n=1），每种颜色最多可以有(n-1)/2条边，因此我们需要至少n种颜色。我们可以通过创建一个虚构的第(n+1)个选手并使用n为偶数的方法来实现这一点。（与选手n+1比赛意味着在那一轮比赛中轮空。）因此，当n为奇数时，K_n的边色数为n。",
        "answer_symbols": [
            "n",
            "v",
            "i",
            "1",
            "2",
            "...",
            "/",
            "-",
            "+",
            "(",
            ")",
            "360",
            "°"
        ]
    },
    "10.8 27": {
        "question": "7 个变量出现在计算机程序的循环中。这些变量以及必须保存它们的计算步骤是：t：步骤 1～6；u：步骤 2；v：步骤 2～4；w：步骤 1，3 和 5；x：步骤 1 和 6；y：步骤 3～6；以及 z：步骤 4 和 5。在执行期间需要多少个不同的变量寄存器来保存这些变量？",
        "answer": "5",
        "answer_symbols": []
    },
    "10.8 28": {
        "question": "关于一个以 K₄ 作为子图的图的着色数能有些什么结论？",
        "answer": "由于子图中的每个顶点都必须有不同的颜色，所以色数至少为n。",
        "answer_symbols": [
            "n"
        ]
    },
    "10.8 29": {
        "question": "用这个算法构造下图的着色。",
        "answer": "颜色 1: e, f, d; 颜色 2: c, a, i, g; 颜色 3: h, b, j",
        "answer_symbols": []
    },
    "10.8 30": {
        "question": "用伪代码描述这个着色算法。",
        "answer": "我们的伪代码如下。注释应解释它是如何实现算法的。\nprocedure coloring(G: 简单图)\n{\n 假设顶点被标记为 1, 2, ..., n 使得\n deg(1) ≥ deg(2) ≥ ... ≥ deg(n)\n}\nfor i := 1 to n\nc(i) := 0 {最初没有顶点被着色} \ncount := 0 {还没有顶点被着色} \ncolor := 1 {尝试第一种颜色} \nwhile count < n {还有顶点需要着色} \n for i := 1 to n {尝试用颜色 color 给顶点 i 着色} \n if c(i) = 0 {顶点 i 尚未着色} \n then c(i) := color {假设我们可以这样做，直到发现不行} \n for j := 1 to n \n if {i, j} 是一条边且 c(j) = color 则 c(i) := 0 {我们发现不行} \n if c(i) = color 则 count := count + 1 {新的着色 i 成功了} \n color := color + 1 {我们必须继续使用下一种颜色} \n{着色完成}",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            ":",
            "=",
            "<",
            "+",
            "≥",
            "→"
        ]
    },
    "10.8 31": {
        "question": "证明：这个算法所产生的着色数可能比着色一个图所需的着色数更多。",
        "answer": "颜色 C6",
        "answer_symbols": []
    },
    "10.8 32": {
        "question": "证明：只要 n 是正的奇数且 n ≥ 3 ，那么 Cₙ 就是着色 3 关键的。",
        "answer": "我们知道奇数圈的色数是 3（见示例 4）。如果我们移除一条边，那么我们得到一个路径，显然可以用两种颜色着色。这表明该圈是色数 3-临界的。",
        "answer_symbols": [
            "=",
            "-"
        ]
    },
    "10.8 33": {
        "question": "证明：只要 n 是正的奇数且 n ≥ 3 ，那么 Wₙ 就是着色 4 关键的。",
        "answer": "当 n 是大于 1 的奇数时，需要四种颜色来为 Wn 着色，因为轮子的边缘需要三种颜色（见示例 4），而中心顶点与所有边缘顶点相邻，因此需要第四种颜色。要看到从 Wn 中删除一条边后所得的图可以用三种颜色着色，请考虑两种情况。如果我们移除一个边缘，则可以使用两种颜色给剩余部分的边缘着色，方法是从已移除边的一个端点开始，交替使用这两种颜色。然后将第三种颜色分配给中心顶点。如果我们移除一个辐条边缘，则可以通过将颜色 #1 分配给已移除边的边缘端点，并将颜色 #2 和 #3 交替分配给轮子上剩余的顶点，再将颜色 #1 分配给中心。",
        "answer_symbols": []
    },
    "10.8 34": {
        "question": "证明：W₄ 不是着色 3 关键的。",
        "answer": "虽然 W₄ 的色数是 3，但如果我们移除一条边，则图中仍然包含一个三角形，因此其色数仍然是 3。因此 W₄ 不是色数 3-临界的。",
        "answer_symbols": [
            "=",
            "-",
            "△"
        ]
    },
    "10.8 35": {
        "question": "证明：如果图 G 为着色 k 关键的，那么 G 中的各个顶点的度至少是 k-1 。",
        "answer": "假设 G 是色数为 k 的临界图，但有一个度数小于等于 k - 2 的顶点 v。从 G 中移除与 v 相邻的一条边。根据“k-临界”的定义，得到的图可以用 k - 1 种颜色着色。现在恢复缺失的边并使用这种着色方式对所有顶点进行着色，除了 v。因为我们对较小的图进行了正确的着色，所以没有两个相邻的顶点具有相同的颜色。此外，v 最多有 k - 2 个邻居，所以我们可以用未使用的颜色对 v 进行着色，以获得 G 的正确 (k - 1)-着色。这与 G 的色数为 k 的事实相矛盾。因此，我们的假设是错误的，G 的每个顶点的度数必须至少为 k - 1。",
        "answer_symbols": [
            "-",
            "=",
            "<=",
            "(",
            ")",
            "+"
        ]
    },
    "10.8 36 a)": {
        "question": "求 χ₂(K₄)。",
        "answer": "对于这个完全图的情况，我们有 k = 2 和 n = 3，所以 2 × 3 = 6 种颜色是必要和充分的。",
        "answer_symbols": []
    },
    "10.8 36 b)": {
        "question": "求 χ₂(K₅)。",
        "answer": " 如同 (a) 部分，答案是 kn，在这里是 2 × 4 = 8。",
        "answer_symbols": []
    },
    "10.8 36 c)": {
        "question": "求 χ₂(W₄)。",
        "answer": "称轮子中间的顶点为 m，称轮缘上的顶点依次为 a, b, c, 和 d。由于 m, a, 和 b 形成一个三角形，我们需要至少 6 种颜色。将颜色 1 和 2 分配给 m，颜色 3 和 4 分配给 a，颜色 5 和 6 分配给 b。然后我们还可以将 3 和 4 分配给 c，将 5 和 6 分配给 d，完成了一个 2-元着色，共用了 6 种颜色。因此 χ₂(W₄) = 6。",
        "answer_symbols": []
    },
    "10.8 36 d)": {
        "question": "求 χ₂(C₅)。",
        "answer": "首先我们证明 4 种颜色是不够的。如果我们只有颜色 1 到 4，那么当我们沿着圈走时，我们必须分配，比如说，1 和 2 给第一个顶点，3 和 4 给第二个顶点，1 和 2 给第三个顶点，3 和 4 给第四个顶点。这给我们最后一个顶点没有颜色可用。为了证明 5 种颜色是足够的，我们只需给出着色：沿圈顺序的颜色是 {1, 2}, {3, 4}, {1, 5}, {2, 4}, 和 {3, 5}。因此 χ₂(C₅) = 5。",
        "answer_symbols": []
    },
    "10.8 36 e)": {
        "question": "求 χ₂(K₃,₄)。",
        "answer": "根据我们对二分图的一般结果，答案是 2k = 2 × 2 = 4。",
        "answer_symbols": []
    },
    "10.8 36 f)": {
        "question": "求 χ₂(K₅)。",
        "answer": "根据我们对完全图的一般结果，答案是 kn = 3 × 5 = 15。",
        "answer_symbols": []
    },
    "10.8 36 g)": {
        "question": "求 χ₃(C₅)。",
        "answer": "我们声称答案是 8。为了证明八种颜色足够，我们可以按以下顺序沿圈着色顶点：{1, 2, 3}, {4, 5, 6}, {1, 2, 7}, {3, 6, 8}, 和 {4, 5, 7}。证明七种颜色不够更难。假设存在七种颜色的着色。不失一般性，将第一个顶点着色为 {1, 2, 3}，将第二个顶点着色为 {4, 5, 6}。如果第三个顶点着色为 {1, 2, 3}，则第四个和第五个顶点需要使用与 1, 2, 和 3 不同的六种颜色，总共需要九种颜色。因此Without loss of generality, assume that the third vertex is colored {1, 2, 7}. But now the other two vertices cannot have colors 1 or 2, and they must have six different colors, so eight colors would be required in all.**\n- This is a contradiction, so there is in fact no coloring with just seven colors.",
        "answer_symbols": []
    },
    "10.8 36 h)": {
        "question": "求 χ₃(K₄,₅)。",
        "answer": "By our general result on bipartite graphs, the answer is 2k = 2 * 3 = 6.",
        "answer_symbols": []
    },
    "10.8 38": {
        "question": "若 G 是二分图且 k 是正整数，则 χₖ(G) 是什么？",
        "answer": "As we observed in the solution to Exercise 36, the answer is 2k if G has at least one edge (and it is clearly k if G has no edges, since every vertex can get the same colors).**\n",
        "answer_symbols": []
    },
    "10.8 39": {
        "question": "移动广播（或蜂窝）电话的频率是按地段分配的。每个地段分配一组该地段中的设备所使用的频率。在产生干扰问题的地段中不能使用相同的频率。解释如何用 k 重着色来对一个区域里的每个移动广播地段分配 k 种频率。",
        "answer": "用颜色表示频率，用顶点表示区域。如果这些顶点代表的区域相互干扰，则连接两个顶点。那么 k-元着色正是避免干扰的频率分配。",
        "answer_symbols": []
    },
    "10.8 40": {
        "question": "证明：每个平面图 G 都可以用不超过 6 种颜色来着色。",
        "answer": "We use induction on the number of vertices of the graph.**\n- Every graph with six or fewer vertices can be colored with six or fewer colors, since each vertex can get a different color. That takes care of the basis case(s).\n- So we assume that all graphs with k vertices can be 6-colored and consider a graph G with k + 1 vertices.\n- By Corollary 2 in Section 10.7, G has a vertex v with degree at most 5. Remove v to form the graph G'.\n- Since G' has only k vertices, we 6-color it by the inductive hypothesis.\n- Now we can 6-color G by assigning to v a color not used by any of its five or fewer neighbors.\n- This completes the inductive step, and the theorem is proved.",
        "answer_symbols": []
    },
    "10.8 41": {
        "question": "证明：每个平面图 G 都可以用不超过 5 种颜色来着色。",
        "answer": "我们对图的顶点数进行归纳。每个有五个或更少顶点的图都可以用五种或更少的颜色着色，因为每个顶点都可以有不同的颜色。这处理了基础情况。所以我们假设所有有 k 个顶点的图都可以 5-着色，并考虑一个有 k + 1 个顶点的图 G。根据第 10.7 节的推论 2，G 有一个度数最多为 5 的顶点 v。移除 v 形成图 G'。由于 G' 只有 k 个顶点，我们可以通过归纳假设对其进行 5-着色。如果 v 的邻居没有使用所有的五种颜色，那么我们可以通过给 v 分配一个未被其任何邻居使用的颜色来对 G 进行 5-着色。困难出现在 v 有五个邻居，并且在 G' 的 5-着色中每个邻居都有不同的颜色。假设 v 的邻居按顺时针顺序排列为 a, b, c, m, 和 p。（这个顺序由表示与 v 相邻的边的曲线的顺时针顺序决定。）假设邻居的颜色分别为天蓝色、蓝色、黄绿色、洋红色和紫色。考虑天蓝-黄绿子图（即 G 中颜色为天蓝色或黄绿色的顶点以及它们之间的所有边）。如果 a 和 c 不在同一连通分支中，那么在包含 a 的连通分支中我们可以交换这两种颜色（使天蓝色顶点变为黄绿色，反之亦然），并且 G' 仍然正确着色。这样 a 就变成了黄绿色，我们现在可以给 v 着天蓝色，G 已经正确着色。如果 a 和 c 在同一连通分支中，那么存在一条交替着色为天蓝色和黄绿色的路径连接 a 和 c。这条路径加上边 av 和 vc 将平面分为两个区域，b 在其中一个区域内，m 在另一个区域内。如果我们现在在与 b 同一区域的所有顶点上交换蓝色和洋红色，我们仍然会有一个 G' 的正确着色，但现在蓝色可用于 v。在这种情况下，我们也找到了 G 的正确着色。这完成了归纳步骤，定理得证。",
        "answer_symbols": [
            "+",
            "=",
            "<="
        ]
    },
    "10.8 42": {
        "question": "通过证明所有的三角形和四边形都能够用一个点来看守，证明：g(3)=1 和 g(4)=1。",
        "answer": "Clearly any convex polygon can be guarded by one guard, because every vertex sees all points on or inside the polygon.**\n- This takes care of triangles and convex quadrilaterals (n = 3 and some of n = 4).\n- It is also clear that for a nonconvex quadrilateral, a guard placed at the vertex with the reflex angle can see all points on or inside the polygon.\n- This completes the proof that g(3) = g(4) = 1.",
        "answer_symbols": []
    },
    "10.8 43": {
        "question": "证明：g(5)=1，即所有的五边形都能够被一个点看守。",
        "answer": "我们遵循提示。由于五边形内角总和为 540°，因此不能有多达三个内角的测量值超过 180°（反向角）。如果没有反向角，那么五边形是凸的，放置在任何顶点的警卫可以看到所有点。如果有一个反向角，那么五边形基本上看起来像下面的图 (a)，并且在顶点 v 放置的警卫可以看到所有点。如果有两个反向角，那么它们可以相邻或不相邻（图 (b) 和 (c)）；无论哪种情况，在顶点 v 放置的警卫都可以看到所有点。[在图 (c) 中，选择靠近底部边的反向顶点。] 因此对于所有五边形，一个警卫就足够了，所以 g(5) = 1。",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "+",
            "<=",
            "°"
        ]
    },
    "10.8 44": {
        "question": "首先运用练习 42 和 43 的结果，以及 5.2 节的引理 1 证明 g(6)≤2，然后找出一个需要两名保安的六边形。最后证明 g(6)=2。",
        "answer": "By Lemma 1 in Section 5.2 every hexagon has an interior diagonal, which will divide the hexagon into two polygons, each with fewer than six sides (either two quadrilaterals or one triangle and one pentagon).**\n- By Exercises 42 and 43, one guard suffices for each, so g(6) ≤ 2.\n- By Exercise 45, we also know that g(6) ≥ 2.\n- Therefore g(6) = 2.",
        "answer_symbols": []
    },
    "10.8 45": {
        "question": "证明：g(n)≥[n/3]。",
        "answer": "提示中建议的图（推广到有 k 个尖刺的任意 k ≥ 1）有 3k 个顶点。从不同尖刺的尖端可见的位置集合是不相交的。因此，每个 k 个尖刺都需要一个单独的警卫，所以至少需要 k 个警卫。这表明 g(3k) ≥ k = ⌊3k/3⌋。如果 n = 3k + i，其中 0 ≤ i ≤ 2，则 g(n) ≥ g(3k) ≥ k = ⌊n/3⌋。",
        "answer_symbols": [
            "=",
            "≥",
            "≤",
            "⌊",
            "⌋",
            "(",
            ")",
            "+",
            "/"
        ]
    },
    "10.8 46": {
        "question": "通过证明艺术馆定理，解决艺术馆问题。该定理说一个 n 个顶点的简单多边形最多需要 [n/3] 个保安来守卫它的边界和内部。",
        "answer": "By Theorem 1 in Section 5.2, we can triangulate the polygon.**\n- We claim that it is possible to color the vertices of the triangulated polygon using three colors so that no two adjacent vertices have the same color.\n- We prove this by induction.\n  - The basis step (n = 3) is trivial.\n  - Assume the inductive hypothesis that every triangulated polygon with k vertices can be 3-colored, and consider a triangulated polygon with k + 1 vertices.\n  - By Exercise 23 in Section 5.2, one of the triangles in the triangulation has two sides that were sides of the original polygon.\n  - If we remove those two sides and their common vertex, the result is a triangulated polygon with k vertices.\n  - By the inductive hypothesis, we can 3-color its vertices.\n  - Now put the removed edges and vertex back. The vertex is adjacent to only two other vertices, so we can extend the coloring to it by assigning it the color not used by those vertices.\n  - This completes the proof of our claim.\n- Now some color must be used no more than n/3 times; if not, then every color would be used more than n/3 times, and that would account for more than 3 * n/3 = n vertices. (This argument is in the spirit of the pigeonhole principle.)\n- Say that red is the color used least in our coloring. Then there are at most n/3 vertices colored red, and since this is an integer, there are at most floor(n/3) vertices colored red.\n- Put guards at all these vertices. Since each triangle must have its vertices colored with three different colors, there is a guard who can see all points on or in the interior of each triangle in the triangulation.\n- But this is all the points on or in the interior of the polygon, and our proof is complete.\n- Combining this with Exercise 45, we have proved that g(n) = floor(n/3).",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 7": {
        "question": "完全 m 部图 K_{n_1, n_2, …, n_m} 有多少个顶点和多少条边？",
        "answer": "∑m i=1 n_i 个顶点，∑t<j n_i n_j 条边",
        "answer_symbols": [
            "∑",
            "i",
            "=",
            "t",
            "<",
            "j",
            "n",
            "_",
            "i",
            "n",
            "_",
            "j"
        ]
    },
    "10 Supplementary Exercises 11": {
        "question": "求集合 S1={a，c，m，e}，S2={m，a，c，e}，S3={a，p，e，x}，S4={x，e，n，a}，S5={n，a，m，e}和 S6={e，x，a，m}的 SDR。",
        "answer": "(c, a, p, x, n, m) 和其他许多",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 12": {
        "question": "使用霍尔婚姻定理证明：集合 S 的有穷子集 S1，S2，…，Sn 有 SDR(a1，a2，…，an)当且仅当对于 {1，2，…，n}的所有子集 I 有 |∪i∈I Si|≥|I|。",
        "answer": "为SDR问题建立二部图模型。V1中的顶点是S1, S2, ..., Sn，V2中的顶点是S的元素。Si与Si的每个元素之间有一条边。一个SDR就是从V1到V2的完全匹配。条件|∪i∈I Si| ≥ |I|正是Hall婚姻定理中的条件。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 14": {
        "question": "使用练习 12 证明：S1={a，b，c}，S2={a，c}，S3={c，d，e}，S4={b，c}，S5={d，e，f}，S6={a，c，e}和 S7={a，b}构成的集合族没有 SDR。",
        "answer": "设I={1, 2, 4, 7}。则|∪i∈I Si| = |{a, b, c}| = 3，但|I| = 4，违反了练习12中给出的必要（且充分）条件。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 15": {
        "question": "设 u、v 和 w 是一个简单图的 3 个顶点，当这些顶点构成的所有 3 对顶点之间都有边相连时，这 3 个顶点构成一个三角形。求用图中三角形个数以及图中长度为 2 的通路的条数表示的 C(G)的公式。",
        "answer": "6 次",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 17 a)": {
        "question": "解释下列各图中簇系数表示什么？（a）好莱坞图",
        "answer": "两名演员各自与随机选择的一名演员共同出演过电影的概率，这两名演员也共同出演过一部电影。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 17 b)": {
        "question": "解释下列各图中簇系数表示什么？（b）“人脸”中的朋友图",
        "answer": "随机选择的一名人员的两名Facebook好友互为好友的概率。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 17 c)": {
        "question": "解释下列各图中簇系数表示什么？（c）图论中的学术合作图",
        "answer": "随机选择的一名人员的两名合作者也是合作者的概率。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 17 d)": {
        "question": "解释下列各图中簇系数表示什么？（d）人类细胞中的蛋白质作用图",
        "answer": "两种蛋白质各自与随机选择的一种蛋白质相互作用，这两种蛋白质之间也相互作用的概率。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 17 e)": {
        "question": "解释下列各图中簇系数表示什么？（e）表示构成万维网的路由器和通信链路的图",
        "answer": "两个路由器各自与随机选择的一个路由器有通信链接，这两个路由器之间也有链接的概率。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 18 a)": {
        "question": "对练习 17 中的每一个图，解释是否可以期望其簇系数接近 0.01 或 0.10，并解释为什么。（a）好莱坞图",
        "answer": "人们期望这个值相当大，因为所有在一部电影中共同出现的演员形成了非常大的完全子图。最早的一项研究（Duncan J. Watts 和 Steven H. Strogatz，“‘小世界’网络的集体动态”，Nature 393(1998) 440–442），使用了略有不同的聚类系数定义，发现的值为 0.79。另一项研究（M. E. J. Newman，“复杂网络的结构和功能”，SIAM Review 45(2003) 167–256）发现好莱坞图的聚类系数为 0.20。",
        "answer_symbols": [
            "0.79",
            "0.20"
        ]
    },
    "10 Supplementary Exercises 18 b)": {
        "question": "对练习 17 中的每一个图，解释是否可以期望其簇系数接近 0.01 或 0.10，并解释为什么。（b）“人脸”中的朋友图",
        "answer": "合理地期望两个与同一个人是 Facebook 好友的人也是 Facebook 好友的可能性相当大。也就是说，合理地期望这种可能性不接近于零。事实上，一项研究发现这一概率约为 0.16——大约每六对你的 Facebook 好友中有 1 对也是 Facebook 好友。",
        "answer_symbols": [
            "0.16"
        ]
    },
    "10 Supplementary Exercises 18 c)": {
        "question": "对练习 17 中的每一个图，解释是否可以期望其簇系数接近 0.01 或 0.10，并解释为什么。（c）图论中的学术合作图",
        "answer": "两个与同一个人合著过论文的人自己也合著过论文的概率不应该接近于零。与同一个人合著过论文的两个人可能甚至在同一篇论文中与这个人合作过。如果不是这样，他们可能研究相同的问题并且相互认识（可能在同一个机构工作），因为他们有一个共同的合作者，并且同时进行活跃的研究，这使得他们成为合作者的可能性比其他情况下更大。根据 Erdős 数项目网站 (www.oakland.edu/enp)，对于整个数学合作图，这个值为 0.14。如果仅限于图论研究人员，这个值可能会增加。",
        "answer_symbols": [
            "0.14"
        ]
    },
    "10 Supplementary Exercises 18 d)": {
        "question": "对练习 17 中的每一个图，解释是否可以期望其簇系数接近 0.01 或 0.10，并解释为什么。（d）人类细胞中的蛋白质作用图",
        "answer": "需要一些生物学方面的专门知识才能对这个图有了解。研究表明，人类细胞的蛋白质相互作用图具有大量的节点，每个节点代表不同的蛋白质，两个都与第三个蛋白质相互作用的蛋白质相互作用的可能性很小。然而，表示细胞特定功能模块的子图的聚类系数通常较大。网上的某篇论文显示，根据使用的数据不同，值范围从 0.01 到 0.43 不等。",
        "answer_symbols": [
            "0.01",
            "0.43"
        ]
    },
    "10 Supplementary Exercises 18 e)": {
        "question": "对练习 17 中的每一个图，解释是否可以期望其簇系数接近 0.01 或 0.10，并解释为什么。（e）表示构成万维网的路由器和通信链路的图",
        "answer": "可能会期望这个值较低，因为连接到同一公共第三路由器的路由器不需要相互连接以实现高效通信。根据 M. E. J. Newman，《网络：导论》（Oxford University Press, 2010），互联网（在自治系统级别）的聚类系数约为 0.01。在这本书中，作者提到技术网络和生物网络的聚类系数通常较小，而社交网络的聚类系数通常较大。特别是后者约为 0.1 或更大，而前者约为 0.01 或更小。",
        "answer_symbols": [
            "0.01",
            "0.1"
        ]
    },
    "10 Supplementary Exercises 19": {
        "question": "叙述关于图的平面性的库拉图斯基定理，并且解释它如何刻画了哪些图是平面图。",
        "answer": "包含以下顶点集的完全子图：{b, c, e, f}，{a, b, g}，{a, d, g}，{d, e, g}，{b, e, g}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "10 Supplementary Exercises 20": {
        "question": "求所给图的所有团。\na---b---c\n| | |\nd---e---f\n| | |\ng---h---i",
        "answer": "仔细观察图后，我们确信没有 K6。有一个 K5，即团 ceghi。有两个不在这个 K5 中的 K4，因此它们是团：abce 和 cdeg。所有不在前面列出的团中的 K3 也是团。我们只找到 aef 和 efg。所有边至少属于前面列出的一个团（没有孤立的顶点），因此完成。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 21": {
        "question": "叙述四色定理。有没有不能用 4 种颜色来着色的图？",
        "answer": "包含以下顶点集的完全子图：{b, c, d, j, k}，{a, b, j, k}，{e, f, g, i}，{a, b, i}，{a, i, j}，{b, d, e}，{b, e, i}，{b, i, j}，{g, h, i}，{h, i, j}",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "10 Supplementary Exercises 22": {
        "question": "解释在建模里如何使用图的着色。至少举两个不同的例子。",
        "answer": "由于 e 与所有其他顶点相邻，唯一的最小支配集为 {e}。",
        "answer_symbols": [
            "{",
            "}"
        ]
    },
    "10 Supplementary Exercises 23": {
        "question": "求所给的图的最小支配集。\na---b\n| |\nc---d\n| |\ne---f",
        "answer": "{c, d} 是最小支配集。",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "10 Supplementary Exercises 24": {
        "question": "求所给的图的最小支配集。\na---b---c---d\n| | | |\ne---f---g---h\n| | | |\ni---j---k---l",
        "answer": "很容易验证集合 {c, e, j, l} 是支配集。我们必须证明没有三个顶点的集合是支配集。假设存在这样的集合。首先假设顶点 f 被包括在内。那么至少还需要两个顶点来覆盖顶点 a 和 i，除非选择顶点 e。如果顶点 e 没有被选择，因此支配集必须有超过三个顶点，因为没有一对顶点可以同时覆盖 a 和 i 并且还覆盖 d，例如。另一方面，如果选择了 e，那么由于没有一个单一的顶点可以同时覆盖 c 和 l，再次需要至少四个顶点。因此我们可以假设 f（以及对称性 g）不在只有三个元素的支配集中。这意味着我们需要从10个顶点的环 a, b, c, d, h, l, k, j, i, e, a 中找到三个顶点来覆盖所有这十个顶点。这是不可能的，因为每个顶点只能覆盖三个顶点，而 3 * 3 < 10。因此我们得出结论，没有只有三个顶点的支配集。",
        "answer_symbols": [
            "{",
            "}",
            "<",
            "*",
            ","
        ]
    },
    "10 Supplementary Exercises 25 a)": {
        "question": "构造表示 3 × 3 棋盘的简单图，用边表示皇后对格子的控制。",
        "answer": "",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 25 b)": {
        "question": "构造表示 4 × 4 棋盘的简单图，用边表示皇后对格子的控制。",
        "answer": "",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 26": {
        "question": "解释一下最小支配集的概念如何应用到确定控制 n × n 棋盘的最少皇后数的问题。",
        "answer": "如果 G 是表示 n × n 棋盘的图，那么 G 的最小支配集正好对应于放置最少数量的皇后以控制棋盘的方格集合。",
        "answer_symbols": [
            "×"
        ]
    },
    "10 Supplementary Exercises 27 a)": {
        "question": "求控制 3 × 3 棋盘的最少皇后数。",
        "answer": "1",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 27 b)": {
        "question": "求控制 4 × 4 棋盘的最少皇后数。",
        "answer": "2",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 27 c)": {
        "question": "求控制 5 × 5 棋盘的最少皇后数。",
        "answer": "3",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 28": {
        "question": "假定 G₁ 和 H₁ 是同构的，而且 G₂ 和 H₂ 是同构的。证明或反证：G₁ ∪ G₂ 和 H₁ ∪ H₂ 是同构的。",
        "answer": "这种同构不一定成立。最简单的反例是让 G1、G2 和 H1 都是仅由单个顶点 v 组成的图，而 H2 是仅由单个顶点 w 组成的图。当然，G1 和 H1 同构，G2 和 H2 也同构。但是 G1 ∪ G2 是一个有一个顶点的图，而 H1 ∪ H2 是一个有两个顶点的图。",
        "answer_symbols": [
            "∪"
        ]
    },
    "10 Supplementary Exercises 29 a)": {
        "question": "证明：下列性质是同构的简单图都有或都没有的不变量。连通性。",
        "answer": "图 G 中从 u 到 v 的路径在同构图 H 中诱导出一条从 f(u) 到 f(v) 的路径。",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "10 Supplementary Exercises 29 b)": {
        "question": "证明：下列性质是同构的简单图都有或都没有的不变量。哈密顿回路的存在性。",
        "answer": "假设 f 是从 G 到 H 的同构。如果 v0, v1, ..., vn, v0 是 G 中的哈密顿回路，则 f(v0), f(v1), ..., f(vn), f(v0) 必须是 H 中的哈密顿回路，因为它仍然是一个回路，并且对于 0 ≤ i < j ≤ n，f(vi) ≠ f(vj)。",
        "answer_symbols": [
            "(",
            ")",
            ",",
            "<",
            "≤",
            "≠"
        ]
    },
    "10 Supplementary Exercises 29 c)": {
        "question": "证明：下列性质是同构的简单图都有或都没有的不变量。欧拉回路的存在性。",
        "answer": "假设 f 是从 G 到 H 的同构。如果 v0, v1, ..., vn, v0 是 G 中的欧拉回路，则 f(v0), f(v1), ..., f(vn), f(v0) 必须是 H 中的欧拉回路，因为它是一个包含每条边恰好一次的回路。",
        "answer_symbols": [
            "(",
            ")",
            ",",
            "≠"
        ]
    },
    "10 Supplementary Exercises 29 d)": {
        "question": "证明：下列性质是同构的简单图都有或都没有的不变量。有交叉数 C。",
        "answer": "两个同构图必须具有相同的交叉数，因为它们可以在平面上以相同的方式绘制。",
        "answer_symbols": [
            "=",
            "≠"
        ]
    },
    "10 Supplementary Exercises 29 e)": {
        "question": "证明：下列性质是同构的简单图都有或都没有的不变量。有 n 个孤立顶点。",
        "answer": "假设 f 是从 G 到 H 的同构。那么 v 在 G 中是孤立的当且仅当 f(v) 在 H 中是孤立的。因此，这些图必须具有相同数量的孤立顶点。",
        "answer_symbols": [
            "(",
            ")",
            ",",
            "≠"
        ]
    },
    "10 Supplementary Exercises 29 f)": {
        "question": "证明：下列性质是同构的简单图都有或都没有的不变量。是二分图。",
        "answer": "假设 f 是从 G 到 H 的同构。如果 G 是二部图，则 G 的顶点集可以划分为 V1 和 V2，使得没有边连接 V1 内的顶点或 V2 内的顶点。那么 H 的顶点集可以划分为 f(V1) 和 f(V2)，使得没有边连接 f(V1) 内的顶点或 f(V2) 内的顶点。",
        "answer_symbols": [
            "(",
            ")",
            ",",
            "≠"
        ]
    },
    "10 Supplementary Exercises 30": {
        "question": "如何从 G 的邻接矩阵求 G̅ 的邻接矩阵？其中 G 是简单图。",
        "answer": "由于邻接矩阵中的 1 表示存在边，0 表示不存在边，为了获得 G 的邻接矩阵，我们将 G 的邻接矩阵中的每个 1 改为 0，并将主对角线以外的每个 0 改为 1（我们不希望引入自环）。",
        "answer_symbols": [
            "1",
            "0"
        ]
    },
    "10 Supplementary Exercises 31": {
        "question": "有多少种非同构的带有 4 个顶点的连通简单二分图？",
        "answer": "3",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 32 a)": {
        "question": "有多少种非同构的带有 5 个顶点简单连通图，并且没有任何顶点的度超过 2？",
        "answer": "如果没有度数大于 2，则该图必须由 5-圈或没有重复顶点的路径组成。因此只有两种图。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 32 b)": {
        "question": "有多少种非同构的带有 5 个顶点简单连通图，并且着色数等于 4？",
        "answer": "当然，除了 K5 之外，任何包含 K4 作为子图的图都将具有色数 4。这样的图有 3 个，因为不在“K4”中的顶点可以与另外四个顶点中的一个、两个或三个相邻。",
        "answer_symbols": [
            "K5",
            "K4"
        ]
    },
    "10 Supplementary Exercises 32 c)": {
        "question": "有多少种非同构的带有 5 个顶点简单连通图，并且是非平面图？",
        "answer": "由于 K5 的每个真子图都是平面图，因此只有一个这样的图，即 K5。",
        "answer_symbols": [
            "K5"
        ]
    },
    "10 Supplementary Exercises 33 a)": {
        "question": "确定下列图是否为自逆的。a -- b / / \\ c -- d -- e",
        "answer": "是",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 33 b)": {
        "question": "确定下列图是否为自逆的。a -- b / / \\ c -- d -- e",
        "answer": "否",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 34": {
        "question": "证明：若有向图 G 是自逆的而且 H 是同构于 G 的有向图，则 H 也是自逆的。",
        "answer": "这是从“同构于”关系的传递性和第 10.3 节的练习 65 推导出来的。如果 G 是自补的，那么 G 同构于 Gc。由于 H 同构于 G，Hc 也同构于 Gc。将这些同构串起来，我们看到 H 同构于 Hc，如所需。",
        "answer_symbols": [
            "G",
            "Gc",
            "H",
            "Hc",
            "→"
        ]
    },
    "10 Supplementary Exercises 35": {
        "question": "确定下列图是否是可定向的。a -- b -- c / / / \\ e -- d -- f",
        "answer": "否",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 36": {
        "question": "确定下列图是否是可定向的。a -- b -- c / / / \\ e -- d -- f",
        "answer": "由于存在割边 {c, d}，这个图不可定向，正如练习 35 所示。",
        "answer_symbols": [
            "{",
            "}",
            "c",
            "d"
        ]
    },
    "10 Supplementary Exercises 37": {
        "question": "确定下列图是否是可定向的。a -- b -- c / / / \\ e -- d -- f",
        "answer": "是",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 38": {
        "question": "因为在城市中心区交通流量正在增长，所以交通工程师正在计划把目前所有双行街道都变成单行街道。解释如何为这个问题建模。",
        "answer": "由于我们需要城市强连通，我们需要找到一个无向图的定向，其中边代表街道，顶点代表交叉路口。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 39": {
        "question": "证明：若一个图具有割边，则它不是可定向的。",
        "answer": "如果 e 是一个割边，端点为 u 和 v，那么如果我们从 u 到 v 定向 e，则在有向图中将不存在从 v 到 u 的路径，否则 e 就不会是割边。类似的推理适用于从 v 到 u 定向 e 的情况。",
        "answer_symbols": [
            "(",
            ")",
            ",",
            "≠"
        ]
    },
    "10 Supplementary Exercises 40": {
        "question": "有多少种不同的带 n 个顶点的竞赛图？",
        "answer": "在一个锦标赛中，有 C(n, 2) = n(n - 1)/2 条边。我们必须决定如何定向每一条边，每条边有两种定向方式。因此答案是 2^(n(n-1)/2)。注意，我们还没有回答有多少个非同构的锦标赛——这个问题要难得多。",
        "answer_symbols": [
            "C",
            "(",
            ")",
            "=",
            "/",
            "^",
            "2"
        ]
    },
    "10 Supplementary Exercises 41": {
        "question": "在竞赛图中一个顶点的入度与出度之和是什么？",
        "answer": "n - 1",
        "answer_symbols": [
            "-",
            "≠"
        ]
    },
    "10 Supplementary Exercises 42": {
        "question": "证明：每个竞赛图都有哈密顿通路。",
        "answer": "我们通过归纳法对 n（锦标赛中的顶点数）进行证明。基本情况是 n = 2，唯一的边就是哈密顿路径。现在设 G 是一个有 n + 1 个顶点的锦标赛。删除一个顶点，比如说 v，然后根据归纳假设，在剩下的图中找到一条哈密顿路径 v1, v2, ..., vn。现在如果 (vn, v) 是 G 的一条边，那么我们有哈密顿路径 v1, v2, ..., vn, v；同样如果 (v, v1) 是 G 的一条边，那么我们有哈密顿路径 v, v1, v2, ..., vn。否则，必须存在一个最小的 i 使得 (vi, v) 和 (v, vi+1) 是 G 的边。然后我们可以在之前的路径中插入 v 以获得哈密顿路径 v1, v2, ..., vi, v, vi+1, ..., vn。",
        "answer_symbols": [
            "(",
            "vi+1",
            ",",
            "v2",
            "v1",
            ")",
            "n",
            "v",
            "vi",
            "vn"
        ]
    },
    "10 Supplementary Exercises 43": {
        "question": "给定鸡群里的两只鸡，其中一只占优势。这样就定义了这个鸡群的啄食次序。如何用竞赛图来为啄食次序建模？",
        "answer": "让顶点表示鸡。当且仅当鸡 u 支配鸡 v 时，我们在图中包含边 (u, v)。",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "10 Supplementary Exercises 44": {
        "question": "设连通图 G 有 n 个顶点且点连通度 k(G) = k。证明：图 G 至少含有 floor(kn/2) 条边。",
        "answer": "因为 κ(G) 小于或等于顶点的最小度数，所以这里的最小度数至少为 k。这意味着度数之和至少为 k 乘以 n，因此根据握手定理，边的数量至少为 k 乘以 n 再除以 2。由于这个值必须是整数，所以它至少为 k 乘以 n 再除以 2 并向下取整。",
        "answer_symbols": [
            "κ",
            "≤",
            "(",
            ")",
            "×",
            "+",
            "/",
            "⌊",
            "⌋"
        ]
    },
    "10 Supplementary Exercises 45": {
        "question": "证明：具有最优连通度的连通图一定是正则图。",
        "answer": "根据握手定理，平均顶点度为 2m/n，等于最小度；因此所有顶点度都相等。",
        "answer_symbols": [
            "/",
            "=",
            "≠"
        ]
    },
    "10 Supplementary Exercises 46 a)": {
        "question": "证明下列各图具有最优连通度。（a）C_n，n ≥ 3",
        "answer": "κ(Cn) = λ(Cn) = δ(Cn) = 2",
        "answer_symbols": [
            "δ"
        ]
    },
    "10 Supplementary Exercises 46 b)": {
        "question": "证明下列各图具有最优连通度。（b）K_n，n ≥ 3",
        "answer": "κ(Kn) = λ(Kn) = δ(Kn) = n - 1",
        "answer_symbols": [
            "δ"
        ]
    },
    "10 Supplementary Exercises 46 c)": {
        "question": "证明下列各图具有最优连通度。（c）K_r,r，r ≥ 2",
        "answer": "κ(Kr,r) = λ(Kr,r) = δ(Kr,r) = r（见第 10.4 节练习 53）",
        "answer_symbols": [
            "δ"
        ]
    },
    "10 Supplementary Exercises 47": {
        "question": "求 2 个带有 6 个顶点，9 条边，具有最优连通度的非同构的简单图。",
        "answer": "K3,3 和三角棱柱的骨架",
        "answer_symbols": [
            "K",
            "3",
            "3",
            "≠"
        ]
    },
    "10 Supplementary Exercises 48": {
        "question": "假定 G 是带 2k 个度为奇数的顶点的连通多重图。证明：存在 k 个子图，它们的并图是 G，其中每个子图都有欧拉通路并且任何两个子图都没有公共边。[提示：向该图添加 k 条连接成对的度为奇数的顶点，并且利用这个变大了的图的欧拉回路。]",
        "answer": "我们遵循提示，任意配对奇数度的顶点，并在每对顶点之间添加一条额外的边。结果得到的多重图的所有顶点都是偶数度，因此它有一个欧拉回路。如果删除新添加的边，则此回路被分割成 k 条路径。由于没有两条新添加的边相邻，因此每条路径都非空。这些路径中的边和顶点构成一个子图，这些子图构成了所需的集合。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 49 a)": {
        "question": "证明：用顶点表示骑士，若两个骑士是朋友，则在图中用边连接这两人。该题可以化简为判断图中是否存在哈密顿回路。",
        "answer": "图中的哈密顿回路正好对应于圆桌上的骑士座位安排，使得相邻的骑士是朋友。",
        "answer_symbols": [
            "≠"
        ]
    },
    "10 Supplementary Exercises 49 b)": {
        "question": "解答在上面智力题中提出的问题。[提示：利用狄拉克定理。]",
        "answer": "该图中每个顶点的度至少为 2n - 1 - (n - 1) = n ≥ (2n/2)，所以根据狄拉克定理，这个图有一个哈密顿回路。",
        "answer_symbols": [
            "-",
            "(",
            ")",
            "/",
            "≥",
            "≠"
        ]
    },
    "10 Supplementary Exercises 50": {
        "question": "假设有 8 个骑士：Alynore、Bedivere、Degore、Gareth、Kay、Lancelot、Perceval 和 Tristan 用每个人的名字的第一个字母表示该骑士，并在该字母后面列出他的敌人列表。他们的敌人列表是：A(D, G, P)、B(K, P, T)、D(A, G, L)、G(A, D, T)、K(B, L, P)、L(D, K, T)、P(A, B, K)、T(B, G, L)。画出表示这 8 个骑士和他们的朋友的图，并且求出安排方式使得每一个骑士都挨着他的两个朋友坐。",
        "answer": "Dirac 定理保证了这个友谊图（其中每个顶点的度数为 4）将具有哈密顿回路。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 51 a)": {
        "question": "求下列图的带宽。（a）K_5",
        "answer": "4",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 51 b)": {
        "question": "求下列图的带宽。（b）K_1,3",
        "answer": "2",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 51 c)": {
        "question": "求下列图的带宽。（c）K_2,3",
        "answer": "3",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 51 d)": {
        "question": "求下列图的带宽。（d）K_3,3",
        "answer": "4",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 51 e)": {
        "question": "求下列图的带宽。（e）Q_3",
        "answer": "4",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 51 f)": {
        "question": "求下列图的带宽。（f）C_6",
        "answer": "2",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 52 a)": {
        "question": "求下列图的半径和直径。（a）K_5",
        "answer": "直径显然为 1，因为两个顶点之间的最大距离为 1。半径也是 1，任何顶点都可以作为中心。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 52 b)": {
        "question": "求下列图的半径和直径。（b）K_4,5",
        "answer": "直径显然为 2，因为在同一部分中的顶点不相邻，但没有任何一对顶点的距离大于 2。同样，半径为 2，任何顶点都可以作为中心。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 52 c)": {
        "question": "求下列图的半径和直径。（c）Q_3",
        "answer": "立方体对角线相对的顶点相距 3，这是最坏的情况，因此直径为 3。通过对称性，我们可以取任何顶点作为中心，因此半径也是 3。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 52 d)": {
        "question": "求下列图的半径和直径。（d）C_6",
        "answer": "六边形对角线相对的顶点相距 3，这是最坏的情况，因此直径为 3。通过对称性，我们可以取任何顶点作为中心，因此半径也是 3。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 53 a)": {
        "question": "证明：若简单图 G 的直径至少为 4，则它的补图 G̅ 的直径不超过 2。",
        "answer": "假设 G = (V, E)。令 a, b 属于 V。我们必须证明 G 中 a 和 b 之间的距离最多为 2。如果 {a, b} 不属于 E，这个距离为 1，所以假设 {a, b} 属于 E。因为 G 的直径大于 3，存在顶点 u 和 v 使得 G 中 u 和 v 之间的距离大于 3。u 或 v 或两者都不在集合 {a, b} 中。假设 u 与 a 和 b 都不同。{a, u} 或 {b, u} 属于 E；否则 a, u, b 将是 G 中长度为 2 的路径。所以，不失一般性，假设 {a, u} 属于 E。因此 v 不能是 a 或 b，并且由于同样的原因，{a, v} 属于 E 或 {b, v} 属于 E。在这两种情况下，这给出了 G 中从 u 到 v 的长度小于或等于 3 的路径，矛盾。",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            ",",
            "≠",
            ">",
            "≤"
        ]
    },
    "10 Supplementary Exercises 53 b)": {
        "question": "证明：若简单图 G 的直径至少为 3，则它的补图 G̅ 的直径不超过 3。",
        "answer": "假设 G = (V, E)。令 a, b 属于 V。我们必须证明 G 中 a 和 b 之间的距离不超过 3。如果 {a, b} 不属于 E，结果成立，所以假设 {a, b} 属于 E。因为 G 的直径大于或等于 3，存在顶点 u 和 v 使得 G 中 u 和 v 之间的距离大于或等于 3。u 或 v 或两者都不在集合 {a, b} 中。假设 u 与 a 和 b 都不同。{a, u} 属于 E 或 {b, u} 属于 E；否则 a, u, b 是 G 中长度为 2 的路径。所以，不失一般性，假设 {a, u} 属于 E。因此 v 与 a 和 b 都不同。如果 {a, v} 属于 E，那么 u, a, v 是 G 中长度为 2 的路径，所以 {a, v} 不属于 E，因此 {b, v} 属于 E（否则 a, v, b 将是 G 中长度为 2 的路径）。因此，{u, b} 不属于 E；否则 u, b, v 是 G 中长度为 2 的路径。因此，a, v, u, b 是 G 中长度为 3 的路径，如所愿。",
        "answer_symbols": [
            "{",
            "}",
            "(",
            ")",
            ",",
            "≠",
            "≥",
            "≤"
        ]
    },
    "10 Supplementary Exercises 54": {
        "question": "假定一个多重图有 2m 个度为奇数的顶点。证明：任何包含该图中每条边的回路，必然至少包含 m 条边超过一次。",
        "answer": "假设我们按照给定的回路穿过多重图，但不是重复使用边，而是在需要时添加新的平行边。结果是一个更大的多重图的欧拉回路。如果我们在这个过程中只在 m - 1 或更少的地方添加了新的平行边，那么我们最多修改了 2(m - 1) 个顶点的度数。这意味着至少有 2m - 2(m - 1) = 2 个奇数度的顶点剩余，这在具有欧拉回路的多重图中是不可能的。因此我们必须在至少 m 个地方添加新的边，这意味着回路必须至少重复使用 m 条边。",
        "answer_symbols": [
            "≤",
            "=",
            "(",
            "×",
            ")",
            "-"
        ]
    },
    "10 Supplementary Exercises 55": {
        "question": "求 10.6 节图 3 中在顶点 a 与 z 之间的次最短通路。",
        "answer": "a, b, e, z",
        "answer_symbols": [
            "≠"
        ]
    },
    "10 Supplementary Exercises 56": {
        "question": "设计一个算法，求在简单连通加权图中两个顶点之间的次最短通路。",
        "answer": "我们假设这里只考虑简单路径。可能没有这样的路径，所以不可能有这种算法。如果我们想要一个寻找此类路径或确定不存在此类路径的算法，我们可以按以下方式操作。首先我们使用迪杰斯特拉算法（或其他算法）找到从a到z（给定顶点）的最短路径。然后对于该路径中的每条边e（一次一条），我们从图中删除e并找到剩余图中a和z之间的最短路径，或者确定不存在这样的路径（再次使用，例如，迪杰斯特拉算法）。从a到z的第二最短路径是从这些找到的路径中长度最小的路径，如果找不到这样的路径，则不存在。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 57": {
        "question": "求 10.6 节练习 3 的加权图中，在顶点 a 与 z 之间经过顶点 f 的最短通路。",
        "answer": "a, c, d, f, g, z",
        "answer_symbols": [
            "≠"
        ]
    },
    "10 Supplementary Exercises 58": {
        "question": "设计一个算法，求在简单连通加权图中两个顶点之间经过第三个指定顶点的最短通路。",
        "answer": "如果我们想要从a到z经过m的最短路径，那么显然我们需要找到从a到m的最短路径以及从m到z的最短路径，然后将它们连接起来。每个路径都可以使用迪杰斯特拉算法找到。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 59": {
        "question": "证明：若 G 是至少带 11 个顶点的简单图，则 G 或 G̅ (G 的补图)不是平面图。",
        "answer": "如果 G 是平面图，那么因为 e ≤ 3v - 6，G 最多有 27 条边。（如果 G 不连通，它甚至有更少的边。）类似地，G 最多有 27 条边。但 G 和 G 的并集是 K11，它有 55 条边，而 55 > 27 + 27。",
        "answer_symbols": [
            "≤",
            "-",
            "+",
            ">"
        ]
    },
    "10 Supplementary Exercises 60 a)": {
        "question": "下列图的独立数是什么？（a）K_n",
        "answer": "没有两个顶点不相邻，因此独立数为1。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 60 b)": {
        "question": "下列图的独立数是什么？（b）C_n",
        "answer": "如果n是偶数，那么我们可以取每隔一个顶点作为我们的独立集，因此独立数为n/2。如果n是奇数，那么这不太行得通，但显然我们可以取每隔一个顶点，除了一个顶点。在这种情况下，独立数为(n - 1)/2。我们可以简洁地表示这个答案为n/2。",
        "answer_symbols": [
            "/",
            "-",
            "(",
            ")"
        ]
    },
    "10 Supplementary Exercises 60 c)": {
        "question": "下列图的独立数是什么？（c）Q_n",
        "answer": "由于Qn是一个二分图，每个部分有2^(n-1)个顶点，独立数至少为2^(n-1)（取其中一个部分作为独立集）。我们通过归纳法证明最多只能有这么多独立顶点。当n=1时这是显而易见的。假设归纳假设成立，并且假设在Qn+1中有超过2^n个独立顶点。回想一下，Qn+1包含两个Qn的副本（每对对应的点由一条边连接）。根据鸽巢原理，至少有一个Qn包含超过2^n/2 = 2^(n-1)个独立顶点。这与归纳假设矛盾。因此，Qn+1只有2^n个独立顶点，如所愿。",
        "answer_symbols": [
            "^",
            "(",
            ")",
            "/"
        ]
    },
    "10 Supplementary Exercises 60 d)": {
        "question": "下列图的独立数是什么？（d）K_m,n",
        "answer": "独立数显然是m和n中较大的那个；要取的独立集是具有这个数量的顶点的部分。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 61": {
        "question": "证明：一个简单图中的顶点数小于或等于这个图的独立数与着色数之积。",
        "answer": "假设 G 用 k 种颜色着色，独立数为 i。因为每个颜色类必须是独立集，每个颜色类的元素数不超过 i。因此最多有 ki。",
        "answer_symbols": [
            "≠",
            "≤"
        ]
    },
    "10 Supplementary Exercises 62": {
        "question": "证明：一个图的着色数小于或等于 n−i+1，其中 n 是这个图的顶点数，i 是这个图的独立数。",
        "answer": "为了证明这个陈述，找到一个使用n-i+1种颜色的着色就足够了。我们按照以下方式着色图。设S是一个具有i个顶点的独立集。将S中的每个顶点涂成颜色n-i+1。将其他n-i个顶点涂成不同的颜色。",
        "answer_symbols": [
            "-",
            "+",
            "(",
            ")"
        ]
    },
    "10 Supplementary Exercises 63 a)": {
        "question": "生成带有 m 条边的图的概率是什么？其中 0≤m≤C(n, 2)。",
        "answer": "C(n, m)pᵐ(1 - p)^(n-m)",
        "answer_symbols": [
            "C",
            "^",
            "(",
            ")"
        ]
    },
    "10 Supplementary Exercises 63 b)": {
        "question": "若包含每一条边的概率为 p，则在随机生成的带有 n 个顶点的图中，边数的期望值是什么？",
        "answer": "np",
        "answer_symbols": [
            "*"
        ]
    },
    "10 Supplementary Exercises 63 c)": {
        "question": "证明：若 p=1/2，则每一个带 n 个顶点的简单图是等概率生成的。",
        "answer": "为了生成一个标记图G，当我们对顶点对应用此过程时，选择的随机数x必须在G有该顶点对之间的边时小于或等于1/2，在G没有该边时大于1/2。因此，每个边做出正确选择的概率为1/2，整体概率为1/2^C(n,2)。因此，所有标记图都是等可能的。",
        "answer_symbols": [
            "<=",
            ">",
            "^",
            "C"
        ]
    },
    "10 Supplementary Exercises 64 a)": {
        "question": "对下列每个性质来说，判断它是否为单调递增的，并判断它是否为单调递减的。（a）图 G 是连通的",
        "answer": "显然，添加边只能有助于使图连通，因此这个属性是单调增加的。它不是单调减少的，因为通过移除边可以使连通图变得不连通。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 64 b)": {
        "question": "对下列每个性质来说，判断它是否为单调递增的，并判断它是否为单调递减的。（b）图 G 不是连通的",
        "answer": "这与(a)部分相反；属性是单调减少的。可以看到，从非连通图中移除边不可能使其连通，而添加边肯定可以。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 64 c)": {
        "question": "对下列每个性质来说，判断它是否为单调递增的，并判断它是否为单调递减的。（c）图 G 有欧拉回路",
        "answer": "这个属性既不是单调增加也不是单调减少。我们需要提供示例来验证这一点。考虑图C4，一个正方形。它有一个欧拉回路。然而，如果我们添加一条边或移除一条边，那么得到的图将不再有欧拉回路。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 64 d)": {
        "question": "对下列每个性质来说，判断它是否为单调递增的，并判断它是否为单调递减的。（d）图 G 有哈密顿回路",
        "answer": "这个属性是单调增加的（因为额外的边不会干扰已经存在的哈密顿回路），但不是单调减少的（例如，从一个环开始）。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 64 e)": {
        "question": "对下列每个性质来说，判断它是否为单调递增的，并判断它是否为单调递减的。（e）图 G 是平面图",
        "answer": "这个属性是单调减少的。如果一个图可以在平面上绘制，那么显然它的每个子图也可以在平面上绘制（只需擦掉多余的部分！）。这个属性不是单调增加的；例如，向缺少一条边的五个顶点的完全图添加缺失的边会使图从平面变为非平面。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 64 f)": {
        "question": "对下列每个性质来说，判断它是否为单调递增的，并判断它是否为单调递减的。（f）图 G 的着色数为 4",
        "answer": "这个属性既不是单调增加也不是单调减少。很容易找到添加边增加色数和移除边减少色数的例子（例如，从C5开始）。",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 64 g)": {
        "question": "对下列每个性质来说，判断它是否为单调递增的，并判断它是否为单调递减的。（g）图 G 的半径为 3",
        "answer": "与(f)部分一样，添加边可以很容易地减小半径，移除边可以很容易地增大半径，因此这个属性既不是单调增加也不是单调减少。例如，C7的半径为三，但Adding enough edges to make K7 reduces the radius to 1, and removing enough edges to disconnect the graph renders the radius infinite.",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 64 h)": {
        "question": "对下列每个性质来说，判断它是否为单调递增的，并判断它是否为单调递减的。（h）图 G 的直径为 3",
        "answer": "As in part(g), this is neither monotone increasing nor monotone decreasing.",
        "answer_symbols": []
    },
    "10 Supplementary Exercises 65": {
        "question": "证明：图的性质 P 是单调递增的当且仅当图的性质 Q 是单调递减的，其中 Q 是不具有性质 P 的性质。",
        "answer": "假设P是单调递增的。如果当从简单图中移除边时，不具有P的性质未被保留，则存在一个简单图G不具有P，而另一个具有相同顶点但缺少G的一些边的简单图G'具有P。但是P是单调递增的，所以因为G'具有P，通过向G'添加边得到的G也具有P。这是一个矛盾。逆命题的证明类似。",
        "answer_symbols": [
            "≠",
            "→",
            "∨",
            "∧",
            "¬"
        ]
    },
    "10 Supplementary Exercises 66": {
        "question": "假定 P 是简单图的单调递增的性质。证明：带 n 个顶点的随机图有性质 P 的概率是 p 的单调非递减函数，其中 p 是一条边被挑选到该图的概率。",
        "answer": "Suppose that G is a graph on n vertices randomly generated using edge probability p, and G' is a graph on n vertices randomly generated using edge probability p', where p < p'. Recall that this means that for G we go through all pairs of vertices and independently put an edge between them with probability p; and similarly for G'. We must show that G is no more likely to have property P than G' is. To see this, we will imagine a different way of forming G. First we generate a random graph G' using edge probability p'; then we go through the edges that are present, and independently erase each of them with probability 1 - (p/p').\nClearly, for an edge to end up in G, it must first get generated and then not get erased, which has probability p' * (p/p') = p; therefore this is a valid way to generate G. Now whenever G has property P, then so does G', since P is monotone increasing. Thus the probability that G has property P is no greater than the probability that G' does; in fact it will usually be less, since once a G' having property P is generated, it is possible that it will lose the property as edges are erased.",
        "answer_symbols": []
    },
    "11.1 2 a)": {
        "question": "下面哪些图是树？（a）",
        "answer": "这是一棵树，因为它连通且没有简单回路。",
        "answer_symbols": [
            "连通",
            "简单回路"
        ]
    },
    "11.1 2 b)": {
        "question": "下面哪些图是树？（b）",
        "answer": "这是一棵树，因为它连通且没有简单回路。",
        "answer_symbols": [
            "连通",
            "简单回路"
        ]
    },
    "11.1 2 c)": {
        "question": "下面哪些图是树？（c）",
        "answer": "这不是一棵树，因为它不连通。",
        "answer_symbols": [
            "连通"
        ]
    },
    "11.1 2 d)": {
        "question": "下面哪些图是树？（d）",
        "answer": "这是一棵树，因为它连通且没有简单回路。",
        "answer_symbols": [
            "连通",
            "简单回路"
        ]
    },
    "11.1 2 e)": {
        "question": "下面哪些图是树？（e）",
        "answer": "这不是一棵树，因为它有一个简单回路。",
        "answer_symbols": [
            "简单回路"
        ]
    },
    "11.1 2 f)": {
        "question": "下面哪些图是树？（f）",
        "answer": "这是一棵树，因为它连通且没有简单回路。",
        "answer_symbols": [
            "连通",
            "简单回路"
        ]
    },
    "11.1 3 a)": {
        "question": "回答下列图中有根树的问题。哪个顶点是根？",
        "answer": "a",
        "answer_symbols": []
    },
    "11.1 3 b)": {
        "question": "回答下列图中有根树的问题。哪些顶点是内点？",
        "answer": "a, b, c, d, f, h, j, q, t",
        "answer_symbols": []
    },
    "11.1 3 c)": {
        "question": "回答下列图中有根树的问题。哪些顶点是树叶？",
        "answer": "e, g, i, k, l, m, n, o, p, r, s, u",
        "answer_symbols": []
    },
    "11.1 3 d)": {
        "question": "回答下列图中有根树的问题。哪些顶点是 j 的孩子？",
        "answer": "q, r",
        "answer_symbols": []
    },
    "11.1 3 e)": {
        "question": "回答下列图中有根树的问题。哪些顶点是 h 的父母？",
        "answer": "c",
        "answer_symbols": []
    },
    "11.1 3 f)": {
        "question": "回答下列图中有根树的问题。哪些顶点是 o 的兄弟？",
        "answer": "p",
        "answer_symbols": []
    },
    "11.1 3 g)": {
        "question": "回答下列图中有根树的问题。哪些顶点是 m 的祖先？",
        "answer": "f, b, a",
        "answer_symbols": []
    },
    "11.1 3 h)": {
        "question": "回答下列图中有根树的问题。哪些顶点是 b 的后代？",
        "answer": "e, f, l, m, n",
        "answer_symbols": []
    },
    "11.1 5": {
        "question": "练习 3 中的有根树对某个正整数 m 来说，是否是满 m 叉树？",
        "answer": "不",
        "answer_symbols": []
    },
    "11.1 6": {
        "question": "练习 4 中的有根树对某个正整数 m 来说，是否是满 m 叉树？",
        "answer": "这不是任何 m 的完全 m 叉树。它是一个 m 叉树，对于所有 m ≥ 3，因为每个顶点最多有 3 个子节点，但由于有些顶点有 3 个子节点，而其他顶点有 1 或 2 个子节点，因此它对任何 m 都不是完全的。",
        "answer_symbols": [
            "≥",
            "子节点"
        ]
    },
    "11.1 7": {
        "question": "练习 3 中的有根树的每个顶点的层数是什么？",
        "answer": "第0层：a；第1层：b, c, d；第2层：e到k（按字母顺序）；第3层：l到r；第4层：s, t；第5层：u",
        "answer_symbols": []
    },
    "11.1 8": {
        "question": "练习 4 中的有根树的每个顶点的层数是什么？",
        "answer": "我们可以从图中轻松确定层次。根 a 在第 0 层。a 下方的一行顶点在第 1 层，即 b、c 和 d。再下方一行的顶点（按字母顺序排列），即 e 到 i，在第 2 层。同样，j 到 p 在第 3 层，q、r 和 s 在第 4 层。",
        "answer_symbols": []
    },
    "11.1 9 a)": {
        "question": "画出练习 3 中的树以下列顶点为根的子树。（a）a",
        "answer": "整棵树",
        "answer_symbols": []
    },
    "11.1 9 b)": {
        "question": "画出练习 3 中的树以下列顶点为根的子树。（b）c",
        "answer": "c, g, h, o, p 和四条边cg, ch, ho, hp",
        "answer_symbols": []
    },
    "11.1 9 c)": {
        "question": "画出练习 3 中的树以下列顶点为根的子树。（c）e",
        "answer": "仅e",
        "answer_symbols": []
    },
    "11.1 10 a)": {
        "question": "画出练习 4 中的树以下列顶点为根的子树。（a）a",
        "answer": "以 a 为根的子树是整棵树，因为 a 是根。",
        "answer_symbols": [
            "根"
        ]
    },
    "11.1 10 b)": {
        "question": "画出练习 4 中的树以下列顶点为根的子树。（b）c",
        "answer": "以 c 为根的子树仅包括顶点 c。",
        "answer_symbols": [
            "根"
        ]
    },
    "11.1 10 c)": {
        "question": "画出练习 4 中的树以下列顶点为根的子树。（c）e",
        "answer": "以 e 为根的子树包括 e、j 和 k，以及边 ej 和 ek。",
        "answer_symbols": [
            "根",
            "边"
        ]
    },
    "11.1 11 a)": {
        "question": "有多少种非同构的带有 3 个顶点的无根树？",
        "answer": "1",
        "answer_symbols": []
    },
    "11.1 11 b)": {
        "question": "有多少种非同构的带有 3 个顶点的有根树（使用有向图的同构）？",
        "answer": "2",
        "answer_symbols": []
    },
    "11.1 12 a)": {
        "question": "有多少种非同构的带有 4 个顶点的无根树？",
        "answer": "有两棵四个顶点的树，即 K1,3 和长度为 3 的简单路径。见下面前两棵树。",
        "answer_symbols": [
            "根",
            "边"
        ]
    },
    "11.1 12 b)": {
        "question": "有多少种非同构的带有 4 个顶点的有根树（使用有向图的同构）？",
        "answer": "The longest path from the root can have a length of 1, 2, or 3. There is only one tree with the longest path of length 1 (the other three vertices are at level 1), and only one with the longest path of length 3. If the longest path has length 2, then the fourth vertex (after using three vertices to draw this path) can be \"attached\" to either the root or the vertex at level 1, giving us two nonisomorphic trees. Thus, there are a total of four nonisomorphic rooted trees on 4 vertices, as shown below.\n",
        "answer_symbols": [
            "根",
            "边"
        ]
    },
    "11.1 13 a)": {
        "question": "有多少种非同构的带有 5 个顶点的无根树？",
        "answer": "3",
        "answer_symbols": []
    },
    "11.1 13 b)": {
        "question": "有多少种非同构的带有 5 个顶点的有根树（使用有向图的同构）？",
        "answer": "9",
        "answer_symbols": []
    },
    "11.1 14": {
        "question": "证明：简单图是树当且仅当它是连通的，但是删除它的任何一条边就产生不连通的图。",
        "answer": "There are two things to prove. First, suppose that T is a tree. By definition, it is connected, so we need to show that the deletion of any of its edges produces a graph that is not connected. Let {x, y} be an edge of T, and note that x ≠ y. Now T with {x, y} deleted has no path from x to y, since there was only one simple path from x to y in T, and the edge itself was it. (We use Theorem 1 here, as well as the fact that if there is a path from a vertex u to another vertex v, then there is a simple path from u to v by Theorem 1 in Section 10.4.) Therefore, the graph with {x, y} deleted is not connected. Conversely, suppose that a simple connected graph T satisfies the condition that the removal of any edge will disconnect it. We must show that T is a tree. If not, then T has a simple circuit, say x1, x2, ..., xr, x1. If we delete edge {xr, x1} from T, then the graph will remain connected, since wherever the deleted edge was used in forming paths between vertices, we can instead use the rest of the circuit: x1, x2, ..., xr or its reverse, depending on which direction we need to go. This is a contradiction to the condition. Therefore, our assumption was wrong, and T is a tree.",
        "answer_symbols": [
            "{",
            "}",
            "≠",
            "→",
            "∈"
        ]
    },
    "11.1 15 a)": {
        "question": "设 G 是带有 n 个顶点的简单图。证明：G 是树当且仅当 G 是连通的并且有 n - 1 条边。",
        "answer": "“只有”部分是定理2和树的定义。假设G是一个具有n个顶点和n - 1条边的连通简单图。如果G不是一棵树，那么根据练习14，它包含一条边，删除这条边后产生的图G'仍然是连通的。如果G'不是一棵树，删除一条边以产生连通图G''。重复这个过程直到结果是一棵树。这最多需要n-1步，因为只有n-1条边。根据定理2，最终图有n-1条边，因为它有n个顶点。由此可知没有删除任何边，所以G已经是一棵树。",
        "answer_symbols": [
            "≠",
            "→",
            "∨",
            "∧",
            "¬"
        ]
    },
    "11.1 15 b)": {
        "question": "设 G 是带有 n 个顶点的简单图。证明：G 是树当且仅当 G 没有简单回路并且有 n - 1 条边。[提示：为了证明当 G 没有简单回路并且有 n - 1 条边时 G 是连通的，证明 G 不能有多于 1 个的连通分部。]",
        "answer": "假设G是一棵树。根据(a)部分，G有n-1条边，并且根据定义，G没有简单的回路。反之，假设G没有简单的回路并且有n - 1条边。令c等于G的组件数，每个组件必然是树，假设它们分别有n_i个顶点，其中n_i的总和为n。根据(a)部分，G中的边总数为n_i-1的总和等于n-c。由于给定这个值等于n - 1，因此c = 1，即G是连通的，因此满足树的定义。",
        "answer_symbols": [
            "≠",
            "→",
            "∨",
            "∧",
            "¬"
        ]
    },
    "11.1 16": {
        "question": "哪些完全二分图 K_m,n 是树，其中 m 和 n 都是正整数？",
        "answer": "If both m and n are at least 2, then clearly there is a simple circuit of length 4 in Km,n. On the other hand, Km,1 is clearly a tree (as is K1,n). Thus, we conclude that Km,n is a tree if and only if m = 1 or n = 1.",
        "answer_symbols": [
            "=",
            "≥"
        ]
    },
    "11.1 17": {
        "question": "带有 10 000 个顶点的树有多少条边？",
        "answer": "9999",
        "answer_symbols": []
    },
    "11.1 18": {
        "question": "带有 100 个内点的满 5 叉树有多少个顶点？",
        "answer": "By Theorem 4(ii), the answer is mi + 1 = 5 * 100 + 1 = 501.",
        "answer_symbols": [
            "*",
            "+",
            "="
        ]
    },
    "11.1 19": {
        "question": "带有 1000 个内点的满二叉树有多少条边？",
        "answer": "2000",
        "answer_symbols": []
    },
    "11.1 20": {
        "question": "带有 100 个顶点的满 3 叉树有多少个树叶？",
        "answer": "By Theorem 4(i), the answer is [(m − 1)n + 1] / m = (2 * 100 + 1) / 3 = 67.",
        "answer_symbols": [
            "[",
            "]",
            "(",
            ")",
            "*",
            "+",
            "-",
            "/",
            "="
        ]
    },
    "11.1 21": {
        "question": "假定 1000 个人参加象棋巡回赛。若一个选手输掉一盘就遭到淘汰，而且比赛进行到只有一位参加者还没有输过为止，则利用这个巡回赛的有根树模型来确定为了决出冠军必须下多少盘棋（假定没有平局）。",
        "answer": "999",
        "answer_symbols": []
    },
    "11.1 22": {
        "question": "一封连环信开始时有一个人寄出一封信给其他 5 个人。收到此信的每个人要么寄出信给从来没有人收到过此信的其他 5 个人，要么不把它寄给任何人。假定在这个连环终止以前有 10 000 个人寄出过此信，并且没有人收到超过一封信。有多少人收到过信？又有多少人收到过信但是没有寄出它？",
        "answer": "The model here is a full 5-ary tree. We are told that there are 10,000 internal vertices (these represent the people who send out the letter). By Theorem 4(ii), we see that n = mi + 1 = 5 * 10000 + 1 = 50,001. Everyone but the root receives the letter, so we conclude that 50,000 people receive the letter. There are 50001 − 10000 = 40,001 leaves in the tree, so that is the number of people who receive the letter but do not send it out.",
        "answer_symbols": [
            "*",
            "+",
            "-",
            "="
        ]
    },
    "11.1 23": {
        "question": "一封连环信开始时一个人寄出一封信给其他 10 个人。要求每个人寄出此信给其他 10 个人，而且每封信都包含该连环中前面 6 个人的列表。除非表中不足 6 个名字，否则每个人都寄一美元给表中的第一个人，从表中删除这个名字，把其他 5 个人的名字向上移动一位，并且把他自己的名字插入到表的末尾。若没有人中断这个连环，并且每人至多收到一封信，则这个连环中的一个人最终将收到多少钱？",
        "answer": "1,000,000美元",
        "answer_symbols": []
    },
    "11.1 24": {
        "question": "要么画出带有 76 个树叶且高度为 3 的满 m 叉树，其中 m 是正整数，要么证明这样的树不存在。",
        "answer": "Such a tree does exist. By Theorem 4(iii), we note that such a tree must have i = 75 / (m − 1) internal vertices. This has to be a whole number, so m − 1 must divide 75. This is possible, for example, if m = 6, so let us try it. A complete 6-ary tree (see preamble to Exercise 27) of height 2 would have 36 leaves. We therefore need to add 40 leaves. This can be accomplished by changing 8 vertices at level 2 to internal vertices; each such change adds 5 leaves to the tree (6 new leaves at level 3, less the one leaf at level 2 that has been changed to an internal vertex). We will not show a picture of this tree, but just summarize its appearance. The root has 6 children, each of which has 6 children, giving 36 vertices at level 2. Of these, 28 are leaves, and each of the remaining 8 vertices at level 2 has 6 children, living at level 3, for a total of 48 leaves at level 3. The total number of leaves is therefore 28 + 48 = 76, as desired.",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "/",
            "*"
        ]
    },
    "11.1 25": {
        "question": "要么画出带有 84 个树叶且高度为 3 的满 m 叉树，其中 m 是正整数，要么证明这样的树不存在。",
        "answer": "不存在这样的树，因为根据定理4，m不可能等于2或84。",
        "answer_symbols": []
    },
    "11.1 26 a)": {
        "question": "一棵满 m 叉树 T 有 81 个树叶并且高度为 4。（a）给出 m 的上界和下界。",
        "answer": "由于高度为4，我们不能有m=2，因为这将给我们最多1+2+4+8+16=31个顶点。任何上面显示的更大的m值，直到21，都允许我们形成一个具有81个叶节点和高度为4的树。在每种情况下，如果我们使所有小于4级别的顶点成为内部顶点，我们可以得到m^4个叶节点；并且我们可以通过在每个这样的级别只放置一个内部顶点来获得最少4(m-1)+1个叶节点。我们可以通过取m=3在前一种情况下得到81个叶节点；另一方面，如果m>21，那么我们将被迫拥有超过81个叶节点。因此，m的范围是3 ≤ m ≤ 21（m还受限于上述列表）。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "^",
            "<=",
            ">"
        ]
    },
    "11.1 26 b)": {
        "question": "一棵满 m 叉树 T 有 81 个树叶并且高度为 4。（b）若 T 也是平衡的，则 m 是多少？",
        "answer": "如果T必须是平衡的，那么当第3层只有一个内部顶点和m^3 - 1个叶节点时，可以获得最小的可能叶节点数量，即T中的总叶节点数量为m^3 - 1 + m。同样，最大的叶节点数量将是m^4。在这种限制下，我们看到m=5已经太大了，因为这需要至少5^3 - 1 + 5 = 129个叶节点。因此，唯一可能是m=3。",
        "answer_symbols": [
            "-",
            "+",
            "^",
            "=",
            ">"
        ]
    },
    "11.1 28": {
        "question": "高度为 h 的完全 m 叉树具有多少个顶点和多少个树叶？",
        "answer": "这棵树在层级0有1个顶点，在层级1有m个顶点，在层级2有m^2个顶点，...，在层级h有m^h个顶点。因此它总共有1+ m+ m^2+ ... + m^h = (m^(h+1) - 1) / (m - 1)个顶点。层级h上的顶点是唯一的叶节点，所以它有m^h个叶节点。",
        "answer_symbols": [
            "+",
            "^",
            "/",
            "-",
            "=",
            "..."
        ]
    },
    "11.1 30": {
        "question": "证明：高度为 h 的满 m 又平衡树具有超过 m^h-1 个树叶。",
        "answer": "首先我们删除所有层级h的顶点；至少有一个这样的顶点，它们都是叶节点。结果必须是一个高度为h-1的完全m叉树。根据练习28的结果，这棵树有m^(h-1)个叶节点。在原始树中，叶子的数量比这更多，因为每个层级h-1的内部顶点（在我们减少的树中计为叶节点）至少生成两个层级h的叶节点。",
        "answer_symbols": [
            "-",
            "^",
            ">="
        ]
    },
    "11.1 31": {
        "question": "在包含总共 n 个顶点的 t 棵树的森林中有多少条边？",
        "answer": "n - t",
        "answer_symbols": [
            "-",
            "+",
            "*",
            "/"
        ]
    },
    "11.1 32": {
        "question": "解释如何用树来表示由章、章节、节中小节组成的书的目录表。",
        "answer": "树的根表示整本书。层级1的顶点代表章节——每个章节是书的子节点。层级2的顶点代表节（每个这样的顶点的父节点是该节所在的章节）。类似地，层级3的顶点是小节。",
        "answer_symbols": []
    },
    "11.1 33 a)": {
        "question": "下面的饱和碳氢化合物有多少种不同的同分异构体？（a）C_3H_8",
        "answer": "1",
        "answer_symbols": []
    },
    "11.1 33 b)": {
        "question": "下面的饱和碳氢化合物有多少种不同的同分异构体？（b）C_5H_12",
        "answer": "3",
        "answer_symbols": []
    },
    "11.1 33 c)": {
        "question": "下面的饱和碳氢化合物有多少种不同的同分异构体？（c）C_6H_14",
        "answer": "5",
        "answer_symbols": []
    },
    "11.1 34 a)": {
        "question": "在组织机构树中下述对象分别表示什么内容？（a）一个顶点的父母",
        "answer": "顶点的父节点是该顶点的上级。",
        "answer_symbols": []
    },
    "11.1 34 b)": {
        "question": "在组织机构树中下述对象分别表示什么内容？（b）一个顶点的孩子",
        "answer": "顶点的子节点是该顶点直接管理的下属。",
        "answer_symbols": []
    },
    "11.1 34 c)": {
        "question": "在组织机构树中下述对象分别表示什么内容？（c）一个顶点的兄弟",
        "answer": "顶点的兄弟节点是与该顶点有相同上级的同事。",
        "answer_symbols": []
    },
    "11.1 34 d)": {
        "question": "在组织机构树中下述对象分别表示什么内容？（d）一个顶点的祖先",
        "answer": "顶点的祖先是从上到下到该顶点的所有上级。",
        "answer_symbols": []
    },
    "11.1 34 e)": {
        "question": "在组织机构树中下述对象分别表示什么内容？（e）一个顶点的后代",
        "answer": "顶点的后代是该顶点最终管理的所有人（直接或间接）。",
        "answer_symbols": []
    },
    "11.1 34 f)": {
        "question": "在组织机构树中下述对象分别表示什么内容？（f）一个顶点的层数",
        "answer": "顶点的层级是从组织顶部到该顶点的距离。",
        "answer_symbols": []
    },
    "11.1 34 g)": {
        "question": "在组织机构树中下述对象分别表示什么内容？（g）一棵树的高度",
        "answer": "树的高度是结构的深度。",
        "answer_symbols": []
    },
    "11.1 35 a)": {
        "question": "对表示计算机文件系统的有根树，回答与练习 34 所给的那些相同的问题。（a）一个顶点的父母",
        "answer": "父目录",
        "answer_symbols": []
    },
    "11.1 35 b)": {
        "question": "对表示计算机文件系统的有根树，回答与练习 34 所给的那些相同的问题。（b）一个顶点的孩子",
        "answer": "子目录或包含的文件",
        "answer_symbols": []
    },
    "11.1 35 c)": {
        "question": "对表示计算机文件系统的有根树，回答与练习 34 所给的那些相同的问题。（c）一个顶点的兄弟",
        "answer": "同一父目录下的子目录或包含的文件",
        "answer_symbols": []
    },
    "11.1 35 d)": {
        "question": "对表示计算机文件系统的有根树，回答与练习 34 所给的那些相同的问题。（d）一个顶点的祖先",
        "answer": "路径名中的所有目录",
        "answer_symbols": []
    },
    "11.1 35 e)": {
        "question": "对表示计算机文件系统的有根树，回答与练习 34 所给的那些相同的问题。（e）一个顶点的后代",
        "answer": "此目录或其子目录中的所有子目录和文件，依此类推",
        "answer_symbols": []
    },
    "11.1 35 f)": {
        "question": "对表示计算机文件系统的有根树，回答与练习 34 所给的那些相同的问题。（f）一个顶点的层数",
        "answer": "到此目录或文件的路径长度",
        "answer_symbols": []
    },
    "11.1 35 g)": {
        "question": "对表示计算机文件系统的有根树，回答与练习 34 所给的那些相同的问题。（g）一棵树的高度",
        "answer": "系统的深度，即最长路径的长度",
        "answer_symbols": []
    },
    "11.1 36 a)": {
        "question": "画出表示 15 个处理器的树形连接网络的有 15 个顶点的完全二叉树。",
        "answer": "我们只需在图12的树中再加一行，得到以下树。",
        "answer_symbols": []
    },
    "11.1 36 b)": {
        "question": "说明如何用 a) 中的 15 个处理器分四步求 16 个数之和。",
        "answer": "在第一步中，我们使用网络的最底层将x1+x2, x3+x4, x5+x6, ..., x15+x16相加。在第二步中，我们使用上一行将第一步计算的结果相加，即(x1+x2)+(x3+x4)，(x5+x6)+(x7+x8)，...，(x13+x14)+(x15+x16)。第三步使用第二步获得的和，树的第二行的两个处理器执行(x1+x2+x3+x4)+(x5+x6+x7+x8)和(x9+x10+x11+x12)+(x13+x14+x15+x16)。最后，在第四步中，根处理器将这两个量相加以获得所需的总和。",
        "answer_symbols": [
            "+",
            "(",
            ")"
        ]
    },
    "11.1 37": {
        "question": "设 n 是 2 的幂。证明：可以用 n-1 个处理器的树形连接网络在 log n 步中求出 n 个数之和。",
        "answer": "设n = 2k，其中k是正整数。如果k = 1，则无需证明，因为我们可以在log 2 = 1步中使用n - 1 = 1个处理器相加两个数。假设我们可以用n = 2k个数在log n步中使用n - 1个处理器组成的树形网络相加。设x1, x2, ..., x2n是2n = 2^(k+1)个数，我们希望相加。由n - 1个处理器组成的树形网络加上每个叶子节点的两个新处理器组成2n - 1个处理器的树形网络。在一步中，我们可以使用较大网络的叶子节点找到x1 + x2, x3 + x4, ..., x2n-1 + x2n，给出我们n个数，根据归纳假设，我们可以用剩余的网络在log n步中相加这些数。因为我们用了log n + 1步，而log(2n) = log 2 + log n = 1 + log n，这完成了证明。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "*",
            "/",
            "^",
            "log"
        ]
    },
    "11.1 38": {
        "question": "标记树是其中每个顶点都指定了标记的树。当在两个标记树之间存在保持顶点标记的同构时，就把这两个标记树当做同构的。用集合 {1, 2, 3} 中 3 个不同的数来标记 3 个顶点的、非同构的标记树有多少种？用集合 {1, 2, 3, 4} 里 4 个不同的数来标记四个顶点的、非同构的标记树有多少种？",
        "answer": "对于n = 3，只有一种树可以考虑，即长度为2的简单路径。有3种选择来标记路径中间的位置，一旦这个选择确定，带标签的树就确定了同构性。因此，有3个带有3个顶点的带标签的树。对于n = 4，树可能有两种结构。如果它是一个长度为3的简单路径，则有12种不同的标记方法；这是因为从1到4的整数有P(4, 4) = 4! = 24种排列方式，但一个排列及其逆序会导致相同的带标签的树。如果树的结构是K1,3，则唯一的选择是将哪个标签放在与另外三个相邻的顶点上，所以有4棵树。因此，总共有16个带有4个顶点的带标签的树。实际上，有一个定理指出，具有n个顶点的带标签的树的数量是n^(n-2)对所有n ≥ 2。",
        "answer_symbols": [
            "=",
            "!",
            "^",
            "(",
            ")",
            ","
        ]
    },
    "11.1 39": {
        "question": "在包含总共 n 个顶点的 t 棵树的森林中有多少条边？",
        "answer": "只有c",
        "answer_symbols": []
    },
    "11.1 40": {
        "question": "在包含总共 n 个顶点的 t 棵树的森林中有多少条边？",
        "answer": "顶点e的离心率是3，并且它是唯一具有如此小离心率的顶点。因此，e是唯一的中心。",
        "answer_symbols": []
    },
    "11.1 41": {
        "question": "在包含总共 n 个顶点的 t 棵树的森林中有多少条边？",
        "answer": "c和h",
        "answer_symbols": []
    },
    "11.1 42": {
        "question": "证明：为了从无根树产生高度最小的有根树，就应当选择中心来作为根。",
        "answer": "由于树的高度是从根到另一个顶点的最大距离，这从中心的定义中是显而易见的。",
        "answer_symbols": []
    },
    "11.1 43": {
        "question": "证明：树有一个中心或两个相邻的中心。",
        "answer": "假设树T至少有两个中心。设u和v是不同的中心，都具有偏心率e，且u和v不相邻。因为T是连通的，所以存在一条从u到v的简单路径P。设c是这条路径上的任意其他顶点。因为c的偏心率至少为e，所以存在一个顶点w，使得从c到w的唯一简单路径长度至少为e。显然，这条路径不能同时包含u和v，否则就会有一个简单回路。实际上，从c到w的路径离开P并且一旦它沿着P朝向u或v的部分移动就不会返回P。不失一般性，假设这条路径不沿P朝向u。那么从u到c再到w的路径是简单的且长度超过e，这是一个矛盾。因此，u和v是相邻的。现在因为任意两个中心都是相邻的，如果有超过两个中心，T将包含K3作为子图，这是矛盾的。",
        "answer_symbols": [
            "≠",
            "→",
            "∨",
            "∧",
            "¬"
        ]
    },
    "11.1 44": {
        "question": "证明：每一棵树都可以用两种颜色来着色。",
        "answer": "我们选择一个根并将其涂成红色。然后我们将所有奇数层的顶点涂成蓝色，所有偶数层的顶点涂成红色。",
        "answer_symbols": []
    },
    "11.1 45": {
        "question": "画出前 7 个有根的斐波那契树。",
        "answer": "T1 T2 T3 T4 T5 T6 T7",
        "answer_symbols": []
    },
    "11.1 46": {
        "question": "有根的斐波那契树 Tn 有多少个顶点、树叶和内点？其中 n 是正整数。它的高度是多少？",
        "answer": "树Tn中的顶点数满足递推关系vn = vn-1 + vn-2 + 1（“+1”是为了根），初始条件v1 = v2 = 1。因此，序列开始为1, 1, 3, 5, 9, 15, 25,...。通过归纳法很容易证明vn = 2fn - 1，其中fn是第n个斐波那契数。叶节点数满足递推关系ln = ln-1 + ln-2，初始条件l1 = l2 = 1，所以ln = fn。由于in = vn - ln，我们有in = fn - 1。最后，很明显，树Tn的高度比树Tn-1的高度多1，对于n ≥ 3，T2的高度为0。因此，对于所有n ≥ 2，Tn的高度为n - 2（当然，T1的高度为0）。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "(",
            ")",
            ","
        ]
    },
    "11.1 47": {
        "question": "下面这个使用数学归纳法的“证明”错在什么地方？命题：有 n 个顶点的每棵树都有长度为 n-1 的通路。基础步骤：有 1 个顶点的每棵树显然有长度为 0 的通路。归纳步骤：假设有 n 个顶点的树有长度为 n-1 的通路，且这个通路以 u 作为终点。加入顶点 v 和从 u 到 v 的边。所得出的树有 n+1 个顶点并且有长度为 n 的通路。这样就完成了归纳步骤。",
        "answer": "这个命题是每个有n个顶点的树都有长度为n-1的路径，但仅证明了存在一个有n个顶点的树具有长度为n-1的路径。",
        "answer_symbols": []
    },
    "11.1 48": {
        "question": "证明：有 n 个顶点的二叉树中，树叶的平均深度是 Ω(logn)。",
        "answer": "设T是一棵具有n个顶点的树，高度为h。如果T在小于h - 1的任何内部顶点处没有两个子节点，取一个位于层次h的叶子并将其移动到这样的缺失子节点处。这只会降低该树中叶子的平均深度，由于我们试图证明的是叶子平均深度的下界，因此只需证明结果树的下界即可。重复此过程直到没有更多此类内部顶点。结果，所有叶子现在都在层次h - 1和h。现在删除所有位于层次h的顶点。这最多改变顶点数的一半（或更少），因此对大Ω估计没有影响（它仅改变log n最多1）。现在树是完整的，根据练习28，它有2^(h-1)个叶子，所有叶子都在深度h - 1，此时n = 2^h - 1。所需的估计随之而来。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "(",
            ")",
            "^",
            ","
        ]
    },
    "11.2 1": {
        "question": "用字母顺序建立下面这些单词的二叉搜索树：banana、peach、apple、pear、coconut、mango 和 papaya。",
        "answer": "banana apple coconut peach pear mango papaya",
        "answer_symbols": []
    },
    "11.2 2": {
        "question": "用字母顺序建立下面这些单词的二叉搜索树：oenology、phrenology、campanology、ornithology、ichthyology、limnology、alchemy 和 astrology。",
        "answer": "我们把第一个词作为根。因为第二个词按字母顺序紧跟在第一个词之后，我们把它作为根的右孩子。同样，第三个词是根的左孩子。为了放置下一个词，ornithology，我们从根向右移动，因为它按字母顺序紧跟在根之后，然后从phrenology向左移动，因为它在这词之前。其余的树以类似的方式构建。",
        "answer_symbols": []
    },
    "11.2 5": {
        "question": "用字母顺序构造下面句子里的单词的二叉搜索树：“The quick brown fox jumps over the lazy dog”。",
        "answer": "the quick brown fox dog jumps over lazy",
        "answer_symbols": []
    },
    "11.2 6": {
        "question": "为了在 4 枚硬币中找出一枚较轻的伪币，需要用天平称多少次？描述用这些次数的称重来找出这枚伪币的算法。",
        "answer": "决策树理论告诉我们至少需要 ⌈log3 4⌉ = 2 次称重。实际上，我们可以轻松实现这一结果。首先将前两枚硬币进行比较。如果有一枚较轻，则它是假币。如果平衡，那么我们再比较另外两枚硬币，较轻的一枚是假币。",
        "answer_symbols": [
            "⌈",
            "⌉",
            "log",
            "="
        ]
    },
    "11.2 7": {
        "question": "若一枚伪币与其他硬币质量不等，那么为了在 4 枚硬币中找出这枚伪币，需要用天平称多少次？描述用同样的称重次数来找出这枚伪币的算法。",
        "answer": "至少需要 ⌊log3 4⌋ = 2 次称重，因为只有四种结果（因为不需要确定硬币是轻还是重）。实际上，两次称重就足够了。首先称量硬币1和硬币2。如果它们平衡，再称量硬币1和硬币3。如果硬币1和硬币3重量相同，硬币4是假币；如果它们重量不同，则硬币3是假币。如果硬币1和硬币2重量不同，再次称量硬币1和硬币3。如果它们平衡，硬币2是假币；如果不平衡，硬币1是假币。",
        "answer_symbols": [
            "⌊",
            "⌋",
            "log",
            "=",
            "≠",
            ">",
            "<",
            "→",
            "∧",
            "∨",
            "¬",
            "∀",
            "∃",
            "⊆",
            "∈",
            "∪",
            "∩",
            "−",
            "∅",
            "≤",
            "≥",
            "=",
            "+",
            "−",
            "*",
            "/",
            "^",
            "√",
            "∑",
            "∏",
            "∫",
            "∂",
            "∇",
            "∈",
            "∉",
            "∋",
            "∌",
            "⊆",
            "⊇",
            "⊂",
            "⊃",
            "⊄",
            "⊅",
            "∪",
            "∩",
            "∧",
            "∨",
            "¬",
            "⇒",
            "⇔",
            "∀",
            "∃",
            "∴",
            "∵",
            "∷",
            "≈",
            "≠",
            "≡",
            "≤",
            "≥",
            "<",
            ">",
            "±",
            "∓",
            "×",
            "÷",
            "⋅",
            "∗",
            "∘",
            "∙",
            "√",
            "∛",
            "∜",
            "∝",
            "∞",
            "∟",
            "∠",
            "∡",
            "∢",
            "∣",
            "∤",
            "∥",
            "∦"
        ]
    },
    "11.2 8": {
        "question": "若一枚伪币与其他硬币质量不等，或者轻或者重，那么为了在 8 枚硬币中找出这枚伪币，需要用天平称多少次？描述用同样的称重次数来找出这枚伪币的算法。",
        "answer": "从决策树理论来看，至少需要 ⌈log3 8⌉ = 2 次称重，但实际上至少需要 3 次称重。为了看到这一点，考虑第一次称重可能达到的效果。我们可以在每个盘子里放一枚、两枚或三枚硬币进行第一次称重（其他安排不会提供任何信息）。如果我们每个盘子里放一枚或两枚硬币，并且天平平衡，那么我们只知道假币在剩下的六枚或四枚硬币中。如果我们每个盘子里放三枚硬币，并且天平不平衡，那么我们基本上只知道假币在参与称重的六枚硬币中。在每种情况下，我们都将搜索范围缩小到超过三枚硬币，因此再多一次称重无法找到假币（因为一次称重只有三种可能的结果）。接下来我们必须展示如何用三次称重解决问题。每个盘子里放两枚硬币。如果天平平衡，那么搜索范围缩小到另外四枚硬币。如果天平不平衡，那么假币在天平上的四枚硬币中。在这两种情况下，我们然后应用练习 7 的解决方案，再进行两次称重找到假币。",
        "answer_symbols": [
            "⌈",
            "⌉",
            "log",
            "=",
            "<"
        ]
    },
    "11.2 9": {
        "question": "若一枚伪币比其他硬币较轻，那么为了在 12 枚硬币中找出这枚伪币，需要用天平称多少次？描述用同样的称重次数来找出这枚伪币的算法。",
        "answer": "至少需要 ⌊log3 13⌋ = 3 次称重。实际上，三次称重就足够了。首先将硬币1、2和3放在天平的左侧，将硬币4、5和6放在右侧。如果平衡，将硬币1、2、7、8、9、10、11和12应用例3。如果不平衡，将硬币1、2、3、4、5、6、7和8应用例3。",
        "answer_symbols": [
            "⌊",
            "⌋",
            "log",
            "=",
            "≠",
            ">",
            "<",
            "→",
            "∧",
            "∨",
            "¬",
            "∀",
            "∃",
            "⊆",
            "∈",
            "∪",
            "∩",
            "−",
            "∅",
            "≤",
            "≥",
            "=",
            "+",
            "−",
            "*",
            "/",
            "^",
            "√",
            "∑",
            "∏",
            "∫",
            "∂",
            "∇",
            "∈",
            "∉",
            "∋",
            "∌",
            "⊆",
            "⊇",
            "⊂",
            "⊃",
            "⊄",
            "⊅",
            "∪",
            "∩",
            "∧",
            "∨",
            "¬",
            "⇒",
            "⇔",
            "∀",
            "∃",
            "∴",
            "∵",
            "∷",
            "≈",
            "≠",
            "≡",
            "≤",
            "≥",
            "<",
            ">",
            "±",
            "∓",
            "×",
            "÷",
            "⋅",
            "∗",
            "∘",
            "∙",
            "√",
            "∛",
            "∜",
            "∝",
            "∞",
            "∟",
            "∠",
            "∡",
            "∢",
            "∣",
            "∤",
            "∥",
            "∦"
        ]
    },
    "11.2 10": {
        "question": "4 枚硬币中一枚可能是伪币。伪币与其他硬币质量不等，或者轻或者重。那么为了确定是否有一个伪币，若有伪币，确定它是比其他硬币较重还是较轻，使用一台天平称，需要称多少次？描述用同样的称重次数来找出这枚伪币并且确定它是较轻还是较重的算法。",
        "answer": "这里有九种可能的结果：要么没有假币，要么我们需要指定一枚硬币（4 种选择）和一种类型（较轻或较重）。决策树理论让我们希望也许只需要两次称重，但我们声称仅凭两次称重是不够的。假设第一次称重涉及每个盘子两枚硬币。如果天平平衡，那么我们知道没有假币，后续的称重不会增加任何信息。因此，我们只有六种可能的决定（每种其他两种结果各三种）来区分其他八种可能的结果，这是不可能的。因此，假设第一次称重将硬币 A 与硬币 B 对比。如果天平平衡，那么我们知道假币（如果有）在另外两枚硬币中。现在我们必须在下一次称重中分开硬币 C 和 D，如果这次称重要决定性的话，所以这次称重相当于将 C 与 D 对比。如果天平不平衡，那么我们还没有解决问题。我们给出一个使用三次称重的解决方案。将硬币 A 与硬币 B 称重。如果它们不平衡，那么不失一般性地假设硬币 A 较轻（相反的结果处理方式类似）。然后将硬币 A 与硬币 C 称重。如果它们平衡，那么我们知道硬币 B 是假币且较重。如果它们不平衡，那么我们知道 A 是假币且较轻。剩下的情况是硬币 A 和 B 平衡。此时我们将 C 与 D 进行比较。如果它们平衡，那么我们得出结论没有假币。如果它们不平衡，那么再进行一次称重，例如将较轻的那个与 A 进行称重，就像在 A 和 B 不平衡的情况下一样解决这个问题。",
        "answer_symbols": [
            "<",
            ">"
        ]
    },
    "11.2 11": {
        "question": "求排序 4 个元素所需要的最少比较次数并且设计一个能够依此次数实现的算法。",
        "answer": "最小的数字是五。设元素为a、b、c和d。首先比较a和b；然后比较c和d。不失一般性，假设a < b且c < d。接下来比较a和c。较小的那个是集合中的最小元素。再次不失一般性，假设a < c。最后，比较b与c和d以完全确定排序。",
        "answer_symbols": [
            "<",
            ">",
            "="
        ]
    },
    "11.2 12": {
        "question": "求排序 5 个元素所需要的最少比较次数并且设计一个能够依此次数实现的算法。",
        "answer": "根据本节中的定理 1，至少需要 ⌈log 5!⌉ 次比较。由于 log₂ 120 ≈ 6.9，至少需要七次比较。我们可以通过七次比较完成排序，具体如下。称这些元素为 a、b、c、d 和 e。首先比较 a 和 b；并比较 c 和 d。不失一般性地假设 a < b 且 c < d（如果不是这样，那么在这次比较后重新标记这些元素）。接下来我们比较 b 和 d（这是我们第三次比较），再次必要时重新标记这四个元素以确保 b < d。因此，在三次比较后，我们有 a < b < d 和 c < d。我们通过二分查找将 e 插入 a、b 和 d 中的适当位置，即先将 e 与 b 比较，然后再与 a 或 d 比较。因此，我们进行了五次比较并获得了 a、b、d 和 e 之间的线性顺序。Knowing one more piece of information about the location of c, namely either that it is less than the largest among a, b, d, and e, or that it is less than the second largest. (Drawing a diagram helps here.) In any case, it then suffices to insert c into its correct position among the three smallest members of a, b, d, and e, which requires two more comparisons (binary search), bringing the total to the desired seven.\n",
        "answer_symbols": [
            "!",
            "⌈",
            "<",
            "⌉",
            "≈",
            "log"
        ]
    },
    "11.2 13": {
        "question": "完成列表 22、8、14、17、3、9、27、11 的竞赛图排序。说明在每个步骤上顶点的标记。",
        "answer": "前两步在文本中显示。在22被识别为第二大的元素后，我们将树中的叶节点22替换为-∞并重新计算从22所在的叶节点到根节点的路径上的获胜者。接下来，我们看到17是第三大的元素，因此我们重复这个过程：将叶节点17替换为-∞并重新计算。接下来，我们看到14是第四大的元素，因此我们重复这个过程：将叶节点14替换为-∞并重新计算。接下来，我们看到11是第五大的元素，因此我们重复这个过程：将叶节点11替换为-∞并重新计算。这个过程继续进行。我们确定9是第六大的元素，8是第七大的元素，3是第八大的元素。除了倒数第二个步骤外，所有步骤中生成的树都显示在这里。",
        "answer_symbols": [
            "-",
            "∞"
        ]
    },
    "11.2 15": {
        "question": "用伪码描述竞赛图排序。",
        "answer": "顶点的值是当前在那里列表元素，标签是负责该值的叶子的位置。 procedure tournament sort(a1, ..., an) k := ⌊log n⌋ 构建高度为k的二叉树 for i := 1 to n 设置第i个叶子的值为a_i和其标签为其自身 for i := n + 1 to 2^k 设置第i个叶子的值为-∞和其标签为其自身 for i := k - 1 downto 0 对每个层级i的顶点v 设置v的值为其子节点值较大的一个，并将其标签设置为较大值子节点的标签 for i := 1 to n c_i := 根节点的值 令v为根节点的标签 将v的值设置为-∞ 当根节点的标签仍为v时 v := v的父节点 设置v的值为其子节点值较大的一个，并将其标签设置为较大值子节点的标签 {c1, ..., cn 是按非递增顺序排列的列表}",
        "answer_symbols": [
            "⌊",
            "⌋",
            "^",
            ":",
            "=",
            "-",
            "∞",
            ">",
            "<"
        ]
    },
    "11.2 16": {
        "question": "假设对于某个正整数 k 来说，待排序元素的个数 n 等于 2^k，若使用竞赛图排序来求这个列表的最大元素，确定竞赛图排序所用的比较次数。",
        "answer": "每次比较会淘汰一个竞争者，需要淘汰 n - 1 个竞争者，因此确定最大元素需要进行 n - 1 次比较。",
        "answer_symbols": [
            "-",
            "n"
        ]
    },
    "11.2 17": {
        "question": "用竞赛图排序求第二大元素、第三大元素……，直到第 (n-1) 大 (或第二小) 元素所使用的比较次数是多少？",
        "answer": "k - 1, 其中 n = 2^k",
        "answer_symbols": [
            "-",
            "^",
            "="
        ]
    },
    "11.2 18": {
        "question": "证明：竞赛图排序需要 Θ(n log n) 次比较来排序含有 n 个元素的列表。[提示：假设对于某个正整数 k 来说，n=2^k，插入适当数目的哑元，比如 -∞，定义为比所有整数都小。]",
        "answer": "根据提示，我们插入足够的 -∞ 值使 n 成为 2 的幂。这最多会使 n 增加一倍，但不会影响我们在大Θ符号中的最终答案。通过练习 16 我们可以使用 n - 1 次比较构建初始树。通过练习 17，每一轮之后识别下一个最大元素需要 k = log n 次比较。有 n - 1 轮额外的比赛，因此这些轮次的总工作量是 (n - 1) log n。因此，总的比较次数是 n - 1 + (n - 1) log n，这是 Θ(n log n)。",
        "answer_symbols": [
            "-",
            "∞",
            "2",
            "log",
            "n",
            "Θ"
        ]
    },
    "11.2 19 a)": {
        "question": "下面哪些编码是前缀码？a) a: 11, e: 00, t: 10, s: 01",
        "answer": "Yes",
        "answer_symbols": []
    },
    "11.2 19 b)": {
        "question": "下面哪些编码是前缀码？b) a: 0, e: 1, t: 01, s: 001",
        "answer": "No",
        "answer_symbols": []
    },
    "11.2 19 c)": {
        "question": "下面哪些编码是前缀码？c) a: 101, e: 11, t: 001, s: 011, n: 010",
        "answer": "Yes",
        "answer_symbols": []
    },
    "11.2 19 d)": {
        "question": "下面哪些编码是前缀码？d) a: 010, e: 11, t: 011, s: 1011, n: 1001, i: 10101",
        "answer": "Yes",
        "answer_symbols": []
    },
    "11.2 21": {
        "question": "若编码方案是用下面的树来表示，那么什么是 a、e、i、k、o、p 和 u 的编码？\n0\n/ \\\n0 1\n/ \\\n0 1\n/ \\\na e\n\\\n0\n/ \\\nk o\n\\\n0\n/ \\\np u",
        "answer": "a: 000, e: 001, i: 01, k: 1100, o: 1101, p: 11110, u: 11111",
        "answer_symbols": [
            ":",
            ","
        ]
    },
    "11.2 22 a)": {
        "question": "给定编码方案 a: 001, b: 0001, e: 1, r: 0000, s: 0100, t: 011, x: 01010，找出用下面的位串来表示的单词。a)01110100011",
        "answer": "前三个比特解码为 t。下一个比特解码为 e。接下来的四个比特解码为 s。最后三个比特解码为 t。因此单词是 test。其余部分类似，所以我们只给出答案。",
        "answer_symbols": []
    },
    "11.2 22 b)": {
        "question": "给定编码方案 a: 001, b: 0001, e: 1, r: 0000, s: 0100, t: 011, x: 01010，找出用下面的位串来表示的单词。b)0001110000",
        "answer": "beer",
        "answer_symbols": []
    },
    "11.2 22 c)": {
        "question": "给定编码方案 a: 001, b: 0001, e: 1, r: 0000, s: 0100, t: 011, x: 01010，找出用下面的位串来表示的单词。c)0100101010",
        "answer": "sex",
        "answer_symbols": []
    },
    "11.2 22 d)": {
        "question": "给定编码方案 a: 001, b: 0001, e: 1, r: 0000, s: 0100, t: 011, x: 01010，找出用下面的位串来表示的单词。d)01100101010",
        "answer": "tax",
        "answer_symbols": []
    },
    "11.2 23": {
        "question": "用哈夫曼编码来编码具有给定频率的如下符号：a：0.20，b：0.10，c：0.15，d：0.25，e：0.30。编码一个符号所需要的平均位数是多少？",
        "answer": "a: 11; b: 101; c: 100; d: 01; e: 00; 2.25 bits (注意: 这种编码取决于如何解决平局，但平均位数总是相同的。)",
        "answer_symbols": [
            ":",
            ";",
            "."
        ]
    },
    "11.2 24": {
        "question": "用哈夫曼编码来编码具有给定频率的如下符号：A：0.10，B：0.25，C：0.05，D：0.15，E：0.30，F：0.07，G：0.08。编码一个符号所需要的平均位数是多少？",
        "answer": "我们遵循算法 2。由于 F 和 C 是权重最小的符号，它们被组合成一个子树，我们称之为 T1，权重为 0.07 + 0.05 = 0.12，较大的权重符号 F 在左边。现在两个权重最小的树是单个符号 A 和 G，因此我们得到一个左子树为 A 右子树为 G 的树 T2，权重为 0.18。下一步是将 D 和 T1 组合成一个子树 T3，权重为 0.27。然后 B 和 T2 形成 T4，权重为 0.43；E 和 T3 形成 T5，权重为 0.57。最后一步是将 T5 和 T4 组合。结果如图所示。通过查看树，我们看到 A 编码为 110，B 编码为 10，C 编码为 0111，D 编码为 010，E 编码为 00，F 编码为 0110，G 编码为 111。为了计算编码一个字符所需的平均比特数，我们将每个字母的比特数乘以该字母的权重并相加。因为 A 需要 3 个比特且权重为 0.10，所以它对总和的贡献为 0.30。同样地，B 贡献 2 * 0.25 = 0.50。总共我们得到 3 * 0.10 + 2 * 0.25 + 4 * 0.05 + 3 * 0.15 + 2 * 0.30 + 4 * 0.07 + 3 * 0.08 = 2.57。因此，平均来说，每个字符需要 2.57 个比特。注意这是一个适当加权的平均值，按字母出现的频率加权。",
        "answer_symbols": [
            "+",
            "=",
            "*",
            "."
        ]
    },
    "11.2 25": {
        "question": "为如下符号和频率构造两个不同的哈夫曼编码：t：0.2，u：0.3，v：0.2，w：0.3。",
        "answer": "总共有四个可能的答案，其中一个是这里所示的，另外三个是从这个答案通过交换t和v和/或交换u和w得到的。 0 0 1 0 1 t v u w 1",
        "answer_symbols": [
            "=",
            "≠",
            ">",
            "<",
            "→",
            "↔"
        ]
    },
    "11.2 26 a)": {
        "question": "以两种不同的方式用哈夫曼编码来编码具有这些频率的符号：a：0.4，b：0.2，c：0.2，d：0.1，e：0.1，在算法中用不同的方式打破平局。第一种，在算法的每个阶段从权最小的树中选择顶点数最多的两个树来组合。",
        "answer": "首先我们将 e 和 d 组合成一个权重为 0.2 的树 T1。然后使用规则选择 T1 和 c 组合成一个权重为 0.4 的树 T2。再次使用规则，必须将 T2 和 b 组合成权重为 0.6 的 T3，最后 T3 和 a。这给出了代码 a:1, b:01, c:001, d:0001, e:0000。对于另一种方法，我们首先将 d 和 e 组合成一个权重为 0.2 的树 T1。接下来我们组合 b 和 c（权重最小的树）。",
        "answer_symbols": [
            "+",
            "=",
            "."
        ]
    },
    "11.2 26 b)": {
        "question": "计算用每种编码来编码一个符号所需要的平均位数并且对每种编码计算这个位数的方差。对于编码一个符号所需要的位数的方差，哪种打破平局的过程所产生的会小一些？",
        "answer": "第一种方法的平均值是 1 * 0.4 + 2 * 0.2 + 3 * 0.2 + 4 * 0.1 + 4 * 0.1 = 2.2，第二种方法的平均值是 2 * 0.4 + 2 * 0.2 + 2 * 0.2 + 3 * 0.1 + 3 * 0.1 = 2.2。当然，我们事先就知道这些结果会相等，因为哈夫曼算法最小化了期望比特数。对于方差，我们使用公式V(X) = E(X^2) - E(X)^2。对于第一种方法，比特数平方的期望值是 1^2 * 0.4 + 2^2 * 0.2 + 3^2 * 0.2 + 4^2 * 0.1 + 4^2 * 0.1 = 6.2，对于第二种方法，它是 2^2 * 0.4 + 2^2 * 0.2 + 2^2 * 0.2 + 3^2 * 0.1 + 3^2 * 0.1 = 5.0。因此，第一种方法的方差为 6.2 - 2.2^2 = 1.36，第二种方法的方差为 5.0 - 2.2^2 = 0.16。在这个例子中，第二种方法的方差更小。",
        "answer_symbols": [
            "*",
            "+",
            "-",
            "^"
        ]
    },
    "11.2 27": {
        "question": "为英文字母表的字母构造哈夫曼编码，其中典型英文文本中字母的频率如下表所示。| 字母 | 频率 | 字母 | 频率 ||------|------|------|------|| A | 0.0817 | N | 0.0662 || B | 0.0145 | O | 0.0781 || C | 0.0248 | P | 0.0156 || D | 0.0431 | Q | 0.0009 || E | 0.1232 | R | 0.0572 || F | 0.0209 | S | 0.0628 || G | 0.0182 | T | 0.0905 || H | 0.0668 | U | 0.0304 || I | 0.0689 | V | 0.0102 || J | 0.0010 | W | 0.0264 || K | 0.0080 | X | 0.0015 || L | 0.0397 | Y | 0.0211 || M | 0.0277 | Z | 0.0005 |",
        "answer": "A:0001; B:101001; C:11001; D:00000; E:100; F:001100; G:001101; H:0101; I:0100; J:110100101; K:1101000; L:00001; M:10101; N:0110; O:0010; P:101000; Q:1101001000; R:1011; S:0111; T:111; U:00111; V:110101; W:11000; X:11010011; Y:11011; Z:1101001001",
        "answer_symbols": [
            ":",
            ";",
            ","
        ]
    },
    "11.2 28": {
        "question": "用伪码描述 m 叉哈夫曼编码算法。",
        "answer": "伪代码与算法2相同，但有以下变化。首先，需要指定m的值，通常作为输入的一部分。在while循环开始之前，我们选择具有最小权重的k=((N-1) mod (m-1)) + 1个顶点，并用一个新的根节点替换它们，这个新根节点的子节点从左到右依次是这k个顶点，按权重从大到小排序，边上的标签从0到k-1，权重是这k个顶点的权重之和。在循环内，而不是替换两个权重最小的树，我们找到m个权重最小的树，删除它们并形成一个新树，新树的新根节点的子节点从左到右依次是这m棵树的根节点，按权重从大到小排序，边上的标签从0到m-1，权重是这m棵原树的权重之和。",
        "answer_symbols": [
            "=",
            "+",
            "-",
            "*",
            "mod"
        ]
    },
    "11.2 29": {
        "question": "使用符号 0、1 和 2，用三叉 (m=3) 哈夫曼编码来编码具有给定频率的这些字母：A：0.25，E：0.30，N：0.10，R：0.05，T：0.12，Z：0.18。",
        "answer": "A:2; E:1; N:010; R:011; T:02; Z:00",
        "answer_symbols": [
            ":",
            ";",
            ","
        ]
    },
    "11.2 30 a)": {
        "question": "为这三个符号构造哈夫曼编码。",
        "answer": "使用哈夫曼编码算法构建这棵树非常简单，如前几道练习所示。我们得到A:0, B:10, C:11。",
        "answer_symbols": [
            ":",
            ","
        ]
    },
    "11.2 30 b)": {
        "question": "通过把两个符号的块 AA、AB、AC、BA、BB、BC、CA、CB 和 CC 分组，形成 9 个符号的一个新的集合。为这 9 个符号构造哈夫曼编码，假设在原始文本中符号的出现是独立的。",
        "answer": "新符号的频率为AA:0.6400, AB:0.1520, AC:0.0080, BA:0.1520, BB:0.0361, BC:0.0019, CA:0.0080, CB:0.0019, CC:0.0001。我们通过算法形成树并获得此编码：AA:0, AB:11, AC:10111, BA:100, BB:1010, BC:1011011, CA:101100, CB:10110100, CC:10110101。",
        "answer_symbols": [
            ":",
            ","
        ]
    },
    "11.2 30 c)": {
        "question": "比较 a) 中三个符号的哈夫曼编码与 b) 构造的 9 个双符号块的哈夫曼编码来编码文本所需要的平均位数。哪一种编码方式更有效？",
        "answer": "第一部分的每个符号的平均比特数为 1 * 0.80 + 2 * 0.19 + 2 * 0.01 = 1.2000。第二部分的每个符号的平均比特数为 1 * 0.6400 + 2 * 0.1520 + 5 * 0.0080 + 3 * 0.1520 + 4 * 0.0361 + 7 * 0.0019 + 6 * 0.0080 + 8 * 0.0019 + 8 * 0.0001 = 1.6617，用于发送两个符号，因此每个符号的比特数为0.83085。第二种方法更有效。",
        "answer_symbols": [
            "*",
            "+",
            "="
        ]
    },
    "11.2 31": {
        "question": "给定 n+1 个符号 x1，x2，…，xn，xn+1，它们在一个符号串中分别出现 1，f1，f2，…，fn 次，其中 fj 是第 j 个斐波那契数。当在哈夫曼编码算法的每个阶段考虑所有可能的打破平局的选择时，用来编码一个符号的最大位数是多少？",
        "answer": "n",
        "answer_symbols": []
    },
    "11.2 32": {
        "question": "证明：对于所有的二叉前缀码来说，如果使用最少的位来表示一个符号串，哈夫曼编码是最优的。",
        "answer": "我们通过归纳法证明这一点。如果有两个符号，则无需证明，所以假设归纳假设是Huffman码对k个符号是最优的，考虑有k+1个符号的情况。首先注意，由于树是满的，最底层的叶子成对出现。设a和b是频率最小的两个符号，其频率分别为pₐ和pₔ。如果在某些二进制前缀码中它们在最底层不是成对出现的，那么我们可以通过交换一些叶子上的符号来获得至少同样有效的编码（因为将出现频率更高的符号移近根节点只会更好）。因此我们可以假设在每一个最优树中a和b都是兄弟节点。现在假设我们将它们视为一个新的符号c，其出现频率等于a和b的频率之和，并应用归纳假设通过哈夫曼算法获得k个符号的最优二进制前缀码Hₖ。注意，这相当于对k+1个符号应用哈夫曼算法，得到的编码我们称之为Hₖ₊₁。我们必须证明Hₖ₊₁对k+1个符号是最优的。注意，Hₖ和Hₖ₊₁中编码一个符号所需的平均比特数相同，除了符号a、b和c，差异为pₐ + pₔ（因为a和b比c多需要一个额外的比特，而其他所有编码词都相同）。如果Hₖ₊₁不是最优的，设Hₖ′₊₁是一个更好的编码（平均每个符号的比特数更少）。由上述观察可知，我们可以在Hₖ′₊₁中假设a和b在最底层是兄弟节点。然后，通过将a和b替换为其父节点（并删除）获得的k个符号的编码Hₖ′。最后一位（last bit）的平均位数等于 Hk′+1 的平均位数减去 pa + pb，这与归纳假设 Hk 是最优的相矛盾。",
        "answer_symbols": [
            "=",
            ")",
            "(",
            "≠",
            ",",
            "+"
        ]
    },
    "11.2 33": {
        "question": "画出取石子游戏的博弈树，假设开局包括分别有 2 块和 3 块石头的两堆石头。在画这棵树的时候，用同一个顶点表示相同移动所导致的对称局面。求出这个博弈树每个顶点的值。如果两个选手都遵循最优策略，则哪个选手获胜？",
        "answer": "因为树相当大，我们在某些地方标示了“见文本”。参见图9；这些正方形或圆形顶点的根子树与图9中对应的子树完全相同。先手玩家赢。",
        "answer_symbols": []
    },
    "11.2 34": {
        "question": "画出取石子游戏的博弈树，假设开局包括分别有 1 块、2 块和 3 块石头的三堆石头。在画这棵树的时候，用同一个顶点表示相同移动所导致的对称局面。求出这棵博弈树每个顶点的值。如果两个选手都遵循最优策略，则哪个选手获胜？",
        "answer": "第一个玩家有六个选择，如下所示。在其中五种情况下，从那一点开始的分析已经在课本中的图 9 或练习 33 的解答中完成，因此我们不会完全显示子树，而只是指出其值。请注意，如果引用的参考是方顶点而不是圆顶点，则结果相反。从第二层的第五个顶点有四个选择，如下所示，这些选择都已先前分析过。最终结果是，由于第二层的所有顶点都是第二个玩家的胜利（值为 -1），根节点的值也是 -1，第二个玩家总是可以赢得这场比赛。",
        "answer_symbols": [
            "-"
        ]
    },
    "11.2 35 a)": {
        "question": "求第一个选手的得分，假设开局包括：分别有1块和3块石头的两堆石头。",
        "answer": "$1",
        "answer_symbols": [
            "$"
        ]
    },
    "11.2 35 b)": {
        "question": "求第一个选手的得分，假设开局包括：分别有2块和4块石头的两堆石头。",
        "answer": "$3",
        "answer_symbols": [
            "$"
        ]
    },
    "11.2 35 c)": {
        "question": "求第一个选手的得分，假设开局包括：分别有1块、2块和3块石头的三堆石头。",
        "answer": "-$3",
        "answer_symbols": [
            "-",
            "$"
        ]
    },
    "11.2 36": {
        "question": "假设在取石子游戏的一个变种中，允许一个选手要么从一堆取走1块以上的石头，要么把两堆石头合并成一堆，只要至少还剩下一个石头。画出这个游戏变种的博弈树，假设开局由分别含有2块、2块和1块石头的3堆石头组成。求出这棵博弈树中每个顶点的值，并且确定当两个选手都遵循最优策略时哪个选手获胜。",
        "answer": "游戏树太大，无法完整绘制，因此我们通过注意玩家永远不会移动到以下情况来简化分析：两个堆中有一个堆只有一个石头，或一个堆有超过一个石头。如果我们省略这些自杀性的移动，游戏树看起来如下所示。请注意，一个没有子节点或只有自杀性移动的顶点是当前不移动的玩家的胜利。第一个玩家通过移动到位置 2 2 来赢得这场游戏。",
        "answer_symbols": []
    },
    "11.2 37 a)": {
        "question": "画出井字游戏博弈树从下列每个局面开始的子树。确定每个子树的值。O | X | X\nX | O | O\nX | X | X",
        "answer": "0",
        "answer_symbols": []
    },
    "11.2 37 b)": {
        "question": "画出井字游戏博弈树从下列每个局面开始的子树。确定每个子树的值。X | O | X\nO | X | X\nO | X | O",
        "answer": "0",
        "answer_symbols": []
    },
    "11.2 37 c)": {
        "question": "画出井字游戏博弈树从下列每个局面开始的子树。确定每个子树的值。X | O | X\nO | O | X\nX | X | O",
        "answer": "1",
        "answer_symbols": []
    },
    "11.2 37 d)": {
        "question": "画出井字游戏博弈树从下列每个局面开始的子树。确定每个子树的值。O | X | X\nX | O | X\nX | O | X",
        "answer": "这个位置不可能在游戏中出现；这个图是不可能的。",
        "answer_symbols": []
    },
    "11.2 38 a)": {
        "question": "假设井字游戏的前4步移动如下图所示。第一个选手（用X标记其移动）是否总能获胜？X | O | X\nO | X | X\nX | O | X",
        "answer": "第一个玩家通过在这个点中心移动获胜。这阻止了第二个玩家的威胁，并且创建了两个威胁，第二个玩家只能阻挡其中一个。",
        "answer_symbols": []
    },
    "11.2 38 b)": {
        "question": "假设井字游戏的前4步移动如下图所示。第一个选手（用X标记其移动）是否总能获胜？X | O | X\nO | X | X\nX | O | X",
        "answer": "如果双方都采取最佳策略，这场游戏将以平局结束。第一个玩家必须首先阻止第二个玩家的威胁，然后只要第二个玩家在他的第三和第四步中在第一列和第三列移动，第一个玩家就无法获胜。",
        "answer_symbols": []
    },
    "11.2 38 c)": {
        "question": "假设井字游戏的前4步移动如下图所示。第一个选手（用X标记其移动）是否总能获胜？O | X | X\nX | O | X\nX | O | X",
        "answer": "第一个玩家可以通过移动到中间行最右边的方格来获胜。这创建了两个威胁，第二个玩家只能阻挡其中一个。",
        "answer_symbols": []
    },
    "11.2 38 d)": {
        "question": "假设井字游戏的前4步移动如下图所示。第一个选手（用X标记其移动）是否总能获胜？X | O | X\nO | X | X\nX | O | X",
        "answer": "只要双方都不做愚蠢的事情（未能阻挡威胁），这场游戏必定以平局结束，因为接下来的三步是固定的，然后没有任何一行可以包含三个相同的符号。",
        "answer_symbols": []
    },
    "11.2 39": {
        "question": "证明：如果取石子游戏从包含相同数目的两堆石头开始，而且这个数目至少是2，则当两个选手都遵循最优策略时第二个选手获胜。",
        "answer": "强归纳法证明：基础步骤：当每堆有 n=2 个石子时，如果第一个玩家从一堆中取走两个石子，则第二个玩家从剩下的那堆中取走一个石子并获胜。如果第一个玩家从一堆中取走一个石子，则第二个玩家从另一堆中取走两个石子并获胜。归纳步骤：假设归纳假设，即如果游戏开始时每堆有 j 个石子（所有 2 ≤ j ≤ k，其中 k ≥ 2），则第二个玩家总是能赢，并考虑每堆有 k+1 个石子的游戏。如果第一个玩家从一堆中取走所有的石子，则第二个玩家从剩余的一堆中取走除一个以外的所有石子并获胜。如果第一个玩家从一堆中取走除一个以外的所有石子，则第二个玩家取走另一堆中的所有石子并获胜。否则，第一个玩家在一堆中留下 j 个石子（2 ≤ j ≤ k），而在另一堆中留下 k+1 个石子。第二个玩家从较大的一堆中取走相同数量的石子，也在那里留下 j 个石子。此时，游戏由两堆各有 j 个石子组成。根据归纳假设，在那个游戏中作为第二个玩家的人，也就是我们实际游戏中的第二个玩家，可以赢，强归纳法证明完成。",
        "answer_symbols": [
            "=",
            "<=",
            "+",
            "-"
        ]
    },
    "11.2 40": {
        "question": "证明：如果取石子游戏从包含不同数目的两堆石头开始，则当两个选手都遵循最优策略时第一个选手获胜。",
        "answer": "如果较小的堆只有一个石头，那么第一个玩家通过移除另一个堆中的所有石头来获胜。否则，较小的堆至少有两个石头，较大的堆有更多的石头，因此第一个玩家可以从较大的堆中移除足够的石头，使两个堆具有相同数量的石头，这个数量至少为 2。根据练习 39 的结果，当以最佳方式玩时，由此产生的游戏是第二个玩家的胜利，而我们的第一个玩家现在是由此产生的游戏中的第二个玩家。",
        "answer_symbols": [
            ">",
            "<",
            "="
        ]
    },
    "11.2 41": {
        "question": "跳棋博弈树的根有多少个孩子？有多少个孙子？",
        "answer": "7； 49",
        "answer_symbols": []
    },
    "11.2 42 a)": {
        "question": "取石子游戏博弈树的根有多少个孩子？有多少个孙子？假设开局是：分别有4块和5块石头的堆。",
        "answer": "从 5 4 开始，可能的移动是到 5 3、5 2、5 1、4 4、4 3、4 2、4 1、5 和 4，因此有九个子节点。类似的分析表明，这些子节点的孩子数量分别是 8、7、6、4、7、6、5、4 和 3，所以孙子节点的数量是这九个数字的总和，即 50。",
        "answer_symbols": []
    },
    "11.2 42 b)": {
        "question": "取石子游戏博弈树的根有多少个孩子？有多少个孙子？假设开局是：分别有2块、3块和4块石头的堆。",
        "answer": "有三个子节点剩下两堆，这些子节点导致了 18 个孙子节点。有六个子节点剩下三堆，这些子节点导致了 37 个孙子节点。因此，总共有九个子节点和 55 个孙子节点。",
        "answer_symbols": []
    },
    "11.2 42 c)": {
        "question": "取石子游戏博弈树的根有多少个孩子？有多少个孙子？假设开局是：分别有1块、2块、3块和4块石头的堆。",
        "answer": "类似的分析表明，有 10 个子节点和 70 个孙子节点。",
        "answer_symbols": []
    },
    "11.2 42 d)": {
        "question": "取石子游戏博弈树的根有多少个孩子？有多少个孙子？假设开局是：分别有2块、2块、3块、3块和5块石头的堆。",
        "answer": "类似的分析表明，有 10 个子节点和 82 个孙子节点。",
        "answer_symbols": []
    },
    "11.2 43": {
        "question": "画出井字游戏博弈树前两步移动所对应的层。指明正文中所提到的求值函数的值，这个函数给局面指定不含O的直线数减去不含X的直线数来作为这一层每个顶点的值，并且在求值函数给出这些顶点的正确值的假设下，对这些顶点计算树的值。",
        "answer": "树的值为 1。注意：第二和第三棵树是第一棵树根的两个子节点的子树，由于空间限制未显示。应将它们视为拼接到第一张图中。",
        "answer_symbols": []
    },
    "11.2 44": {
        "question": "用伪码描述当两个选手都遵循最小最大策略时确定博弈树的值的算法。",
        "answer": "这个递归过程找到了游戏的价值。它需要跟踪当前移动的玩家，因此变量 player 的值将是“First”或“Second”。变量 P 是游戏的一个位置（例如，nim 游戏中各堆的石头数量）。过程 value(P, player) 如果 P 是叶节点，则返回对第一个玩家的支付 否则，如果玩家 = First，则 {计算子节点的最大值} v := -无穷 对于每个合法的移动 m 对于 First {计算结果位置的游戏价值} Q := (P 后跟移动 m) v' := value(Q, Second) 如果 v' > v，则 v := v' 返回 v 否则 {玩家 = Second} {计算子节点的最小值} v := 无穷 对于每个合法的移动 m 对于 Second {计算结果位置的游戏价值} Q := (P 后跟移动 m) v' := value(Q, First) 如果 v' < v，则 v := v' 返回 v",
        "answer_symbols": [
            "-",
            ">",
            "<",
            ":=",
            "∞"
        ]
    },
    "11.3 1": {
        "question": "求表达式的前缀、后缀和中缀形式：分别以前序、后序和中序来遍历这个有根树（包含括号）。",
        "answer": "0\n1 2 3\n1.1 1.2 0 < 1 < 1.1 < 1.2 < 2 < 3",
        "answer_symbols": []
    },
    "11.3 2": {
        "question": "假定在有序根树 T 中顶点 v 的地址是 3.4.5.2.4。a) v 是在哪一层？b) v 的父母的地址是什么？c) v 的兄弟最少有多少？d) 若 v 具有这个地址，那么在 T 里最少可能有多少个顶点？e) 求其他必然出现的地址。",
        "answer": "参见练习 1 的注释。顺序为 0 < 1 < 1.1 < 1.1.1 < 1.1.1.1 < 1.1.1.2 < 1.1.2 < 1.2 < 2。",
        "answer_symbols": [
            "<"
        ]
    },
    "11.3 3": {
        "question": "假定在有序根树 T 中，地址最大的顶点的地址是 2.3.4.3.1。是否有可能确定 T 中的顶点数？",
        "answer": "0 < 1 < 1.1 < 1.2 < 1.2.1 < 1.2.1.1 < 1.2.1.2 < 1.2.2 < 1.2.3 < 1.2.3.1 < 1.2.3.2 < 1.2.3.2.1 < 1.2.3.2.2 < 1.2.3.3 < 2 < 2.1",
        "answer_symbols": [
            "<"
        ]
    },
    "11.3 4 a)": {
        "question": "假定在有序根树 T 中顶点 v 的地址是 3.4.5.2.4。v 是在哪一层？",
        "answer": "The vertex is at level 5. It is clear that an address (other than 0) of length l gives a vertex at level l.",
        "answer_symbols": []
    },
    "11.3 4 b)": {
        "question": "假定在有序根树 T 中顶点 v 的地址是 3.4.5.2.4。v 的父母的地址是什么？",
        "answer": "We obtain the address of the parent by deleting the last number in the address of the vertex. Therefore, the parent is 3.4.5.2.",
        "answer_symbols": []
    },
    "11.3 4 c)": {
        "question": "假定在有序根树 T 中顶点 v 的地址是 3.4.5.2.4。v 的兄弟最少有多少？",
        "answer": "Since v is the fourth child, it has at least three siblings.",
        "answer_symbols": []
    },
    "11.3 4 d)": {
        "question": "假定在有序根树 T 中顶点 v 的地址是 3.4.5.2.4。若 v 具有这个地址，那么在 T 里最少可能有多少个顶点？",
        "answer": "We know that v’s parent must have at least 1 sibling, its grandparent must have at least 4, its great-grandparent at least 3, and its great-great-grandparent at least 2. Adding to this count the fact that v has 5 ancestors and 3 siblings (and not forgetting to count v itself), we obtain a total of 19 vertices in the tree.",
        "answer_symbols": []
    },
    "11.3 4 e)": {
        "question": "假定在有序根树 T 中顶点 v 的地址是 3.4.5.2.4。求其他必然出现的地址。",
        "answer": "The other addresses are 0 together with all prefixes of v and all the addresses that can be obtained from v or prefixes of v by making the last number smaller. Thus, we have 0, 1, 2, 3, 3.1, 3.2, 3.3, 3.4, 3.4.1, 3.4.2, 3.4.3, 3.4.4, 3.4.5, 3.4.5.1, 3.4.5.2, 3.4.5.2.1, 3.4.5.2.2, and 3.4.5.2.3.",
        "answer_symbols": []
    },
    "11.3 5": {
        "question": "在练习 7~9 中，确定前序遍历访问所给的有序根树的顶点的顺序。",
        "answer": "No",
        "answer_symbols": []
    },
    "11.3 6 a)": {
        "question": "有序根树的树叶能否具有下面的通用地址表？若能，则构造出这样的有序根树。（a）1.1.1, 1.1.2, 1.2, 2.1.1.1, 2.1.2, 2.1.3, 2.2, 3.1.1, 3.1.2.1, 3.1.2.2, 3.2",
        "answer": "The following tree has these addresses for its leaves. We construct it by starting from the beginning of the list and drawing the parts of the tree that are made necessary by the given leaves. First, there must be a root. Then, since the first leaf is labeled 1.1.1, there must be a first child of the root, a first child of this child, and a first child of this latter child, which is then a leaf. Next, there must be the second child of the root’s first grandchild (1.1.2), and then a second child of the first child of the root (1.2). We continue in this manner until the entire tree is drawn.",
        "answer_symbols": []
    },
    "11.3 6 b)": {
        "question": "有序根树的树叶能否具有下面的通用地址表？若能，则构造出这样的有序根树。（b）1.1, 1.2.1, 1.2.2, 1.2.3, 2.1, 2.2.1, 2.3.1, 2.3.2, 2.4.2.1, 2.4.2.2, 3.1, 3.2.1, 3.2.2",
        "answer": "If there is such a tree, then the address 2.4.1 must occur since the address 2.4.2 does (the parent of 2.4.2.1). The vertex with that address must either be a leaf or have a descendant that is a leaf. The address of any such leaf must begin 2.4.1. Since no such address is in the list, we conclude that the answer to the question is no.",
        "answer_symbols": []
    },
    "11.3 7": {
        "question": "在练习 7~9 中，确定前序遍历访问所给的有序根树的顶点的顺序。",
        "answer": "a, b, d, e, f, g, c",
        "answer_symbols": []
    },
    "11.3 8": {
        "question": "在练习 7~9 中，确定前序遍历访问所给的有序根树的顶点的顺序。",
        "answer": "See the comments in the solution to Exercise 7 for the procedure. The only difference here is that some vertices have more than two children: after listing such a vertex, we list the vertices of its subtrees, in preorder, from left to right. The answer is a, b, d, e, i, j, m, n, o, c, f, g, h, k, l, p.",
        "answer_symbols": []
    },
    "11.3 9": {
        "question": "在练习 7~9 中，确定前序遍历访问所给的有序根树的顶点的顺序。",
        "answer": "a, b, e, k, l, m, f, g, n, r, s, c, d, h, o, i, j, p, q",
        "answer_symbols": []
    },
    "11.3 10": {
        "question": "使用中序遍历，以什么顺序访问练习 7 中有序根树的顶点？",
        "answer": "The left subtree of the root comes first, namely the tree rooted at b. There again the left subtree comes first, so the list begins with d. After that comes b, the root of this subtree, and then the right subtree of b, namely (in order) f, e, and g. Then comes the root of the entire tree and finally its right child. Thus the answer is d, b, f, e, g, a, c.",
        "answer_symbols": []
    },
    "11.3 11": {
        "question": "使用中序遍历，以什么顺序访问练习 8 中有序根树的顶点？",
        "answer": "d, b, i, e, m, j, n, o, a, f, c, g, k, h, p, l",
        "answer_symbols": []
    },
    "11.3 12": {
        "question": "使用中序遍历，以什么顺序访问练习 9 中有序根树的顶点？",
        "answer": "This is similar to Exercise 11. The answer is k, e, l, m, b, f, r, n, s, g, a, c, o, h, d, i, p, j, q.",
        "answer_symbols": []
    },
    "11.3 13": {
        "question": "使用后序遍历，以什么顺序访问练习 7 中有序根树的顶点？",
        "answer": "d, f, g, e, b, c, a",
        "answer_symbols": []
    },
    "11.3 14": {
        "question": "使用后序遍历，以什么顺序访问练习 8 中有序根树的顶点？",
        "answer": "The procedure is the same as in Exercise 13, except that some vertices have more than two children here: before listing such a vertex, we list the vertices of its subtrees, in postorder, from left to right. The answer is d, i, m, n, o, j, e, b, f, g, k, p, l, h, c, a.",
        "answer_symbols": []
    },
    "11.3 15": {
        "question": "使用后序遍历，以什么顺序访问练习 9 中有序根树的顶点？",
        "answer": "k, l, m, e, f, r, s, n, g, b, c, o, h, i, p, q, j, d, a",
        "answer_symbols": []
    },
    "11.3 20": {
        "question": "有多少种方式给字符串 ¬p ∧ q ↔ p ∨ ¬q 完全加上括号以便产生中缀表达式？",
        "answer": "This requires fairly careful counting. Let us work from the outside in. There are four symbols that can be the outermost operation: the first ¬, the ∧, the ↔, and the ∨. Let us first consider the cases in which the first ¬ is the outermost operation, necessarily applied, then, to the rest of the expression. Then there are three possible choices for the outermost operation of the rest: the ∧, the ↔, and the ∨. Let us assume first that it is the ∧. Then there are two choices for the outermost operation of the rest of the expression: the ↔ and the ∨. If it is the ↔, then there are two ways to parenthesize the rest—depending on whether the second ¬ applies to the disjunction or only to the p. Backing up, we next consider the case in which the ∨ is the outermost operation among the last seven symbols, rather than the ↔. In this case there are no further choices. We then back up again and assume that the ↔, rather than the ∧, is the second outermost operation. In this case there are two possibilities for completing the parenthesization (involving the second ¬). If the ∨ is the second outermost operation, then again there are two possibilities, depending on whether the ∧ or the ↔ is applied first. Thus in the case in which the outermost operation is the first ¬, we have counted 7 ways to parenthesize the expression: (¬(p ∧ (q ↔ (¬(p ∨ (¬q)))))) (¬(p ∧ (q ↔ ((¬p) ∨ (¬q))))) (¬(p ∧ ((q ↔ (¬p)) ∨ (¬q)))) (¬((p ∧ q) ↔ (¬(p ∨ (¬q))))) (¬((p ∧ q) ↔ ((¬p) ∨ (¬q)))) (¬((p ∧ (q ↔ (¬p))) ∨ (¬q))) (¬(((p ∧ q) ↔ (¬p)) ∨ (¬q))). Other three cases are similar, if ∧ is the outermost operation, then there are 3 possibilities; if ↔ is the outermost operation, then there are 4 possibilities; if ∨ is the outermost operation, then there are 5 possibilities. Therefore, the answer is 7 + 3 + 4 + 5 = 19.",
        "answer_symbols": [
            "¬",
            "∧",
            "↔",
            "∨",
            "(",
            ")",
            "p",
            "q"
        ]
    },
    "11.3 21": {
        "question": "有多少种方式给字符串 A ∩ B − A ∪ B − A 完全加上括号以便产生中缀表达式？",
        "answer": "14",
        "answer_symbols": []
    },
    "11.3 22": {
        "question": "证明：当指定了有序根树的前序遍历所生成的顶点列表，并且指定了每个顶点的孩子数时，这个有序根树是唯一确定的。",
        "answer": "We start working from the beginning of the expression. In part (a), the root node of the tree must be the first +. Then we use as much of the remaining expression as possible to construct the left subtree of the root node. The root node of this left subtree is *, and its left subtree is as much of the remaining expression as possible. We continue doing this until we build a subtree with the root node - and children 5 and 3. Then 2 must be the right child of the second +, 1 must be the right child of *, and 4 must be the right child of the root node. The result is shown below. The infix form is (((5 - 3) + 2) * 1) + 4. The other two trees are constructed similarly. The infix expressions are (2 + 3) ↑ (5 - 1) and (9 / 3) * ((2 * 4) + (7 - 6)).",
        "answer_symbols": [
            "+",
            "*",
            "-",
            "↑",
            "/"
        ]
    },
    "11.3 24": {
        "question": "证明：下图所示的两个有序根树的前序遍历产生相同的顶点列表。注意这个结果不与练习 26 的命题相矛盾，因为在这两个有序根树中内点的孩子数是不同的。",
        "answer": "We show the operations in parentheses, which are applied from left to right (always involving the first occurrence of the operator symbol). a) 5 (2 1 -) - 3 1 4 + + * = (5 1 -) 3 1 4 + + * = 4 3 (1 4 +) + * = 4 (3 5 +) * = (4 8 *) = 32 b) (9 3 /) 5 + 7 2 - * = (3 5 +) 7 2 - * = 8 (7 2 -) * = (8 5 *) = 40 c) (3 2 *) 2 ↑ 5 3 - 8 4 / * - = (6 2 ↑) 5 3 - 8 4 / * - = 36 (5 3 -) 8 4 / * - = 36 2 (8 4 /) * - = 36 (2 2 *) - = (36 4 -) = 32",
        "answer_symbols": [
            "-",
            "+",
            "*",
            "/",
            "↑"
        ]
    },
    "11.3 16 a)": {
        "question": "用二叉树来表示表达式 ((x+2)^3) * (y-(3+x)) - 5。表示方式应采用：（a）前缀记法",
        "answer": "We build the tree from the top down while analyzing the expression by identifying the outermost operation at each stage. The outermost operation in this expression is the final subtraction. Therefore, the tree has - at its root, with the two operands as the subtrees at the root. The right operand is clearly 5, so the right child of the root is 5. The left operand is the result of a multiplication, so the left subtree has * as its root. We continue recursively in this way until the entire tree is constructed.",
        "answer_symbols": [
            "-",
            "*"
        ]
    },
    "11.3 16 b)": {
        "question": "用二叉树来表示表达式 ((x+2)^3) * (y-(3+x)) - 5。表示方式应采用：（b）后缀记法",
        "answer": "We can read off the answer from the picture we have just drawn simply by listing the vertices of the tree in preorder: First list the root, then the left subtree in preorder, then the right subtree in preorder. Therefore the answer is − * ↑ + x^² 3 − y + 3 x^⁵.",
        "answer_symbols": [
            "−",
            "*",
            "↑",
            "+",
            "x²",
            "3",
            "−",
            "y",
            "+",
            "3",
            "x⁵"
        ]
    },
    "11.3 16 c)": {
        "question": "用二叉树来表示表达式 ((x+2)^3) * (y-(3+x)) - 5。表示方式应采用：（c）中缀记法",
        "answer": "We can read off the answer from the picture we have just drawn simply by listing the vertices of the tree in postorder: x^² + 3 ↑ y 3 x + − * 5 −.",
        "answer_symbols": [
            "x²",
            "+",
            "3",
            "↑",
            "y",
            "3",
            "x",
            "+",
            "−",
            "*",
            "5",
            "−"
        ]
    },
    "11.3 17 a)": {
        "question": "用二叉树来表示表达式 (x+x*y) + (x/y) 和 x + ((x*y+x)/y)。表示方式应采用：（a）前缀记法",
        "answer": "+ + * x x / y x y x + + * x / y y x",
        "answer_symbols": [
            "+",
            "*",
            "/"
        ]
    },
    "11.3 17 b)": {
        "question": "用二叉树来表示表达式 (x+x*y) + (x/y) 和 x + ((x*y+x)/y)。表示方式应采用：（b）后缀记法",
        "answer": "++x *xy/xy, +x/ + *xyxy",
        "answer_symbols": [
            "+",
            "*",
            "/"
        ]
    },
    "11.3 17 c)": {
        "question": "用二叉树来表示表达式 (x+x*y) + (x/y) 和 x + ((x*y+x)/y)。表示方式应采用：（c）中缀记法",
        "answer": "xxy* +xy/, + xxy*x +y/",
        "answer_symbols": [
            "*",
            "+",
            "/"
        ]
    },
    "11.3 18 a)": {
        "question": "用有序根树来表示复合命题 ¬(p ∧ q) ↔ (¬p ∨ ¬q) 和 (¬p ∧ (q ↔ ¬p)) ∨ ¬q。表示方式应采用：（a）前缀记法",
        "answer": "This exercise is similar to the previous few exercises. The only difference is that some portions of the tree represent the unary operation of negation (¬). In the first tree, for example, the left subtree represents the expression ¬(p ∧ q), so the root is the negation symbol, and the only child of this root is the tree for the expression p ∧ q. Since this exercise is similar to previous exercises, we will not go into the details of obtaining the different expressions. The only difference is that negation (¬) is a unary operator; we show it preceding its operand in infix notation, even though it would follow it in an inorder traversal of the expression tree.",
        "answer_symbols": [
            "¬",
            "∧",
            "p",
            "q"
        ]
    },
    "11.3 18 b)": {
        "question": "用有序根树来表示复合命题 ¬(p ∧ q) ↔ (¬p ∨ ¬q) 和 (¬p ∧ (q ↔ ¬p)) ∨ ¬q。表示方式应采用：（b）后缀记法",
        "answer": "↔ ¬ ∧ p q ∨ ¬ p ¬ q and ∨ ∧ ¬ p ↔ q ¬ p ¬ q",
        "answer_symbols": [
            "↔",
            "¬",
            "∧",
            "∨",
            "p",
            "q"
        ]
    },
    "11.3 18 c)": {
        "question": "用有序根树来表示复合命题 ¬(p ∧ q) ↔ (¬p ∨ ¬q) 和 (¬p ∧ (q ↔ ¬p)) ∨ ¬q。表示方式应采用：（c）中缀记法",
        "answer": "p q ∧ ¬ p ¬ q ¬ ∨ ↔ and p ¬ q p ¬ ↔ ∧ q ¬ ∨",
        "answer_symbols": [
            "p",
            "q",
            "∧",
            "¬",
            "∨",
            "↔"
        ]
    },
    "11.3 19 a)": {
        "question": "用有序根树来表示 (A ∩ B) − (A ∪ (B − A))。表示方式应采用：（a）前缀记法",
        "answer": "– ∩ B A A – ∪ A B",
        "answer_symbols": [
            "–",
            "∩",
            "∪"
        ]
    },
    "11.3 19 b)": {
        "question": "用有序根树来表示 (A ∩ B) − (A ∪ (B − A))。表示方式应采用：（b）后缀记法",
        "answer": "− ∩ A B ∪ A − B A",
        "answer_symbols": [
            "−",
            "∩",
            "∪"
        ]
    },
    "11.3 19 c)": {
        "question": "用有序根树来表示 (A ∩ B) − (A ∪ (B − A))。表示方式应采用：（c）中缀记法",
        "answer": "A B ∩ A B A − ∪ −",
        "answer_symbols": [
            "∩",
            "−",
            "∪"
        ]
    },
    "11.3 23 a)": {
        "question": "下面每个前缀表达式的值是什么？（a）- * 2 / 8 4 3",
        "answer": "1",
        "answer_symbols": []
    },
    "11.3 23 b)": {
        "question": "下面每个前缀表达式的值是什么？（b）+ - * 3 3 * 4 2 5",
        "answer": "1",
        "answer_symbols": []
    },
    "11.3 23 c)": {
        "question": "下面每个前缀表达式的值是什么？（c）+ - 1 + 3 2 * 2 3 / 6 - 4 2",
        "answer": "4",
        "answer_symbols": []
    },
    "11.3 25": {
        "question": "构造前序遍历为 a, b, f, c, g, h, i, d, e, j, k, l 的有序根树，其中 a 有 4 个孩子，c 有 3 个孩子，j 有 2 个孩子，b 和 e 都有 1 个孩子，所有其他顶点都是树叶。",
        "answer": "a\nb c d e\nf g h i\nk l\nj",
        "answer_symbols": []
    },
    "11.3 26": {
        "question": "证明：当指定了有序根树的前序遍历所生成的顶点列表，并且指定了每个顶点的孩子数时，这个有序根树是唯一确定的。",
        "answer": "We prove this by induction on the length of the list. If the list has only one element, then the statement is obviously true. For the inductive step, consider the beginning of the list. There we find a vertex sequence starting from the root node and ending at the first leaf node (we can identify the first leaf as the first vertex without children), with each vertex being the first child of its previous vertex. Now remove this leaf and reduce the number of children of its parent by 1. The result is a preorder and child count of a tree with one fewer vertex. By the inductive hypothesis, we can uniquely determine this smaller tree. Then we can uniquely determine the position of the removed vertex, as it is the first child of its known parent.",
        "answer_symbols": []
    },
    "11.3 27": {
        "question": "证明：当指定了有序根树的后序遍历所生成的顶点列表，并且指定了每个顶点的孩子数时，这个有序根树是唯一确定的。",
        "answer": "Use mathematical induction. The result is trivial for a list with one element. Assume the result is true for a list with n elements. For the inductive step, start at the end. Find the sequence of vertices at the end of the list starting with the last leaf, ending with the root, each vertex being the last child of the one following it. Remove this leaf and apply the inductive hypothesis.",
        "answer_symbols": []
    },
    "11.3 28": {
        "question": "证明：下图所示的两个有序根树的前序遍历产生相同的顶点列表。注意这个结果不与练习 26 的命题相矛盾，因为在这两个有序根树中内点的孩子数是不同的。",
        "answer": "It is easy to see that the list is alphabetically ordered in each case. In the first tree, vertex b has two children, while in the second tree, vertex b has three children, so the statement in Exercise 26 is not contradicted.",
        "answer_symbols": []
    },
    "11.3 29": {
        "question": "证明：下图所示的两个有序根树的后序遍历产生相同的顶点列表。注意这个结果不与练习 27 里的命题相矛盾，因为在这两个有序根树中内点的孩子数是不同的。",
        "answer": "c, d, b, f, g, h, e, a in each case",
        "answer_symbols": []
    },
    "11.3 31": {
        "question": "证明：在符号集合和二元运算符集合上用前缀记法表示的任何合式公式所包含的符号数都比运算符数恰好多一个。",
        "answer": "Proof by mathematical induction. Let S(X) and O(X) represent the number of symbols and number of operators in the well-formed formula X, respectively. The statement is true for well-formed formulae of length 1, because they have 1 symbol and 0 operators. Assume the statement is true for all well-formed formulae of length less than n. A well-formed formula of length n must be of the form *XY, where * is an operator and X and Y are well-formed formulae of length less than n.\nThen by the inductive hypothesis S(*XY) = S(X) + S(Y) = [O(X) + 1] + [O(Y) + 1] = O(X) + O(Y) + 2. Because O(*XY) = 1 + O(X) + O(Y), it follows that S(*XY) = O(*XY) + 1.",
        "answer_symbols": [
            "+",
            "=",
            "[",
            "]"
        ]
    },
    "11.3 32": {
        "question": "给出在符号集合和二元运算符集合上用后缀记法表示的合式公式的定义。",
        "answer": "定义与前缀表达式的定义逐字相同，只是将“前缀”替换为“后缀”，并将 ∗XY 替换为 XY ∗。",
        "answer_symbols": [
            "∗"
        ]
    },
    "11.3 33": {
        "question": "给出在符号集合 {x, y, z} 和二元运算符集合 {+, ×, ∘} 上带 3 个以上运算的、用后缀记法表示的合式公式的 6 个例子。",
        "answer": "x y + z x ° + x °, xyz++ yx++, xyxy°°xy°°z°+, xz×, zz+°, yyyy°°°, zx+y+z°",
        "answer_symbols": [
            "+",
            "°",
            "×"
        ]
    },
    "11.3 34": {
        "question": "把用前缀记法表示的合式公式的定义推广到这样的符号和运算符集合上，其中运算符可能不是二元的。",
        "answer": "我们在定义中用以下陈述替换归纳步骤(ii)：如果 X1, X2,..., Xn 是良构公式，且 ∗ 是 n 元运算符，则 ∗X1X2... Xn 是一个良构公式。",
        "answer_symbols": [
            "∗",
            "..."
        ]
    },
    "11.4 1": {
        "question": "为了产生生成树，必须从带有n个顶点和m条边的连通图里删除多少条边？",
        "answer": "m − n + 1",
        "answer_symbols": [
            "−",
            "+"
        ]
    },
    "11.4 2": {
        "question": "通过删除简单回路里的边来求所示图的生成树。",
        "answer": "由于边 {a, b} 是简单回路的一部分，我们可以移除它。然后由于边 {b, c} 仍然是简单回路的一部分，我们可以移除它。此时没有更多的简单回路，所以我们得到了一棵生成树。还有许多其他可能的答案，对应于不同的边移除选择。",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "11.4 3": {
        "question": "通过删除简单回路里的边来求所示图的生成树。",
        "answer": "a b c g f e d",
        "answer_symbols": []
    },
    "11.4 4": {
        "question": "通过删除简单回路里的边来求所示图的生成树。",
        "answer": "我们可以移除这些边以生成一棵生成树（参见练习2的注释）：{a, i}, {b, i}, {b, j}, {c, d}, {c, j}, {d, e}, {e, j}, {f, i}, {f, j}, 和 {g, i}。",
        "answer_symbols": [
            "{",
            "}",
            ",",
            "和"
        ]
    },
    "11.4 5": {
        "question": "通过删除简单回路里的边来求所示图的生成树。",
        "answer": "b a c d e h l j g f i k",
        "answer_symbols": []
    },
    "11.4 6": {
        "question": "通过删除简单回路里的边来求所示图的生成树。",
        "answer": "有许多可能的答案。一组选择是移除边 {a, e}, {a, h}, {b, g}, {c, f}, {c, j}, {d, k}, {e, i}, {g, l}, {h, l}, 和 {i, k}。",
        "answer_symbols": [
            "{",
            "}",
            ",",
            "和"
        ]
    },
    "11.4 8": {
        "question": "画出所给的简单图的所有生成树.\na\nb\nc",
        "answer": "我们可以移除三条边中的任意一条以生成一棵生成树。因此，生成的树如图所示。",
        "answer_symbols": []
    },
    "11.4 10": {
        "question": "画出所给的简单图的所有生成树.\na\nb\nc\nd\ne\nf\ng\nh",
        "answer": "我们可以移除中间正方形的四条边中的任意一条以生成一棵生成树，如图所示。",
        "answer_symbols": []
    },
    "11.4 11 a)": {
        "question": "下面的每个简单图各有多少棵不同的生成树?（a）K3",
        "answer": "3",
        "answer_symbols": []
    },
    "11.4 11 b)": {
        "question": "下面的每个简单图各有多少棵不同的生成树?（b）K4",
        "answer": "16",
        "answer_symbols": []
    },
    "11.4 11 c)": {
        "question": "下面的每个简单图各有多少棵不同的生成树?（c）K22",
        "answer": "4",
        "answer_symbols": []
    },
    "11.4 11 d)": {
        "question": "下面的每个简单图各有多少棵不同的生成树?（d）C5",
        "answer": "5",
        "answer_symbols": []
    },
    "11.4 13": {
        "question": "用深度优先搜索来构造所给的简单图的生成树。选择 a 作为这棵生成树的根并且假定顶点都以字母顺序来排序。",
        "answer": "a e h i b f g j c d",
        "answer_symbols": []
    },
    "11.4 14": {
        "question": "用深度优先搜索来构造所给的简单图的生成树。选择 a 作为这棵生成树的根并且假定顶点都以字母顺序来排序。",
        "answer": "树用粗线表示。它是通过从 a 开始并尽可能地前进而不回溯生成的，在每个点选择第一个未使用的顶点（按字母顺序）。当路径到达顶点 l 时，我们需要回溯。回溯到 h 后，我们可以继续形成一条路径直到 n 而不再回溯。最后我们回溯到顶点 i 以拾取顶点 m。",
        "answer_symbols": []
    },
    "11.4 15": {
        "question": "用深度优先搜索来构造所给的简单图的生成树。选择 a 作为这棵生成树的根并且假定顶点都以字母顺序来排序。",
        "answer": "a b c d e f g h i j k l m n o p q",
        "answer_symbols": []
    },
    "11.4 16": {
        "question": "用宽度优先搜索来构造练习 13~15 中每个简单图的生成树。选择 a 作为每棵生成树的根。",
        "answer": "如果我们从顶点 a 开始并使用字母顺序，则广度优先搜索生成树是唯一的。考虑练习13中的图。我们首先从顶点 a 扩展，选择边 {a, b} 和 {a, c}。从 b 没有新的顶点，所以我们从 c 扩展，得到边 {c, d}。然后我们从 d 扩展，得到边 {d, e} 和 {d, f}。这个过程继续进行，直到我们得到下图中用粗线表示的整个树。",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "11.4 17 a)": {
        "question": "用深度优先搜索求下列这些图的生成树。 (a) W₆ (参见 10.2 节例 7)，从度数为 6 的顶点开始",
        "answer": "长度为 6 的路径",
        "answer_symbols": []
    },
    "11.4 17 b)": {
        "question": "用深度优先搜索求下列这些图的生成树。 (b) K₅",
        "answer": "长度为 5 的路径",
        "answer_symbols": []
    },
    "11.4 17 c)": {
        "question": "用深度优先搜索求下列这些图的生成树。 (c) K₄₄，从度数为 3 的顶点开始",
        "answer": "长度为 6 的路径",
        "answer_symbols": []
    },
    "11.4 17 d)": {
        "question": "用深度优先搜索求下列这些图的生成树。 (d) Q₂",
        "answer": "取决于选择访问顶点的顺序；可能是长度为 7 的路径",
        "answer_symbols": []
    },
    "11.4 19": {
        "question": "描述轮图 Wₙ 的宽度优先搜索和深度优先搜索所产生的树，从度数为 n 的顶点开始，其中 n 是整数满足 n ≥ 3 (参见 10.2 节例 7)。说明答案的合理性。",
        "answer": "在广度优先搜索中，初始顶点是中间顶点，当处理该顶点时将 n 条边添加到树中。因此，生成的树是 K1,n。在深度优先搜索中，我们从轮图中间的顶点开始，访问一个邻居——轮缘上的一个顶点。从那里移动到轮缘上的相邻顶点，依次类推直到到达每个顶点。因此，生成的生成树是一条长度为 n 的路径。",
        "answer_symbols": [
            "n"
        ]
    },
    "11.4 20": {
        "question": "描述完全图 Kₙ 的宽度优先搜索和深度优先搜索所产生的树，从度数为 m 的顶点开始，其中 n 是正整数。说明答案的合理性。",
        "answer": "由于每个顶点都与其他每个顶点相连，广度优先搜索将构造生成树 K1,n-1，每个顶点都与起始顶点相邻。深度优先搜索将产生长度为 n-1 的简单路径，原因相同。",
        "answer_symbols": [
            ",",
            "-"
        ]
    },
    "11.4 21": {
        "question": "描述完全二分图 Kₘₙ 的宽度优先搜索和深度优先搜索所产生的树，从度数为 m 的顶点开始，其中 m 和 n 都是正整数。说明答案的合理性。",
        "answer": "在广度优先搜索中，我们从度为 m 的顶点向外扩展到所有度为 n 的顶点作为第一步。接下来，处理一个度为 n 的顶点，并添加从它到所有剩余度为 m 的顶点的边。结果是一个 K1,n-1 和一个 K1,m-1，它们的中心由一条边连接。在深度优先搜索中，我们在两个部分集之间来回移动，直到无法继续为止。如果 m = n 或 m = n - 1，则我们得到一条长度为 m + n - 1 的路径。否则，路径在较大部分集中的某些顶点未被访问时结束，所以我们回退路径中的一个链接到顶点 v，然后从 v 依次访问该集中的剩余顶点。结果是一条带有多余悬挂边的路径。",
        "answer_symbols": [
            "m",
            "n",
            "-",
            "+"
        ]
    },
    "11.4 22": {
        "question": "描述 n 立方体图 Qₙ 的宽度优先搜索和深度优先搜索所产生的树，其中 n 是正整数。",
        "answer": "Qn 的广度优先搜索树最易于递归描述。对于 n=0，树只是一个顶点。给定 Qn 的树 Tn，Qn+1 的树由 Tn 组成，在根的左到右顺序中添加一个额外的孩子，并且该孩子是 Tn 的副本的根。这些树也可以明确描述。如果我们认为 Qn 的顶点是长度为 n 的位串，则根是 n 个 0 的字符串，每个顶点的子节点是通过将一个没有后续 1 的 0 改变为 1 而获得的所有顶点。对于深度优先搜索树，树将取决于顶点的选择顺序。因为 Qn 有一条哈密顿路径，所以树可能是路径。然而，如果做出“错误”的选择，路径可能在访问所有顶点之前陷入死胡同，这种情况下树必须分支。",
        "answer_symbols": [
            "+",
            "=",
            "->"
        ]
    },
    "11.4 24": {
        "question": "解释如何用宽度优先搜索或深度优先搜索来排序连通图的顶点。",
        "answer": "我们可以按照搜索过程中首次遇到顶点的顺序对图中的顶点进行排序。然而，需要注意的是，我们已经需要一个顺序（至少是局部的，即在一个顶点的邻居之间）来使搜索过程明确定义。深度优先搜索或广度优先搜索产生的顺序当然不同。",
        "answer_symbols": []
    },
    "11.4 25": {
        "question": "证明：在连通简单图里顶点 v 和 u 之间的最短通路的长度，等于在以 v 为根的 G 的宽度优先生成树里 u 的层数。",
        "answer": "对路径长度进行归纳证明：如果路径长度为 0，则结果是显而易见的。如果长度为 1，则 u 与 v 相邻，因此 u 在广度优先生成树中处于第 1 层。假设对于长度为 l 的路径结果成立。如果路径长度为 l + 1，设 u' 是从 v 到 u 的最短路径中倒数第二个顶点。根据归纳假设，u' 在广度优先生成树中处于第 l 层。如果 u 处于不超过 l 的层，则显然从 v 到 u 的最短路径长度也不会超过 l。所以在添加了第 l 层的顶点后，u 还没有被添加到广度优先生成树中。因为 u 与 u' 相邻，所以它将在第 l + 1 层被添加（尽管连接 u' 和 u 的边不一定被添加）。",
        "answer_symbols": [
            "+",
            "<="
        ]
    },
    "11.4 26": {
        "question": "用回溯来试验使用 3 种颜色对 10.8 节练习 7～9 中每个图的着色。",
        "answer": "在每种情况下，我们将颜色称为红色、蓝色和绿色。我们的回溯计划是按字母顺序对顶点进行着色。我们首先尝试为当前顶点使用红色，如果可能的话，然后继续下一个顶点。当我们回溯到这个顶点时，再尝试蓝色，如果可能的话。最后尝试绿色。如果这个顶点的任何着色都不成功，则擦除该顶点的颜色并回溯到前一个顶点。",
        "answer_symbols": []
    },
    "11.4 28 a)": {
        "question": "用回溯来求集合 {27, 24, 19, 14, 11, 8} 的和为 20 的子集，若存在的话。",
        "answer": "可能包含的最大数字是19。由于19与列表中任何较小的数字之和都大于20，因此我们得出结论：没有包含19的子集其和为20。然后我们尝试14，得出相同的结论。最后，我们尝试11，并注意到在包括8之后，列表已用尽且总和不是20。因此，没有子集的和为20。",
        "answer_symbols": [
            ">",
            "+",
            "="
        ]
    },
    "11.4 28 b)": {
        "question": "用回溯来求集合 {27, 24, 19, 14, 11, 8} 的和为 41 的子集，若存在的话。",
        "answer": "从集合中的27开始，我们很快发现子集{27, 14}的和为41。",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "11.4 28 c)": {
        "question": "用回溯来求集合 {27, 24, 19, 14, 11, 8} 的和为 60 的子集，若存在的话。",
        "answer": "首先我们尝试将27放入子集中。如果我们还包括24，则无法进一步添加，因此我们回溯并尝试将19与27一起包括。现在可以添加14，这使我们得到所需的和60。",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "11.4 29": {
        "question": "解释如何用回溯来找出图中的哈密顿通路或哈密顿回路。",
        "answer": "从一个顶点开始，沿着路径前进，尽可能长地不重复顶点，允许在访问完所有顶点后返回起点。当无法继续沿路径前进时，回溯并尝试当前路径的另一个扩展。",
        "answer_symbols": []
    },
    "11.4 30 a)": {
        "question": "解释如何用回溯来找出迷宫的出路，给定出发位置和出口位置。考虑把迷宫划分成位置，其中在每个位置上的移动包括四种可能性之一（上、下、右、左）。",
        "answer": "我们从起始位置开始。在每个位置，我们记录已经尝试的移动，并按上、下、右、左的顺序尝试移动。（我们假设进入此位置的方向已经被尝试过，因为我们不希望解决方案重走步骤。）当我们尝试一个移动时，我们沿着选择的路线前进，直到被阻碍，此时我们回溯并尝试下一个可能的移动。这最终会引导我们到达出口位置，或者我们尝试了所有可能性并得出没有解决方案的结论。",
        "answer_symbols": []
    },
    "11.4 30 b)": {
        "question": "找出在下面的迷宫里从标记为 X 的出发位置到出口的通路。",
        "answer": "我们从位置X开始。由于不能向上移动，我们尝试向下移动。在下一个交叉路口只有一个选择，所以我们向左移动。（所有方向都是根据我们对图片的视角描述的。）这导致了一个死胡同。因此我们回溯到位置X并尝试向右移动。这（没有选择地）引导我们到达第二行大约三分之二处的开口，这里我们可以选择向左或向下。我们尝试向下，然后向右。直到到达出口上方的开口之前，没有进一步的选择。在这里我们首先尝试向上，但那会导致一个死胡同，所以我们尝试向下，这引导我们到达出口。",
        "answer_symbols": []
    },
    "11.4 31": {
        "question": "证明：每个有穷简单图都有生成森林。",
        "answer": "取G的连通分量的生成树的并集。它们是不相交的，所以结果是一个森林。",
        "answer_symbols": []
    },
    "11.4 32": {
        "question": "在图的生成森林里有多少棵树？",
        "answer": "每个图的连通分量对应一棵树。",
        "answer_symbols": []
    },
    "11.4 33": {
        "question": "对带有 n 个顶点、m 条边和 c 个连通分支的图来说，必须删除多少条边才能产生它的生成森林？",
        "answer": "m−n+ c",
        "answer_symbols": [
            "-",
            "+"
        ]
    },
    "11.4 34": {
        "question": "证明：如果 T 是用宽度优先搜索构造的 G 的生成树，则 G 的不在 T 中的边必定连接这个生成树中在同一层上或相差一层的顶点。",
        "answer": "首先注意顶点被放入（因此也被取出）列表L的顺序是层次顺序。换句话说，生成树的根节点首先出现，然后是第1层的顶点（在处理根节点时放入列表），接着是第2层的顶点（在处理第1层的顶点时放入列表），依此类推。现在假设uv是一条不在树中的边，并且不失一般性地假设算法先处理u再处理v。由于边uv不在树中，必须是v在u被处理时已经在列表L中。为了发生这种情况，v的父节点p必须在u之前已被处理。注意p在树中的层级比v低一级。因此u的层级大于等于p的层级但小于等于v的层级，证明完成。",
        "answer_symbols": []
    },
    "11.4 35": {
        "question": "解释如何使用宽度优先搜索求无向图中两个顶点之间最短通路的长度。",
        "answer": "假设我们希望使用算法1找到从v1到图G中每个其他顶点的最短路径的长度。在该算法的第2行，添加 L(v1):= 0，并在末尾的then子句中添加以下作为第三步：L(w):= 1+ L(v)。",
        "answer_symbols": [
            ":=",
            "+"
        ]
    },
    "11.4 36": {
        "question": "设计一个基于宽度优先搜索的算法，判断一个图是否有简单回路，如果有，找出该回路。",
        "answer": "我们使用广度优先搜索构建生成树。如果在从顶点v扩展时遇到已经在树中的邻居w，则我们知道存在一个简单回路，该回路由从根到v的路径、边vw以及从根到w的逆向路径组成。",
        "answer_symbols": []
    },
    "11.4 37": {
        "question": "设计一个基于宽度优先搜索的算法，求一个图的连通分支。",
        "answer": "向BFS算法添加一条指令，在遇到每个顶点时对其进行标记。当BFS终止时，我们已经找到了（图的一个连通分量的所有顶点）。重复，从一个未标记的顶点开始，并以这种方式继续，直到所有顶点都被标记。",
        "answer_symbols": []
    },
    "11.4 38": {
        "question": "解释如何使用宽度优先搜索和如何使用深度优先搜索判断一个图是否为二分图。",
        "answer": "我们使用这些搜索方法之一构造一棵树。我们把第一个顶点涂成红色，每当我们在树中添加一个新顶点时，如果它是由一个红色顶点到达的，我们就把它涂成蓝色；如果它是由一个蓝色顶点到达的，我们就把它涂成红色。当我们遇到已经在树中的顶点（因此不会被添加到树中）时，我们将它的颜色与当前处理的顶点的颜色进行比较。如果颜色相同，那么我们可以立即知道图不是二部图。如果我们整个过程都没有发现这样的冲突，那么我们得出结论该图是二部图。",
        "answer_symbols": []
    },
    "11.4 39": {
        "question": "哪种连通的简单图恰好只有一棵生成树？",
        "answer": "树",
        "answer_symbols": []
    },
    "11.4 40": {
        "question": "设计基于删除形成简单回路的边来构造图的生成树的算法。",
        "answer": "该算法与通过删除简单回路中的边来获得生成树的算法相同。当回路仍然存在时，我们移除简单回路中的一条边。这不会断开图的任何连通分量，并且最终这个过程会在每个分量的生成树的森林中终止。",
        "answer_symbols": []
    },
    "11.4 41": {
        "question": "设计基于深度优先搜索来构造图的生成森林的算法。",
        "answer": "对每个连通分量使用深度优先搜索。",
        "answer_symbols": []
    },
    "11.4 42": {
        "question": "设计基于宽度优先搜索来构造图的生成森林的算法。",
        "answer": "我们从第一个顶点开始应用广度优先搜索。当搜索终止，即列表为空时，我们寻找尚未包含在森林中的第一个顶点。如果没有找到这样的顶点，那么我们就完成了。如果v是这样一个顶点，那么我们再次从v开始广度优先搜索，构建森林中的第二棵树。我们继续这样做，直到所有顶点都被包括在内。",
        "answer_symbols": []
    },
    "11.4 43": {
        "question": "证明：如果 T 是用深度优先搜索构造的 G 的生成树，则 G 的不在 T 中的边必定是背边，换句话说，这条边必定连接一个顶点到这个顶点在 T 中的祖先或后代。",
        "answer": "如果边uv在深度优先搜索过程中处理顶点u时不被跟踪，则必须是顶点v已经被访问过。有两种情况。如果顶点v是在我们开始处理u之后被访问的，那么因为还没有完成对u的处理，v必须出现在以u为根的子树中（因此，必须是u的后代）。另一方面，如果v的处理在我们开始处理u之前已经开始，那么为什么当时没有跟踪这条边？一定是还没有完成对v的处理，换句话说，我们仍在形成以v为根的子树，因此u是v的后代，而v是u的祖先。",
        "answer_symbols": []
    },
    "11.4 44": {
        "question": "什么情况下，连通简单图的一条边一定在该图的每棵生成树中？",
        "answer": "如果边是割边，那么它提供了其端点之间的唯一简单路径。因此，它必须出现在图的所有生成树中。相反，如果一条边不是割边，那么可以将其移除而不使图断开，且所得图的所有生成树将是不包含这条边的原图的生成树。因此，我们已经证明了连通简单图的一条边必须出现在该图的所有生成树中当且仅当这条边是割边——即它的移除会使图断开。",
        "answer_symbols": []
    },
    "11.4 45": {
        "question": "对于哪些图来说，无论选择哪个顶点作为树根，深度优先搜索和宽度优先搜索都产生同样的生成树？说明答案的合理性。",
        "answer": "当然，如果我们要处理的图本身是一棵树，那么这两种过程将产生相同的生成树，因为在这种情况下只有一棵生成树（整个图）。然而，这是唯一的情况。如果原始图有其他任何边，那么根据练习43，它们必须是回边，因此连接一个顶点到其祖先或后代，而根据练习34，它们必须连接同一层或相差一层的顶点。显然，这两种可能性是互斥的。因此，如果两棵生成树要相同，就不能有其他边。",
        "answer_symbols": []
    },
    "11.4 46": {
        "question": "用练习 43 证明：如果 G 是含有 n 个顶点的连通简单图并且 G 不含长度为 k 的简单通路，则 G 至多含有 (k-1)n 条边。",
        "answer": "假设连通简单图G没有长度至少为k的简单路径。考虑深度优先搜索树中最长的路径。由于每条边连接一个祖先和一个后代，我们可以通过计算每个后代的祖先总数来限定边的数量。但如果最长路径短于k，那么每个后代最多有k - 1个祖先。因此最多有(k - 1)n条边。",
        "answer_symbols": [
            "-",
            "<="
        ]
    },
    "11.4 47": {
        "question": "用数学归纳法证明：宽度优先搜索按照顶点在所得出的生成树中的层数的顺序来访问这些顶点。",
        "answer": "因为不在生成树中的边在过程中不会被跟踪，我们可以忽略它们。因此我们可以假设图一开始就是一棵有根树。基本情况是微不足道的（只有一个顶点），所以我们假设归纳假设，即应用于具有n个顶点的树的广度优先搜索按其在树中的层级顺序访问顶点，并考虑具有n+1个顶点的树T。在这棵树的广度优先搜索过程中最后被访问的顶点，比如说v，是被添加到最后等待处理的顶点列表中的。它是在其父节点，比如说u，正在处理时被添加的。我们必须证明v处于树的最低（最底部，即数值最大）层级。如果不是这样；说顶点x，其父节点是顶点w，处于较低的层级。那么w处于比u更低的层级。显然v必须是一个叶子节点，因为v的任何孩子都不可能在看到v之前被看到。考虑从T中删除v得到的树T'。根据归纳假设，T'中的顶点必须按其在T'中的层级顺序处理（这与它们在T中的层级相同，v在T'中的缺失不影响其余算法）。因此u必须在w之前被处理，因此v会在x之前加入等待列表，这是一个矛盾。因此v处于树的最底层，证明完成。",
        "answer_symbols": [
            "+",
            "<",
            "=>"
        ]
    },
    "11.4 48": {
        "question": "用伪码来描述深度优先搜索的一个变种，它把整数 n 指定给在搜索中访问的第 n 个顶点。证明：这个编号对应着生成树的前序遍历所建立的顶点的编号。",
        "answer": "我们修改算法1中给出的伪代码，在算法开始时将全局变量m初始化为0，并在访问过程的第一行添加语句“m := m + 1”和“将m分配给顶点v”。为了看到这种编号对应于生成树的前序遍历创建的顶点编号，我们需要证明每个顶点的编号小于其子节点的编号，并且子节点的编号从左到右递增（假设每次向树中添加的新子节点都位于其已在树中的兄弟节点的右侧）。显然，顶点的子节点只有在该顶点被添加后才会被添加到树中，因此它们的编号必须大于其父节点的编号。并且如果一个顶点的兄弟节点有一个更小的编号，那么它一定已经被访问过，因此已经被添加到树中。",
        "answer_symbols": [
            "<",
            ">"
        ]
    },
    "11.4 49": {
        "question": "用伪码来描述宽度优先搜索的一个变种，它把整数 m 指定给在搜索中访问的第 m 个顶点。",
        "answer": "我们修改算法2中给出的伪代码，在算法开始时将m初始化为0，并在删除顶点v的语句后添加“m:= m+ 1”和“将m分配给顶点v”。",
        "answer_symbols": [
            ":=",
            "+",
            ":="
        ]
    },
    "11.4 50": {
        "question": "假设 G 是有向图并且 T 是用宽度优先搜索构造的生成树。证明：G 的每条边都连接同一层的两个顶点、连接一个顶点到低一层的一个顶点或者连接一个顶点到更高层的一个顶点。",
        "answer": "注意，“较低”的层次是在树中更靠下，即更远离根，因此具有更大的值。这类似于练习34。同样注意顶点放入（因此也从）列表L的顺序是层次顺序。换句话说，生成树的根首先出现，然后是第一层的顶点（在处理根时放入列表），接着是第二层的顶点（在处理第一层顶点时放入列表），依此类推。现在假设uv是一条不在树中的有向边。首先假设算法先处理u再处理v。换句话说，u在列表L中出现的时间早于v。由于边uv不在树中，因此当处理u时，v已经在列表L中了。为了发生这种情况，v的父节点p必须在u之前被处理。注意，p在树中的层级比v少一级。因此，u的层级大于或等于p的层级但小于或等于v的层级，所以这条有向边从一个层级的顶点指向同一层级或低一层级的顶点。接下来假设算法先处理了v再处理了u。那么v的层级在u的层级之上或与之相同，没有什么需要证明的。",
        "answer_symbols": [
            "<=",
            ">="
        ]
    },
    "11.4 51": {
        "question": "证明：如果 G 是有向图并且 T 是用深度优先搜索构造的生成树，则不在这个生成树上的每条边都是连接祖先到后代的前进边、连接后代到祖先的后退边，或者连接一个顶点到从前访问过的子树的一个顶点的交叉边。",
        "answer": "如果有向边uv在深度优先搜索过程中处理其尾部u时不被跟踪，则必须是其头部v已经被访问。有三种情况。如果顶点v是在我们开始处理u之后被访问的，那么因为还没有完成对u的处理，v必须出现在以u为根的子树中（因此，必须是u的后代），所以我们有一个前向边。否则，v的处理必须在我们开始处理u之前已经开始。如果它尚未完成（即我们仍在形成以v为根的子树），那么u是v的后代，因此v是u的祖先（我们有一个回边）。最后，如果v的处理已经完成，那么根据定义我们有一个交叉边。",
        "answer_symbols": []
    },
    "11.4 52": {
        "question": "描述深度优先搜索的一个变种，当算法完全处理完一个顶点时，它把最小可用的正整数指定给这个顶点。证明：在这个编号中，每个顶点的编号大于其孩子的编号并且孩子的编号从左到右递增。",
        "answer": "维护一个全局变量c，初始化为0。在过程visit结束时，添加语句\"c:= c + 1\"和\"将c分配给v\"。我们需要证明每个顶点的编号都大于其子节点的编号，并且子节点的编号从左到右递增（假设每次新添加的子节点都在树中已有的兄弟节点的右侧）。顶点v只有在其处理完成时才会被编号，这意味着v的所有后代必须已经完成了它们的处理。因此，每个顶点的编号都大于其所有子节点的编号。此外，如果一个顶点的兄弟节点编号较小，则该兄弟节点必须已经被访问过，因此已经被添加到树中。（注意，按编号列出顶点给出树的后序遍历。）",
        "answer_symbols": [
            ">"
        ]
    },
    "11.4 53": {
        "question": "求图 2 所示图 G 的在图 3c 和图 4 里所示的每对生成树之间的距离。",
        "answer": "设T是图3中构造的生成树，T1、T2、T3和T4是图4中的生成树。用d(T', T'')表示T'和T''之间的距离。那么d(T, T1)= 6，d(T, T2)= 4，d(T, T3)= 4，d(T, T4)= 2，d(T1, T2)= 4，d(T1, T3)= 4，d(T1, T4)= 6，d(T2, T3)= 4，d(T2, T4)= 2，d(T3, T4)= 4。",
        "answer_symbols": [
            "=",
            "-",
            "=",
            "=",
            "=",
            "=",
            "=",
            "=",
            "=",
            "="
        ]
    },
    "11.4 54": {
        "question": "假定 T_1、T_2 和 T_3 都是简单图 G 的生成树。证明：在 T_1 和 T_3 之间的距离不超过 T_1 和 T_2 之间的距离与 T_2 和 T_3 之间的距离的和。",
        "answer": "假设T1包含a条不在T2中的边，因此T1和T2之间的距离是2a。进一步假设T2包含b条不在T3中的边，因此T2和T3之间的距离是2b。现在最坏的情况下，T1中不在T3中的唯一边是那些a + b条边，这些边要么在T1中但不在T2中，要么在T1和T2中但不在T3中。因此，T1和T3之间的距离最多为2(a + b)。",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "11.4 55": {
        "question": "假定 T_1 和 T_2 都是简单图 G 的生成树。另外，假定 e_1 是在 T_1 里但不在 T_2 里的一条边。证明：存在在 T_2 里但不在 T_1 里的一条边 e_2，使得若从 T_1 里删除 e_1 而添加 e_2 到 T_1 里，则 T_1 仍然是生成树，并且若从 T_2 里删除 e_2 而添加 e_1 到 T_2 里，则 T_2 仍然是生成树。",
        "answer": "假设e1={u, v}如指定。那么T2 ∪ {e1} 包含一个包含e1的简单回路C。图T1−{e1}有两个连通分量；e1的端点位于不同的分量中。沿C从u向与e1相反的方向行进，直到你到达与v在同一个分量中的第一个顶点。刚刚经过的边就是e2。显然，T2 ∪ {e1} − {e2} 是一棵树，因为e2在C上。同样，T1 − {e1} ∪ {e2} 是一棵树，因为e2重新连接了两个分量。",
        "answer_symbols": [
            "∪",
            "−",
            "∪",
            "−",
            "∪"
        ]
    },
    "11.4 56": {
        "question": "证明：通过依次删除一条边而添加另外一条边，就有可能从任何一个生成树得出一个生成树的序列。",
        "answer": "按照练习55的构造方法，当我们从T1中移除边e1并添加边e2到T1时，T1和T2之间的距离减少2。因此，在应用此操作d次之后，我们可以将任何树T1转换为任何其他生成树T2（其中d是T1和T2之间距离的一半）。",
        "answer_symbols": [
            "-"
        ]
    },
    "11.4 57": {
        "question": "对 10.5 节练习 18~23 中的每个有向图来说，求这个图的有根生成树，或者确定不存在这样的树。",
        "answer": "练习18：c a d b 练习19：b c a d 练习20：b a d e c",
        "answer_symbols": []
    },
    "11.4 58": {
        "question": "证明：每个顶点的人度和出度都相等的连通有向图具有有根生成树。",
        "answer": "根据第10.5节练习16，有向图中存在欧拉回路C。我们沿着C进行并删除有向图中每个终端顶点已在C中先前访问过的边。我们声称，C中剩余的边形成一棵根树。显然，从根到每个其他顶点都有一条有向路径，因为我们只删除了允许我们到达已经可以到达的顶点的边。此外，不可能存在简单回路，因为我们移除了每一个会形成简单回路的边。",
        "answer_symbols": []
    },
    "11.4 59": {
        "question": "给出构造每个顶点的人度和出度都相等的连通有向图的有根生成树的算法。",
        "answer": "首先在有向图中构造一个欧拉回路。然后从这个回路中删除所有通向已访问顶点的边。",
        "answer_symbols": []
    },
    "11.4 60": {
        "question": "证明：如果 G 是有向图并且 T 是用深度优先搜索构造的生成树，则 G 含有回路当且仅当 G 含有相对于生成树 T 的背边。",
        "answer": "由于这是一个“当且仅当”陈述，我们需要证明两件事。首先，假设G包含一个回路v1, v2, ..., vk, v1，并且不失一般性地假设v1是深度优先搜索过程中第一个被访问的顶点。由于存在从v1到vk的有向路径，顶点vk必须在v1的处理完成之前被访问。因此v1是vk在树中的祖先，边vkv1是一条后向边。现在我们需要证明逆命题。假设T包含一条从顶点u到其祖先v的后向边uv。那么从v到u的T中的路径，再加上这条边，就是G中的一个回路。",
        "answer_symbols": []
    },
    "11.4 61": {
        "question": "用练习 60 来构造一个确定有向图是否含有回路的算法。",
        "answer": "根据练习60，有向图包含回路当且仅当存在任何后向边。我们可以通过以下方式检测后向边。在每个顶点v上添加一个标记，以指示其状态：尚未看到（初始情况），已看到（即放入T）但尚未完成（即visit(v)尚未终止），或已完成（即visit(v)已终止）。算法1中的几行额外代码可以完成这种记录。然后，要确定有向图是否有回路，只需检查在查看边uv时，v的状态是否为“已看到”。如果这种情况发生，则我们知道存在回路；否则，没有回路。",
        "answer_symbols": []
    },
    "11.5 1": {
        "question": "下图所表示的道路都还没有铺设路面。边的权表示在成对的乡镇之间的道路长度。哪些道路应当铺设路面，以便在每对乡镇之间都有铺设路面的道路，而且使得铺设的道路的长度最短？（注意：这些乡镇都在内华达州。)",
        "answer": "Deep Springs–Oasis, Oasis–Dyer, Oasis–Silver Peak, Silver Peak–Goldfield, Lida–Gold Point, Gold Point–Beatty, Lida–Goldfield, Goldfield–Tonopah, Tonopah–Manhattan, Tonopah–Warm Springs",
        "answer_symbols": []
    },
    "11.5 2": {
        "question": "用普林算法求所给的加权图的最小生成树。",
        "answer": "我们从最小权重边{a, b}开始。与到目前为止构建的树相关联的最小权重边是边{a, e}，其权重为2，因此我们将其添加到树中。接下来我们添加边{d, e}，然后是边{c, d}。这完成了树的构建，其总权重为6。",
        "answer_symbols": [
            "{",
            "}",
            ","
        ]
    },
    "11.5 3": {
        "question": "用普林算法求所给的加权图的最小生成树。",
        "answer": "{e, f}, {c, f}, {e, h}, {h, i}, {b, c}, {b, d}, {a, d}, {g, h}",
        "answer_symbols": [
            "{",
            "}",
            ",",
            "e",
            "f",
            "c",
            "h",
            "i",
            "b",
            "d",
            "a",
            "g"
        ]
    },
    "11.5 4": {
        "question": "用普林算法求所给的加权图的最小生成树。",
        "answer": "边按以下顺序添加：{a, b}、{a, e}、{a, d}、{c, d}、{d, h}、{a, m}、{d, p}、{e, f}、{e, i}、{g, h}、{l, p}、{m, n}、{n, o}、{f, j} 和 {k, l}，总权重为28。",
        "answer_symbols": [
            "{",
            "}",
            ",",
            "和"
        ]
    },
    "11.5 5": {
        "question": "用克鲁斯卡尔算法设计在本节开头所描述的通信网络。",
        "answer": "San Francisco Denver Chicago Atlanta New York $1200 $900",
        "answer_symbols": [
            "$",
            "$"
        ]
    },
    "11.5 6": {
        "question": "用克鲁斯卡尔算法求练习2里加权图的最小生成树。",
        "answer": "使用Kruskal算法时，我们在每一步都添加不会形成简单回路的最短边。首先选择边{a, b}，然后是边{c, d}（按字母顺序解决平局），接着是{a, e}和{d, e}。总权重为6。",
        "answer_symbols": [
            "{",
            "}",
            ",",
            "（",
            "）"
        ]
    },
    "11.5 7": {
        "question": "用克鲁斯卡尔算法求练习3里加权图的最小生成树。",
        "answer": "{e, f}, {a, d}, {h, i}, {b, d}, {c, f}, {e, h}, {b, c}, {g, h}",
        "answer_symbols": [
            "{",
            "}",
            ",",
            "e",
            "f",
            "a",
            "d",
            "h",
            "i",
            "b",
            "c",
            "g"
        ]
    },
    "11.5 8": {
        "question": "用克鲁斯卡尔算法求练习4里加权图的最小生成树。",
        "answer": "边按以下顺序添加：{a, b}、{a, e}、{c, d}、{d, h}、{a, d}、{a, m}、{d, p}、{e, f}、{e, i}、{g, h}、{l, p}、{m, n}、{n, o}、{f, j} 和 {k, l}，总权重为28。",
        "answer_symbols": [
            "{",
            "}",
            ",",
            "和"
        ]
    },
    "11.5 9": {
        "question": "找出具有多于一棵最小生成树的、带有最少可能边数的连通加权简单图。",
        "answer": "1 a 1 1 b c",
        "answer_symbols": [
            "1",
            "a",
            "b",
            "c"
        ]
    },
    "11.5 10": {
        "question": "加权图里的最小生成森林是权最小的生成森林。解释如何修改普林算法和克鲁斯卡尔算法来构造最小生成森林。",
        "answer": "一种方法是将所选算法应用于每个组件。实际上，这意味着我们必须先确定组件。更具体地说，我们可以这样实现这些过程。对于Prim算法，从第一个顶点开始，反复添加不形成简单回路的最短相邻边。当没有这样的边时，我们找到一个尚未在生成森林中的顶点，并从此顶点生长出新的树。我们重复这个过程，直到没有新的顶点剩余。Kruskal算法的实现甚至更简单。我们不断选择不会形成简单回路的最短边，直到没有这样的边剩余。结果是最小权重的生成森林。",
        "answer_symbols": []
    },
    "11.5 11": {
        "question": "设计与普林算法类似的、构造连通加权图的最大生成树的算法。",
        "answer": "在每个阶段不选择最小权重的边，而是选择具有相同性质的最大权重的边。",
        "answer_symbols": []
    },
    "11.5 12": {
        "question": "设计与克鲁斯卡尔算法类似的、构造连通加权图的最大生成树的算法。",
        "answer": "如果我们简单地将“最小”一词替换为“最大”一词（并在注释中将“最小”一词替换为“最大”），则生成的算法将找到最大生成树。",
        "answer_symbols": []
    },
    "11.5 13": {
        "question": "求练习2里加权图的最大生成树。",
        "answer": "a b c d e 4 3 3 3",
        "answer_symbols": [
            "a",
            "b",
            "c",
            "d",
            "e",
            "4",
            "3"
        ]
    },
    "11.5 14": {
        "question": "求练习3里加权图的最大生成树。",
        "answer": "答案是唯一的。它使用了边{d, h}、{d, e}、{b, f}、{d, g}、{a, b}、{b, e}、{b, c} 和 {f, i}。",
        "answer_symbols": [
            "{",
            "}",
            ",",
            "和"
        ]
    },
    "11.5 15": {
        "question": "求练习4里加权图的最大生成树。",
        "answer": "a b c d e f g h i j k l m n o p 2 2 3 2 3 3 4 3 3 4 3 3 3 4 3",
        "answer_symbols": [
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g",
            "h",
            "i",
            "j",
            "k",
            "l",
            "m",
            "n",
            "o",
            "p",
            "2",
            "3",
            "4"
        ]
    },
    "11.5 16": {
        "question": "求在本节开头所提出问题中连接5个计算机中心的次最便宜的通信网络。",
        "answer": "我们遵循练习17中概述的程序。回想一下，最小生成树使用了边亚特兰大–芝加哥、亚特兰大–纽约、丹佛–旧金山和芝加哥–旧金山。首先删除亚特兰大到芝加哥的边。剩余图的最小生成树的成本为3900美元。接下来删除亚特兰大到纽约的边（并恢复先前删除的边）。此时最小生成树的成本为3800美元。接下来查看删除丹佛到旧金山的边的图。最小生成树的成本为4000美元。最后查看删除芝加哥到旧金山的边的图。最小生成树的成本为3700美元。这就是我们的答案；它包括链接亚特兰大–芝加哥、亚特兰大–纽约、丹佛–旧金山和芝加哥–丹佛。",
        "answer_symbols": [
            "–"
        ]
    },
    "11.5 17": {
        "question": "设计求连通加权图里次短生成树的算法。",
        "answer": "首先找到具有n条边的图G的一棵最小生成树T。然后对于i=1到n-1，从G中删除T的第i条边，并找到剩余图的最小生成树。选择这n-1棵树中最短的一棵。",
        "answer_symbols": [
            "n",
            "i",
            "-",
            "1"
        ]
    },
    "11.5 18": {
        "question": "证明：连通加权图里权最小的边，必然属于任何一个最小生成树。",
        "answer": "假设最小权重的边e未包含在某个最小生成树中；换句话说，假设最小生成树T仅包含权重大于e的边。如果我们向T中添加e，则将获得一个恰好包含一个简单回路的图，该回路包含e。然后我们可以删除此回路中的其他某条边，得到一个权重严格小于T的生成树（因为所有其他边的权重都大于e）。这与T是最小生成树的事实矛盾。因此，最小权重的边必须包含在T中。",
        "answer_symbols": []
    },
    "11.5 19": {
        "question": "证明：若所有边的权都不相同，则连通加权图里有唯一的最小生成树。",
        "answer": "如果所有边的权重都不同，那么当添加一条边e(k+1)到T并删除一条边e时，而不是可能产生另一棵生成树，Prim算法的证明中会得到矛盾。",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "1"
        ]
    },
    "11.5 20": {
        "question": "假定连接图1里城市的计算机网络必须包含纽约与丹佛之间的直接连接。那么应当包含哪些其他的连接，使得在每两个计算机中心之间都存在连接，并且费用最少？",
        "answer": "我们从纽约到丹佛的链接开始，然后通过依次添加不会形成简单回路的最便宜的边来形成生成树。事实上，最便宜的三条边就足够了：亚特兰大–芝加哥、亚特兰大–纽约和丹佛–旧金山。这给出了4000美元的成本。",
        "answer_symbols": [
            "-",
            "->",
            "–"
        ]
    },
    "11.5 22": {
        "question": "描述一个算法，它求连通加权无向简单图里包含所规定的一组边的权最小的生成树。",
        "answer": "The algorithm is the same as Kruskal's, except that instead of starting with the empty tree, we start with the given set of edges. (If there is already a simple circuit among these edges, then there is no solution.)",
        "answer_symbols": []
    },
    "11.5 23": {
        "question": "用伪码表达练习 22 设计的算法。",
        "answer": "与Kruskal算法相同，只是从T:=这组边开始，并从i=1迭代到i=n-1-s，其中s是你开始时的边数。",
        "answer_symbols": [
            "=",
            ":",
            "i",
            "n",
            "-",
            "1",
            "s"
        ]
    },
    "11.5 24": {
        "question": "证明：在索林算法的每个阶段，边的添加都产生一个森林。",
        "answer": "We prove this by contradiction. Suppose that there is a simple circuit formed after the addition of edges at some stage in the algorithm. The circuit will contain some edges that were added at that stage and perhaps some edges that were already present. Let e₁, e₂, ..., eₙ be the edges that are new, in the order they are traversed in the circuit. Thus the circuit can be thought of as the sequence e₁, T₁, e₂, T₂, ..., eₙ, Tₙ, e₁, where each Tᵢ is a tree that existed before the addition of new edges. Each edge in this sequence was the edge picked by the tree containing one of its two endpoints, so since there are the same number of trees as there are edges in this sequence, each tree must have picked a different edge. However, let e be the shortest edge (after tie-breaking) among {e₁, e₂, ..., eₙ}. Then the tree at both of its ends necessarily picked e to add to the tree, a contradiction. Therefore, there are no simple circuits.",
        "answer_symbols": [
            "{",
            "}",
            "∈",
            "→",
            "≠",
            "≤",
            "∑"
        ]
    },
    "11.5 26": {
        "question": "用伪代码表达索林算法。",
        "answer": "The actual implementation of this algorithm is more difficult than this pseudocode shows, of course.",
        "answer_symbols": []
    },
    "11.5 27": {
        "question": "证明：索林算法产生连通无向加权图里的最小生成树。",
        "answer": "根据练习24，在Sollin算法的每个阶段都会生成一个森林。因此，在选择了n-1条边之后，会生成一棵树。接下来需要证明这棵树是最小生成树。设T是一棵最小生成树，它与Sollin的树S有尽可能多的公共边。如果T ≠ S，则在算法的某个阶段会添加一条边e ∈ S - T，而在此阶段之前，S中的所有边都在T中。T ∪ {e}包含一个唯一的简单回路。在这个回路上找到一条边e' ∈ S - T和一条边e'' ∈ T - S，并将它们视为“超级顶点”。根据算法，w(e') ≤ w(e'')。所以用T - {e''} ∪ {e'}替换T，生成一棵比T更接近S的最小生成树。",
        "answer_symbols": [
            "=",
            "∪",
            "∈",
            "-",
            "∪",
            "∈",
            "-",
            "≤",
            "∪"
        ]
    },
    "11.5 28": {
        "question": "证明：当输入为含有 n 个顶点的无向图时，索林算法的第一步产生至少包含 ⌈n/2⌉ 条边的森林。",
        "answer": "This is a special case of Exercise 29, with r equal to the number of vertices in the graph (each vertex is a tree by itself at the beginning of the algorithm); see the solution to that exercise.",
        "answer_symbols": [
            "="
        ]
    },
    "11.5 29": {
        "question": "证明：若在索林算法的某个中间步骤存在 r 棵树，则算法的下一次迭代至少添加 ⌈r/2⌉ 条边。",
        "answer": "每棵r树至少通过一条新边连接到另一棵树。因此，结果中最多有r/2棵树（每棵新树包含两个或多个旧树）。为了实现这一点，我们需要添加r - (r/2) = r/2条边。因为添加的边数是整数，所以至少需要⌊r/2⌋条边。",
        "answer_symbols": [
            "/",
            "-",
            "⌊",
            "⌋"
        ]
    },
    "11.5 30": {
        "question": "证明：当输入为含有 n 个顶点的无向图时，在已经完成索林算法的第一步，并且已经 k-1 次执行索林算法的第二步之后，还剩下不超过 ⌈n/2^k⌉ 棵树。",
        "answer": "As argued in the solution to Exercise 29, each stage in the algorithm reduces the number of trees by a factor of at least 2. Therefore, after k stages at most n/2ᵏ trees remain. Since the number of trees is an integer, the number must be less than or equal to floor(n/2ᵏ).",
        "answer_symbols": [
            "/",
            "^",
            "<=",
            "⌊",
            "⌋"
        ]
    },
    "11.5 31": {
        "question": "证明：索林算法至少需要 log n 次迭代，以便从带有 n 个顶点的连通无向加权图产生一棵最小生成树。",
        "answer": "如果k ≥ log n，则n/2^k ≤ 1，所以⌊n/2^k⌋ = 1，所以根据练习30，算法在最多log n次迭代后结束。",
        "answer_symbols": [
            "≥",
            "≤",
            "⌊",
            "⌋"
        ]
    },
    "11.5 32": {
        "question": "证明：克鲁斯卡尔算法产生最小生成树。",
        "answer": "Let G be a connected weighted graph. Suppose that the successive edges chosen by Kruskal's algorithm are e₁, e₂, ..., eₙ−₁, in that order, so that the tree S containing these edges is the tree constructed by the algorithm. Let T be a minimum spanning tree of G containing e₁, e₂, ..., eₖ, with k chosen as large as possible (possibly 0). If k = n − 1, then we are done, since S = T. Otherwise, k < n − 1, and in this case, we will derive a contradiction by finding a minimum spanning tree T' which gives us a larger value of k. Consider T ∪ {eₖ₊₁}. Since T is a tree, this graph has a simple circuit which must contain eₖ₊₁. Some edge e in this simple circuit is not in S, since S is a tree. Furthermore, e was available to be chosen by Kruskal's algorithm at the point at which eₖ₊₁ was chosen, since there is no simple circuit among {e₁, e₂, ..., eₖ, e} (these edges are all in T). Therefore, the weight of eₖ₊₁ is less than or equal to the weight of e (otherwise, the algorithm would have chosen e instead of eₖ₊₁). Now add eₖ₊₁ to T and delete e; call the resulting tree T'. The weight of T' cannot be any greater than the weight of T. Therefore, T' is also a minimum spanning tree, which contains the edges e₁, e₂, ..., eₖ, eₖ₊₁. This contradicts the choice of T, and our proof is complete.",
        "answer_symbols": [
            "=",
            "∪",
            "{",
            "}",
            "∈",
            "<=",
            "→",
            "≠",
            "∑"
        ]
    },
    "11.5 33": {
        "question": "证明：若 G 是各边权值都不同的加权图，则对于 G 中的每条简单回路，该回路中权值最大的边不属于 G 的任何一棵最小生成树。",
        "answer": "假设最小生成树T包含一条边e = uv，它是简单回路C中的最大权重边。从T中删除e。这将创建一个森林，其中有两个组件，一个包含u，另一个包含v。沿着路径C - e从u开始。在某个点，这条路径必须从包含u的T - e的组件跳到包含v的T - e的组件，假设使用边f。这条边不能在T中，因为e可以是唯一连接这两个组件的T的边（否则T中会有简单回路）。因为e是C中的最大权重边，",
        "answer_symbols": []
    },
    "11.5 34": {
        "question": "用伪码描述逆删除算法。",
        "answer": "This algorithm converts G into its minimum spanning tree. To implement it, it is best to order the edges by decreasing weight before we start.procedure reverse-delete(G : weighted connected undirected graph with n vertices)\nwhile G has more than n − 1 edges\ne := any edge of largest weight that is in a simple circuit in G\n(i.e., whose removal would not disconnect G)\nG := G with edge e deleted",
        "answer_symbols": []
    },
    "11 Supplementary Exercises 1": {
        "question": "证明：简单图是树当且仅当它不包含简单回路，并且添加连接两个不相邻顶点的一条边产生的新图恰好有一条简单回路（这里包含相同边的回路只算作一个）。",
        "answer": "假设 T 是一棵树。显然 T 没有简单回路。如果我们添加一条连接两个非相邻顶点 u 和 v 的边 e，则显然会形成一个简单回路，因为当 e 添加到 T 时，形成的图的边太多而不能成为一棵树。唯一形成的简单回路由边 e 和 T 中从 v 到 u 的唯一路径组成。假设 T 满足给定条件。只需要证明 T 是连通的，因为图中没有简单回路。假设 T 不连通。则让 u 和 v 在不同的连通分支中。添加 e={u, v} 不满足条件。",
        "answer_symbols": [
            "=",
            "+",
            "-"
        ]
    },
    "11 Supplementary Exercises 2": {
        "question": "有多少种非同构的带 6 个顶点的有根树？",
        "answer": "有20棵树。我们可以通过树的高度来组织计数。只有一棵以6个顶点为根的树高度为5。如果高度为4（即从根开始有一条包含5个顶点的路径），那么第六个顶点有4种选择。如果高度为3，固定一条从根开始长度为3的路径。需要再添加两个顶点。如果它们都直接附加到原始路径上，则有C(3 + 2 - 1, 2) = 6种方法将它们附加（因为有三个可能的附着点）。另一方面，如果它们从附着点形成长度为2的路径，则有2种选择。接下来假设高度为2。如果没有从根开始的两条不相交的长度为2的路径，则其他3个顶点可以以4种方式附着到给定的长度为2的路径上（0、1、2或3个顶点可以附着到根上）。如果有两条不相交的路径，则有2种选择第六个顶点的方法。最后，高度为1的树有1棵。因此，总共有1 + 4 + 6 + 2 + 4 + 2 + 1 = 20棵树。",
        "answer_symbols": [
            "+",
            "-",
            "(",
            ")",
            "=",
            "C"
        ]
    },
    "11 Supplementary Exercises 3": {
        "question": "证明：每一个至少有一条边的树都至少有两个悬挂点。",
        "answer": "假设一棵树 T 有 n 个顶点，度分别为 d1, d2, ..., dn。因为 2e = Σ(di) (i 从 1 到 n)，且 e = n - 1，所以有 2(n - 1) = Σ(di) (i 从 1 到 n)。因为每个 di ≥ 1，所以 2(n - 1) = n + Σ(di - 1) (i 从 1 到 n)，或 n - 2 = Σ(di - 1) (i 从 1 到 n)。因此，最多有 n - 2 项大于或等于 1。因此，至少有两项为 0。因此，至少有两个 di = 1。",
        "answer_symbols": [
            "=",
            "≥",
            "+",
            "-",
            "Σ"
        ]
    },
    "11 Supplementary Exercises 4": {
        "question": "证明：有 n-1 个悬挂点的、带有 n 个顶点的树必然同构于 K1,n-1。",
        "answer": "我们知道度数之和必须是2(n - 1)。n - 1个悬挂顶点在这个和中占n - 1，所以另一个顶点的度数必须是n - 1。这个顶点是K1, n - 1的一部分，而悬挂顶点是另一部分。",
        "answer_symbols": [
            "-",
            "(",
            ")",
            "+"
        ]
    },
    "11 Supplementary Exercises 5": {
        "question": "带有 n 个顶点的树的顶点的度之和是什么？",
        "answer": "2n - 2",
        "answer_symbols": [
            "-",
            "*"
        ]
    },
    "11 Supplementary Exercises 6": {
        "question": "假定 d1, d2, …, dn 是和为 2n-2 的 n 个正整数。证明：存在一个带有 n 个顶点的树，使得这些顶点的度为 d1, d2, …, dn。",
        "answer": "我们通过归纳法证明这一点。如果n ≤ 2，问题很简单，所以假设归纳假设成立且n ≥ 3。首先注意至少有一个正整数di等于1，因为每个大于或等于2的n个数的和大于或等于2n。不失一般性假设dn = 1。现在不可能所有剩余的di都等于1，因为2n - 2 > n（我们假设n > 2）；不失一般性假设d1 > 1。现在对序列d1 - 1, d2, d3, ..., dn - 1应用归纳假设。存在具有这些度数的树。从度数为d1 - 1的顶点到一个新顶点添加一条边，我们就得到了所需的度数为d1, d2, ..., dn的树。",
        "answer_symbols": [
            "≤",
            "≥",
            "+",
            "-",
            "(",
            ")",
            ">"
        ]
    },
    "11 Supplementary Exercises 8": {
        "question": "证明：每个树都是二分图。",
        "answer": "我们将树视为有根树。一部分是位于偶数层次的顶点集，另一部分是位于奇数层次的顶点集。",
        "answer_symbols": []
    },
    "11 Supplementary Exercises 9": {
        "question": "证明：每个森林都可以用两种颜色来着色。",
        "answer": "分别对每个连通分支进行着色。对于这些连通分支中的每一个，首先将树根化，然后将所有偶数层的顶点涂成红色，所有奇数层的顶点涂成蓝色。",
        "answer_symbols": []
    },
    "11 Supplementary Exercises 10": {
        "question": "画出 3 种不同的高度为 4 的 3 度 B 树。",
        "answer": "下图显示了一些具有所需高度和度的B树。根必须有2或3个子节点，其他内部节点必须有2到4个子节点（包括2和4）。注意我们的第一个例子是一个完全二叉树。",
        "answer_symbols": [
            "-",
            "(",
            ")",
            "≥",
            "≤"
        ]
    },
    "11 Supplementary Exercises 11": {
        "question": "给出高度为 h 的 k 度 B 树里树叶数的上界和下界。",
        "answer": "上界：kh；下界：⌊2^(k/2)⌋ h - 1",
        "answer_symbols": [
            "*",
            "^",
            "⌊",
            "⌋",
            "-"
        ]
    },
    "11 Supplementary Exercises 12": {
        "question": "给出有 n 个树叶的 k 度 B 树的高度的上界和下界。",
        "answer": "度为 k 且有 n 个叶子节点的 B 树的高度下界来自于度为 k 高度为 h 的 B 树的叶子节点数量上界，该上界在第 11 题中已求得。由于我们在那里发现 n ≤ kʰ，因此我们有 h ≥ logₖ(n)。度为 k 且有 n 个叶子节点的 B 树的高度上界来自于度为 k 高度为 h 的 B 树的叶子节点数量下界，该下界在第 11 题中已求得。由于我们在那里发现 n ≥ 2 * (k/2)^(h-1)，因此我们有 h ≤ 1 + log₍k/2₎(n/2)。",
        "answer_symbols": [
            "≤",
            "≥",
            "^",
            "(",
            ")",
            "+",
            "log"
        ]
    },
    "11 Supplementary Exercises 13": {
        "question": "对 k=0, 1, 2, 3, 4，画出 Bk。",
        "answer": "B0 B1 B2 B3 B4",
        "answer_symbols": []
    },
    "11 Supplementary Exercises 14": {
        "question": "Bk 有多少个顶点？证明你的答案是正确的。",
        "answer": "由于 B_(k+1) 是由两个 B_k 的副本形成的，当 k 增加 1 时，顶点的数量翻倍。因为 B_0 有 1 = 2^⁰ 个顶点，所以通过归纳可以得出 B_k 有 2ᵏ 个顶点。",
        "answer_symbols": [
            "+",
            "=",
            "^"
        ]
    },
    "11 Supplementary Exercises 15": {
        "question": "求 Bk 的高度。证明你的答案是正确的。",
        "answer": "因为 Bk+1 是由两个 Bk 的副本组成的，其中一个向下移动一层，所以随着 k 增加 1，高度增加 1。因为 B0 的高度为 0，所以通过归纳可以得出 Bk 的高度为 k。",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "11 Supplementary Exercises 16": {
        "question": "Bk 在深度 j 有多少个顶点？其中 0 ≤ j < k。证明你的答案是正确的。",
        "answer": "查看 B_k 的图示可以推测深度为 j 的顶点数量是 C(k, j)。例如，在 B_4 中，各级别的顶点数量形成序列 1, 4, 6, 4, 1，这些正好是 C(4, 0), C(4, 1), C(4, 2), C(4, 3), C(4, 4)。通过数学归纳法证明这一点（基础步骤是平凡的），注意到 B_(k+1) 的构建方式，B_(k+1) 中第 j+1 层的顶点数量是 B_k 中第 j+1 层的顶点数量和 B_k 中第 j 层的顶点数量之和。根据归纳假设，这是 C(k, j+1) + C(k, j)，这等于 C(k+1, j+1)，正如所期望的，由帕斯卡恒等式得出。这同样适用于 j=k，以及第 0 层，显然只有一个顶点。",
        "answer_symbols": [
            "+",
            "(",
            ")",
            ","
        ]
    },
    "11 Supplementary Exercises 17": {
        "question": "Bk 的根的度数是多少？证明你的答案是正确的。",
        "answer": "因为 Bk+1 的根是 Bk 的根加上一个额外的孩子（即另一个 Bk 的根），所以随着 k 增加 1，根的度数增加 1。因为 B0 的根的度数为 0，所以通过归纳可以得出 Bk 的根的度数为 k。",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "11 Supplementary Exercises 18": {
        "question": "证明：Bk 中度数最大的顶点是根。",
        "answer": "我们的归纳假设是 B_k 的根节点和最左边的孩子节点的度数为 k，其他每个节点的度数小于 k。这显然对 B_0 和 B_1 成立。考虑 B_(k+1)。根据第 17 题，其根节点的度数为 k+1，如预期。最左边的孩子节点是 B_k 的根节点，它原本的度数为 k，并且我们添加了一条边将其连接到 B_(k+1) 的根节点，因此它的度数现在为 k+1，如预期。B_(k+1) 的每个其他节点在 B_k 中的度数相同，根据归纳假设，最多为 k，我们的证明完成。",
        "answer_symbols": [
            "+",
            "<="
        ]
    },
    "11 Supplementary Exercises 19": {
        "question": "对 k=0, 1, 2, 3, 4，画出一个 Sk 树。",
        "answer": "S0 S1 S2 S3 S4",
        "answer_symbols": []
    },
    "11 Supplementary Exercises 20": {
        "question": "证明：Sk 树有 2^k 个顶点并且在 k 层上有唯一一个顶点。在 k 层上的这个顶点称为柄。",
        "answer": "S_k 树有 2ᵏ 个顶点是很清楚的，因为 S_k 树的顶点数量是 S_(k-1) 树的两倍，而 S_0 树有 2^⁰ = 1 个顶点。同样通过归纳法，我们可以看到第 k 层有一个唯一的顶点，因为在构造 S_k 树时，S_(k-1) 树的唯一第 k-1 层顶点被设为另一个 S_(k-1) 树的根节点的孩子。",
        "answer_symbols": [
            "=",
            "^",
            "-"
        ]
    },
    "11 Supplementary Exercises 21": {
        "question": "假定 T 是带有柄 v 的 Sk 树。证明：T 可以从根分别为 r1, r2, …, rk-1 的不相交的树 T0, T1, …, Tk-1 来获得，其中 v 不在这些树的任何一个中，对 i=0, 1, …, k-1 来说，Ti 是通过对 i=0, 1, …, k-2，连接 v 到 vi 并且连接 ri 到 ri+1 得到的 Si 树。",
        "answer": "使用数学归纳法。当 k = 0 时，结果是平凡的。假设当 k - 1 时成立。Tk-1 是 T 的父树。通过归纳，T 的子树可以从 T0, ..., Tk-2 以所述方式获得。最终的连接是从 rk-2 到 rk-1，这是 Sk-树定义中的内容。",
        "answer_symbols": [
            "=",
            "-"
        ]
    },
    "11 Supplementary Exercises 22": {
        "question": "列出 11.3 节图 3 和图 9 中的有序根树在层顺序下的顶点列表。",
        "answer": "每种情况下的层次顺序是顶点标签的字母顺序。",
        "answer_symbols": []
    },
    "11 Supplementary Exercises 23": {
        "question": "设计列出有序根树在层顺序下的顶点列表的算法。",
        "answer": "过程 level(T: 有序根树，根为 r) 队列 := 仅包含根 r 的序列 当队列至少包含一个元素时 v := 队列中的第一个顶点 列出 v 从队列中移除 v 并将其子节点放在队列的末尾",
        "answer_symbols": []
    },
    "11 Supplementary Exercises 24": {
        "question": "设计一种算法，确定一组通用地址能否成为有根树的树叶地址。",
        "answer": "给定一组通用地址，我们需要检查两件事。首先，确保列表中的任何地址都不是内部节点的地址。这可以通过检查列表中的任何地址都不是列表中另一个地址的前缀来实现。（当然，如果列表包含 0，则不能包含其他地址。）其次，确保所有内部节点都有一个叶节点作为后代。为此，对于列表中的每个地址 a1.a2...ar，以及从 1 到 r（包括 r）的每个 i，以及满足 1 ≤ b < ai 的每个 b，我们检查列表中是否存在以 a1.a2...ai-1.b 为前缀的地址。",
        "answer_symbols": [
            "<",
            "≤"
        ]
    },
    "11 Supplementary Exercises 25": {
        "question": "设计从树叶的通用地址来构造有根树的算法。",
        "answer": "通过插入地址 0 的根，然后为每个标记为 i 的顶点（i 为正整数）插入一个子树来构建树，这些子树由每个标记为 i.j 的顶点（j 为正整数）的子树构建，依此类推。",
        "answer_symbols": []
    },
    "11 Supplementary Exercises 26": {
        "question": "证明：图的割集必然与这个图的任何生成树都有至少一条公共边。",
        "answer": "假设所讨论的图是连通的。（如果不是，则该陈述显然是成立的。）如果我们移除所有割集的边，结果图将不再连通。如果结果图包含生成树的所有边，则它将是连通的。因此，割集中必须至少包含生成树的一条边。",
        "answer_symbols": []
    },
    "11 Supplementary Exercises 28": {
        "question": "树是否必然是仙人掌图？",
        "answer": "树必然是仙人掌图，因为没有边在任何简单回路中。",
        "answer_symbols": []
    },
    "11 Supplementary Exercises 29": {
        "question": "证明：若在树里添加一条回路，它包含一些起止于树里顶点上的新边，则形成一个仙人掌图。",
        "answer": "结果图没有任何边出现在多于一个描述类型的简单回路中。因此，它是一个仙人掌图。",
        "answer_symbols": []
    },
    "11 Supplementary Exercises 30": {
        "question": "证明：若在连通图里，每条不经过任何顶点（除起点以外）超过一次的回路都包含奇数条边，则这个图必然是仙人掌图。",
        "answer": "假设 G 不是仙人掌图；我们将证明 G 包含一个具有偶数条边的非常简单的回路（参见第 27 题的“非常简单回路”定义）。相反，假设 G 的每个非常简单回路都包含奇数条边。因为 G 不是仙人掌图，我们可以找到一条边 e = {u, v}，它在两个不同的非常简单回路中。通过必要时简化第二个回路，我们可以假设情况如图所示，其中x可能是u，y可能是v。由于电路u, P3, x, P1, y, P4, v, e, u 和 u, P3, x, P2, y, P4, v, e, u 都是奇数长度，路径P1和P2必须具有相同的奇偶性。因此，由P1后跟反向的P2组成的非常简单的电路具有偶数长度，正如所希望的那样。\n",
        "answer_symbols": [
            "=",
            "{",
            "}"
        ]
    },
    "11 Supplementary Exercises 31": {
        "question": "在练习 31～33 中，求所给图的限制度数生成树，其中每个顶点的度都小于或等于 3，或者证明不存在这样的生成树。\no---o---o\n / \\ / \\ / \\\no---o---o---o",
        "answer": "a b c - d e f",
        "answer_symbols": [
            "-"
        ]
    },
    "11 Supplementary Exercises 32": {
        "question": "在练习 31～33 中，求所给图的限制度数生成树，其中每个顶点的度都小于或等于 3，或者证明不存在这样的生成树。\no---o---o\n / \\ / \\ / \\\no---o---o---o\n / \\ / \\\no---o---o",
        "answer": "这里的唯一生成树就是图本身，并且顶点i的度大于3。因此，不存在每个顶点的度都小于或等于3的度约束生成树。",
        "answer_symbols": []
    },
    "11 Supplementary Exercises 33": {
        "question": "在练习 31～33 中，求所给图的限制度数生成树，其中每个顶点的度都小于或等于 3，或者证明不存在这样的生成树。\no---o---o\n / \\ / \\ / \\\no---o---o---o\n / \\ / \\\no---o---o",
        "answer": "a b c - d e f - i h g",
        "answer_symbols": [
            "-"
        ]
    },
    "11 Supplementary Exercises 34": {
        "question": "证明：每个顶点的度都不超过 2 的简单图的限制度数生成树包含该图中的单独一条哈密顿通路。",
        "answer": "这样的树必须是一条路径（因为它连通且没有度大于2的顶点），并且由于它包括图中的每个顶点，因此它是一条哈密顿路径。",
        "answer_symbols": []
    },
    "11 Supplementary Exercises 36": {
        "question": "练习 35 的图，哪些是毛虫图？",
        "answer": "前三个部分中的图是毛毛虫图，因为每个顶点要么在长度为3的水平路径上，要么与这条路径上的某个顶点相邻。在第d部分中，显然没有可以作为毛毛虫“脊柱”的路径。",
        "answer_symbols": []
    },
    "11 Supplementary Exercises 37": {
        "question": "带 6 个顶点的互不同构的毛虫图有多少种？",
        "answer": "6",
        "answer_symbols": []
    },
    "11 Supplementary Exercises 38 a)": {
        "question": "证明或反证：其边形成一条唯一通路的所有树都是优美的。",
        "answer": "我们可以按照以下方式优雅地标记路径中的顶点。假设有n个顶点。我们每隔一个顶点标记一次，从第一个开始，用数字1, 2,..., [n/2]；我们按相同顺序用n, n−1,..., [n/2]+1编号剩余的顶点。例如，如果n=7，则顶点被标记为1, 7, 2, 6, 3, 5, 4。然后可以很容易地看到连续的差值为n − 1, n − 2,..., 2, 1，正如所希望的那样。",
        "answer_symbols": [
            "−",
            "[",
            "]"
        ]
    },
    "11 Supplementary Exercises 38 b)": {
        "question": "证明或反证：所有的毛虫图都是优美的。",
        "answer": "我们扩展了a部分解决方案中的想法，允许同时标记毛毛虫的“脊柱”和“脚”。我们可以假设脊柱的第一个和最后一个顶点没有脚。首先，我们将脊柱起点的顶点标记为1，然后将与其相邻的顶点标记为n。如果有脚在该顶点上，那么我们将其标记为2, 3,..., k（该顶点的脚的数量为k − 1）。然后，我们用最小可用的数字（2或k+1）标记脊柱上的下一个顶点（如果有脚需要标记）。如果这个顶点有脚，那么我们将其标记为n−1, n−2，等等。最大的可用数字用于脊柱上下一个顶点的标签。我们继续这样做，直到标记整个毛毛虫。很明显，这种标记是优雅的。请参见下面的例子。",
        "answer_symbols": [
            "−",
            "[",
            "]"
        ]
    },
    "12.1 1 a)": {
        "question": "求下列表达式的值。（a）1 + 0",
        "answer": "1",
        "answer_symbols": []
    },
    "12.1 1 b)": {
        "question": "求下列表达式的值。（b）1 + 1",
        "answer": "1",
        "answer_symbols": []
    },
    "12.1 1 c)": {
        "question": "求下列表达式的值。（c）0 + 0",
        "answer": "0",
        "answer_symbols": []
    },
    "12.1 1 d)": {
        "question": "求下列表达式的值。（d）(1 + 0)",
        "answer": "0",
        "answer_symbols": []
    },
    "12.1 2 a)": {
        "question": "求满足下列方程的布尔变量x的值（如果有的话）。（a）x + 1 = 0",
        "answer": "由于 x · 1 = x，唯一解是 x = 0。",
        "answer_symbols": [
            "·",
            "="
        ]
    },
    "12.1 2 b)": {
        "question": "求满足下列方程的布尔变量x的值（如果有的话）。（b）x + x = 0",
        "answer": "由于 0 + 0 = 0 和 1 + 1 = 1，唯一解是 x = 0。",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "12.1 2 c)": {
        "question": "求满足下列方程的布尔变量x的值（如果有的话）。（c）x + 1 = x",
        "answer": "由于这个方程对所有 x 都成立，因此有两个解，x = 0 和 x = 1。",
        "answer_symbols": [
            "="
        ]
    },
    "12.1 2 d)": {
        "question": "求满足下列方程的布尔变量x的值（如果有的话）。（d）x + x' = 1",
        "answer": "由于 x 或 x 必须为 0，无论 x 是什么值，都没有解。",
        "answer_symbols": [
            "或"
        ]
    },
    "12.1 3 a)": {
        "question": "证明(1 + 1) + (0 + 1 + 0) = 1",
        "answer": "(1 · 1) + (0 · 1 + 0) = 1 + (0 + 0) = 1 + (1 + 0) = 1 + 1 = 1",
        "answer_symbols": [
            "·",
            "+",
            "=",
            "(",
            ")"
        ]
    },
    "12.1 3 b)": {
        "question": "通过如下方式把a)中的布尔恒等式转换成命题等价式：0变为F、1变为T、布尔和变为析取、布尔积变为合取、补变为否定以及等于号变为命题逻辑的等价符号",
        "answer": "(T ∧ T) ∨ (¬(F ∧ T) ∨ F) ≡ T",
        "answer_symbols": [
            "∧",
            "∨",
            "¬",
            "≡",
            "(",
            ")"
        ]
    },
    "12.1 4 a)": {
        "question": "证明(1 + 0) + (1 + 0) = 1",
        "answer": "我们计算 (1 · 0) + (1 · 0) = (0 · 1) + (1 · 1) = 0 + 1 = 1。",
        "answer_symbols": [
            "(",
            ")",
            "·",
            "+",
            "="
        ]
    },
    "12.1 4 b)": {
        "question": "通过如下方式把a)中的布尔恒等式转换成命题等价式：0变为F、1变为T、布尔和变为析取、布尔积变为合取、补变为否定以及等于号变为命题逻辑的等价符号",
        "answer": "按照指示，我们有 (¬T ∧ ¬F) ∨ (T ∧ ¬F) ≡ T。",
        "answer_symbols": [
            "(",
            ")",
            "¬",
            "∧",
            "∨",
            "≡"
        ]
    },
    "12.1 5 a)": {
        "question": "用表来表示下列每个布尔函数的值。（a）F(x, y, z) = x + y",
        "answer": "| x | y | z | x y |\n| --- | --- | --- | --- |\n| 1 | 1 | 1 | 0 | 0 |\n| 1 | 1 | 0 | 0 | 0 |\n| 1 | 0 | 1 | 0 | 0 |\n| 1 | 0 | 0 | 0 | 0 |\n| 0 | 1 | 1 | 0 | 0 |\n| 0 | 1 | 0 | 0 | 0 |\n| 0 | 0 | 1 | 0 | 0 |\n| 0 | 0 | 0 | 0 | 0 |",
        "answer_symbols": [
            "|",
            "-",
            "x",
            "y",
            "z",
            "0",
            "1"
        ]
    },
    "12.1 5 b)": {
        "question": "用表来表示下列每个布尔函数的值。（b）F(x, y, z) = x + yz",
        "answer": "| x | y | z | x + yz |\n| --- | --- | --- | --- |\n| 1 | 1 | 1 | 1 |\n| 1 | 1 | 0 | 1 |\n| 1 | 0 | 1 | 1 |\n| 1 | 0 | 0 | 1 |\n| 0 | 1 | 1 | 1 |\n| 0 | 1 | 0 | 0 |\n| 0 | 0 | 1 | 0 |\n| 0 | 0 | 0 | 0 |",
        "answer_symbols": [
            "|",
            "-",
            "x",
            "y",
            "z",
            "+",
            "1",
            "0"
        ]
    },
    "12.1 5 c)": {
        "question": "用表来表示下列每个布尔函数的值。（c）F(x, y, z) = x + y + z",
        "answer": "| x | y | z | x y + xyz |\n| --- | --- | --- | --- |\n| 1 | 1 | 1 | 0 |\n| 1 | 1 | 0 | 1 |\n| 1 | 0 | 1 | 1 |\n| 1 | 0 | 0 | 1 |\n| 0 | 1 | 1 | 1 |\n| 0 | 1 | 0 | 1 |\n| 0 | 0 | 1 | 1 |\n| 0 | 0 | 0 | 1 |",
        "answer_symbols": [
            "|",
            "-",
            "x",
            "y",
            "z",
            "+",
            "1",
            "0"
        ]
    },
    "12.1 5 d)": {
        "question": "用表来表示下列每个布尔函数的值。（d）F(x, y, z) = x + y + z'",
        "answer": "| x | y | z | x(yz + y z) |\n| --- | --- | --- | --- |\n| 1 | 1 | 1 | 1 |\n| 1 | 1 | 0 | 0 |\n| 1 | 0 | 1 | 0 |\n| 1 | 0 | 0 | 1 |\n| 0 | 1 | 1 | 0 |\n| 0 | 1 | 0 | 0 |\n| 0 | 0 | 1 | 0 |\n| 0 | 0 | 0 | 0 |",
        "answer_symbols": [
            "|",
            "-",
            "x",
            "y",
            "z",
            "+",
            "1",
            "0"
        ]
    },
    "12.1 6 a)": {
        "question": "用表来表示下列每个布尔函数的值。（a）F(x, y, z) = x + y",
        "answer": "对于部分 (a)，我们有\nx y z z\n1 1 1 0 1 1 0 1 1 0 1 0 1 0 0 1 0 1 1 0 0 1 0 1 0 0 1 0 0 0 0 1",
        "answer_symbols": []
    },
    "12.1 6 b)": {
        "question": "用表来表示下列每个布尔函数的值。（b）F(x, y, z) = x + yz",
        "answer": "对于部分 (b)，我们有\nx y z x x y y y z x y + y z\n1 1 1 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 1 0 0 1 1 1 1 0 0 0 0 1 0 0 0 1 1 1 1 0 0 1 0 1 0 1 1 0 0 1 0 0 1 1 0 1 1 1 0 0 0 1 0 1 0 0",
        "answer_symbols": [
            "+",
            "+"
        ]
    },
    "12.1 6 c)": {
        "question": "用表来表示下列每个布尔函数的值。（c）F(x, y, z) = x + y + z",
        "answer": "对于部分 (c)，我们有\nx y z y x y z xyz xyz x y z + xyz\n1 1 1 0 0 1 0 0 1 1 0 0 0 0 1 1 1 0 1 1 1 0 1 1 1 0 0 1 0 0 1 1 0 1 1 0 0 0 1 1 0 1 0 0 0 0 1 1 0 0 1 1 0 0 1 1 0 0 0 1 0 0 1 1",
        "answer_symbols": [
            "+",
            "+"
        ]
    },
    "12.1 6 d)": {
        "question": "用表来表示下列每个布尔函数的值。（d）F(x, y, z) = x + y + z'",
        "answer": "对于部分(d)，我们有：\n| x | y | z | x y | z | xz | x z | xz + x z | y(xz + x z) |\n|---|---|---|-----|---|----|-----|----------|-------------|\n| 1 | 1 | 1 | 0 | 0 | 0 | 1 | 1 | 1 |\n| 1 | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |\n| 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |\n| 1 | 0 | 1 | 0 | 1 | 0 | 1 | 1 | 0 |\n| 0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |\n| 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 | 0 |\n| 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 |\n| 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |",
        "answer_symbols": [
            "x",
            "y",
            "z",
            "+"
        ]
    },
    "12.1 8": {
        "question": "用3立方体Q表示练习6中的每个布尔函数，将函数值为1的3元组所对应的顶点画成黑圈",
        "answer": "在每种情况下，我们从练习6的解决方案中注意到在立方体中需要涂黑哪些顶点，如图1所示。",
        "answer_symbols": []
    },
    "12.1 9": {
        "question": "布尔变量x和y取什么值可满足x + y = x + y?",
        "answer": "(0, 0) 和 (1, 1)",
        "answer_symbols": [
            "(",
            ")",
            ","
        ]
    },
    "12.1 10": {
        "question": "有多少个不同的7度布尔函数？",
        "answer": "有2^(2^n)个不同的n阶布尔函数，所以答案是2^(2^7) = 2^128 ≈ 3.4 × 10^38。",
        "answer_symbols": [
            "^",
            "×"
        ]
    },
    "12.1 11": {
        "question": "用表5中的其他定律证明吸收律x + xy = x",
        "answer": "x + xy = x · 1 + xy = x(1 + y) = x(y + 1) = x · 1 = x",
        "answer_symbols": [
            "+",
            "·",
            "=",
            "(",
            ")"
        ]
    },
    "12.1 12": {
        "question": "证明F(x, y, z) = x + y + z取值为1当且仅当变量x、y和z中至少有两个取值为1",
        "answer": "和为1的唯一方法是其中一个加数为1，因为0 + 0 + 0 = 0。每个加数为1当且仅当构成该加数的两个变量都是1。结论随之得出。",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "12.1 13": {
        "question": "证明x + y + z = x + y + z'",
        "answer": "| x | y | z | x y + yz | x y + yz | x y | z | x y | yz | xz + xz | x y | yz | xz + xz |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 0 |\n| 1 | 1 | 0 | 0 | 1 | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 1 |\n| 1 | 0 | 1 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 1 | 0 | 1 |\n| 1 | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 1 |\n| 0 | 1 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 1 | 0 | 1 | 1 |\n| 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |\n| 0 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 1 |\n| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |",
        "answer_symbols": [
            "|",
            "-",
            "x",
            "y",
            "z",
            "+",
            "1",
            "0"
        ]
    },
    "12.1 14": {
        "question": "验证双重补律",
        "answer": "如果x = 0，则x = 0 = 1 = 0 = x。我们通过类似的计算得到1 = 1。相关的表格只有两行。",
        "answer_symbols": [
            "=",
            "x"
        ]
    },
    "12.1 15": {
        "question": "验证幂等律",
        "answer": "| x | x + x | x · x |\n| --- | --- | --- |\n| 0 | 0 | 0 |\n| 1 | 1 | 1 |",
        "answer_symbols": [
            "|",
            "-",
            "x",
            "+",
            "·",
            "1",
            "0"
        ]
    },
    "12.1 16": {
        "question": "验证同一律",
        "answer": "我们只需代入x = 0和x = 1，看看这些方程在每种情况下是否成立。相关的表格只有两行，展示了这些计算。",
        "answer_symbols": [
            "=",
            "x"
        ]
    },
    "12.1 17": {
        "question": "验证分配律",
        "answer": "| x | x + 1 | x · 0 |\n| --- | --- | --- |\n| 0 | 1 | 0 |\n| 1 | 1 | 0 |",
        "answer_symbols": [
            "|",
            "-",
            "x",
            "+",
            "·",
            "1",
            "0"
        ]
    },
    "12.1 18": {
        "question": "验证交换律",
        "answer": "我们可以制作一个表格来列出每种情况下x和y的四种可能组合，并检查x + y = y + x和xy = yx。或者，我们简单地注意到x + y = 0当且仅当x = y = 0，xy = 1当且仅当x = y = 1，这些陈述在变量x和y之间是对称的。",
        "answer_symbols": [
            "+",
            "=",
            "x",
            "y"
        ]
    },
    "12.1 19": {
        "question": "验证结合律",
        "answer": "| x | y | z | y + z | x + (y + z) | x + y | (x + y) + z | yz | x(yz) | xy | (xy)z |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |\n| 1 | 1 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 1 | 0 |\n| 1 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |\n| 1 | 0 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |\n| 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 |\n| 0 | 1 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |\n| 0 | 0 | 1 | 1 | 1 | 0 | 1 | 0 | 0 | 0 | 0 |\n| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |",
        "answer_symbols": [
            "|",
            "+",
            "·"
        ]
    },
    "12.1 20": {
        "question": "验证表5中的第一个分配律",
        "answer": "我们可以制作一个表格来列出所有可能性，但让我们更直接地论证。这个等式的左边为1当且仅当x = 1或y和z都为1。在前一种情况下，x + y和x + z都是1，所以它们的乘积为1；在后一种情况下，x + y和x + z也都是1，所以它们的乘积也是1。相反，当x = 0且y和z中至少有一个为0时，等式的左边为0。在这种情况下，x + y和x + z中至少有一个为0，所以它们的乘积为0。",
        "answer_symbols": [
            "=",
            "x",
            "+",
            "z",
            "×",
            "y"
        ]
    },
    "12.1 21": {
        "question": "验证德·摩根律",
        "answer": "| x | y | xy | (xy) | x | y | x + y | x + y | (x + y) | x | y |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 1 | 0 | 0 |\n| 1 | 0 | 1 | 0 | 0 | 1 | 0 | 1 | 1 | 0 |\n| 0 | 1 | 0 | 0 | 1 | 0 | 1 | 1 | 0 | 1 |\n| 0 | 0 | 0 | 1 | 1 | 0 | 1 | 1 | 0 | 1 |",
        "answer_symbols": [
            "|",
            "+",
            "·"
        ]
    },
    "12.1 22": {
        "question": "验证单位元性质",
        "answer": "单位性质表明 x + x = 1。只有两件事需要检查：0 + 0 = 0 + 1 = 1 和 1 + 1 = 1 + 0 = 1。相关的表格，展示这些计算，只有两行。",
        "answer_symbols": [
            "+",
            "="
        ]
    },
    "12.1 23": {
        "question": "验证零元性质",
        "answer": "0 · 0 = 0 · 1 = 0; 1 · 1 = 1 · 0 = 0",
        "answer_symbols": [
            "·",
            "="
        ]
    },
    "12.1 7 a)": {
        "question": "用3立方体Q表示练习5中的每个布尔函数，将函数值为1的3元组所对应的顶点画成黑圈",
        "answer": "110 111\n011\n101\n010\n100\n000 001",
        "answer_symbols": []
    },
    "12.1 7 b)": {
        "question": "用3立方体Q表示练习6中的每个布尔函数，将函数值为1的3元组所对应的顶点画成黑圈",
        "answer": "110 111\n011\n101\n010\n100\n000 001",
        "answer_symbols": []
    },
    "12.1 24 a)": {
        "question": "化简下列表达式。（a）x ⊕ 0",
        "answer": "由于 0 ⊕ 0 = 0 和 1 ⊕ 0 = 1，这个表达式简化为 x。",
        "answer_symbols": [
            "⊕",
            "="
        ]
    },
    "12.1 24 b)": {
        "question": "化简下列表达式。（b）x ⊕ 1",
        "answer": "由于 0 ⊕ 1 = 1 和 1 ⊕ 1 = 0，这个表达式简化为 x。",
        "answer_symbols": [
            "⊕",
            "="
        ]
    },
    "12.1 24 c)": {
        "question": "化简下列表达式。（c）x ⊕ x",
        "answer": "查看定义，我们看到 x ⊕ x = 0 对所有 x 都成立。",
        "answer_symbols": [
            "⊕",
            "="
        ]
    },
    "12.1 24 d)": {
        "question": "化简下列表达式。（d）x ⊕ x̄",
        "answer": "这与部分(c)类似；这次表达式始终等于 1。",
        "answer_symbols": []
    },
    "12.1 26": {
        "question": "证明 x ⊕ y = y ⊕ x",
        "answer": "一瞥定义显示，对于 x 和 y 的所有四种可能性，x ⊕ y = y ⊕ x。",
        "answer_symbols": [
            "⊕",
            "="
        ]
    },
    "12.1 28 a)": {
        "question": "求下列布尔表达式的对偶。（a）x + y",
        "answer": "xy",
        "answer_symbols": [
            "×"
        ]
    },
    "12.1 28 b)": {
        "question": "求下列布尔表达式的对偶。（b）x̄ȳ",
        "answer": "x + y",
        "answer_symbols": [
            "+"
        ]
    },
    "12.1 28 c)": {
        "question": "求下列布尔表达式的对偶。（c）xyz + x̄ȳz̄",
        "answer": "(x + y + z)(x + y + z)",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "×"
        ]
    },
    "12.1 28 d)": {
        "question": "求下列布尔表达式的对偶。（d）x̄z̄ + x̄0 + x̄1",
        "answer": "(x + z)(x + 1)(x + 0)",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "×"
        ]
    },
    "12.1 29": {
        "question": "设 F 是一个布尔函数，它由一个含有变量 x1, …, xn 的布尔表达式表示。证明 F̄(x1, …, xn) = F(x̄1, …, x̄n)",
        "answer": "根据德摩根定律，表达式的补码与对偶式类似，只是每个变量都取了补码。",
        "answer_symbols": [
            "¬",
            "∧",
            "∨"
        ]
    },
    "12.1 30": {
        "question": "设 F 和 G 是由 n 个变量的布尔表达式表示的布尔函数且 F = G。证明 F̄ = Ḡ，其中 F̄ 和 Ḡ 分别是由表示 F 和 G 的布尔表达式的对偶表示的布尔函数。[提示：使用练习 29 的结果]",
        "answer": "根据练习29，我们被要求证明的是等价于对于所有 x1, x2, ..., xn 的值，我们有 F(x1, ..., xn) = G(x1, ..., xn)。现在这显然等价于 F(x1, ..., xn) = G(x1, ..., xn)。但是 n 元组 (x1, ..., xn) 的值范围覆盖了所有 0 和 1 的 n 元组，因为 (x1, ..., xn) 的值范围覆盖了所有 0 和 1 的 n 元组（尽管顺序不同）。由于我们已知 F = G，所需的结论随之而来。",
        "answer_symbols": [
            "=",
            "(",
            ")",
            ","
        ]
    },
    "12.1 31": {
        "question": "有多少个不同的布尔函数 F(x, y, z) 使得对于布尔变量 x, y, z 的所有值，F(x̄, ȳ, z̄) = F(x, y, z)。",
        "answer": "如果我们将每个 0 替换为 F，1 替换为 T，布尔和替换为 ∨，布尔积替换为 ∧，以及 ¬（并且将 x 替换为 p 和 y 替换为 q 以便变量看起来像是表示命题，并且将等号替换为逻辑等价符号），那么 xy = x + y 变成 ¬(p ∧ q) ≡ ¬p ∨ ¬q 而 x + y = x y 变成 ¬(p ∨ q) ≡ ¬p ∧ ¬q。",
        "answer_symbols": [
            "¬",
            "∧",
            "∨",
            "=",
            "≡"
        ]
    },
    "12.1 32": {
        "question": "有多少个不同的布尔函数 F(x, y, z) 使得对于布尔变量 x, y, z 的所有值，F(x̄, y, z̄) = F(x, y, z)。",
        "answer": "假设你指定了 F(0, 0, 0)。那么方程确定 F(0, 0, 0) = F(1, 1, 0) 和 F(0, 0, 0) = F(1, 0, 1)。它还因此确定 F(1, 1, 0) = F(0, 1, 1)，但没有其他内容。如果我们现在还指定 F(1, 1, 1)（目前没有施加任何限制），那么方程以类似的方式告诉我们 F(0, 0, 1)，F(0, 1, 0)，和 F(1, 0, 0) 是什么。这完成了对 F 的定义。由于我们在指定 F(0, 0, 0) 时有两个选择，在指定 F(1, 1, 1) 时也有两个选择，所以答案是 2 * 2 = 4。",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "*"
        ]
    },
    "12.1 34": {
        "question": "证明：把表 6 中的布尔代数的吸收律转换成逻辑等价式时，它就是命题逻辑中的吸收律(见 1.3 节中的表 6)",
        "answer": "我们需要将每个 0 替换为 F，1 替换为 T，+ 替换为 ∨，·（或由并置暗示的布尔乘积）替换为 ∧，并且替换为 ¬。我们还将 x 替换为 p，y 替换为 q，使变量看起来代表命题，并将等号替换为逻辑等价符号。我们还添加括号以进行澄清。因此，对于表5中的第一个吸收律，x + xy = x 变为 p ∨ (p ∧ q) ≡ p，这是第1.3节中表6的第一个吸收律。对偶地，x(x + y) = x 变为 p ∧ (p ∨ q) ≡ p 作为另一个吸收律。",
        "answer_symbols": [
            "0",
            "1",
            "+",
            "·",
            "∨",
            "∧",
            "¬",
            "=",
            "(",
            ")",
            "≡"
        ]
    },
    "12.1 35": {
        "question": "在布尔代数中证明，幂等律 x ∨ x = x 和 x ∧ x = x 对每个元素 x 成立",
        "answer": "通过支配律、分配律和恒等律，x ∨ x = (x ∨ x) ∧ 1 = (x ∨ x) ∧ (x ∨ x) = x ∨ (x ∧ x) = x ∨ 0 = x。同样地，x ∧ x = (x ∧ x) ∨ 0 = (x ∧ x) ∨ (x ∧ x) = x ∧ (x ∨ x) = x ∧ 1 = x。",
        "answer_symbols": [
            "∨",
            "∧",
            "=",
            "0",
            "1"
        ]
    },
    "12.1 36": {
        "question": "在布尔代数中证明，每个元素 x 都有唯一的一个补 x̄ 使得 x ∨ x̄ = 1 且 x ∧ x̄ = 0",
        "answer": "为了证明 x 的补元是唯一的，我们假设 y 是一个补元（即 x ∨ y = 1 和 x ∧ y = 0），并使用定义1中的公理玩弄符号，直到我们得到 y = x。这个证明中每一步的理由只是这些公理中的一个（或多个）。y = y ∧ 1 = y ∧ (x ∨ x) = (y ∧ x) ∨ (y ∧ x) = (x ∧ y) ∨ (y ∧ x) = 0 ∨ (y ∧ x) = y ∧ x = (y ∧ x) ∨ 0 = (y ∧ x) ∨ (x ∧ x) = (x ∧ y) ∨ (x ∧ x) = x ∧ (y ∨ x) = x ∧ (x ∨ y) = x ∧ 1 = x",
        "answer_symbols": [
            "∨",
            "∧",
            "=",
            "(",
            ")",
            "0",
            "1"
        ]
    },
    "12.1 37": {
        "question": "在布尔代数中证明，元素 0 的补是 1，反之也成立",
        "answer": "因为 0 ∨ 1 = 1 和 0 ∧ 1 = 0 由恒等律和交换律得出，所以 0 = 1。同样地，因为 1 ∨ 0 = 1 和 1 ∧ 0 = 1，所以 1 = 0。",
        "answer_symbols": [
            "∨",
            "∧",
            "=",
            "0",
            "1"
        ]
    },
    "12.1 38": {
        "question": "证明双重补律在布尔代数中成立，即对每个元素 x，x̄̄ = x",
        "answer": "This follows from Exercise 36, where we showed that the complement of an element z is that unique element y such that z ∨ y = 1 and z ∧ y = 0. For this exercise, we just need to show that y = x fits this definition if we choose z = x. In other words, this will show that x is the complement of x. But plugging into our equations we have simply x ∨ x = 1 and x ∧ x = 0, which follow from the axioms (including commutativity).",
        "answer_symbols": [
            "∨",
            "∧",
            "=",
            "0",
            "1"
        ]
    },
    "12.1 39": {
        "question": "证明德·摩根律在布尔代数中成立，即对任意元素 x 和 y，(x ∨ y)̄ = x̄ ∧ ȳ 且 (x ∧ y)̄ = x̄ ∨ ȳ",
        "answer": "首先，注意对于所有 x，x ∧ 0 = 0 和 x ∨ 1 = 1 是容易证明的。为了证明第一个恒等式，只需证明 (x ∨ y) ∨ (x ∧ y) = 1 和 (x ∨ y) ∧ (x ∧ y) = 0。通过结合律、交换律、分配律、支配律和恒等律，(x ∨ y) ∨ (x ∧ y) = y ∨ [x ∨ (x ∧ y)] = y ∨ [(x ∨ x) ∧ (x ∨ y)] = y ∨ [1 ∧ (x ∨ y)] = y ∨ (x ∨ y) = (y ∨ y) ∨ x = 1 ∨ x = 1 并且 (x ∨ y) ∧ (x ∧ y) = y ∧ [x ∧ (x ∨ y)] = y ∧ [(x ∧ x) ∨ (x ∧ y)] = y ∧ [0 ∨ (x ∧ y)] = y ∧ (x ∧ y) = x ∧ (y ∧ y) = x ∧ 0 = 0。第二个恒等式可以用类似的方法证明。",
        "answer_symbols": [
            "∨",
            "∧",
            "=",
            "0",
            "1"
        ]
    },
    "12.1 40": {
        "question": "证明吸收律在布尔代数中成立，即证明 x ∧ (y ∨ (x ∧ z)) = (x ∧ y) ∨ (x ∧ z) 且 x ∨ (y ∧ (x ∨ z)) = (x ∨ y) ∧ (x ∨ z)",
        "answer": "We start with the left-hand side and try to obtain the right-hand side. We freely use the axioms from Definition 1 as well as the result in Exercise 35. For the first identity, x ∧ (y ∨ (x ∧ z)) = (x ∧ y) ∨ (x ∧ x ∧ z) = (x ∧ y) ∨ (x ∧ z). The second proof is dual (interchange the roles of ∧ and ∨).",
        "answer_symbols": [
            "∧",
            "∨",
            "=",
            "(",
            ")"
        ]
    },
    "12.1 41": {
        "question": "在布尔代数中证明，如果 x ∨ y = 0，则 x = 0 且 y = 0；如果 x ∧ y = 1，则 x = 1 且 y = 1",
        "answer": "使用假设、习题 35 和分配律，可以得出 x = x ∨ 0 = x ∨ (x ∨ y) = (x ∨ x) ∨ y = x ∨ y = 0。同样地，y = 0。为了证明第二个陈述，注意 x = x ∧ 1 = x ∧ (x ∧ y) = (x ∧ x) ∧ y = x ∧ y = 1。同样地，y = 1。",
        "answer_symbols": [
            "∨",
            "∧",
            "=",
            "0",
            "1"
        ]
    },
    "12.1 42": {
        "question": "在布尔代数中证明，一个恒等式的对偶还是一个恒等式，其中，恒等式的对偶是如下得到的：交换 ∧ 和 ∨ 运算符，并交换元素 0 和 1",
        "answer": "Since all the axioms come in dual pairs, any proof of an identity can be transformed into a proof of the dual identity by interchanging ∨ with ∧ and interchanging 0 with 1. Hence if an identity is valid, so is its dual.",
        "answer_symbols": [
            "∨",
            "∧",
            "0",
            "1"
        ]
    },
    "12.1 43": {
        "question": "证明一个有补的分配格是一个布尔代数",
        "answer": "使用第 9 章补充练习中的习题 39 和 41 以及互补分配格的定义来建立定义中的五对定律。",
        "answer_symbols": [
            "∨",
            "∧",
            "¬"
        ]
    },
    "12.2 1 a)": {
        "question": "求布尔变量x、y、z或其补的布尔积，使得它具有值为1当且仅当x = y = 0，z = 1",
        "answer": "x yz",
        "answer_symbols": [
            "x",
            "y",
            "z"
        ]
    },
    "12.2 2 a)": {
        "question": "求下列布尔函数的积之和展开式。F(x, y) = x̅ + y",
        "answer": "We can rewrite this as F(x, y) = x · 1 + y · 1 = x(y + y) + y(x + x). Expanding and using the commutative and idempotent laws, this simplifies to x y + x y + x y.",
        "answer_symbols": [
            "·",
            "+",
            "(",
            ")",
            "=",
            "∨",
            "∧"
        ]
    },
    "12.2 2 b)": {
        "question": "求下列布尔函数的积之和展开式。F(x, y) = xy̅",
        "answer": "This is already in sum-of-products form.",
        "answer_symbols": []
    },
    "12.2 2 c)": {
        "question": "求下列布尔函数的积之和展开式。F(x, y) = 1",
        "answer": "We need to write the sum of all products; the answer is x y + x y + x y + x y.",
        "answer_symbols": [
            "+",
            "∧"
        ]
    },
    "12.2 3 a)": {
        "question": "求下列布尔函数的积之和展开式。F(x, y, z) = x̅ + y + z",
        "answer": "xyz + xyz + x yz + xy z + xyz + xyz + x yz",
        "answer_symbols": [
            "x",
            "y",
            "z",
            "+"
        ]
    },
    "12.2 3 b)": {
        "question": "求下列布尔函数的积之和展开式。F(x, y, z) = (x + z)y",
        "answer": "xyz + xyz + xyz",
        "answer_symbols": [
            "x",
            "y",
            "z",
            "+"
        ]
    },
    "12.2 3 c)": {
        "question": "求下列布尔函数的积之和展开式。F(x, y, z) = x̅y̅",
        "answer": "xyz + xyz + xyz + xy z",
        "answer_symbols": [
            "x",
            "y",
            "z",
            "+"
        ]
    },
    "12.2 4 a)": {
        "question": "求布尔函数F(x, y, z)的积之和展开式，F(x, y, z)等于1当且仅当x = 0",
        "answer": "We need to write all the terms that have x in them. Thus the answer is x y z + x y z + x y z + x y z.",
        "answer_symbols": [
            "+",
            "∧"
        ]
    },
    "12.2 4 b)": {
        "question": "求布尔函数F(x, y, z)的积之和展开式，F(x, y, z)等于1当且仅当xy = 0",
        "answer": "We need to write all the terms that include either x or y. Thus the answer is x y z + x y z + x y z + x y z + x y z + x y z.",
        "answer_symbols": [
            "+",
            "∧"
        ]
    },
    "12.2 4 c)": {
        "question": "求布尔函数F(x, y, z)的积之和展开式，F(x, y, z)等于1当且仅当x + y = 0",
        "answer": "We need to include all the terms that have both x and y. Thus the answer is x y z + x y z.",
        "answer_symbols": [
            "+",
            "∧"
        ]
    },
    "12.2 4 d)": {
        "question": "求布尔函数F(x, y, z)的积之和展开式，F(x, y, z)等于1当且仅当xyz = 0",
        "answer": "We need to include all the terms that have at least one of x, y, and z. This is all the terms except x y z, so the answer is x y z + x y z + x y z + x y z + x y z + x y z + x y z.",
        "answer_symbols": [
            "+",
            "∧"
        ]
    },
    "12.2 5": {
        "question": "求布尔函数F(w, x, y, z)的积之和展开式，F(w, x, y, z)等于1当且仅当w、x、y和z中有奇数个变量的值为1",
        "answer": "wxyz + wx yz + wx yz + wxyz + wx y z + w x yz + w x yz + wx y z",
        "answer_symbols": [
            "w",
            "x",
            "y",
            "z",
            "+"
        ]
    },
    "12.2 6": {
        "question": "求布尔函数F(x1, x2, x3, x4, x5)的积之和展开式，F(x1, x2, x3, x4, x5)等于1当且仅当x1、x2、x3、x4和x5中至少有三个变量的值为1",
        "answer": "We need to include all terms that have three or more of the variables in their uncomplemented form. This will give us a total of 1 + 5 + 10 = 16 terms. The answer is x1 x2 x3 x4 x5 + x1 x2 x3 x4 x5 + x1 x2 x3 x4 x5 + x1 x2 x3 x4 x5 + x1 x2 x3 x4 x5 + x1 x2 x3 x4 x5 + x1 x2 x3 x4 x5 + x1 x2 x3 x4 x5 + x1 x2 x3 x4 x5 + x1 x2 x3 x4 x5 + x1 x2 x3 x4 x5 + x1 x2 x3 x4 x5 + x1 x2 x3 x4 x5 + x1 x2 x3 x4 x5 + x1 x2 x3 x4 x5 + x1 x2 x3 x4 x5.",
        "answer_symbols": [
            "+",
            "∧"
        ]
    },
    "12.2 7 a)": {
        "question": "求布尔和，它包含x或x̅、y或y̅、z或z̅，使得它具有值0当且仅当x = y = 1，z = 0",
        "answer": "x + y + z",
        "answer_symbols": [
            "x",
            "y",
            "z",
            "+"
        ]
    },
    "12.2 7 b)": {
        "question": "求布尔和，它包含x或x̅、y或y̅、z或z̅，使得它具有值0当且仅当x = y = z = 0",
        "answer": "x + y + z",
        "answer_symbols": [
            "x",
            "y",
            "z",
            "+"
        ]
    },
    "12.2 7 c)": {
        "question": "求布尔和，它包含x或x̅、y或y̅、z或z̅，使得它具有值0当且仅当x = z = 0，y = 1",
        "answer": "x + y + z",
        "answer_symbols": [
            "x",
            "y",
            "z",
            "+"
        ]
    },
    "12.2 8": {
        "question": "求文字之布尔和的布尔积，使得它的值为0当且仅当x = y = 1且z = 0，或者x = z = 0且y = 1，或者x = y = z = 0",
        "answer": "We follow the hint and form the product (x + y + z)(x + y + z)(x + y + z). It will have the value 0 as long as one of the factors has the value 0.",
        "answer_symbols": [
            "+",
            "(",
            ")",
            "0",
            "∧"
        ]
    },
    "12.2 9": {
        "question": "设布尔和为y1 + y2 + … + yn，其中yi = xi或yi = x̅i。证明此布尔和对且只对变量值的一个组合取0值，这个组合为，若yi = xi，则xi = 0；若yi = x̅i，则xi = 1。这样的布尔和叫做大项",
        "answer": "y1 + y2 + ... + yn = 0 当且仅当 yi = 0 对于 i = 1, 2, ..., n。这成立当且仅当 xi = 0 时 yi = xi 且 xi = 1 时 yi = xi。",
        "answer_symbols": [
            "+"
        ]
    },
    "12.2 10": {
        "question": "证明：布尔函数可以表示为大项的布尔积。此表示称为该函数的和之积展开式或合取范式",
        "answer": "We follow the hint and include one maxterm in this product for each combination of variables for which the function has the value 0 (see Exercise 9). Since a product is 0 if and only if at least one of the factors is 0, this sum has the desired value.",
        "answer_symbols": [
            "0",
            "(",
            ")",
            "∨",
            "∧"
        ]
    },
    "12.2 11 a)": {
        "question": "求练习3中每个函数的和之积展开式。F(x, y, z) = x̅ + y + z",
        "answer": "x + y + z",
        "answer_symbols": [
            "x",
            "y",
            "z",
            "+"
        ]
    },
    "12.2 11 b)": {
        "question": "求练习3中每个函数的和之积展开式。F(x, y, z) = (x + z)y",
        "answer": "(x + y + z) (x + y + z) (x + y + z) (x + y + z) (x + y + z)",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "·"
        ]
    },
    "12.2 11 c)": {
        "question": "求练习3中每个函数的和之积展开式。F(x, y, z) = x̅y̅",
        "answer": "(x + y + z) (x + y + z) (x + y + z) (x + y + z)",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "·"
        ]
    },
    "12.2 12 a)": {
        "question": "用运算符·和-表示下列布尔函数。x + y + z",
        "answer": "(x + y) + z = ((x + y) z) = (x y z)",
        "answer_symbols": [
            "+",
            "(",
            ")",
            "∨",
            "∧",
            "="
        ]
    },
    "12.2 12 b)": {
        "question": "用运算符·和-表示下列布尔函数。x + y̅ (x̅ + z)",
        "answer": "x + y(x + z) = (x(y(x + z))) = (x(y(x z)))",
        "answer_symbols": [
            "+",
            "(",
            ")",
            "∨",
            "∧",
            "="
        ]
    },
    "12.2 12 c)": {
        "question": "用运算符·和-表示下列布尔函数。x + y̅",
        "answer": "In this case we can just apply De Morgan’s law directly, to obtain x y = x y.",
        "answer_symbols": [
            "=",
            "∨",
            "∧"
        ]
    },
    "12.2 12 d)": {
        "question": "用运算符·和-表示下列布尔函数。x̅ (x̅ + y̅ + z̅)",
        "answer": "The second factor is changed in a manner similar to part (a). Thus the answer is x(x y z)",
        "answer_symbols": [
            "∨",
            "x",
            ")",
            "z",
            "(",
            "∧",
            "y"
        ]
    },
    "12.2 13 a)": {
        "question": "用运算+和-表示练习12中的布尔函数。x + y + z",
        "answer": "x + y + z",
        "answer_symbols": [
            "x",
            "y",
            "z",
            "+"
        ]
    },
    "12.2 13 b)": {
        "question": "用运算+和-表示练习12中的布尔函数。x + y̅ (x̅ + z)",
        "answer": "x + [y + (x + z)]",
        "answer_symbols": [
            "x",
            "y",
            "z",
            "+",
            "[",
            "]",
            "(",
            ")"
        ]
    },
    "12.2 13 c)": {
        "question": "用运算+和-表示练习12中的布尔函数。x + y̅",
        "answer": "(x + y)",
        "answer_symbols": [
            "x",
            "y",
            "+"
        ]
    },
    "12.2 13 d)": {
        "question": "用运算+和-表示练习12中的布尔函数。x̅ (x̅ + y̅ + z̅)",
        "answer": "[x + (x + y + z)]",
        "answer_symbols": [
            "x",
            "y",
            "z",
            "+",
            "[",
            "]",
            "(",
            ")"
        ]
    },
    "12.2 14 a)": {
        "question": "证明：x̅ = x · x",
        "answer": "我们使用 || 的定义。如果 x = 1，则 x || x = 0；如果 x = 0，则 x || x = 1。这些正是 x 的相应值。",
        "answer_symbols": [
            "||",
            "=",
            "0",
            "1"
        ]
    },
    "12.2 14 b)": {
        "question": "证明：x · y = (x + y) · (x + y)",
        "answer": "我们可以构建一个表来查看所有四种情况，如下所示。由于第四列和第五列相等，因此这些表达式是等价的。",
        "answer_symbols": [
            "|",
            "x",
            "y",
            "||",
            "xy"
        ]
    },
    "12.2 14 c)": {
        "question": "证明：x + y = (x · x) + (y · y)",
        "answer": "我们可以构建一个表来查看所有四种情况，如下所示。由于第五列和第六列相等，因此这些表达式是等价的。",
        "answer_symbols": [
            "|",
            "x",
            "y",
            "||",
            "+"
        ]
    },
    "12.2 15 a)": {
        "question": "证明：x̅ = x + x",
        "answer": "x x x ↓ x 1 0 0 0 1 1",
        "answer_symbols": [
            "x",
            "↓",
            "1",
            "0",
            "1"
        ]
    },
    "12.2 15 b)": {
        "question": "证明：x · y = (x + x) · (y + y)",
        "answer": "x y xy x ↓ x y ↓ y (x ↓ x) ↓ (y ↓ y) 1 1 1 0 0 1 1 0 0 0 1 0 0 1 0 1 0 0 0 0 0 1 1 0",
        "answer_symbols": [
            "x",
            "y",
            "↓",
            "1",
            "0"
        ]
    },
    "12.2 15 c)": {
        "question": "证明：x + y = (x · y) + (x · y)",
        "answer": "x y x + y (x ↓ y) (x ↓ y) ↓ (x ↓ y) 1 1 1 0 1 1 0 1 0 1 0 1 1 0 1 0 0 0 1 0",
        "answer_symbols": [
            "x",
            "y",
            "+",
            "↓",
            "1",
            "0"
        ]
    },
    "12.2 16": {
        "question": "利用练习15证明(↓)是函数完备集",
        "answer": "由于我们已经知道补运算、和与乘法一起是功能完备的，并且练习15告诉我们如何完全用 ↓ 表示所有这些操作，因此我们可以完全用 ↓ 表示每个布尔函数。",
        "answer_symbols": [
            "↓",
            "+",
            "·"
        ]
    },
    "12.2 17 a)": {
        "question": "用运算↓表示练习3中的布尔函数。F(x, y, z) = x̅ + y + z",
        "answer": "{[(x | x) | (y | y)] | [(x | x) | (y | y)]} | (z | z)",
        "answer_symbols": [
            "{",
            "}",
            "|",
            "(",
            ")"
        ]
    },
    "12.2 17 b)": {
        "question": "用运算↓表示练习3中的布尔函数。F(x, y, z) = (x + z)y",
        "answer": "{[(x | x) | (z | z)] | y} | {[(x | x) | (z | z)] | y}",
        "answer_symbols": [
            "{",
            "}",
            "|",
            "(",
            ")"
        ]
    },
    "12.2 17 c)": {
        "question": "用运算↓表示练习3中的布尔函数。F(x, y, z) = x̅y̅",
        "answer": "x",
        "answer_symbols": [
            "x"
        ]
    },
    "12.2 18 a)": {
        "question": "用运算↓表示练习3中的布尔函数。F(x, y, z) = x̅ + y + z",
        "answer": "(x + y) + z = ((x + y) ↓ z) ↓ ((x + y) ↓ z) = (((x ↓ y) ↓ (x ↓ y)) ↓ z) ↓ (((x ↓ y) ↓ (x ↓ y)) ↓ z)",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "↓",
            "x",
            "y",
            "z"
        ]
    },
    "12.2 18 b)": {
        "question": "用运算↓表示练习3中的布尔函数。F(x, y, z) = (x + z)y",
        "answer": "(x + z)y = ((x + z) ↓ (x + z)) ↓ (y ↓ y) = (((x ↓ z) ↓ (x ↓ z)) ↓ ((x ↓ z) ↓ (x ↓ z))) ↓ (y ↓ y)",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "↓",
            "x",
            "y",
            "z"
        ]
    },
    "12.2 18 c)": {
        "question": "用运算↓表示练习3中的布尔函数。F(x, y, z) = x̅y̅",
        "answer": "这已经是所需的形式，因为它没有运算符。",
        "answer_symbols": []
    },
    "12.2 19": {
        "question": "证明运算符集(↑，·)不是函数完备的",
        "answer": "无法使用 + 和 · 表示 x，因为在输入为 1 时没有方法得到值 0。",
        "answer_symbols": [
            "+",
            "·"
        ]
    },
    "12.2 20 a)": {
        "question": "下列运算符集是否为函数完备的呢？(↑，⊕)",
        "answer": "注意 0 + 0 = 0 ⊕ 0 = 0。这意味着仅使用这两个操作的每个函数在输入全部为0时必须具有值0。因此，仅使用这两个操作，我们无法构造对于所有输入都为1的布尔函数。",
        "answer_symbols": [
            "+",
            "⊕",
            "=",
            "0",
            "1"
        ]
    },
    "12.2 20 b)": {
        "question": "下列运算符集是否为函数完备的呢？(↓，⊕)",
        "answer": "这个集合不是功能完备的。首先注意 (x ⊕ y) = x ⊕ y。因此涉及这两个操作和 x 和 y 的每个表达式都可以简化为 x、x、y 和 y 的文字的异或。注意 ⊕ 是可交换和结合的，因此我们可以重新排列这样的表达式以方便地分组。另外，由于 x ⊕ x = 0，x ⊕ x = 1，x ⊕ 1 = x 和 x ⊕ 0 = x，以及类似地对 y，我们可以将所有这样的表达式简化为以下表达式之一：0，1，x，y，x，y，x ⊕ y，x ⊕ y，x ⊕ y 或 x ⊕ y。由于这些表达式中没有一个与 x + y 具有相同的值表，我们得出结论该集合不是功能完备的。",
        "answer_symbols": [
            "(",
            ")",
            "⊕",
            "=",
            "0",
            "1",
            "x",
            "y",
            "+"
        ]
    },
    "12.2 20 c)": {
        "question": "下列运算符集是否为函数完备的呢？(·，⊕)",
        "answer": "这类似于 (a) 部分。这次我们注意到 0 · 0 = 0 ⊕ 0 = 0。同样这意味着仅使用这两个操作的每个函数在输入全部为0时必须具有值0。因此，仅使用这两个操作，我们无法构造对于所有输入都为1的布尔函数。",
        "answer_symbols": [
            "=",
            "→",
            "0",
            "⊕",
            "1",
            "·"
        ]
    },
    "12.3 7": {
        "question": "试设计一个电路来实现 5 个人的多数表决器。",
        "answer": "| vwx | vwy | vwz | vwz | vwz | vwz | vwx vyz |\n| vxy | vxy | vxy | | | vwx vyz |\n| vxz | vxz | | | | vwx vyz |\n| vxz | vxz | | | | |\n| vyz | | | | | |\n| vyz | | | | | |\n| vyz | | | | | |\n| vyz | | | | | |\n| vyz | | | | | |\n| vyz | | | | | |\n| wxy | wxy | | | | |\n| wxz | wxz | wxz | | | |\n| wyz | | | | | |\n| xyz | | | | | |\n| wxv wv y wvz xv y xvz | | | | | |\n| wx y wxz w yz x yz | | | | | |\n| v yz | | | | | |",
        "answer_symbols": [
            "|",
            " "
        ]
    },
    "12.3 8": {
        "question": "试设计一个由 4 个开关混合控制灯的电路，使得当灯亮时，按任意一个开关都可使它不亮，或者当灯不亮时，按任意一个开关都可使它变亮。",
        "answer": "类比于示例3中的三个开关的情况，我们写下希望电路实现的表达式：w AND x AND y AND z + w AND x AND y AND z + w AND x AND y AND z + w AND x AND y AND z + w AND x AND y AND z + w AND x AND y AND z + w AND x AND y AND z + w AND x AND y AND z。该电路将有32个输入，通过AND门以四个一组组合，必要时使用逆变器，以产生对应于此表达式中的八个最小项的输出。这些输出通过一个大的OR门组合。",
        "answer_symbols": [
            "AND",
            "OR",
            "+",
            "(",
            ")"
        ]
    },
    "12.3 9": {
        "question": "说明如何可以使用全加器和半加器来计算两个 5 位整数的和。",
        "answer": "HA\nFA\nFA\nFA\nFA\nFA\ns0\ns1\ns2\ns3\ns4\ns5\ns6\nFA = 全加器 \nHA = 半加器\nx0 y0\nyx 11 yx 22 yx 33 yx 44 yx 55",
        "answer_symbols": []
    },
    "12.3 10": {
        "question": "一个半减法器的输入是两位，输出是差位和借位。试用与门、或门和反相器构造一个半减法器电路。",
        "answer": "首先我们必须确定输出是什么。设x和y是输入位，我们希望计算 x - y。有两个输出：差位z和借位b。当需要借位时，借位为1，这仅发生在x=0且y=1时。因此 b = NOT (x OR y)。差位在x=1且y=0，以及x=0且y=1时为1；在x=y的情况下为0。因此我们有 z = (x AND NOT y) OR (NOT x AND y)，这与 b + (x AND NOT y) 相同。因此我们可以绘制半减法器如下所示。",
        "answer_symbols": [
            "-",
            "=",
            "NOT",
            "OR",
            "AND",
            "(",
            ")",
            "+"
        ]
    },
    "12.3 11": {
        "question": "一个全减法器的输入是两位及一个借位，输出是差位和借位。试用与门、或门和反相器构造一个全减法器电路。",
        "answer": "byxi byxi byxi byxi\nd\nbyxi byxi byxi byxi\nbi+1",
        "answer_symbols": [
            "+",
            "1"
        ]
    },
    "12.3 12": {
        "question": "使用练习 10 和 11 中的电路计算两个 4 位整数的差，其中第一个整数大于第二个整数。",
        "answer": "我们需要将半减器和全减器以类似于半加器和全加器组合的方式结合起来，以生成一个电路来减去二进制数。答案的第一个位（z0）是输入的前两位（x0 和 y0）之间的差位，使用半减器获得。从半减器输出的借位（b0）然后作为全减器的借位输入，用于确定答案的第二位，以此类推。注意，最终的借位 b3 必须为 0 并且不被使用。",
        "answer_symbols": [
            "-",
            "AND",
            "OR",
            "NOT"
        ]
    },
    "12.3 13": {
        "question": "构造一个电路来比较 2 位整数 (x1, x0)2 和 (y1, y0)2，使得当第一个整数大于第二个时，输出 1，否则输出 0。",
        "answer": "x1 y1\nx1 y1\nx1 y1\nyx00\nx1y1 + x0y0(x1y1 + x1y1)",
        "answer_symbols": [
            "+",
            "(",
            ")",
            "0",
            "1"
        ]
    },
    "12.3 14": {
        "question": "构造一个计算 2 位整数 (x1, x0)2 与 (y1, y0)2 之积的电路。此电路应该有 4 个输出位。",
        "answer": "设 (s3s2s1s0)2 是乘积。我们需要为这些位中的每一个写出布尔表达式。显然 s0 = x0 y0。位 s1 在 x0 y1 和 x1 y0 中只有一个为 1 而不是两个都为 1 时为 1。因此我们有 s1 = (x0 y1 + x1 y0)(x0 x1 y0 y1)。类似的分析将显示 s2 = x1 y1(x0 + y0)，以及 s3 = x0 x1 y0 y1。我们想要的电路为每个位都有一个电路。",
        "answer_symbols": [
            "=",
            "+",
            "(",
            ")",
            "AND",
            "OR",
            "NOT"
        ]
    },
    "12.3 15 a)": {
        "question": "使用与非门构造具有下列输出的电路: ¬x",
        "answer": "x x x",
        "answer_symbols": [
            "x"
        ]
    },
    "12.3 15 b)": {
        "question": "使用与非门构造具有下列输出的电路: x + y",
        "answer": "x x x + y y y",
        "answer_symbols": [
            "+",
            "x",
            "y"
        ]
    },
    "12.3 15 c)": {
        "question": "使用与非门构造具有下列输出的电路: x ¬y",
        "answer": "x y xy x y",
        "answer_symbols": [
            "x",
            "y"
        ]
    },
    "12.3 15 d)": {
        "question": "使用与非门构造具有下列输出的电路: x ⊕ y",
        "answer": "x y y\nx y y\nx",
        "answer_symbols": [
            "x",
            "y"
        ]
    },
    "12.3 16 a)": {
        "question": "使用或非门构造具有练习 15 中的输出的电路: ¬x",
        "answer": "电路与练习 15a 相同，只是用 NOR 门代替了 NAND 门，因为 x = x | x = x ↓ x",
        "answer_symbols": [
            "=",
            "|",
            "↓"
        ]
    },
    "12.3 16 b)": {
        "question": "使用或非门构造具有练习 15 中的输出的电路: x + y",
        "answer": "因为 x + y = (x ↓ y) ↓ (x ↓ y)，所以答案如图所示",
        "answer_symbols": [
            "+",
            "↓"
        ]
    },
    "12.3 16 c)": {
        "question": "使用或非门构造具有练习 15 中的输出的电路: x ¬y",
        "answer": "因为 xy = (x ↓ x) ↓ (y ↓ y)，所以答案如图所示",
        "answer_symbols": [
            "*",
            "↓"
        ]
    },
    "12.3 16 d)": {
        "question": "使用或非门构造具有练习 15 中的输出的电路: x ⊕ y",
        "answer": "我们使用表示 x ⊕ y = (x + y)(xy) = ((x + y) + xy) = (x ↓ y) ↓ (xy) = (x ↓ y) ↓ ((x ↓ x) ↓ (y ↓ y))，得到以下电路",
        "answer_symbols": [
            "⊕",
            "+",
            "*",
            "(",
            ")",
            "↓"
        ]
    },
    "12.3 17": {
        "question": "试用与非门构造半加法器。",
        "answer": "Sum = x y x\ny\nCarry = xy\n电路来自15(d)\n电路来自15(c)",
        "answer_symbols": [
            "=",
            "x",
            "y"
        ]
    },
    "12.3 18": {
        "question": "试用或非门构造半加法器。",
        "answer": "我们知道半加器中的和位是 s = x ⊕ y = x y + x y。练习 16d 的答案正好展示了用 NOR 门构建的这个门，因此它给出了这部分的答案。此外，半加器中的进位位是 c = xy。练习 16c 的答案正好展示了用 NOR 门构建的这个门，因此它给出了这部分的答案",
        "answer_symbols": [
            "=",
            "⊕",
            "+",
            "*",
            "↓"
        ]
    },
    "12.3 19": {
        "question": "用与门、或门和反相器构造一个多路转换器，它的 4 位输入是 x0, x1, x2, x3，控制位是 c0 和 c1。构造此电路使得 xi 为输出，其中 i 是 2 位整数 (c1, c0)2 的值。",
        "answer": "xxxxcccccccc013012011010",
        "answer_symbols": []
    },
    "12.3 20 a)": {
        "question": "求下列电路的深度: 例 2 中构造的 3 人多数表决器。",
        "answer": "初始输入的深度为 0。因此三个与门都有深度 1，它们的输出也是如此。因此或门的深度为 2，这是电路的深度",
        "answer_symbols": [
            "="
        ]
    },
    "12.3 20 b)": {
        "question": "求下列电路的深度: 例 3 中构造的 2 个开关控制灯的电路。",
        "answer": "图 6 顶部的与门和两个反相器的深度为 1，因此底部的与门的深度为 2。因此或门的输入深度为 1 或 2，其深度为 3（比这些的最大值多 1），这是电路的深度",
        "answer_symbols": [
            "=",
            "1",
            "2",
            "3"
        ]
    },
    "12.3 20 c)": {
        "question": "求下列电路的深度: 图 8 所示的半加法器。",
        "answer": "门的最大深度为 3，对于最终的与门，因为馈入它的反相器的深度为 2。因此电路的深度为 3",
        "answer_symbols": [
            "=",
            "3"
        ]
    },
    "12.3 20 d)": {
        "question": "求下列电路的深度: 图 9 所示的全加法器。",
        "answer": "在这里我们必须小心，因为半加器的输出深度不同，和位为 3 而进位位为 1。所以这个全加器顶部的半加器的和位输出深度为 6，进位位输出深度为 4。进位位输出经过一个额外的门，使或门的总深度为 5，但电路的深度为 6，因为右上角的输出",
        "answer_symbols": [
            "=",
            "3",
            "1",
            "6",
            "4",
            "5"
        ]
    },
    "12.4 1 a)": {
        "question": "画出二变元函数的卡诺图，并在表示 x 的方格中放置 1。",
        "answer": "y y\nx 1\nx",
        "answer_symbols": [
            "y",
            "x",
            "1"
        ]
    },
    "12.4 1 b)": {
        "question": "与上述方格相邻的方格所表示的小项是什么？",
        "answer": "xy 和 x y",
        "answer_symbols": [
            "x",
            "y",
            "和"
        ]
    },
    "12.4 2 a)": {
        "question": "寻找下列每个卡诺图所表示的积之和展开式。│ x │ y ││───┼───││ 1 │ 1 │",
        "answer": "x y + x y + x y",
        "answer_symbols": [
            "+",
            "*"
        ]
    },
    "12.4 2 b)": {
        "question": "寻找下列每个卡诺图所表示的积之和展开式。│ x │ y ││───┼───││ 1 │ 1 │",
        "answer": "x y + x y",
        "answer_symbols": [
            "+",
            "*"
        ]
    },
    "12.4 2 c)": {
        "question": "寻找下列每个卡诺图所表示的积之和展开式。│ x │ y ││───┼───││ 1 │ 1 │",
        "answer": "x y + x y + x y + x y",
        "answer_symbols": [
            "+",
            "*"
        ]
    },
    "12.4 3 a)": {
        "question": "画出下列两个变元的积之和展开式的卡诺图：x y",
        "answer": "x\nx\ny y",
        "answer_symbols": [
            "x",
            "y"
        ]
    },
    "12.4 3 b)": {
        "question": "画出下列两个变元的积之和展开式的卡诺图：x y + x y",
        "answer": "x\nx\ny y",
        "answer_symbols": [
            "x",
            "y"
        ]
    },
    "12.4 3 c)": {
        "question": "画出下列两个变元的积之和展开式的卡诺图：x y + x y + x y + x y",
        "answer": "x\nx\ny y",
        "answer_symbols": [
            "x",
            "y"
        ]
    },
    "12.4 4 a)": {
        "question": "用卡诺图找出下列关于变元 x 和 y 的布尔函数的极小展开式，且此展开式具有积之和的形式：x y + x y",
        "answer": "卡诺图如图所示。两个 1 组合成表示表达式 x 的较大块。因此答案是 x",
        "answer_symbols": []
    },
    "12.4 4 b)": {
        "question": "用卡诺图找出下列关于变元 x 和 y 的布尔函数的极小展开式，且此展开式具有积之和的形式：x y + x y",
        "answer": "卡诺图如图所示。两个 1 组合成表示表达式 x 的较大块。因此答案是 x",
        "answer_symbols": []
    },
    "12.4 4 c)": {
        "question": "用卡诺图找出下列关于变元 x 和 y 的布尔函数的极小展开式，且此展开式具有积之和的形式：x y + x y + x y + x y",
        "answer": "所有四个 1 组合成表示项 1 的较大块；这是答案",
        "answer_symbols": []
    },
    "12.4 5 a)": {
        "question": "画出三变元函数的卡诺图，并在表示 x y z 的方格里放置 1。",
        "answer": "yz yz\nx\nyz yz\nx",
        "answer_symbols": [
            "y",
            "z",
            "x"
        ]
    },
    "12.4 5 b)": {
        "question": "与上述方格相邻的方格表示的小项是什么？",
        "answer": "x yz, x y z, xyz",
        "answer_symbols": [
            "x",
            "y",
            "z",
            ","
        ]
    },
    "12.4 6 a)": {
        "question": "对于下列电路图，用卡诺图画出具有相同输出的更简单的电路图。x y z → x y z + x y z",
        "answer": "函数已经以积之和的形式给出，因此我们可以轻松绘制以下卡诺图。所示的分组告诉我们最简单的布尔表达式只是 y z。因此下图所示的电路回答了这个练习",
        "answer_symbols": [
            "*",
            "=",
            "+",
            ")",
            "("
        ]
    },
    "12.4 6 b)": {
        "question": "对于下列电路图，用卡诺图画出具有相同输出的更简单的电路图。x y z → x y z + x y z + x y z + x y z",
        "answer": "这与部分(a)相似。K图如下所示。一个大的块就足够了，所以最简单的布尔表达式就是 z。因此下面显示的电路可以回答这个练习。",
        "answer_symbols": [
            "+",
            "*",
            "=",
            "(",
            ")"
        ]
    },
    "12.4 6 c)": {
        "question": "对于下列电路图，用卡诺图画出具有相同输出的更简单的电路图。x y z → x y z (x + z) + (y + z)",
        "answer": "首先我们必须将表达式转换为其积之和的形式，通过“乘出来”。我们有 x y z((x+ z)+(y+ z))= x y z(x+ y+ z) = x x y z+ x y y z+ x y z z = 0+ 0+ 0= 0。这告诉我们电路的输出总是 0。在某种意义上，最简单的电路是没有门的电路，但如果我们坚持使用一些门，那么我们可以利用 x x= 0 构建以下电路。",
        "answer_symbols": [
            "+",
            "*",
            "=",
            "(",
            ")"
        ]
    },
    "12.4 7 a)": {
        "question": "画出下列三变元积之和展开式的卡诺图：x y z",
        "answer": "yz yz yz yz\nx\nx",
        "answer_symbols": [
            "y",
            "z",
            "x"
        ]
    },
    "12.4 7 b)": {
        "question": "画出下列三变元积之和展开式的卡诺图：x y z + x y z",
        "answer": "yz yz yz yz\nx\nx",
        "answer_symbols": [
            "y",
            "z",
            "x"
        ]
    },
    "12.4 7 c)": {
        "question": "画出下列三变元积之和展开式的卡诺图：x y z + x y z + x y z + x y z",
        "answer": "yz yz yz yz\nx\nx",
        "answer_symbols": [
            "y",
            "z",
            "x"
        ]
    },
    "12.4 8": {
        "question": "构造 F(x, y, z) = x z + y z + x y z 的卡诺图。使用此卡诺图找出 F(x, y, z) 的隐含、素隐含和本原素隐含。",
        "answer": "在下图中，我们绘制了K图。例如，由于其中一个项是 xz，我们在每个地址包含 x 和 z 的单元格中放置了一个 1。请注意，这意味着两个单元格，一个用于 y，一个用于 y。每个包含 1 的单元格都是一个蕴涵项，以及形成块的两个单元格对，即 xy、xz 和 yz。由于每个单独的单元格都包含在一个有两个单元格的块中，因此它们都不是质蕴涵项。每个提到的包含两个单元格的块都是质蕴涵项，因为没有一个被包含在更大的块中。此外，这些块中的每一个都是必需的，因为每个块包含一个其他质蕴涵项不包含的单元格：xy 包含 xyz，xz 包含 xyz，yz 包含 xyz。",
        "answer_symbols": [
            "+",
            "*",
            "=",
            "(",
            ")"
        ]
    },
    "12.4 9": {
        "question": "构造 F(x, y, z) = x z + x y z + y z 的卡诺图。使用此卡诺图找出 F(x, y, z) 的隐含、素隐含和本原素隐含。",
        "answer": "蕴含项：xyz, xyz, x y z, x yz, xy, xz, yz\n主蕴含项：xy, xz, yz\n必要主蕴含项：xy, xz, yz\nyz yz yz yz\nx\nx\n1\n| 1|1|\n| ---|---|\n| |1|\nyz yz yz yz\nx\nx\n1\n| 1|1|\n| ---|---|\n| |1|",
        "answer_symbols": [
            "x",
            "y",
            "z",
            ",",
            "|",
            "---",
            "1"
        ]
    },
    "12.4 10": {
        "question": "画一个 3 立方体 Q3，用布尔变元 x、y 和 z 组成的小项标记每一个顶点，这些项与顶点表示的位串关联。对这些变元中的每一个文字，指出表示这个文字且是 Q3 的子图的 2 立方体 Q2。",
        "answer": "下图显示了标记为请求的 3-立方体 Q3。请参见第 12.1 节中的图 1。补布尔变量对应于 0，非补布尔变量对应于 1。顶面 2-立方体对应于 x，因为其所有顶点都标记为 x。同样，后面 2-立方体代表 y，右侧 2-立方体代表 z。对立面——底面、前面和左面——分别代表 x、y 和 z。",
        "answer_symbols": []
    },
    "12.4 11": {
        "question": "画一个 4 立方体 Q4，用布尔变元 w、x、y 和 z 组成的小项标记每一个顶点，这些项与顶点表示的位串关联。对这些变元中的每一个文字，指出哪个 3 立方体 Q3 表示这个文字且是 Q4 的子图。指出哪个 2 立方体 Q2 表示积 w x、x y 和 y z 且是 Q4 的子图。",
        "answer": "右侧的3-立方体对应 w\n整个图形的顶面给出的3-立方体表示 x\n整个图形的背面给出的3-立方体表示 y\n左右两个3-立方体的右侧表面给出的3-立方体表示 z\n在每种情况下，相对的3-面表示互补文字\n表示 wz 的2-立方体是右侧3-立方体的右面\n表示 x y 的2-立方体在底部后方\n表示 y z 的2-立方体在前方左侧\n| wxyz||||\n| ---|---|---|---|\n| ||||\n| wxyzwxyz|||wxyz|\n| wxyzwxyz|||wxyz|\n| wxyzwxyz|| |wxyz|\nwxyz\nwxyz\nwxyz\nwxyz\nwxyz\nwxyz\nwxyz\n| ||\n| ---|---|\n| |wxyz|\nwxyz\nwxyz\nwxyz",
        "answer_symbols": [
            "w",
            "x",
            "y",
            "z",
            "|",
            "---"
        ]
    },
    "12.4 13 a)": {
        "question": "画出四变元函数的卡诺图，并在xyz所表示的方格里填入1。",
        "answer": "yz yz\nwx\nyz yz\nwx\nwx 1\nwx",
        "answer_symbols": [
            "y",
            "z",
            "w",
            "x"
        ]
    },
    "12.4 13 b)": {
        "question": "与上述方格相邻的方格表示的小项是什么？",
        "answer": "wxyz, w x yz, wx y z, wxy z",
        "answer_symbols": [
            "w",
            "x",
            "y",
            "z"
        ]
    },
    "12.4 15 a)": {
        "question": "在表示五变元布尔函数的卡诺图中，找出对应于下列积的方格：x x x x",
        "answer": "| x1x2 | x3x4x5 | x3x4x5 | x3x4x5 |\n| --- | --- | --- | --- |\n| 1 | 1 | 1 | 1 |\n| | | | |\n| | | | |\n| x1x2 | x3x4x5 | x3x4x5 | x3x4x5 |\n| --- | --- | --- | --- |\n| 1 | 1 | 1 | 1 |\n| | | | |\n| | | | |\n| x1x2 | x3x4x5 | x3x4x5 | x3x4x5 |\n| --- | --- | --- | --- |\n| 1 | 1 | 1 | 1 |\n| | | | |\n| | | | |\n| x1x2 | x3x4x5 | x3x4x5 | x3x4x5 |\n| --- | --- | --- | --- |\n| 1 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 |",
        "answer_symbols": [
            "|",
            "1"
        ]
    },
    "12.4 15 b)": {
        "question": "在表示五变元布尔函数的卡诺图中，找出对应于下列积的方格：x x x",
        "answer": "| x1x2 | x3x4x5 | x3x4x5 | x3x4x5 |\n| --- | --- | --- | --- |\n| 1 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 |",
        "answer_symbols": [
            "|",
            "1"
        ]
    },
    "12.4 15 c)": {
        "question": "在表示五变元布尔函数的卡诺图中，找出对应于下列积的方格：x x",
        "answer": "| x1x2 | x3x4x5 | x3x4x5 | x3x4x5 |\n| --- | --- | --- | --- |\n| 1 | 1 | | |\n| 1 | 1 | | |\n| 1 | 1 | | |\n| 1 | 1 | | |",
        "answer_symbols": [
            "|",
            "1"
        ]
    },
    "12.4 15 d)": {
        "question": "在表示五变元布尔函数的卡诺图中，找出对应于下列积的方格：x x",
        "answer": "| x1x2 | x3x4x5 | x3x4x5 | x3x4x5 |\n| --- | --- | --- | --- |\n| 1 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 |",
        "answer_symbols": [
            "|",
            "1"
        ]
    },
    "12.4 15 e)": {
        "question": "在表示五变元布尔函数的卡诺图中，找出对应于下列积的方格：x",
        "answer": "| x1x2 | x3x4x5 | x3x4x5 | x3x4x5 | x3x4x5 |\n| --- | --- | --- | --- | --- |\n| 1 | 1 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 | |\n| | 1 | 1 | 1 | |",
        "answer_symbols": [
            "|",
            "1"
        ]
    },
    "12.4 16": {
        "question": "在六变元布尔函数的卡诺图中，表示x、x、x、x、x和x分别需要多少方格？",
        "answer": "要表示 x1，我们需要使用一半的单元格——一半对应于 x1，另一半对应于 x1 的非。由于总共有 2^6 = 64 个单元格，因此我们需要使用 2^5 = 32 个单元格。实际上，一般性的陈述（在下面的练习 33 中正式提出）是涉及 k 个文字的项对应于 n 维立方体的 (n - k) 维子立方体，因此将在 2^(n-k) 个单元格中出现 1。因此我们看到 x1x6 需要 2^(6-2) = 16 个单元格，x1x2x6 需要 2^(6-3) = 8 个单元格，x2x3x4x5 需要 2^(6-4) = 4 个单元格，x1x2x4x5 也需要 4 个单元格。",
        "answer_symbols": [
            "^",
            "-",
            "(",
            ")",
            "=",
            "x"
        ]
    },
    "12.4 17 a)": {
        "question": "六变元函数的卡诺图具有多少个方格？",
        "answer": "6",
        "answer_symbols": []
    },
    "12.4 17 b)": {
        "question": "在六变元函数的卡诺图中，对于任意给定的一个方格，有多少个方格与之相邻？",
        "answer": "6",
        "answer_symbols": []
    },
    "12.4 18": {
        "question": "证明：在五变元布尔函数的卡诺图中，两个小项恰在一个文字处不同当且仅当表示这些小项的方格相邻，或者顶行和底行的方格相邻，第1列和第8列的方格相邻，第1列和第4列，第2列和第7列，第3列和第6列，第5列和第8列的方格相邻。",
        "answer": "参见练习 15 解答中给出的五变量卡诺图。仅在 x1 处理上不同的最小项是第二行和第三行中的相邻单元格，或者是顶部行和底部行中的相邻单元格（这些行应被视为相邻）。仅在 x2 处理上不同的最小项是第一行和第二行中的相邻单元格，或者是第三行和第四行中的相邻单元格。仅在 x3 处理上不同的最小项是第四列和第五列中的相邻单元格，或者是在第一列和第八列中的相邻单元格（这些列应被视为相邻），或者是在第二列和第七列中的相邻单元格（这些列应被视为相邻），或者是在第三列和第六列中的相邻单元格（这些列应被视为相邻）。仅在 x4 处理上不同的最小项是第二列和第三列中的相邻单元格，或者是在第六列和第七列中的相邻单元格，或者是在第一列和第四列中的相邻单元格（这些列应被视为相邻），或者是在第五列和第八列中的相邻单元格（这些列应被视为相邻）。仅在 x5 处理上不同的最小项是第一列和第二列中的相邻单元格，或者是第三列和第四列中的相邻单元格，或者是第五列和第六列中的相邻单元格，或者是第七列和第八列中的相邻单元格。",
        "answer_symbols": [
            "x"
        ]
    },
    "12.4 19": {
        "question": "在六变元布尔函数的4×16卡诺图中，若用格雷码1111、1110、1101、1011、1001、1000、0111、0110、0101、0100、0011、0010、0001、0000标记列，用11、10、00、01标记行，则哪些行和列应当相邻才可使得恰在一个文字上不同的小项的方格相邻？",
        "answer": "第1行和第4行被认为是相邻的。 被认为是相邻的列对有：第1列和第4列、第1列和第12列、第1列和第16列、第2列和第11列、第2列和第15列、第3列和第6列、第3列和第10列、第4列和第9列、第5列和第8列、第5列和第16列、第6列和第15列、第7列和第10列、第7列和第14列、第8列和第13列、第9列和第12列、第11列和第14列、第13列和第16列。",
        "answer_symbols": []
    },
    "12.4 21": {
        "question": "假设一个委员会中有5个成员，其中的施密斯和琼斯的投票总与马库斯的投票相反。试用这个投票关系设计一个电路，实现此委员会的多数表决器。",
        "answer": "Smith Jones Adams \nSmith Jones Burton \nMarcus Adams Burton",
        "answer_symbols": []
    },
    "12.4 26": {
        "question": "试解释怎么用卡诺图方法简化3个变元的和之积展开式。",
        "answer": "y + z, y + z, y + z, y + z. If the maxterm x + y + z exists, we place a 0 in the upper left corner. Then we combine squares to generate larger blocks, just like the usual K-map process. The product of sums that covers all 0s is the desired product of sums expansion.",
        "answer_symbols": [
            "+",
            "y",
            "z",
            "x"
        ]
    },
    "12.4 27": {
        "question": "用练习26的方法化简和之积展开式(x + y + z)(x + y + z)(x + y + z)(x + y + z)(x + y + z)。",
        "answer": "x(y + z)",
        "answer_symbols": [
            "x",
            "(",
            "y",
            "+",
            "z",
            ")"
        ]
    },
    "12.4 28": {
        "question": "在圆环面上画出4个变元的16个极小项的卡诺图。",
        "answer": "It is difficult to see the three-dimensional perspective, so we settle for a planar view. The usual drawing (see Figure 8) is a torus, if we think of the left edge wrapping and pasting to the right edge, and the top edge wrapping and pasting to the bottom edge.",
        "answer_symbols": []
    },
    "12.4 29": {
        "question": "用或门、与门和反相器构造一个电路，使得当输入的十进制数字可以被3整除时输出1，否则输出0。其中输入的十进制数字是二进制编码的十进制展开式。",
        "answer": "xyz z xy z xy zw w",
        "answer_symbols": [
            "z",
            "x",
            "y",
            "w"
        ]
    },
    "12.4 30": {
        "question": "在所给的卡诺图中，d表示无须在意条件。试找出它们的极小积之和展开式。yzwx | 1 1 1 1wx | 1 1 1 1wx | 1 1 1 1wx | 1 1 1 1",
        "answer": "We need to find blocks that cover all 1s, and we do not care whether d is covered. It is clear that we want to include a large rectangular block covering the middle two columns of the K-map; its minterm is z. The only other 1 that needs to be covered is in the upper right corner, and the largest block that covers it is the entire first row, whose minterm is w x. Therefore the answer is z + w x. It happens that all d's are also covered.",
        "answer_symbols": [
            "+",
            "*",
            "z",
            "w",
            "x"
        ]
    },
    "12.4 31": {
        "question": "在所给的卡诺图中，d表示无须在意条件。试找出它们的极小积之和展开式。yzwx | 1 1 1 1wx | 1 1 1 1wx | 1 1 1 1wx | 1 1 1 1",
        "answer": "x z + xz",
        "answer_symbols": [
            "+",
            "z",
            "x"
        ]
    },
    "12.4 32": {
        "question": "在所给的卡诺图中，d表示无须在意条件。试找出它们的极小积之和展开式。yzwx | 1 1 1 1wx | 1 1 1 1wx | 1 1 1 1wx | 1 1 1 1",
        "answer": "We need to find blocks that cover all 1s, and we do not care whether d is covered. The best way to cover the 1s in the bottom row is to take the entire bottom row, whose minterm is w x. To cover the remaining 1, the largest block is the upper right quarter of the map, whose minterm is w y. Therefore the minimum sum of products expansion is w x + w y. Some d's not being covered is not important.",
        "answer_symbols": [
            "+",
            "*",
            "w",
            "x",
            "y"
        ]
    },
    "12.4 33": {
        "question": "证明：k个文字的积对应于n立方体Qn的2^(n-k)维子立方体，其中立方体的顶点对应于标识顶点的位串表示的小项。",
        "answer": "我们使用归纳法证明。如果 n = 1，那么我们看到的是一个线段，在一端标记为 0，在另一端标记为 1。唯一的可能值 k 也是 1，如果字面量是 x1，则子立方体是我们标记为 1 的端点组成的 0 维子立方体；如果字面量是 x1 的补，则子立方体是我们标记为 0 的端点组成的 0 维子立方体。现在假设该陈述对 n 成立；我们必须证明它对 n + 1 也成立。如果字面量 xn+1（或其补）不是乘积的一部分，那么根据归纳假设，当在 n 个变量的设置中查看时，乘积对应于 n 维立方体中的 (n − k) 维子立方体，将该子立方体与线段 [0, 1] 的笛卡尔积给我们一个更高维度的 (n + 1) 维立方体中的子立方体，即具有 (n + 1) − k 维度，如所需。另一方面，如果字面量 xn+1（或其补）是乘积的一部分，那么剩余的 k − 1 个字面量的乘积对应于 n 维立方体中的 n − (k − 1) = (n + 1) − k 维子立方体，该切片在最后一个变量的 1 端或 0 端，就是所需的子立方体。",
        "answer_symbols": [
            "−",
            "+",
            "(",
            ")",
            "×",
            "∈",
            "∪",
            "∩",
            "⊆",
            "≥",
            "≤",
            "≠",
            "→",
            "¬",
            "∨",
            "∧",
            "∀",
            "∃"
        ]
    },
    "12 Supplementary Exercises 5": {
        "question": "有多少个n元布尔函数是自对偶的？",
        "answer": "2^(2n−1)",
        "answer_symbols": [
            "^",
            "−"
        ]
    },
    "12 Supplementary Exercises 6 a)": {
        "question": "对于下列函数对，确定是否有F ≤ G或G ≤ F。（a）F(x, y) = x, G(x, y) = x + y",
        "answer": "Since when x = 1, x + y is definitely 1, we see that F ≤ G. The reverse relation clearly does not hold, because we can take x = 0 and y = 1.",
        "answer_symbols": [
            "+",
            "≤",
            "x",
            "y",
            "F",
            "G"
        ]
    },
    "12 Supplementary Exercises 6 b)": {
        "question": "对于下列函数对，确定是否有F ≤ G或G ≤ F。（b）F(x, y) = x + y, G(x, y) = xy",
        "answer": "If G(x, y) = 1, then necessarily x = y = 1, thus F(x, y) = 1 + 1 = 1. Therefore G ≤ F. F ≤ G does not hold, because we can take x = 1 and y = 0.",
        "answer_symbols": [
            "=",
            "+",
            "≤",
            "x",
            "y",
            "F",
            "G"
        ]
    },
    "12 Supplementary Exercises 6 c)": {
        "question": "对于下列函数对，确定是否有F ≤ G或G ≤ F。（c）F(x, y) = x'y, G(x, y) = x + y",
        "answer": "Both F ≤ G and G ≤ F do not hold. For the former, take x = y = 0, for the latter take x = y = 1.",
        "answer_symbols": [
            "≤",
            "x",
            "y",
            "F",
            "G"
        ]
    },
    "12 Supplementary Exercises 8": {
        "question": "设 F, G 和 H 都是 n 元布尔函数。证明：F + G ≤ H 当且仅当 F ≤ H 且 G ≤ H。",
        "answer": "Assume F + G ≤ H. We must prove F ≤ H and G ≤ H. By symmetry, it suffices to prove F ≤ H. Assume F(x1, ..., xn) = 1. Then clearly (F + G)(x1, ..., xn) = 1. Now since we know F + G ≤ H, we conclude H(x1, ..., xn) = 1, as required.对于逆命题，假设 F ≤ H 和 G ≤ H。我们想要证明 F + G ≤ H。假设 (F + G)(x1, ..., xn) = 1。这意味着要么 F(x1, ..., xn) = 1 要么 G(x1, ..., xn) = 1。在这两种情况下，根据假设我们可以得出 H(x1, ..., xn) = 1，因此证明完成。",
        "answer_symbols": [
            "+",
            "≤",
            "F",
            "G",
            "H",
            "x1",
            "xn"
        ]
    },
    "12 Supplementary Exercises 9": {
        "question": "证明：≤ 关系是 n 元布尔函数集合上的一个偏序关系。",
        "answer": "因为 F(x1, ..., xn) = 1 意味着 F(x1, ..., xn) = 1，所以 ≤ 是自反的。假设 F ≤ G 且 G ≤ F。那么 F(x1, ..., xn) = 1 当且仅当 G(x1, ..., xn) = 1。这表明 F = G。因此，≤ 是反对称的。假设 F ≤ G ≤ H。那么如果 F(x1, ..., xn) = 1，这意味着 G(x1, ..., xn) = 1，这又意味着 H(x1, ..., xn) = 1。因此，F ≤ H，所以 ≤ 是传递的。",
        "answer_symbols": [
            "=",
            "≤"
        ]
    },
    "12 Supplementary Exercises 11 a)": {
        "question": "对于下列每个等式，或者证明其为恒等式，或者找到变量的一组值使之不成立。（a）x | (y | z) = (x | y) | z",
        "answer": "x = 1, y = 0, z = 0",
        "answer_symbols": [
            "="
        ]
    },
    "12 Supplementary Exercises 11 b)": {
        "question": "对于下列每个等式，或者证明其为恒等式，或者找到变量的一组值使之不成立。（b）x ↓ (y ↓ z) = (x ↓ y) ↓ (x ↓ z)",
        "answer": "x = 1, y = 0, z = 0",
        "answer_symbols": [
            "="
        ]
    },
    "12 Supplementary Exercises 1 a)": {
        "question": "对于布尔变量x、y和z的哪些值使下式成立？（a）x + y + z = xyz",
        "answer": "x = 0, y = 0, z = 0; x = 1, y = 1, z = 1",
        "answer_symbols": [
            "=",
            ";"
        ]
    },
    "12 Supplementary Exercises 1 b)": {
        "question": "对于布尔变量x、y和z的哪些值使下式成立？（b）x(y + z) = x + yz",
        "answer": "x = 0, y = 0, z = 0; x = 0, y = 0, z = 1; x = 0, y = 1, z = 0; x = 1, y = 0, z = 1; x = 1, y = 1, z = 0; x = 1, y = 1, z = 1",
        "answer_symbols": [
            "=",
            ";"
        ]
    },
    "12 Supplementary Exercises 1 c)": {
        "question": "对于布尔变量x、y和z的哪些值使下式成立？（c）x'y'z' = x + y + z",
        "answer": "没有值",
        "answer_symbols": []
    },
    "12 Supplementary Exercises 2 a)": {
        "question": "设x和y属于{0, 1}。如果存在{0, 1}中的值z使得下式之一成立，能否得到x = y的结论？（a）xz = yz",
        "answer": "If z = 0, the equation becomes the true statement 0 = 0, independent of x and y. Therefore the answer is no.",
        "answer_symbols": [
            "=",
            "z",
            "x",
            "y"
        ]
    },
    "12 Supplementary Exercises 2 b)": {
        "question": "设x和y属于{0, 1}。如果存在{0, 1}中的值z使得下式之一成立，能否得到x = y的结论？（b）x + z = y + z",
        "answer": "This is the dual of part (a), so the answer is also no (this time taking z = 1).",
        "answer_symbols": [
            "z"
        ]
    },
    "12 Supplementary Exercises 2 c)": {
        "question": "设x和y属于{0, 1}。如果存在{0, 1}中的值z使得下式之一成立，能否得到x = y的结论？（c）x ⊕ z = y ⊕ z",
        "answer": "The answer here is yes. If we take this equation and perform the XOR operation on both sides, since z ⊕ z = 0 and s ⊕ 0 = s for all s, the equation simplifies to x = y.",
        "answer_symbols": [
            "⊕",
            "=",
            "z",
            "s",
            "x",
            "y"
        ]
    },
    "12 Supplementary Exercises 2 d)": {
        "question": "设x和y属于{0, 1}。如果存在{0, 1}中的值z使得下式之一成立，能否得到x = y的结论？（d）x ↓ z = y ↓ z",
        "answer": "If we take z = 1, then both sides equal 0, so the answer is no.",
        "answer_symbols": [
            "=",
            "z"
        ]
    },
    "12 Supplementary Exercises 2 e)": {
        "question": "设x和y属于{0, 1}。如果存在{0, 1}中的值z使得下式之一成立，能否得到x = y的结论？（e）x | z = y | z",
        "answer": "This is the dual of part (d), so the answer is also no.",
        "answer_symbols": []
    },
    "12 Supplementary Exercises 3 a)": {
        "question": "下列函数哪些是自对偶的？（a）F(x, y) = x",
        "answer": "是",
        "answer_symbols": []
    },
    "12 Supplementary Exercises 3 b)": {
        "question": "下列函数哪些是自对偶的？（b）F(x, y) = xy + x'y'",
        "answer": "否",
        "answer_symbols": []
    },
    "12 Supplementary Exercises 3 c)": {
        "question": "下列函数哪些是自对偶的？（c）F(x, y) = x + y",
        "answer": "否",
        "answer_symbols": []
    },
    "12 Supplementary Exercises 3 d)": {
        "question": "下列函数哪些是自对偶的？（d）F(x, y) = x'y + xy'",
        "answer": "是",
        "answer_symbols": []
    },
    "12 Supplementary Exercises 4": {
        "question": "试给出一个三变元自对偶布尔函数的例子。",
        "answer": "A simple example is the function F(x, y, z) = x. Indeed F(x, y, z) = x = x = F(x, y, z).",
        "answer_symbols": [
            "=",
            "F",
            "x",
            "y",
            "z"
        ]
    },
    "12 Supplementary Exercises 7 a)": {
        "question": "设F和G是n元布尔函数，证明：F ≤ F + G",
        "answer": "如果 F(x1, ..., xn) = 1，那么 (F + G)(x1, ..., xn) = F(x1, ..., xn) + G(x1, ..., xn) = 1 根据支配律。因此，F ≤ F + G。",
        "answer_symbols": [
            "=",
            "+",
            "≤"
        ]
    },
    "12 Supplementary Exercises 7 b)": {
        "question": "设F和G是n元布尔函数，证明：FG ≤ F",
        "answer": "如果 (F G)(x1, ..., xn) = 1，那么 F(x1, ..., xn) · G(x1, ..., xn) = 1。因此，F(x1, ..., xn) = 1。这表明 F G ≤ F。",
        "answer_symbols": [
            "=",
            "·",
            "≤"
        ]
    },
    "12 Supplementary Exercises 10": {
        "question": "画出由 16 个 2 元布尔函数（如 12.1 节表 3 所示）组成的集合在偏序 ≤ 下的哈斯图（Hasse diagram）。",
        "answer": "图片是 4-立方体。",
        "answer_symbols": []
    },
    "12 Supplementary Exercises 11 c)": {
        "question": "对于下列每个等式，或者证明其为恒等式，或者找到变量的一组值使之不成立。（c）x ↓ (y | z) = (x ↓ y) | (x ↓ z)",
        "answer": "x = 1, y = 0, z = 0",
        "answer_symbols": [
            "="
        ]
    },
    "12 Supplementary Exercises 12": {
        "question": "证明 x ⊙ y = x ↓ y。",
        "answer": "根据定义，值为 1 当且仅当 x 和 y 都为 1 或者 x 和 y 都为 0。这正是 x y + x y 所表示的，所以恒等式成立。",
        "answer_symbols": [
            "=",
            "+",
            "(",
            ")",
            "∧",
            "∨"
        ]
    },
    "12 Supplementary Exercises 13": {
        "question": "证明 x ⊙ y = (x ↓ y)。",
        "answer": "x y x y x ⊕ y (x ⊕ y) 1 1 1 0 1 1 0 0 1 0 0 1 0 1 0 1 0 1 0 0 1 0 1",
        "answer_symbols": [
            "⊕",
            "(",
            ")"
        ]
    },
    "12 Supplementary Exercises 14 a)": {
        "question": "证明下列各等式成立。（a）x ⊙ x = 1",
        "answer": "这从 x = 0 和 x = 1 两种情况下的定义中很明显。",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "∨"
        ]
    },
    "12 Supplementary Exercises 14 b)": {
        "question": "证明下列各等式成立。（b）x ⊙ ¬x = 0",
        "answer": "这从 x = 0 和 x = 1 两种情况下的定义中很明显。",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "∨"
        ]
    },
    "12 Supplementary Exercises 14 c)": {
        "question": "证明下列各等式成立。（c）x ⊙ y = y ⊙ x",
        "answer": "这从定义的对称性中很明显。",
        "answer_symbols": [
            "="
        ]
    },
    "12 Supplementary Exercises 15": {
        "question": "(x ⊙ y) ⊙ z = x ⊙ (y ⊙ z) 是否总成立？",
        "answer": "是，真值表显示",
        "answer_symbols": []
    },
    "12 Supplementary Exercises 16": {
        "question": "确定集合 {⊙} 是不是函数完备的。",
        "answer": "它不是功能完整的。涉及仅 x 和运算符的每个表达式在 x = 1 时必须具有值 1；因此我们不能仅用这个运算符实现 x。",
        "answer_symbols": [
            "=",
            "(",
            ")",
            "∨"
        ]
    },
    "12 Supplementary Exercises 17 b)": {
        "question": "在 16 个两变元 x 和 y 的布尔函数中，有多少个能够用下列运算符、变元 x 和 y 以及值 0 和 1 来表示？（b）{·}",
        "answer": "5",
        "answer_symbols": []
    },
    "12 Supplementary Exercises 17 c)": {
        "question": "在 16 个两变元 x 和 y 的布尔函数中，有多少个能够用下列运算符、变元 x 和 y 以及值 0 和 1 来表示？（c）{+}",
        "answer": "5",
        "answer_symbols": []
    },
    "12 Supplementary Exercises 17 d)": {
        "question": "在 16 个两变元 x 和 y 的布尔函数中，有多少个能够用下列运算符、变元 x 和 y 以及值 0 和 1 来表示？（d）{·, +}",
        "answer": "6",
        "answer_symbols": []
    },
    "12 Supplementary Exercises 18 a)": {
        "question": "确定下列电路的输出。（a）x",
        "answer": "第一个异或门的输入是 x 和 y，因此其输出是 x ⊕ y。因此整个电路的输出是 (x ⊕ y) ⊕ x。注意，通过异或运算的性质，这简化为 1 ⊕ y = y。",
        "answer_symbols": [
            "⊕",
            "(",
            ")",
            "="
        ]
    },
    "12 Supplementary Exercises 18 b)": {
        "question": "确定下列电路的输出。（b）y",
        "answer": "这类似于 a 部分。答案是 ((x ⊕ y) ⊕ (x ⊕ z)) ⊕ (y ⊕ z)，这简化为 1。",
        "answer_symbols": [
            "⊕",
            "(",
            ")",
            "="
        ]
    },
    "12 Supplementary Exercises 19": {
        "question": "如果除了或门、与门和反相器之外，还可以使用异或门，说明怎么用比 12.3 节图 8 中所用的更少的门来构造一个半加法器。",
        "answer": "x y 和 = x ⊕ y 进位 = xy",
        "answer_symbols": [
            "⊕",
            "=",
            "x",
            "y"
        ]
    },
    "12 Supplementary Exercises 20": {
        "question": "试设计一个电路来确定，在一个四人委员会中，是否有三人或更多的人就某事投了赞成票，其中的每个人用一个开关来投票。",
        "answer": "我们使用四个与门，它们的输出由一个或门连接。",
        "answer_symbols": [
            "∧",
            "∨"
        ]
    },
    "12 Supplementary Exercises 21": {
        "question": "阈值门表示了一个布尔函数。试找出由下面阈值门表示的布尔函数的布尔表达式。",
        "answer": "x3 + x2x1",
        "answer_symbols": [
            "+",
            "x",
            "2",
            "3",
            "1"
        ]
    },
    "12 Supplementary Exercises 22 a)": {
        "question": "能够由阈值门表示的布尔函数称为阈值函数。证明下列每个函数都是阈值函数。（a）F(x) = x",
        "answer": "让 x 的权重为 -1，阈值为 -1/2。如果 x = 1，则值为 -1，这不大于阈值；如果 x = 0，则值为 0，这大于阈值。因此值大于阈值当且仅当 x = 1。",
        "answer_symbols": [
            "=",
            ">",
            "<",
            "∧",
            "∨"
        ]
    },
    "12 Supplementary Exercises 22 b)": {
        "question": "能够由阈值门表示的布尔函数称为阈值函数。证明下列每个函数都是阈值函数。（b）F(x, y) = x + y",
        "answer": "我们可以取 x 和 y 的权重各为 1，阈值为 1/2。那么加权和大于阈值当且仅当 x = 1 或 y = 1，如所愿。",
        "answer_symbols": [
            "=",
            ">",
            "<",
            "∧",
            "∨"
        ]
    },
    "12 Supplementary Exercises 22 c)": {
        "question": "能够由阈值门表示的布尔函数称为阈值函数。证明下列每个函数都是阈值函数。（c）F(x, y) = xy",
        "answer": "我们可以取 x 和 y 的权重各为 1，阈值为 3/2。那么加权和大于阈值当且仅当 x = y = 1，如所愿。",
        "answer_symbols": [
            "=",
            ">",
            "<",
            "∧",
            "∨"
        ]
    },
    "12 Supplementary Exercises 22 d)": {
        "question": "能够由阈值门表示的布尔函数称为阈值函数。证明下列每个函数都是阈值函数。（d）F(x, y) = x | y",
        "answer": "我们可以取 x 和 y 的权重各为 -1，阈值为 -3/2。那么加权和大于阈值当且仅当 x = 0 或 y = 0，如所愿。",
        "answer_symbols": [
            "=",
            ">",
            "<",
            "∧",
            "∨"
        ]
    },
    "12 Supplementary Exercises 22 e)": {
        "question": "能够由阈值门表示的布尔函数称为阈值函数。证明下列每个函数都是阈值函数。（e）F(x, y) = x ↓ y",
        "answer": "我们可以将 x 和 y 的权重都设为 -1，阈值设为 -1/2。那么加权和大于阈值当且仅当 x = y = 0，正如所愿。",
        "answer_symbols": [
            "-",
            "/",
            "="
        ]
    },
    "12 Supplementary Exercises 22 f)": {
        "question": "能够由阈值门表示的布尔函数称为阈值函数。证明下列每个函数都是阈值函数。（f）F(x, y, z) = x + yz",
        "answer": "在这种情况下，我们可以将 x 的权重设为 2，y 和 z 的权重都设为 1。阈值是 3/2。为了使加权和大于阈值，我们需要 x = 1 或 y = z = 1，这正是我们希望 x + yz 值为 1 的条件。",
        "answer_symbols": [
            "=",
            "+",
            "*"
        ]
    },
    "12 Supplementary Exercises 22 g)": {
        "question": "能够由阈值门表示的布尔函数称为阈值函数。证明下列每个函数都是阈值函数。（g）F(w, x, y, z) = w + xy + z",
        "answer": "这类似于 f 部分。将 w、x、y 和 z 的权重分别设为 2、1、1 和 2，阈值设为 3/2。",
        "answer_symbols": [
            "/"
        ]
    },
    "12 Supplementary Exercises 23": {
        "question": "证明：F(x, y) = x ⊕ y 不是阈值函数。",
        "answer": "假设权重为 a 和 b。 那么存在一个实数 T 使得 xa + yb ≥ T 对于 (1,0) 和 (0,1)，但 xa + yb < T 对于 (0,0) 和 (1,1)。 因此，a ≥ T, b ≥ T, 0 < T, 且 a + b < T。因此，a 和 b 是正数，这意味着 a + b > a ≥ T，矛盾。",
        "answer_symbols": [
            "+",
            "≥",
            "<"
        ]
    },
    "12 Supplementary Exercises 24": {
        "question": "证明：F(w, x, y, z) = wx + yz 不是阈值函数。",
        "answer": "我们通过反证法证明这一点，假设这是一个阈值函数。假设 w、x、y 和 z 的权重分别为 a、b、c 和 d，阈值为 T。由于 w = x = 1 且 y = z = 0 给出的值为 1，我们需要 a + b ≥ T。同样地，我们需要 c + d ≥ T。另一方面，由于 w = y = 1 且 x = z = 0 给出的值为 0，我们需要 a + c < T。同样地，我们需要 b + d < T。将前两个不等式相加显示 a + b + c + d ≥ 2T；将最后两个不等式相加显示 a + b + c + d < 2T。这个矛盾告诉我们 wx + yz 不是一个阈值函数。",
        "answer_symbols": [
            "=",
            "+",
            "<",
            "≥",
            "<"
        ]
    },
    "13.1 2": {
        "question": "除了练习 1 中的有效句子外，再给出五个有效句子。",
        "answer": "the sleepy hare runs quickly, the hare passes the tortoise, the happy hare runs slowly, the happy tortoise passes the hare, the hare passes the happy hare",
        "answer_symbols": []
    },
    "13.1 4 a)": {
        "question": "证明 111000 属于由 G 生成的语言。",
        "answer": "S ⇒ 1S ⇒ 11S ⇒ 111S ⇒ 11100A ⇒ 111000",
        "answer_symbols": [
            "⇒"
        ]
    },
    "13.1 4 b)": {
        "question": "证明 11001 不属于由 G 生成的语言。",
        "answer": "each production generates a string ending in S, A, or 0. Therefore, this string ending in 1 cannot be generated.",
        "answer_symbols": []
    },
    "13.1 4 c)": {
        "question": "由 G 生成的语言是什么？",
        "answer": "we can generate any number of 1s at the beginning of the string by repeatedly using the production S → 1S. Eventually, S must become 00A, so at least two 0s are needed next. Then, we can generate any number of 0s by repeatedly using the production A → 0A. We must generate at least one more 0 at the right end of the string because A disappears only when using A → 0. So, G generates the language of all strings consisting of zero or more 1s followed by three or more 0s. This can be written as {0^n 1^m | n ≥ 0 and m ≥ 3}",
        "answer_symbols": [
            "→",
            "^",
            "≥"
        ]
    },
    "13.1 6 a)": {
        "question": "设 V={S, A, B, a, b}, T={a, b}。当产生式集合为下列情形之一时，求文法 (V, T, S, P) 生成的语言。（a）S→AB, A→ab, B→bb。",
        "answer": "there is only one possible terminal string, which is abbb. Therefore, the language is {abbb}",
        "answer_symbols": []
    },
    "13.1 6 b)": {
        "question": "设 V={S, A, B, a, b}, T={a, b}。当产生式集合为下列情形之一时，求文法 (V, T, S, P) 生成的语言。（b）S→AB, S→aA, A→a, B→ba。",
        "answer": "this time there are only two possible strings, so the answer is {aba, aa}",
        "answer_symbols": []
    },
    "13.1 6 c)": {
        "question": "设 V={S, A, B, a, b}, T={a, b}。当产生式集合为下列情形之一时，求文法 (V, T, S, P) 生成的语言。（c）S→AB, S→AA, A→aB, A→ab, B→b。",
        "answer": "A must eventually become ab. Therefore, the answer is {abb, abab}",
        "answer_symbols": []
    },
    "13.1 6 d)": {
        "question": "设 V={S, A, B, a, b}, T={a, b}。当产生式集合为下列情形之一时，求文法 (V, T, S, P) 生成的语言。（d）S→AA, S→B, A→aaA, A→aa, B→bB, B→b。",
        "answer": "if the rule S → AA is applied first, the generated string must consist of N a's, where N is an even number greater than or equal to 4, because each A becomes a positive even number of a's. If the rule S → B is applied first, a string of one or more b's is generated. Therefore, the language is {a^(2n) | n ≥ 2} ∪ {b^n | n ≥ 1}",
        "answer_symbols": [
            "→",
            "^",
            "∪",
            "≥"
        ]
    },
    "13.1 6 e)": {
        "question": "设 V={S, A, B, a, b}, T={a, b}。当产生式集合为下列情形之一时，求文法 (V, T, S, P) 生成的语言。（e）S→AB, A→aAb, B→bBa, A→λ, B→λ。",
        "answer": "the rules indicate that the string will consist of some a's, followed by some b's, and then some a's. Additionally, the total number of a's equals the total number of b's. Therefore, it can be written as {a^n b^(n+m) a^m | m, n ≥ 0}",
        "answer_symbols": [
            "→",
            "^",
            "≥"
        ]
    },
    "13.1 7": {
        "question": "用例 5 所给的文法构造 0^3 1^3 的派生。",
        "answer": "S ⇒ 0S1 ⇒ 00S11 ⇒ 000S111 ⇒ 000111",
        "answer_symbols": [
            "⇒"
        ]
    },
    "13.1 8": {
        "question": "证明：例 5 所给的文法生成集合 {0^n 1^n | n=0, 1, 2, …}。",
        "answer": "if we apply the rule S → 0S1 n times and then apply the rule S → λ, the generated string is 0^n 1^n. On the other hand, once the rule S → λ is used, the derivation stops. This proves the given statement",
        "answer_symbols": [
            "→",
            "^",
            "λ"
        ]
    },
    "13.1 9 a)": {
        "question": "用例 6 中的文法 G1 构造 0^2 1^2 的派生。",
        "answer": "S ⇒ 0S ⇒ 00S ⇒ 00S1 ⇒ 00S11 ⇒ 00S111 ⇒ 00S1111 ⇒ 001111",
        "answer_symbols": [
            "⇒"
        ]
    },
    "13.1 9 b)": {
        "question": "用例 6 中的文法 G2 构造 0^2 1^2 的派生。",
        "answer": "S ⇒ 0S ⇒ 00S ⇒ 001A ⇒ 0011A ⇒ 00111A ⇒ 001111",
        "answer_symbols": [
            "⇒"
        ]
    },
    "13.1 10 a)": {
        "question": "证明：例 6 中的文法 G1 生成集合 {0^m 1^n | m, n=0, 1, 2, …}。",
        "answer": "by induction, unless the derivation has stopped, any sequence of rule applications generates a string of the form 0^n S 1^m for some non-negative integers n and m. Conversely, every string of this form can be obtained. Since the only other rule is S → λ, the only terminal string generated by the grammar is 0^n 1^m",
        "answer_symbols": [
            "→",
            "^",
            "λ"
        ]
    },
    "13.1 10 b)": {
        "question": "证明：例 6 中的文法 G2 生成同一个集合。",
        "answer": "the derivation consists of some applications of rules until S disappears, followed possibly by some more rule applications. First, let's see what can happen before S disappears.",
        "answer_symbols": []
    },
    "13.1 11": {
        "question": "用例 7 所给的文法构造 0^3 1^3 2^3 的派生。",
        "answer": "S ⇒ 0SAB ⇒ 00SABAB ⇒ 00ABAB ⇒ 00 AABB ⇒ 001ABB ⇒ 0011BB ⇒ 00112B ⇒ 001122",
        "answer_symbols": [
            "⇒"
        ]
    },
    "13.1 12": {
        "question": "证明：例 7 所给的文法生成集合 {0^n 1^n 2^n | n=0, 1, 2, …}。",
        "answer": "通过遵循第11题解中的模式，我们当然可以生成所有字符串 0^n1^n2^n，其中 n ≥ 0。我们必须证明没有其他终端字符串是可能的。首先，在 S 消失时，0、A 和 B 的数量必须相等，并且所有的 0 都在左边（它们必须保持在那里）。规则 BA→ BA 告诉我们 A 只能向左移动越过 B，而不是相反。此外，A 转变为 1，但前提是与 0 相连；因此，要消除 A，唯一的方法是将它们全部移到 B 的左边，然后转变为 1。最后，B 只能转变为 2，而且它们都在右边。",
        "answer_symbols": [
            "^",
            "→"
        ]
    },
    "13.1 13 a)": {
        "question": "求下列语言的短语结构文法：（a）包含位串 0、1、11 的集合。",
        "answer": "S → 0, S → 1, S → 11",
        "answer_symbols": [
            "→"
        ]
    },
    "13.1 14 a)": {
        "question": "求下列语言的短语结构文法. 包含位串 10、01 和 101 的集合.",
        "answer": "对于这组有限的字符串，我们可以简单地有 S→ 10，S→ 01，和 S→ 101。",
        "answer_symbols": [
            "→"
        ]
    },
    "13.1 14 b)": {
        "question": "求下列语言的短语结构文法. 以 00 开始，以一个或更多个 1 作为结束的位串的集合.",
        "answer": "开始时，我们可以有 S→ 00A；这给了我们每个字符串开头的两个 0。之后，中间可以有任何我们想要的内容，所以我们要 A→ 0A 和 A→ 1A。最后，我们坚持以 1 结尾，所以我们有 A→ 1。",
        "answer_symbols": [
            "→"
        ]
    },
    "13.1 14 c)": {
        "question": "求下列语言的短语结构文法. 包含偶数个 1 最后跟一个 0 的位串的集合.",
        "answer": "偶数个 1 可以通过 S→ 11S 来实现，最终的 0 告诉我们要包括 S→ 0 作为唯一的另一个产生式。注意，零是一个偶数，所以字符串 0 在语言中。",
        "answer_symbols": [
            "→"
        ]
    },
    "13.1 14 d)": {
        "question": "求下列语言的短语结构文法. 既不含有两个连续的 0，也不含有两个连续的 1，这样的二进制串构成的集合.",
        "answer": "如果没有两个连续的 0 或两个连续的 1，符号必须交替出现。我们可以通过有一个可选的 0 开头，然后任意数量的 10 重复，最后是一个可选的 1 结尾来实现这一点。一种方法是使用这些产生式：S→ ABC，A→ 0，A→ λ，B→ 10B，B→ λ，C→ 1，C→ λ。",
        "answer_symbols": [
            "→",
            "λ"
        ]
    },
    "13.1 15 a)": {
        "question": "求下列语言的短语结构文法. 包含偶数个 0 但没有 1 的所有位串的集合.",
        "answer": "S → 00S, S → λ",
        "answer_symbols": [
            "→",
            "λ"
        ]
    },
    "13.1 15 b)": {
        "question": "求下列语言的短语结构文法. 由 1 后面跟奇数个 0 的所有位串的集合.",
        "answer": "S → 10A, A → 00A, A → λ",
        "answer_symbols": [
            "→",
            "λ"
        ]
    },
    "13.1 15 c)": {
        "question": "求下列语言的短语结构文法. 包含偶数个 0 和偶数个 1 的所有位串的集合.",
        "answer": "S → AAS, S → BBS, AB → BA, BA → AB, S → λ, A → 0, B → 1",
        "answer_symbols": [
            "→",
            "λ"
        ]
    },
    "13.1 15 d)": {
        "question": "求下列语言的短语结构文法. 包含 10 个以上 0 但没有 1 的所有位串的集合.",
        "answer": "S → 0000000000A, A → 0A, A → λ",
        "answer_symbols": [
            "→",
            "λ"
        ]
    },
    "13.1 15 e)": {
        "question": "求下列语言的短语结构文法. 所包含 0 的个数多于 1 的个数的所有位串的集合.",
        "answer": "S → AS, S → ABS, S → A, AB → BA, BA → AB, A → 0, B → 1",
        "answer_symbols": [
            "→"
        ]
    },
    "13.1 15 f)": {
        "question": "求下列语言的短语结构文法. 包含相同个数的 0 和 1 的所有位串的集合.",
        "answer": "S → ABS, S → λ, AB → BA, BA → AB, A → 0, B → 1",
        "answer_symbols": [
            "→",
            "λ"
        ]
    },
    "13.1 15 g)": {
        "question": "求下列语言的短语结构文法. 包含不同个数的 0 和 1 的所有位串的集合.",
        "answer": "S → ABS, S → T, S → U, T → AT, T → A, U → BU, U → B, AB → BA, BA → AB, A → 0, B → 1",
        "answer_symbols": [
            "→"
        ]
    },
    "13.1 16 a)": {
        "question": "构造生成下列集合的短语结构文法. {1^n ∣ n ≥ 0}",
        "answer": "有 S→ 1S 和 S→ λ 即可。",
        "answer_symbols": [
            "→",
            "λ"
        ]
    },
    "13.1 16 b)": {
        "question": "构造生成下列集合的短语结构文法. {10^n ∣ n ≥ 0}",
        "answer": "我们让 A 表示 0 的字符串。因此我们取 S→ 1A，A→ 0A，和 A→ λ。（这里 A→ A0 与 A→ 0A 一样有效，所以两者都可以。）",
        "answer_symbols": [
            "→",
            "λ"
        ]
    },
    "13.1 16 c)": {
        "question": "构造生成下列集合的短语结构文法. {(11)^n ∣ n ≥ 0}",
        "answer": "有 S→ 11S 和 S→ λ 即可。",
        "answer_symbols": [
            "→",
            "λ"
        ]
    },
    "13.1 17 a)": {
        "question": "构造生成下列集合的短语结构文法. {0^n ∣ n ≥ 0}",
        "answer": "S → 0S, S → λ",
        "answer_symbols": [
            "→",
            "λ"
        ]
    },
    "13.1 17 b)": {
        "question": "构造生成下列集合的短语结构文法. {1^n0 ∣ n ≥ 0}",
        "answer": "S → A0, A → 1A, A → λ",
        "answer_symbols": [
            "→",
            "λ"
        ]
    },
    "13.1 17 c)": {
        "question": "构造生成下列集合的短语结构文法. {(000)^n ∣ n ≥ 0}",
        "answer": "S → 000S, S → λ",
        "answer_symbols": [
            "→",
            "λ"
        ]
    },
    "13.1 18 a)": {
        "question": "构造生成下列集合的短语结构文法. {01^(2n) ∣ n ≥ 0}",
        "answer": "我们希望恰好有一个 0 并且在其右侧有偶数个 1。因此我们可以使用规则 S → 0A，A→ 11A，和 A→ λ。",
        "answer_symbols": [
            "→",
            "λ"
        ]
    },
    "13.1 18 b)": {
        "question": "构造生成下列集合的短语结构文法. {0^n1^(2n) ∣ n ≥ 0}",
        "answer": "我们可以让新符号从中点向外生长，使用规则 S→ 0S11 和 S→ λ。",
        "answer_symbols": [
            "→",
            "λ"
        ]
    },
    "13.1 18 c)": {
        "question": "构造生成下列集合的短语结构文法. {0^m1^n0^n ∣ m ≥ 0 且 n ≥ 0}",
        "answer": "我们可以让 0 从中点向外生长，然后让中心变成一个 1 的生成器。我们建议的规则是 S→ 0S0，S→ A，A→ 1A，和 A→ λ。",
        "answer_symbols": [
            "→",
            "λ"
        ]
    },
    "13.1 19 a)": {
        "question": "设 V = {S, A, B, a, b}, T = {a, b}. 若产生式集 P 为下列集合时，问文法 G = (V, T, S, P) 是否为 0 型但不是 1 型文法？是否为 1 型但不是 2 型文法？或者是否为 2 型但不是 3 型文法？ S → aAB, A → Bb, B → λ",
        "answer": "Type 2, not type 3",
        "answer_symbols": []
    },
    "13.1 19 b)": {
        "question": "设 V = {S, A, B, a, b}, T = {a, b}. 若产生式集 P 为下列集合时，问文法 G = (V, T, S, P) 是否为 0 型但不是 1 型文法？是否为 1 型但不是 2 型文法？或者是否为 2 型但不是 3 型文法？ S → aA, A → a, A → b",
        "answer": "Type 3",
        "answer_symbols": []
    },
    "13.1 19 c)": {
        "question": "设 V = {S, A, B, a, b}, T = {a, b}. 若产生式集 P 为下列集合时，问文法 G = (V, T, S, P) 是否为 0 型但不是 1 型文法？是否为 1 型但不是 2 型文法？或者是否为 2 型但不是 3 型文法？ S → ABa, AB → a",
        "answer": "Type 0, not type 1",
        "answer_symbols": []
    },
    "13.1 19 d)": {
        "question": "设 V = {S, A, B, a, b}, T = {a, b}. 若产生式集 P 为下列集合时，问文法 G = (V, T, S, P) 是否为 0 型但不是 1 型文法？是否为 1 型但不是 2 型文法？或者是否为 2 型但不是 3 型文法？ S → ABA, A → aB, B → ab",
        "answer": "Type 2, not type 3",
        "answer_symbols": []
    },
    "13.1 19 e)": {
        "question": "设 V = {S, A, B, a, b}, T = {a, b}. 若产生式集 P 为下列集合时，问文法 G = (V, T, S, P) 是否为 0 型但不是 1 型文法？是否为 1 型但不是 2 型文法？或者是否为 2 型但不是 3 型文法？ S → bA, A → B, B → a",
        "answer": "Type 2, not type 3",
        "answer_symbols": []
    },
    "13.1 19 f)": {
        "question": "设 V = {S, A, B, a, b}, T = {a, b}. 若产生式集 P 为下列集合时，问文法 G = (V, T, S, P) 是否为 0 型但不是 1 型文法？是否为 1 型但不是 2 型文法？或者是否为 2 型但不是 3 型文法？ S → aA, aA → B, B → aA, A → b",
        "answer": "Type 0, not type 1",
        "answer_symbols": []
    },
    "13.1 19 g)": {
        "question": "设 V = {S, A, B, a, b}, T = {a, b}. 若产生式集 P 为下列集合时，问文法 G = (V, T, S, P) 是否为 0 型但不是 1 型文法？是否为 1 型但不是 2 型文法？或者是否为 2 型但不是 3 型文法？ S → bA, A → b, S → λ",
        "answer": "Type 3",
        "answer_symbols": []
    },
    "13.1 19 h)": {
        "question": "设 V = {S, A, B, a, b}, T = {a, b}. 若产生式集 P 为下列集合时，问文法 G = (V, T, S, P) 是否为 0 型但不是 1 型文法？是否为 1 型但不是 2 型文法？或者是否为 2 型但不是 3 型文法？ S → AB, B → aAb, aAb → b",
        "answer": "Type 0, not type 1",
        "answer_symbols": []
    },
    "13.1 19 i)": {
        "question": "设 V = {S, A, B, a, b}, T = {a, b}. 若产生式集 P 为下列集合时，问文法 G = (V, T, S, P) 是否为 0 型但不是 1 型文法？是否为 1 型但不是 2 型文法？或者是否为 2 型但不是 3 型文法？ S → aA, A → bB, B → b, B → λ",
        "answer": "Type 2, not type 3",
        "answer_symbols": []
    },
    "13.1 19 j)": {
        "question": "设 V = {S, A, B, a, b}, T = {a, b}. 若产生式集 P 为下列集合时，问文法 G = (V, T, S, P) 是否为 0 型但不是 1 型文法？是否为 1 型但不是 2 型文法？或者是否为 2 型但不是 3 型文法？ S → A, A → B, B → λ",
        "answer": "Type 2, not type 3",
        "answer_symbols": []
    },
    "13.1 20": {
        "question": "回文是从前往后读和从后往前读都一样的串，也就是，串 w, w = w^R, w^R 是串 w 的逆. 试求一个上下文无关的文法，使得其生成的集合是字母表 {0, 1} 上的所有回文.",
        "answer": "我们可以让相同的符号从中点向外生长，中间本身有一个可选的最终符号。因此我们使用规则 S→ 0S0，S→ 1S1，S→ λ，S→ 0，和 S→ 1。请注意，这个文法是上下文无关的，因为每个左侧都是一个单一的非终结符。",
        "answer_symbols": [
            "→",
            "λ"
        ]
    },
    "13.1 21 a)": {
        "question": "设 G_1 和 G_2 是两个上下文无关的文法，它们生成的语言分别为 L(G_1) 和 L(G_2). 试证：对于下列每个集合，都有一个上下文无关文法生成下列集合. L(G_1) ∪ L(G_2)",
        "answer": "Add S and productions S → S1 and S → S2.",
        "answer_symbols": [
            "→"
        ]
    },
    "13.1 21 b)": {
        "question": "设 G_1 和 G_2 是两个上下文无关的文法，它们生成的语言分别为 L(G_1) 和 L(G_2). 试证：对于下列每个集合，都有一个上下文无关文法生成下列集合. L(G_1) · L(G_2)",
        "answer": "Add S and production S → S1 S2.",
        "answer_symbols": [
            "→"
        ]
    },
    "13.1 21 c)": {
        "question": "设 G_1 和 G_2 是两个上下文无关的文法，它们生成的语言分别为 L(G_1) 和 L(G_2). 试证：对于下列每个集合，都有一个上下文无关文法生成下列集合. L(G_1)^*",
        "answer": "Add S and production S → λ and S → S1 S.",
        "answer_symbols": [
            "→",
            "λ"
        ]
    },
    "13.1 24 a)": {
        "question": "设 G 是一个文法，其中 V = {a, b, c, S}, T = {a, b, c}，初始符号为 S，产生式为 S → abS、S→bcS、S→bbS、S→a、S→cb. 构造下列串的派生树. bcbbba",
        "answer": "如果我们查看字符串的开头，我们可以看到可以先使用规则 S→ bcS。然后，由于字符串剩余部分（初始 bc 之后）以 bb 开头，我们可以使用规则 S→ bbS。最后，我们可以使用规则 S→ a。因此我们得到下面显示的第一棵树。",
        "answer_symbols": [
            "→"
        ]
    },
    "13.1 24 b)": {
        "question": "设 G 是一个文法，其中 V = {a, b, c, S}, T = {a, b, c}，初始符号为 S，产生式为 S → abS、S→bcS、S→bbS、S→a、S→cb. 构造下列串的派生树. bbbcbcba",
        "answer": "这类似于部分(a)，使用三条规则来处理前六个字符，每次处理两个。",
        "answer_symbols": [
            "→"
        ]
    },
    "13.1 24 c)": {
        "question": "设 G 是一个文法，其中 V = {a, b, c, S}, T = {a, b, c}，初始符号为 S，产生式为 S → abS、S→bcS、S→bbS、S→a、S→cb. 构造下列串的派生树. bcabbbbbcbb",
        "answer": "我们再次从左边开始，每次处理两个字符，生成如图所示的树。",
        "answer_symbols": [
            "→"
        ]
    },
    "13.1 26 a)": {
        "question": "对于练习 25 中的串，用自底向上的语法分析方法，确定其是否属于例 12 中的文法生成的语言. baba",
        "answer": "由于字符串以 b 开头，我们可能有以下两种情况作为派生的最后一步：Baba⇒ baba 或 Caba⇒ baba。后者看起来更有希望，因为 Ca 可能来自规则 A→ Ca，这意味着派生过程为 Aba⇒ Caba⇒ baba。现在我们看到，由于 B→ Ba 和 B→ b 是规则，因此派生过程可能是 S⇒ AB⇒ ABa⇒ Aba⇒ Caba⇒ baba。",
        "answer_symbols": [
            "⇒",
            "→"
        ]
    },
    "13.1 26 b)": {
        "question": "对于练习 25 中的串，用自底向上的语法分析方法，确定其是否属于例 12 中的文法生成的语言. abab",
        "answer": "无法在左侧获得 a，因为每个规则中的 a 都被另一个符号（永远不会变为 λ）所前置。",
        "answer_symbols": []
    },
    "13.1 26 c)": {
        "question": "对于练习 25 中的串，用自底向上的语法分析方法，确定其是否属于例 12 中的文法生成的语言. cbaba",
        "answer": "这与部分(a)相同，因为我们本可以使用规则 C→ cb 而不是规则 C→ b，从而在左侧多出一个 c。因此派生过程为 S⇒ AB⇒ ABa⇒ Aba⇒ Caba⇒ cbaba。",
        "answer_symbols": [
            "→",
            "⇒"
        ]
    },
    "13.1 26 d)": {
        "question": "对于练习 25 中的串，用自底向上的语法分析方法，确定其是否属于例 12 中的文法生成的语言. bbbcbba",
        "answer": "符号 c 出现的唯一方式是通过规则 C→ cb。因此我们可以假设（不失一般性），派生的最后一步为 bbbCa⇒ bbbcba。现在 Ca 出现的唯一方式是从规则 A→ Ca。因此我们可以假设派生过程为 bbbA⇒ bbbCa⇒ bbbcba。但是 A 不可能出现在末尾（唯一产生 A 的规则会在其后添加一个 B）。因此这个字符串不在语言中。",
        "answer_symbols": [
            "→",
            "⇒"
        ]
    },
    "13.1 28 a)": {
        "question": "如果一个文法的产生式由下列巴克斯-诺尔范式给出，那么这些产生式是什么？〈表达式〉::=〈表达式〉|〈表达式〉+〈表达式〉|〈表达式〉*〈表达式〉|〈变元〉〈变元〉::=x|y",
        "answer": "我们只需将 Backus-Naur 形式机械地翻译成产生式。让我们用 E 表示〈expression〉（我们假设这是起始符号），用 V 表示〈variable〉以方便表示。规则为 E→(E)，E→ E+ E，E→ E * E，以及 E→ V（从第一种形式），加上 V → x 和 V → y（从第二种形式）。",
        "answer_symbols": [
            "→",
            "+",
            "*",
            "(",
            ")"
        ]
    },
    "13.1 28 b)": {
        "question": "求此文法中 (x * y) + x 的派生树.",
        "answer": "构建这棵树很容易。最外层的操作是 +，因此树的顶部显示 E 成为 E+ E。右侧的 E 现在是变量 x。左侧的 E 是括号内的表达式，该表达式本身是两个变量的乘积。",
        "answer_symbols": [
            "+",
            "(",
            ")"
        ]
    },
    "13.1 30 a)": {
        "question": "构造一个短语结构文法，使其生成所有形如 a/b 的分数构成的集合，其中 a 为带符号的十进制数，b 是正整数.",
        "answer": "我们首先纳入练习 29a 解答中的所有规则，除了前两条。然后我们简单地添加规则 S→〈sign〉〈integer〉/〈positive integer〉。",
        "answer_symbols": [
            "→",
            "/"
        ]
    },
    "13.1 30 b)": {
        "question": "给出这个文法的巴克斯-诺尔范式.",
        "answer": "我们纳入练习 29b 解答中的所有规则，除了第一行，再加上规则〈fraction〉::= 〈sign〉〈integer〉/〈positive integer〉。",
        "answer_symbols": [
            "/"
        ]
    },
    "13.1 30 c)": {
        "question": "构造此文法中 +311/17 的派生树.",
        "answer": "树几乎是根据规则自动生成的。",
        "answer_symbols": []
    },
    "13.1 32": {
        "question": "给出如下人名的巴克斯-诺尔范式产生式规则，人名包含：“名”，它是一个仅有首字母大写的字母串；“中间名”；“姓”，它可以是任意字母串.",
        "answer": "We ignore the need for spaces between the names, and we assume that names need to be nonempty. We also do not assume anything more than was given in the statement of the exercise.\n- 〈person〉 ::= 〈firstname〉〈middleinitial〉〈lastname〉\n- 〈lastname〉 ::= 〈letterstring〉\n- 〈middleinitial〉 ::= 〈letter〉\n- 〈firstname〉 ::= 〈ucletter〉 | 〈ucletter〉〈letterstring〉\n- 〈letterstring〉 ::= 〈letter〉 | 〈letterstring〉〈letter〉\n- 〈letter〉 ::= 〈lcletter〉 | 〈ucletter〉\n- 〈lcletter〉 ::= a | b | c | ... | z\n- 〈ucletter〉 ::= A | B | C | ... | Z",
        "answer_symbols": [
            "::=",
            "|"
        ]
    },
    "13.1 34 a)": {
        "question": "描述由下列 EBNF 产生式集合定义的串的集合. string ::= L+D?L+ L ::= a|b|c D ::= 0|1",
        "answer": "Strings in this set consist of one or more letters followed by an optional binary digit, followed by one or more letters. Only the letters a, b, and c are used, however.",
        "answer_symbols": []
    },
    "13.1 34 b)": {
        "question": "描述由下列 EBNF 产生式集合定义的串的集合. string ::= sign D+|D+ sign ::= +|- D ::= 0|1|2|3|4|5|6|7|8|9",
        "answer": "Strings in this set consist of an optional plus or minus sign followed by one or more digits.",
        "answer_symbols": [
            "+",
            "-"
        ]
    },
    "13.1 34 c)": {
        "question": "描述由下列 EBNF 产生式集合定义的串的集合. string ::= L*(D+)?L* L ::= x|y D ::= 0|1",
        "answer": "Strings in this set consist of any number of letters, followed by any number of binary digits, followed by any number of letters. \"Any number\" includes 0, so the string could consist of letters only or of binary digits only, and it could also be empty. Only the letters x and y are used, however. Note that (D+)? is equivalent to D*.",
        "answer_symbols": [
            "?",
            "+",
            "*"
        ]
    },
    "13.2 5 a)": {
        "question": "在例 2 所给的有限状态机中，对于下列每个输入串，试确定其输出。0111",
        "answer": "1100",
        "answer_symbols": []
    },
    "13.2 5 b)": {
        "question": "在例 2 所给的有限状态机中，对于下列每个输入串，试确定其输出。110110111",
        "answer": "00110110",
        "answer_symbols": []
    },
    "13.2 5 c)": {
        "question": "在例 2 所给的有限状态机中，对于下列每个输入串，试确定其输出。01010101010",
        "answer": "11111111111",
        "answer_symbols": []
    },
    "13.2 6 a)": {
        "question": "在例 3 所给的有限状态机中，对于下列每个输入串，试确定其输出。0000",
        "answer": "机器从状态s0开始。- 输入为0时，机器移动到状态s1并输出1。在接下来的三个输入中，它保持在状态s1并输出1。因此，输出为1111。",
        "answer_symbols": []
    },
    "13.2 6 b)": {
        "question": "在例 3 所给的有限状态机中，对于下列每个输入串，试确定其输出。101010",
        "answer": "机器从状态s0开始。- 输入为1时，机器移动到状态s3并输出0。然后在下一个输入（0）时，它移动到状态s1并输出0。接下来的四次移动分别是到状态s2、s3、s0和s1，输出分别为1001。因此，答案是001001。",
        "answer_symbols": []
    },
    "13.2 6 c)": {
        "question": "在例 3 所给的有限状态机中，对于下列每个输入串，试确定其输出。11011100010",
        "answer": "同样的思路。- 答案是00110000110。",
        "answer_symbols": []
    },
    "13.2 7": {
        "question": "试构造一个有限状态机作为下列饮料机的模型：饮料机接受 5 分、1 角和 25 分的硬币，一直到它接受了 35 分钱时它才开始找回零钱，退出超过 35 分的所有钱币。然后顾客就可以按某些按钮，得到一简可乐，或一瓶软饮料，或一瓶姜汁啤酒。",
        "answer": "s0 s1 s2 s3 s4 s5 s6\n5, 0 5, 0 5, 0 5, 0 5, 0 5, 0\n10, 0 10, 0 10, 0 10, 0 10, 0\n25, 0 25, 0 25, 5 25, 20\n10, 5\n25, 25\nx, 0 x, 0 x, 0 x, 0 x, 0 x, 0\n开始\nx, 0\n5, 0\n10, 0\n25, 0\ns7 5, 5 10, 10\n25, 10 25, 15",
        "answer_symbols": [
            ",",
            "0",
            "5",
            "10",
            "25"
        ]
    },
    "13.2 8": {
        "question": "试构造一个有限状态机作为下列售报机的模型：它有一个门，此门只在下列两种情形下才可打开；一是放人了 3 个 1 角硬币（和任意数量的其他硬币）；二是放入了一个 25 分的硬币和一个 5 分的硬币（和任意数量的其他硬币）。一旦门能够被打开，顾客就打开门，取出一份报纸，再关上门。不管塞进去多少额外的钱币，机器都不找回零钱。下一个顾客重新开始时也不能使用上一位多余的零钱。",
        "answer": "我们需要9个状态。- 中间行的状态对应于没有投入硬币的情况。顶行处理投入一个五分硬币的情况，底行处理投入一个二十五分硬币的情况。列记录投入的十分硬币的数量（0、1或2）。\n- 回到状态s0的转换显示为指向开放空间以避免混乱。此外，为了避免混乱，我们没有画出六个循环，即在状态s3、s4和s5上的N输入（因为额外的五分硬币不被记录），以及在状态s6、s7和s8上的Q输入（因为额外的二十五分硬币不被记录）。我们没有显示输出，除了所有回到状态s0的转换；在那里，输出是“解锁门”。字母代表明显的硬币。\n",
        "answer_symbols": []
    },
    "13.2 9": {
        "question": "构造一个有限状态机，将输入延迟两位，且以 00 作为输出的头两位。",
        "answer": "开始\n0, 1\n0, 1\n1, 0\n1, 0\n0, 0\n1, 1\ns0\ns2\ns1 s3\ns4",
        "answer_symbols": [
            ",",
            "0",
            "1"
        ]
    },
    "13.2 10": {
        "question": "构造一个有限状态机，对输入串每隔一位改变一次值，且从第二位开始。但保持其他位不变。",
        "answer": "我们只需要两个状态，因为动作仅取决于我们读取的位数的奇偶性。- 从状态s0到状态s1的转换是在奇数位上进行的，因此我们在那里输出与输入相同的位。回到s0的转换是在偶数位上进行的，因此我们在那里输出与输入相反的位。",
        "answer_symbols": []
    },
    "13.2 11": {
        "question": "构造一个有限状态机来模拟计算机的登录过程：用户首先输人用户标识码，然后输入口令；用户标识码和口令分别被看做是一个输入；如果输入的口令不对，则要求用户重新输入用户标识码。",
        "answer": "s0\ns1\ns3\ns2\n开始\nx, c\nv= 有效ID i= 无效ID p= 有效密码 q= 无效密码\na=\"输入用户ID\" b=\"输入密码\" c= 提示 x= 任何输入",
        "answer_symbols": [
            ",",
            "=",
            "\""
        ]
    },
    "13.2 12": {
        "question": "构造一个有限状态机来模拟组合锁，此锁包含数 1 到 40，只有在输入正确的组合时它才能被打开。正确组合是：10 右，8 左，37 右。每个输入都是“一个数、旋转方向、在此方向旋转锁的时间”构成的三元组。",
        "answer": "为了防止机器过于复杂，我们将模型保持非常简单，假设锁只有在输入为(10, R, 1)(8, L, 2)(37, R, 1)时才会打开。- 在我们的图中，“输入”A代表除所示输入外的所有其他输入。输出0表示没有发生任何事情；输出U表示锁已解锁。如果我们希望使模型更现实，例如，我们可以允许输入(10, R, 1)(8, L, 1)(8, L, 1)(37, R, 1)打开锁，或者(10, R, 1)(8, L, 2)(30, R, 1)(37, R, 1)（假设表盘上的数字按逆时针排列）。",
        "answer_symbols": []
    },
    "13.2 14": {
        "question": "构造一个有限状态机模拟自动出纳机 (ATM) 的密码登录过程：用户输入一个 4 位数的串，一次输入一个数字。如果用户正确输入这 4 个数字的口令，ATM 显示欢迎界面。当用户输入不正确时，ATM 提示用户密码输入错误。如果用户输入错误密码 3 次，账户就被锁定。",
        "answer": "这个机器的图示会有些繁琐；它有25个状态。相反，我们将口头描述这个机器。我们假设可能的输入是数字0到9。我们将让s0作为起始状态。状态s1、s2、s3和s4将是用户输入正确密码的连续数字后到达的状态，因此从s3到s4的转换时输出欢迎屏幕。从s0到s1、从s1到s2或从s2到s3的转换没有输出。状态s11、s12、s13和s14将对应于错误的数字。因此，如果第一个数字错误，将从s0到s11；如果第二个数字错误，将从s1到s12，依此类推。所有输入都有从s11到s12、从s12到s13、从s13到s14的转换。对于向s11、s12或s13的转换没有输出。在转换到s14时给出错误消息。现在状态s14扮演s0的角色，还有八个状态来处理用户的第二次正确密码尝试，最终成功登录（例如，状态s104）或再次失败（例如，状态s114）。然后另一组八个状态处理第三次尝试。状态s214是最后的尝试——转换到它时告诉用户账户被锁定。",
        "answer_symbols": []
    },
    "13.2 15": {
        "question": "构造一个有限状态机来模拟有一定限制的电话交换系统，发送到网络的电话号码要求是以 0、911 和 1 开头，后跟以 212、800、866、877 和 888 开始的 10 位电话号码。所有其他数字串都被系统锁定，并且用户会听到一个报错信息。",
        "answer": "Let s0 be the start state and let s1 be the state representing a successful call. From s0, inputs of 2, 3, 4, 5, 6, 7, or 8 send the machine back to s0 with output of an error message for the user. From s0 an input of 0 sends the machine to state s1, with the output being that the 0 is sent to the network. From s0 an input of 9 sends the machine to state s2 with no output; from there an input of 1 sends the machine to state s3 with no output; from there an input of 1 sends the machine to state s1 with the output being that the 911 is sent to the network. All other inputs while in states s2 or s3 send the machine back to s0 with output of an error message for the user. From s0 an input of 1 sends the machine to state s4 with no output; from s4 an input of 2 sends the machine to state s5 with no output; and this path continues in a similar manner to the 911 path, looking next for 1, then 2, then any seven digits, at which point the machine goes to state s1 with the output being that the ten-digit input is sent to the network. Any 'incorrect' input while in states s5 or s6 (that is, anything except a 1 while in s5 or a 2 while in s6) sends the machine back to s0 with output of an error message for the user. Similarly, from s4 an input of 8 followed by appropriate successors drives us eventually to s1, but inappropriate outputs drive us back to s0 with an error message. Also, inputs while in state s4 other than 2 or 8 send the machine back to s0 with output of an error message for the user.",
        "answer_symbols": []
    },
    "13.2 16": {
        "question": "构造一个有限状态机，当读取的输入符号所代表的数能够被 3 整除时，输出 1；否则，输出 0。",
        "answer": "我们只需要三个状态，以跟踪到目前为止读取的位数除以3的余数。当进入状态s0（余数为0）时，我们输出1。",
        "answer_symbols": []
    },
    "13.2 18": {
        "question": "构造一个有限状态机，确定到目前为止所读取的输入串中，其结尾是否有至少 5 个连续的 1。",
        "answer": "这里我们只需要跟踪最近遇到的连续1的数量。",
        "answer_symbols": []
    },
    "13.2 19": {
        "question": "构造一个有限状态机，确定到目前为止所读取的输入中，其最后的 8 个字符是否为 computer。输入可能是任意的英文字母。",
        "answer": "s0 s1 s2 s3 s4 s5 s6 开始 s7 C, 0 O, 0 M, 0 P, 0 U, 0 T, 0 E, 0 R, 1 –{C}, 0 Σ –{M}, 0 Σ –{P}, 0 Σ –{U}, 0 Σ –{T}, 0 Σ –{E}, 0 Σ –{R}, 0 Σ –{O}, 0",
        "answer_symbols": [
            "–",
            "Σ"
        ]
    },
    "13.2 22 a)": {
        "question": "对于下列每个输入串，求练习 20 中的摩尔机所生成的输出串。0101",
        "answer": "遇到的状态（在s0之后）依次为s0、s2、s2和s1。因此输出为00111。",
        "answer_symbols": []
    },
    "13.2 22 b)": {
        "question": "对于下列每个输入串，求练习 20 中的摩尔机所生成的输出串。111111",
        "answer": "访问的状态顺序为s2、s1、s0、s2、s1、s0（初始状态之后）。因此输出为0110110。",
        "answer_symbols": []
    },
    "13.2 22 c)": {
        "question": "对于下列每个输入串，求练习 20 中的摩尔机所生成的输出串。11101110111",
        "answer": "处理过程与其他部分类似。答案是011001100110。",
        "answer_symbols": []
    },
    "13.2 24": {
        "question": "构造一个摩尔机，只要读取的输入符号的个数能够被 4 整除时，就输出 1。",
        "answer": "机器如图所示。注意状态s_i表示到目前为止读取的符号数量与4同余的条件。因此我们在状态s_0处设置输出为1，其他每个状态的输出为0。每个箭头，标记为0, 1，代表两个箭头，它们的起点和终点相同，一个标记为0，另一个标记为1。",
        "answer_symbols": [
            "→",
            "0",
            "1"
        ]
    },
    "13.2 25": {
        "question": "构造一个摩尔机，使其能够判断输入串是包含偶数个 1 还是奇数个 1。如果输入串中有偶数个 1，则输出 1；如果输入串中有奇数个 1，则输出 0。",
        "answer": "s0 开始 s3 1 1 0 1 0 1 1 0 s1 1 0 s2 0 0",
        "answer_symbols": []
    },
    "13.3 14": {
        "question": "证明：如果 M = (S, I, f, s0, F) 是一个确定性的有限状态自动机，并且当 s ∈ S，输入串 x ∈ I* 时，有 f(s, x) = s，则对于每个非负整数 n，有 f(s, x^n) = s。（这里，x^n 指的是串 x 的 n 个副本的连接，是在 5.3 节练习 37 中递归定义的。）",
        "answer": "我们可以通过数学归纳法来证明这一点。对于 n = 0（基础步骤），我们需要证明 f(s, λ) = s，这在示例 4 后面的递归定义的基础步骤中是成立的。归纳步骤直接从练习 15 跟随，因为 x^(n+1) = x^n * x。",
        "answer_symbols": [
            "=",
            "^",
            "*"
        ]
    },
    "13.3 15": {
        "question": "给定一个确定性的有限状态机 M = (S, I, f, s0, F)，使用结构归纳和扩展转移函数 f 的递归定义来证明：对于所有的状态 s ∈ S，输入串 x ∈ I*，y ∈ I*，有 f(s, xy) = f(f(s, x), y)。",
        "answer": "我们使用结构归纳法来证明输入字符串 y。基础步骤考虑 y= λ，对于归纳步骤我们写 y= wa，其中 w ∈ I * 和 a ∈ I。对于基础步骤，我们有 xy= x，因此必须证明 f(s, x)= f(f(s, x), λ)。但是扩展转换函数定义的第一部分说这是正确的。然后假设归纳假设该等式对 w 成立并证明 f(s, xwa)= f(f(s, x), wa)。根据定义的第二部分，此等式的左侧等于 f(f(s, xw), a)。根据归纳假设，f(s, xw)= f(f(s, x), w)，所以 f(f(s, xw), a)= f(f(f(s, x), w), a)。我们期望的等式的右侧，根据定义的第二部分，也等于 f(f(f(s, x), w), a)，如所需。",
        "answer_symbols": [
            "∈",
            "λ",
            "="
        ]
    },
    "13.3 23": {
        "question": "构造一个确定性的有限状态自动机，它能识别以 01 开始的所有位串构成的集合。",
        "answer": "让 s2 成为唯一的最终状态，并从 s2 到自身放置转换。从初始状态 s0 在输入 0 上放置到 s1 的转换，从 s1 在输入 1 上放置到 s2 的转换。创建状态 s3，并将 s0 和 s1 的其他转换（以及 s3 的两个转换）引导到 s3。",
        "answer_symbols": []
    },
    "13.3 24": {
        "question": "构造一个确定性的有限状态自动机，它能识别以 10 结束的所有位串构成的集合。",
        "answer": "我们需要跟踪最后两个输入符号是什么，因此我们创建了四个状态：s0、s1、s2 和 s3，分别对应刚刚看到 00、01、10 和 11。只有 s2 是最终状态，因为我们希望接受恰好以 10 结尾的字符串。我们将 s0 设为初始状态，因此实际上我们在接受输入之前假装字符串以两个 0 开头；这不会造成任何伤害。",
        "answer_symbols": []
    },
    "13.3 2": {
        "question": "设 A 是串的一个集合。证明 A∅ = ∅A = ∅。",
        "answer": "根据定义 AØ={xy | x ∈ A ∧ y ∈ Ø}。由于空集没有元素，这个集合是空的。同样 ØA= Ø。(这个结果也是练习6的推论，因为一个集合为空当且仅当其基数为0。)",
        "answer_symbols": [
            "∈",
            "∧",
            "∅",
            "="
        ]
    },
    "13.3 3": {
        "question": "求所有串的集合对 A 和 B，使得 AB = {10, 111, 1010, 1000, 10111, 101000}。",
        "answer": "A={1, 101}, B={0,11,000}; A={10,111,1010,1000,10111,101000}, B={λ}; A={λ, 10}, B={10, 111, 1000} 或 A={λ}, B={10, 111, 1010, 1000, 10111, 101000}",
        "answer_symbols": [
            "λ"
        ]
    },
    "13.3 4 a)": {
        "question": "证明下列等式成立。(λ)∗ = {λ}",
        "answer": "如果我们将空字符串的任意多个副本连接起来，我们得到的是空字符串。",
        "answer_symbols": []
    },
    "13.3 4 b)": {
        "question": "证明下列等式成立。对任意串的集合 A，(A∗)∗ = A∗",
        "answer": "显然 A* ⊆ (A*)*，因为对于所有集合B，B ⊆ B*。为了证明 (A*)* ⊆ A*，设w是 (A*)* 的一个元素。那么 w= w1w2...wk 对于某些字符串 wi ∈ A*。这意味着每个 wi= wi1wi2...win_i 对于某些字符串 wij ∈ A。但是，w= w11w12...w1n1 w21w22...w2n2...wk1wk2...wknk，这是A的元素的连接，所以 w ∈ A*。",
        "answer_symbols": [
            "⊆",
            "∈",
            "*"
        ]
    },
    "13.3 6": {
        "question": "设 V 是一个字母表，A 和 B 是 V∗ 的子集。证明：|AB| ≤ |A| · |B|。",
        "answer": "最多，AB 包含 A × B 中每个元素的一个元素，即当 (u, v) ∈ A × B 时，uv ∈ AB。(它可能包含比这更少的元素，因为AB中的同一个字符串可能以两种不同的方式出现，即来自两个不同的有序对。) 因此 |AB| ≤ |A × B| = |A||B|。",
        "answer_symbols": [
            "×",
            "∈",
            "≤",
            "|"
        ]
    },
    "13.3 7": {
        "question": "设 V 是一个字母表，A 和 B 是 V∗ 的子集，且 A ⊆ B。证明：A∗ ⊆ B∗。",
        "answer": "字符串属于 A* 当且仅当它是 A 中任意数量字符串的连接。因为 A 中的每个字符串也在 B 中，所以 A* 中的字符串也是 B 中字符串的连接。因此，A* ⊆ B*。",
        "answer_symbols": [
            "⊆"
        ]
    },
    "13.3 8 a)": {
        "question": "设 V 是一个字母表，A 是 V∗ 的子集。证明或反证下列命题。A ⊆ A^²",
        "answer": "这是错误的；取 A={1}，则 A2={11}。",
        "answer_symbols": [
            "=",
            "{}"
        ]
    },
    "13.3 8 b)": {
        "question": "设 V 是一个字母表，A 是 V∗ 的子集。证明或反证下列命题。如果 A = A^²，则 λ ∈ A",
        "answer": "如果我们取 A= Ø，则这不是真的。如果我们排除这种可能性，那么A2中每个字符串的长度都会大于A中最短字符串的长度（如果 λ 不属于 A）。因此，当 A ≠ Ø 时，该陈述是真的。",
        "answer_symbols": [
            "Ø",
            "≠",
            "λ"
        ]
    },
    "13.3 8 c)": {
        "question": "设 V 是一个字母表，A 是 V∗ 的子集。证明或反证下列命题。A {λ} = A",
        "answer": "这是真的，因为对于所有字符串 w，wλ= w。",
        "answer_symbols": [
            "λ",
            "="
        ]
    },
    "13.3 8 d)": {
        "question": "设 V 是一个字母表，A 是 V∗ 的子集。证明或反证下列命题。(A∗)∗ = A∗",
        "answer": "这是练习4b。",
        "answer_symbols": []
    },
    "13.3 8 e)": {
        "question": "设 V 是一个字母表，A 是 V∗ 的子集。证明或反证下列命题。A∗ A = A∗",
        "answer": "如果 λ 不属于 A，这是错误的，因为右边包含空字符串，但左边不包含。",
        "answer_symbols": [
            "λ"
        ]
    },
    "13.3 8 f)": {
        "question": "设 V 是一个字母表，A 是 V∗ 的子集。证明或反证下列命题。|A∗| = |A|∗",
        "answer": "这是错误的。取 A={0, λ}。那么 A2={λ, 0, 00}，所以 |A2| = 3 ≠ 4 = |A|^2。",
        "answer_symbols": [
            "{",
            "}",
            "λ",
            "≠",
            "^",
            "|"
        ]
    },
    "13.3 10 a)": {
        "question": "确定下列集合是否包含串 01001。{0, 1}∗",
        "answer": "这个集合包含所有位串，所以答案当然是肯定的。",
        "answer_symbols": []
    },
    "13.3 10 b)": {
        "question": "确定下列集合是否包含串 01001。{0}∗ {10} {1}∗",
        "answer": "这个集合中的每个字符串不能有两个连续的0，除非在字符串的最开始。因为 01001 违反了这个条件，所以它不在这个集合中。",
        "answer_symbols": []
    },
    "13.3 10 c)": {
        "question": "确定下列集合是否包含串 01001。{010}∗ {0}∗ {1}",
        "answer": "我们的字符串是 (010)1011，所以在这个集合中。",
        "answer_symbols": [
            "(",
            ")"
        ]
    },
    "13.3 10 d)": {
        "question": "确定下列集合是否包含串 01001。{010, 011} {00, 01}",
        "answer": "答案是肯定的；只需从第一个集合中取 010 和第二个集合中取 01。",
        "answer_symbols": []
    },
    "13.3 10 e)": {
        "question": "确定下列集合是否包含串 01001。{00} {0}∗ {01}",
        "answer": "这个集合中的每个字符串必须以00开头；由于我们的字符串不符合这个条件，所以它不在这个集合中。",
        "answer_symbols": []
    },
    "13.3 10 f)": {
        "question": "确定下列集合是否包含串 01001。{01}∗ {01}∗",
        "answer": "这个集合中的每个字符串不能有两个连续的0。因为 01001 违反了这个条件，所以它不在这个集合中。",
        "answer_symbols": []
    },
    "13.3 12 a)": {
        "question": "确定下列串能否由图 1 中的确定性的有限状态自动机所识别。010",
        "answer": "第一个输入使机器保持在状态 s0。第二个输入将其驱动到状态 s1。第三个输入又将其驱动回状态 s0。由于此状态 (s0) 是最终状态，因此接受该字符串。",
        "answer_symbols": [
            "(",
            ")"
        ]
    },
    "13.3 12 b)": {
        "question": "确定下列串能否由图 1 中的确定性的有限状态自动机所识别。1101",
        "answer": "输入字符串将机器驱动到状态 s1、s2、s0 和 s1。由于 s1 不是最终状态，因此不接受此字符串。",
        "answer_symbols": []
    },
    "13.3 12 c)": {
        "question": "确定下列串能否由图 1 中的确定性的有限状态自动机所识别。1111110",
        "answer": "输入字符串将机器驱动到状态 s1、s2、s0、s1、s2、s0 和 s1。由于 s1 不是最终状态，因此不接受此字符串。",
        "answer_symbols": []
    },
    "13.3 12 d)": {
        "question": "确定下列串能否由图 1 中的确定性的有限状态自动机所识别。010101010",
        "answer": "输入字符串将机器驱动到状态 s0、s1、s0、s1、s0、s1、s0、s1 和 s0。由于 s0 是最终状态，因此接受该字符串。",
        "answer_symbols": []
    },
    "13.3 13": {
        "question": "对于下列每个集合，确定其中的每个串是否都能由图 1 中的确定性的有限状态自动机所识别。",
        "answer": "a) 是 b) 是 c) 否 d) 否 e) 否 f) 否",
        "answer_symbols": []
    },
    "13.3 25": {
        "question": "构造一个确定性的有限状态自动机，它能识别包含串 101 的所有位串构成的集合。",
        "answer": "初始状态 s0，唯一最终状态 s3；从 s0 在 0 上转换到 s0，从 s0 在 1 上转换到 s1，从 s1 在 0 上转换到 s2，从 s1 在 1 上转换到 s1，从 s2 在 0 上转换到 s0，从 s2 在 1 上转换到 s3，从 s3 在 0 上转换到 s3，从 s3 在 1 上转换到 s3",
        "answer_symbols": []
    },
    "13.3 26": {
        "question": "构造一个确定性的有限状态自动机，它能识别不包含 3 个连续 0 的所有位串构成的集合。",
        "answer": "这与练习 29 非常相似，只是 0 和 1 的角色互换了，而且我们希望接受练习 29 中未被接受的字符串。因此我们采用练习 29 解决方案中给出的机器，将所有输入的 0 和 1 互换，并使 s3 成为唯一的非最终状态（参见练习 39）。",
        "answer_symbols": []
    },
    "13.3 27": {
        "question": "构造一个确定性的有限状态自动机，它能识别恰好包含 3 个 0 的所有位串构成的集合。",
        "answer": "有五个状态，只有 s3 是最终状态。对于 i= 0, 1, 2, 3，在输入 1 上从 si 转换到自身，在输入 0 上从 si 转换到 si+1。s4 的两个转换都是到自身。",
        "answer_symbols": []
    },
    "13.3 28": {
        "question": "构造一个确定性的有限状态自动机，它能识别至少包含 3 个 0 的所有位串构成的集合。",
        "answer": "我们有四个状态：s0（初始状态）表示尚未看到 0；s1 表示仅看到一个 0；s2 表示仅看到两个 0；s3 表示至少看到三个 0。只有状态 s3 是最终状态。转换是显而易见的：每个状态在输入 1 时都转换到自身，从 si 在输入 0 时转换到 si+1（i = 0, 1, 2），从 s3 在输入 0 时转换到自身。",
        "answer_symbols": []
    },
    "13.3 29": {
        "question": "构造一个确定性的有限状态自动机，它能识别包含 3 个连续 1 的所有位串构成的集合。",
        "answer": "有四个状态，只有 s3 是最终状态。对于 i= 0, 1, 2，在输入 1 上从 si 转换到 si+1，但在输入 0 上回到 s0。s3 的两个转换都是到自身。",
        "answer_symbols": []
    },
    "13.3 30": {
        "question": "构造一个确定性的有限状态自动机，它能识别以 0 或 11 开始的所有位串构成的集合。",
        "answer": "我们有五个状态：非终态s0（起始状态）；终态s1表示字符串以0开始；非终态s2表示字符串的第一个符号是1；终态s3表示字符串的前两个符号是11；非终态s4是一个墓地。转换是从s0在输入0时到s1，从s0在输入1时到s2，从s2在输入1时到s3，从s2在输入0时到s4，以及从每个状态s1、s3和s4在任何输入下都回到自身。",
        "answer_symbols": [
            "→"
        ]
    },
    "13.3 31": {
        "question": "构造一个确定性的有限状态自动机，它能识别以 11 开始和结束的所有位串构成的集合。",
        "answer": "开始状态 0 0 1 1 1 0 1 1 0 0 1 0, 1 s0 s3 s1 s4 s5 s6 s2",
        "answer_symbols": [
            "0",
            "1",
            ","
        ]
    },
    "13.3 32": {
        "question": "构造一个确定性的有限状态自动机，它能识别包含偶数个 1 的所有位串构成的集合。",
        "answer": "这与练习33非常相似，只是0和1的角色互换了，并且我们希望接受恰好不是练习33中接受的那些字符串。因此我们采用该练习解决方案中的机器，将所有输入0和1互换，并使s0成为唯一的终态（参见练习39）。",
        "answer_symbols": []
    },
    "13.3 33": {
        "question": "构造一个确定性的有限状态自动机，它能识别包含奇数个 0 的所有位串构成的集合。",
        "answer": "开始状态 s0，唯一结束状态 s1；从 s0 到 s0 的转换在输入为 1 时，从 s0 到 s1 的转换在输入为 0 时，从 s1 到 s1 的转换在输入为 1 时；从 s1 到 s0 的转换在输入为 0 时。",
        "answer_symbols": [
            "1",
            "0"
        ]
    },
    "13.3 34": {
        "question": "构造一个确定性的有限状态自动机，它能识别包含偶数个 0，奇数个 1 的所有位串构成的集合。",
        "answer": "这与练习36完全相同，只是这里s1是唯一的一个终态。",
        "answer_symbols": []
    },
    "13.3 35": {
        "question": "构造一个确定性的有限状态自动机，它能识别包含 0 后接奇数个 1 的所有位串构成的集合。",
        "answer": "开始状态 1 0 0 0 1 1 0, 1 s0 s3 s1 s2",
        "answer_symbols": [
            "1",
            "0",
            ","
        ]
    },
    "13.3 36": {
        "question": "构造一个确定性的有限状态自动机，它能识别包含偶数个 1，奇数个 0 的所有位串构成的集合。",
        "answer": "这个确定性机器是显而易见的选择。顶行表示看到偶数个0（底行表示看到奇数个0）；左列表示看到偶数个1（右列表示看到奇数个1）。",
        "answer_symbols": [
            "→"
        ]
    },
    "13.3 37": {
        "question": "构造一个确定性的有限状态自动机，它能识别包含 1 个或多个 1，并且以 0 作结束的所有位串构成的集合。",
        "answer": "假设存在这样的机器，开始状态为 s0 和其他状态 s1。因为空字符串不在语言中但某些字符串被接受，我们必须将 s1 作为唯一的最终状态，并且至少有一个从 s0 到 s1 的转换。因为字符串 0 不在语言中，从 s0 输入 0 的转换必须回到自身，所以从 s0 输入 1 的转换必须到 s1。但这与 1 不在语言中的事实相矛盾。",
        "answer_symbols": [
            "0",
            "1"
        ]
    },
    "13.3 38": {
        "question": "构造一个确定性的有限状态自动机，它能识别包含偶数个 1，偶数个 0 的所有位串构成的集合。",
        "answer": "我们通过反证法来证明这一点。假设存在这样的机器，起始状态为s0。因为空字符串属于语言，所以s0必须是终态。从s0必须有每个输入的转换，但它们不能回到s0本身，因为字符串0或1不被接受。此外，不能是s0的两个转换都指向同一个状态s'，因为从s'的0转换必须指向一个接受状态（因为00属于语言），但这会使我们的机器也接受10，而这不在语言中。因此必须有非终态s1和s2，从s0在输入0时到s1，从s0在输入1时到s2。如果我们的机器只有三个状态，那么就没有其他状态了。由于字符串00被接受，从s1在输入0时必须有一个转换回到s0。同样，由于字符串11被接受，从s2在输入1时必须有一个转换回到s0。由于字符串01不被接受（但一些以这种方式开头的更长字符串被接受），从s1在输入1时必须有一个转换要么回到自身，要么到s2。如果它回到s1，那么我们的机器会接受010，这是不应该的；如果它到s2，那么我们的机器会接受011，这也是不应该的。得到矛盾后，我们得出结论，不存在这样的有限状态自动机。",
        "answer_symbols": [
            "→",
            "≠"
        ]
    },
    "13.3 39": {
        "question": "如何改造有限状态自动机 M，使经过改变的自动机能识别集合 Γ* - L(M)。",
        "answer": "将每个最终状态改为非最终状态，反之亦然。",
        "answer_symbols": []
    },
    "13.3 41": {
        "question": "使用练习 39 叙述的方法以及练习 25 构造的有限状态自动机，求能识别不包含串 101 的位串构成集合的确定性的有限状态自动机。",
        "answer": "与练习 25 中相同的机器，但 s0、s1 和 s2 为最终状态。",
        "answer_symbols": []
    },
    "13.3 42": {
        "question": "使用练习 39 叙述的方法以及练习 29 构造的有限状态自动机，求能识别不包含 3 个连续 1 的所有位串构成集合的确定性的有限状态自动机。",
        "answer": "我们使用与练习29完全相同的机器，但使s0、s1和s2成为终态，使s3成为非终态。参见练习26。",
        "answer_symbols": []
    },
    "13.3 43": {
        "question": "求所给的非确定性有限状态自动机所识别的语言。开始 s_0 s_1 s_2",
        "answer": "{0, 01, 11}",
        "answer_symbols": [
            "{",
            "}",
            ",",
            "0",
            "1"
        ]
    },
    "13.3 44": {
        "question": "求所给的非确定性有限状态自动机所识别的语言。开始 s_0 s_1 s_2",
        "answer": "空字符串被接受，因为起始状态是终态。没有其他字符串能将机器驱动到状态s0，所以唯一其他被接受的字符串是能将机器驱动到状态s1的字符串。显然，字符串0和1能做到这一点。另外，每一个或多个1组成的字符串都能将机器驱动到状态s2，之后一个0会将其带到状态s1。因此所有形式为1^n0（n ≥ 1）的字符串也被接受。因此答案是{λ, 0, 1} ∪ {1^n0 | n ≥ 1}。（这也可以写成{λ, 1} ∪ {1^n0 | n ≥ 0}，因为0 = 1^00。）",
        "answer_symbols": [
            "∪",
            "^",
            "λ",
            "≥"
        ]
    },
    "13.3 45": {
        "question": "求所给的非确定性有限状态自动机所识别的语言。开始 s_0 s_1 s_2",
        "answer": "{λ, 0} ∪ {0^m 1^n | m ≥ 1, n ≥ 1}",
        "answer_symbols": [
            "{",
            "}",
            "∪",
            "^",
            "|",
            "≥",
            "0",
            "1",
            "λ"
        ]
    },
    "13.3 46": {
        "question": "求所给的非确定性有限状态自动机所识别的语言。开始 s_0 s_1 s_2",
        "answer": "我们可以通过不执行任何操作到达状态s0，也可以通过读取1到达状态s1。我们还可以通过首先读取{10}{0, 1}任意次数来结束于这些最终状态。因此答案是({10}{0, 1})*{λ, 1}。",
        "answer_symbols": [
            "*",
            "λ"
        ]
    },
    "13.3 47": {
        "question": "求所给的非确定性有限状态自动机所识别的语言。开始 s_0 s_1 s_2",
        "answer": "{10^n | n ≥ 0} ∪ {10^n 10^m | n, m ≥ 0}",
        "answer_symbols": [
            "{",
            "}",
            "∪",
            "^",
            "|",
            "≥",
            "0",
            "1"
        ]
    },
    "13.3 48": {
        "question": "求所给的非确定性有限状态自动机所识别的语言。开始 s_0 s_1 s_2 s_3 s_4 s_5",
        "answer": "我们只需写下将我们带到状态s0（即{0}*），状态s1（即{0}*{0, 1}{0}*），以及通过s3（即{0}*{0, 1}{0}*{10}{0}*）或通过s2（即{0}*{0, 1}{0}*{1}{0}*{0, 1}{0}*）到达状态s4的路径。我们的最终答案是这些路径的并集：{0}* 并 {0}*{0, 1}{0}* 并 {0}*{0, 1}{0}*{10}{0}* 并 {0}*{0, 1}{0}*{1}{0}*{0, 1}{0}*",
        "answer_symbols": [
            "*",
            "∪"
        ]
    },
    "13.3 49": {
        "question": "求所给的非确定性有限状态自动机所识别的语言。开始 s_0 s_1 s_2 s_3 s_4 s_5",
        "answer": "所有以 0 开头的字符串集合和所有没有 0 的字符串集合的并集。",
        "answer_symbols": [
            "0",
            "∪"
        ]
    },
    "13.3 50": {
        "question": "求一个确定性的有限状态自动机，它能与练习43中的非确定性的有限状态自动机识别相同的语言。",
        "answer": "解答练习50至54的一种方法是按照定理1的证明构建机器。而不是这样做，我们以一种特设的方式构建机器，使用在练习43至47中获得的答案。正如我们在练习43的解答中所见，这台机器识别的语言是{0, 01, 11}。下面显示了一台识别这种语言的确定性机器。请注意，状态s5是一个墓地状态。",
        "answer_symbols": []
    },
    "13.3 51": {
        "question": "求一个确定性的有限状态自动机，它能与练习44中的非确定性的有限状态自动机识别相同的语言。",
        "answer": "s0 s2 s3 s4 s5 开始 0 0 1 1 0 1 0, 1 0, 1 0, 1 s1",
        "answer_symbols": [
            "0",
            "1",
            ","
        ]
    },
    "13.3 52": {
        "question": "求一个确定性的有限状态自动机，它能与练习45中的非确定性的有限状态自动机识别相同的语言。",
        "answer": "这与练习44类似；下面是机器。",
        "answer_symbols": []
    },
    "13.3 53": {
        "question": "求一个确定性的有限状态自动机，它能与练习46中的非确定性的有限状态自动机识别相同的语言。",
        "answer": "添加一个非最终状态 s3，从 s0 在输入 0 时转换到 s3，从 s1 在输入 1 时转换到 s3，以及从 s3 在输入 0 或 1 时转换到 s3。",
        "answer_symbols": [
            "0",
            "1"
        ]
    },
    "13.3 54": {
        "question": "求一个确定性的有限状态自动机，它能与练习47中的非确定性的有限状态自动机识别相同的语言。",
        "answer": "这个比较简单，因为非确定性机器几乎是确定性的。实际上，我们需要做的是消除从s1到墓地状态s2的输入为0的转换，以及从s3到s2的输入为0的转换。",
        "answer_symbols": []
    },
    "13.3 55 a)": {
        "question": "对于下列每个集合，分别求识别它的确定性的有限状态自动机。（a）{0}",
        "answer": "s0 开始 0, 1 s1 s2 0 1 0, 1",
        "answer_symbols": [
            "0",
            "1",
            ","
        ]
    },
    "13.3 55 b)": {
        "question": "对于下列每个集合，分别求识别它的确定性的有限状态自动机。（b）{1, 00}",
        "answer": "s0 s1 s4 s2 s3 开始 1 1 0 0 0, 1 0, 1 0, 1",
        "answer_symbols": [
            "0",
            "1",
            ","
        ]
    },
    "13.3 55 c)": {
        "question": "对于下列每个集合，分别求识别它的确定性的有限状态自动机。（c）{1^n | n = 2, 3, 4, ...}",
        "answer": "s0 s1 s2 s3 1 1 0 0 0 0,1 1 开始",
        "answer_symbols": [
            "0",
            "1",
            ","
        ]
    },
    "13.3 57": {
        "question": "对于由个数相同的0和1组成的串构成的集合，证明没有有限状态自动机能够识别它。",
        "answer": "假设 M 是一个有限状态自动机，它接受具有相同数量 0 和 1 的位串集合。假设 M 有 n 个状态。考虑字符串 0^(n+1)1^(n+1)。根据抽屉原理，当 M 处理这个字符串时，在读取前 n+1 个 0 时，它必须遇到同一个状态多次；因此，让 s 是至少两次出现的状态。那么 k 个 0 的输入将 M 从状态 s 带回自身，其中 k 是某个正整数。但是，M 在读取 0^(n+1+k)1^(n+1) 后会结束在与读取 0^(n+1)1^(n+1) 相同的位置。因此，因为 M 接受 0^(n+1)1^(n+1)，它也接受 0^(n+k+1)1^(n+1)，这是矛盾的。",
        "answer_symbols": [
            "0",
            "1",
            "+",
            "^",
            "="
        ]
    },
    "13.3 58 a)": {
        "question": "证明：对于每个非负整数k，R_k是S上的等价关系。我们说如果sR_kt，则状态s和t是k等价的。",
        "answer": "关系 Rk 是自反的这一点是显然的；Rk 是对称的是从其定义的对称性质中明显得出的。为了证明 Rk 是传递的，假设 sRkt 和 tRku；我们必须证明 sRku。设 x 是任意长度不超过 k 的字符串。如果 f(s, x) 是终态，则 f(t, x) 是终态，因此 f(u, x) 是终态；同样地，如果 f(s, x) 不是终态，则 f(t, x) 不是终态，因此 f(u, x) 不是终态。这就是 tRku 的定义。",
        "answer_symbols": [
            "→",
            "∧",
            "¬"
        ]
    },
    "13.3 58 b)": {
        "question": "证明：R_是S上的等价关系。我们说如果sR_tt，则状态s和t是*等价的。",
        "answer": "注意到 R0 包含 R1 包含 R2 包含 ...（见 c 部分）并且 R* = 从 k=0 到无穷大的所有 Rk 的交集（见 e 部分）。要看到 R* 是自反的，只需注意对于每个状态 s 和每个非负整数 k 我们有 (s, s) 属于 Rk，所以 (s, s) 属于 R*。要看到 R* 是对称的，假设 sR*t。那么对于每一个 k，sRkt，从而 tRks，从而 tR*s。要看到 R* 是传递的，假设 sR*t 和 tR*u。那么对于每一个 k，sRkt 和 tRku。由于 Rk 的传递性我们有 sRku，从而 sR*u。",
        "answer_symbols": [
            "→",
            "∧",
            "¬",
            "∩",
            "∪",
            "∞"
        ]
    },
    "13.3 58 c)": {
        "question": "证明：如果状态s和t是自动机M的两个k等价状态，其中k是正整数，则s和t也是(k-1)等价的。",
        "answer": "条件 sRkt 比条件 sRk-1t 更强，因为所有考虑为 sRk-1t 的字符串也是考虑为 sRkt 的字符串。因此如果 sRkt，则 sRk-1t。",
        "answer_symbols": [
            "→",
            "∧",
            "¬"
        ]
    },
    "13.3 58 d)": {
        "question": "证明：如果k是正整数，则R_k的等价类是R_(k-1)等价类的细分。(集合划分的细分在9.5节练习49的引言中定义。)",
        "answer": "这是第8.5节练习54中证明的一般结果的一个例子。",
        "answer_symbols": []
    },
    "13.3 58 e)": {
        "question": "证明：对于每个非负整数k，如果s和t是k等价的，则它们是*等价的。",
        "answer": "假设 s 和 t 对于每一个 k 都是 k-等价的。设 x 是长度为 k 的字符串。那么 f(s, x) 和 f(t, x) 要么都是终态要么都不是终态，所以根据定义，s 和 t 是 *-等价的。",
        "answer_symbols": [
            "→",
            "∧",
            "¬"
        ]
    },
    "13.3 58 f)": {
        "question": "证明：在给定的R_等价类中，所有状态都是终结状态或都不是终结状态。",
        "answer": "如果 s 和 t 是 *-等价的，那么特别是空字符串将它们都驱动到一个终态或都将它们驱动到一个非终态。但空字符串将一个状态驱动到它自身，结果随之而来。",
        "answer_symbols": [
            "→",
            "∧",
            "¬"
        ]
    },
    "13.3 58 g)": {
        "question": "证明：如果s和t是R_等价的，则对于所有的a∈I，f(s, a)和f(t, a)也是R_等价的。",
        "answer": "我们必须证明 f(f(s, a), x) 和 f(f(t, a), x) 要么都是终态要么都不是终态。由练习15我们知道 f(f(s, a), x) = f(s, ax) 并且 f(f(t, a), x) = f(t, ax)。但由于 s 和 t 是 *-等价的，我们知道 f(s, ax) 和 f(t, ax) 要么都是终态要么都不是终态。",
        "answer_symbols": [
            "→",
            "∧",
            "¬",
            "="
        ]
    },
    "13.3 59": {
        "question": "证明：存在非负整数n，使得自动机M的n等价类集合与(n+1)等价类集合是相同的。然后证明：对于该整数n，自动机M的n等价类集合与*等价类集合相同。",
        "answer": "我们从练习 58d 知道，对于每个正整数 k，Rk 的等价类是 Rk−1 的等价类的细化。等价类是有限集，有限集不能无限细化（最细化的情况是每个等价类只包含一个状态）。因此，这个细化序列必须在某一点之后保持不变。剩下的需要证明的是，一旦我们有 Rn = Rn+1，则对于所有 m > n，都有 Rn = Rm，从而得出 Rn = R*，因此这两个关系的等价类将相同。通过归纳法，只需证明如果 Rn = Rn+1，则 Rn+1 = Rn+2。假设 Rn+1 ≠ Rn+2。这意味着存在状态 s 和 t，它们是 (n+1)-等价的，但不是 (n+2)-等价的。因此存在长度为 n + 2 的字符串 x，使得例如 f(s, x) 是最终状态但 f(t, x) 不是最终状态。将 x 写为 aw，其中 a 属于 I。那么 f(s, a) 和 f(t, a) 就不是 (n + 1)-等价的，因为 w 将第一个驱动到最终状态而将第二个驱动到非最终状态。但是 f(s, a) 和 f(t, a) 是 n-等价的，因为 s 和 t 是 (n + 1)-等价的。这与 Rn = Rn+1 的事实相矛盾。",
        "answer_symbols": [
            "+",
            "=",
            "≠",
            ">",
            "−"
        ]
    },
    "13.3 60 a)": {
        "question": "证明：状态s和t是0等价的，当且仅当s和t要么都是终结状态，要么都不是终结状态。由此得出自动机M的每个终结状态，即R_等价类，只包含自动机M的终结状态。",
        "answer": "两个状态是 0-等价的，如果空字符串将它们都驱动到一个终态或都驱动到一个非终态。但空字符串将一个状态驱动到它自身。因此两个状态是 0-等价的，如果它们都是终态或都是非终态。因此 R0 的每个等价类仅由终态组成或仅由非终态组成。由于 R* 的等价类是 R0 的等价类的细化，R* 的每个等价类也仅由终态组成或仅由非终态组成。",
        "answer_symbols": [
            "→",
            "∧",
            "¬"
        ]
    },
    "13.3 60 b)": {
        "question": "证明：如果k是正整数，状态s和t是k等价的，当且仅当对于所有的输入字符a∈I，f(s, a)和f(t, a)是(k-1)等价的。由此得出转移函数f是定义良好的。",
        "answer": "首先假设 s 和 t 是 k-等价的。根据练习 58c，s 和 t 是 (k-1)-等价的。此外，如果 f(s, a) 和 f(t, a) 不是 (k-1)-等价的，那么某些长度为 k-1 的字符串 x 将 f(s, a) 和 f(t, a) 驱动到不同类型的态（一个终态，一个非终态）。这意味着 ax，这是一个长度为 k 的字符串，会将 s 和 t 驱动到不同类型的态，这与 s 和 t 是 k-等价的事实相矛盾。反之，假设 s 和 t 是 (k-1)-等价的，并且对于每个 a ∈ I，f(s, a) 和 f(t, a) 都是 (k-1)-等价的。我们必须证明 s 和 t 是 k-等价的。长度小于 k 的字符串将两者都驱动到相同类型的态，因为 s 和 t 是 (k-1)-等价的。因此假设 x = aw 是一个长度为 k 的字符串。那么 x 将 s 和 t 都驱动到相同类型的态，因为机器首先移动到 f(s, a) 和 f(t, a)，但我们已知 f(s, a) 和 f(t, a) 是 (k-1)-等价的。因此转换函数 f 的定义不依赖于等价类中的代表选择，因此是明确定义的。",
        "answer_symbols": [
            "→",
            "∧",
            "¬",
            "∈"
        ]
    },
    "13.3 60 c)": {
        "question": "描述一个用来构造有限自动机M的商自动机的过程。",
        "answer": "对于每个 k，只有有限数量的长度为 k 的字符串。因此我们可以通过跟踪所有可能的计算在有限的时间内测试两个状态的 k-等价性。如果我们这样做 k = 0, 1, 2, ...，那么根据练习 59 我们知道最终我们将找不到新的东西，在那个点上我们已经确定了 R* 的等价类。这告诉我们 M 的状态，而本练习前言中的定义给出了 M 的转换函数、起始状态和终态集。更多详细信息，请参阅 John E. Hopcroft、Rajeev Motwani 和 Jeffrey D. Ullman 的《自动机理论、语言和计算导论》（第2版）（Addison Wesley, 2000年）。",
        "answer_symbols": [
            "→",
            "∧",
            "¬",
            "∈",
            "∪",
            "∩",
            "∞"
        ]
    },
    "13.3 61 a)": {
        "question": "证明：如果M是一个有限状态自动机，那么其商自动机能与M识别相同的语言。",
        "answer": "通过机器 M 的构造方式，一个字符串会从起始状态驱动 M 到最终状态当且仅当该字符串从起始状态驱动 M 到最终状态。",
        "answer_symbols": []
    },
    "13.3 56": {
        "question": "对于练习55中的每种语言，分别求识别它的非确定性的有限状态自动机，并且，如果可能，使之所具有的状态比你在练习55中所给的确定性的有限状态自动机更少。",
        "answer": "练习55解答中的机器，在移除墓地状态后，满足本练习的要求。",
        "answer_symbols": []
    },
    "13.3 62 a)": {
        "question": "回答关于下图所示的有限状态自动机 M 的问题。（a）当 k=0, 1, 2, 3 时，求 M 的 k 等价类，同时求 M 的 * 等价类。",
        "answer": "对于 k = 0，唯一的问题是状态是否为终态。因此一个等价类是 {s0, s1, s2, s4}（非终态），另一个等价类是 {s3, s5, s6}（终态）。对于 k = 1，我们需要通过查看长度为 1 的字符串将机器从给定状态驱动到终态或非终态来细化这些类。字符串 0 将我们从 s0 驱动到一个非终态，字符串 1 也将我们从 s0 驱动到一个非终态，所以 让我们称 s0 为类型 NN。那么我们看到 s1 是类型 FN，s2 是类型 FF，s4 也是类型 FF。因此 s2 和 s4 仍然是等价的（它们具有相同的类型，因此在长度为 1 的字符串上驱动到最终状态的行为相同），但 s0 和 s1 不与它们或彼此 1-等价。同样地，状态 s3、s5 和 s6 分别是类型 FN、FN 和 FF，因此 s3 和 s5 是 1-等价的，但 s6 与它们中的任何一个都不 1-等价。这给我们以下 1-等价类：{s0}、{s1}、{s2, s4}、{s3, s5} 和 {s6}。请注意，不仅 s2 和 s4 是 1-等价的，而且它们对于所有 k 都是 k-等价的，因为它们具有完全相同的转换（在输入 0 时转到 s5，在输入 1 时转到 s6）。同样的情况也适用于 s3 和 s5。因此，2-等价类将与 1-等价类相同，并且这些将是所有 k ≥ 1 的 k-等价类以及 *-等价类。",
        "answer_symbols": [
            "{",
            "}",
            "∪",
            "→",
            "=",
            "≥",
            "*"
        ]
    },
    "13.3 62 b)": {
        "question": "回答关于下图所示的有限状态自动机 M 的问题。（b）构造自动机 M 的商自动机 M。",
        "answer": "我们将 s2 和 s4 合并成一个状态（标记为 s2），并将 s3 和 s5 合并成一个状态（标记为 s3）。转换可以从 M 的图中复制。",
        "answer_symbols": [
            "∪",
            "→"
        ]
    },
    "13.4 1 a)": {
        "question": "用文字描述下列每个正则集合中的串。1^* 0",
        "answer": "任意数量的 1 后跟一个 0",
        "answer_symbols": []
    },
    "13.4 1 b)": {
        "question": "用文字描述下列每个正则集合中的串。1^* 00^*",
        "answer": "任意数量的 1 后跟一个或多个 0",
        "answer_symbols": []
    },
    "13.4 1 c)": {
        "question": "用文字描述下列每个正则集合中的串。111 ∪ 001",
        "answer": "111 或 001",
        "answer_symbols": []
    },
    "13.4 1 d)": {
        "question": "用文字描述下列每个正则集合中的串。（1 ∪ 00）^*",
        "answer": "任意数量的 1 或 00 或它们中的一些连续排列",
        "answer_symbols": []
    },
    "13.4 1 e)": {
        "question": "用文字描述下列每个正则集合中的串。（00）^* 1^*",
        "answer": "空串或以 1 结尾且每个 1 前有一个或多个 0 的字符串",
        "answer_symbols": []
    },
    "13.4 1 f)": {
        "question": "用文字描述下列每个正则集合中的串。（0 ∪ 1）（0 ∪ 1）^* 00",
        "answer": "长度至少为 3 且以 00 结尾的字符串",
        "answer_symbols": []
    },
    "13.4 2 a)": {
        "question": "用文字描述下列每个正则集合中的串。001^*",
        "answer": "这个正则表达式生成所有由恰好两个 0 后跟零个或多个 1 组成的字符串。",
        "answer_symbols": [
            "*",
            "0",
            "1"
        ]
    },
    "13.4 2 b)": {
        "question": "用文字描述下列每个正则集合中的串。（01）^*",
        "answer": "这个正则表达式生成所有由零个或多个 01 重复组成的字符串。",
        "answer_symbols": [
            "*",
            "0",
            "1"
        ]
    },
    "13.4 2 c)": {
        "question": "用文字描述下列每个正则集合中的串。01 ∪ 001^*",
        "answer": "这是字符串 01 以及所有由恰好两个 0 后跟零个或多个 1 组成的字符串。",
        "answer_symbols": [
            "*",
            "0",
            "1"
        ]
    },
    "13.4 2 d)": {
        "question": "用文字描述下列每个正则集合中的串。0（11 ∪ 0）^*",
        "answer": "这个集合包含所有以 0 开头并且满足所有最大 1 子串都有偶数个 1 的字符串。",
        "answer_symbols": [
            "*",
            "0",
            "1"
        ]
    },
    "13.4 2 e)": {
        "question": "用文字描述下列每个正则集合中的串。（101^*）^*",
        "answer": "这个集合包含所有每个 0 前面都有一个 1 的字符串，并且如果字符串不为空，则必须以 10 开头。",
        "answer_symbols": [
            "*",
            "0",
            "1"
        ]
    },
    "13.4 2 f)": {
        "question": "用文字描述下列每个正则集合中的串。（（0^* ∪ 1）11",
        "answer": "这给出了所有由零个或多个 0 后跟 11 组成的字符串，加上字符串 111。",
        "answer_symbols": [
            "*",
            "0",
            "1"
        ]
    },
    "13.4 3 a)": {
        "question": "判断 0101 是否属于下列正则集合。01*0*",
        "answer": "否",
        "answer_symbols": []
    },
    "13.4 3 b)": {
        "question": "判断 0101 是否属于下列正则集合。0(11)* (01)*",
        "answer": "否",
        "answer_symbols": []
    },
    "13.4 3 c)": {
        "question": "判断 0101 是否属于下列正则集合。0(10)* 1*",
        "answer": "是",
        "answer_symbols": []
    },
    "13.4 3 d)": {
        "question": "判断 0101 是否属于下列正则集合。0*10(0∪1)*",
        "answer": "是",
        "answer_symbols": []
    },
    "13.4 3 e)": {
        "question": "判断 0101 是否属于下列正则集合。(01)* (11)*",
        "answer": "是",
        "answer_symbols": []
    },
    "13.4 3 f)": {
        "question": "判断 0101 是否属于下列正则集合。0*(10∪11)*",
        "answer": "否",
        "answer_symbols": []
    },
    "13.4 3 g)": {
        "question": "判断 0101 是否属于下列正则集合。0*(10)* 11",
        "answer": "否",
        "answer_symbols": []
    },
    "13.4 3 h)": {
        "question": "判断 0101 是否属于下列正则集合。01(01∪0)* 1*",
        "answer": "是",
        "answer_symbols": []
    },
    "13.4 4 a)": {
        "question": "判断 1011 是否属于下列正则集合。10*1*",
        "answer": "该字符串属于该集合，因为它可以表示为 1011^²。",
        "answer_symbols": [
            "1",
            "0",
            "²"
        ]
    },
    "13.4 4 b)": {
        "question": "判断 1011 是否属于下列正则集合。0*(10∪11)*",
        "answer": "该字符串属于该集合，因为它可以表示为 (10)(11)。",
        "answer_symbols": [
            "(",
            ")",
            "1",
            "0"
        ]
    },
    "13.4 4 c)": {
        "question": "判断 1011 是否属于下列正则集合。1(01)* 1*",
        "answer": "该字符串属于该集合，因为它可以表示为 1(01)1。",
        "answer_symbols": [
            "(",
            ")",
            "1",
            "0"
        ]
    },
    "13.4 4 d)": {
        "question": "判断 1011 是否属于下列正则集合。1*01(0∪1)*",
        "answer": "该字符串属于该集合：取第一个 * 为 1，并取并集中的 1。",
        "answer_symbols": [
            "*",
            "1"
        ]
    },
    "13.4 4 e)": {
        "question": "判断 1011 是否属于下列正则集合。(10)* (11)*",
        "answer": "该字符串属于该集合，因为它可以表示为 (10)(11)。",
        "answer_symbols": [
            "(",
            ")",
            "1",
            "0"
        ]
    },
    "13.4 4 f)": {
        "question": "判断 1011 是否属于下列正则集合。1(00)* (11)*",
        "answer": "该集合中的字符串必须具有奇数长度，所以给定的字符串不属于该集合。",
        "answer_symbols": []
    },
    "13.4 4 g)": {
        "question": "判断 1011 是否属于下列正则集合。(10)* 1011",
        "answer": "该字符串属于该集合：取 * 为 0。",
        "answer_symbols": [
            "*",
            "0"
        ]
    },
    "13.4 4 h)": {
        "question": "判断 1011 是否属于下列正则集合。1011",
        "answer": "该字符串属于该集合：从第一组中选择 1，从第二组中选择 01，并取 * = 1。",
        "answer_symbols": [
            "*",
            "1",
            "0"
        ]
    },
    "13.4 5 a)": {
        "question": "用正则表达式表达下列集合。包含串 0、11、010 的集合。",
        "answer": "0 ∪ 11 ∪ 010",
        "answer_symbols": [
            "∪"
        ]
    },
    "13.4 5 b)": {
        "question": "用正则表达式表达下列集合。3 个 0 后面跟两个或两个以上 0 形成的串的集合。",
        "answer": "000000*",
        "answer_symbols": [
            "*"
        ]
    },
    "13.4 5 c)": {
        "question": "用正则表达式表达下列集合。串的长度为奇数的集合。",
        "answer": "(0 ∪ 1)((0 ∪ 1)(0 ∪ 1))*",
        "answer_symbols": [
            "(",
            ")",
            "∪",
            "*"
        ]
    },
    "13.4 5 d)": {
        "question": "用正则表达式表达下列集合。只包含一个 1 的串的集合。",
        "answer": "0*10*",
        "answer_symbols": [
            "*",
            "1"
        ]
    },
    "13.4 5 e)": {
        "question": "用正则表达式表达下列集合。以 1 结束，并且并不包含 000 形成的串的集合。",
        "answer": "(1 ∪ 01 ∪ 001)*",
        "answer_symbols": [
            "(",
            ")",
            "∪",
            "*"
        ]
    },
    "13.4 6 a)": {
        "question": "用正则表达式表达下列集合。集合中所有串的长度是 0、1、2。",
        "answer": "有多种方法可以实现这一点，例如 (λ ∪ 0 ∪ 1)(λ ∪ 0 ∪ 1)(λ ∪ 0 ∪ 1)。",
        "answer_symbols": [
            "(",
            ")",
            "∪",
            "λ",
            "0",
            "1"
        ]
    },
    "13.4 6 b)": {
        "question": "用正则表达式表达下列集合。集合中的串是由两个 0，后跟 0 个或多个 1，并且以 0 作为结束的串构成。",
        "answer": "001*0",
        "answer_symbols": [
            "0",
            "1",
            "*"
        ]
    },
    "13.4 6 c)": {
        "question": "用正则表达式表达下列集合。集合中的串每遇到一个 1，后跟两个 0。",
        "answer": "我们假设并不是每个 1 都后跟恰好两个 0，因此可以写成 0*(100 ∪ 0)*。",
        "answer_symbols": [
            "*",
            "0",
            "1",
            "∪"
        ]
    },
    "13.4 6 d)": {
        "question": "用正则表达式表达下列集合。集合中的串以 00 作为结束，并且不包含 11。",
        "answer": "一种说法是每个 1 必须后跟一个 0。因此可以写成 0*(10 ∪ 0)*00。",
        "answer_symbols": [
            "*",
            "0",
            "1",
            "∪"
        ]
    },
    "13.4 6 e)": {
        "question": "用正则表达式表达下列集合。集合中的串包含偶数个 1。",
        "answer": "要得到偶数个 1，可以写成类似 (0*10*10*)*。",
        "answer_symbols": [
            "*",
            ")",
            "0",
            "(",
            "1"
        ]
    },
    "13.4 7 a)": {
        "question": "用正则表达式表达下列每个集合。一个或更多的 0 后面跟一个 1 形成的串的集合。",
        "answer": "00*1",
        "answer_symbols": [
            "*",
            "1"
        ]
    },
    "13.4 7 b)": {
        "question": "用正则表达式表达下列每个集合。两个或两个以上符号后面跟 3 个或 3 个以上 0 形成的串的集合。",
        "answer": "(0 ∪ 1)(0 ∪ 1)(0 ∪ 1)*0000*",
        "answer_symbols": [
            "(",
            ")",
            "∪",
            "*",
            "1"
        ]
    },
    "13.4 7 c)": {
        "question": "用正则表达式表达下列每个集合。一个 0 前没有 1 或一个 1 前没有 0 的串的集合。",
        "answer": "0*1* ∪ 1*0*",
        "answer_symbols": [
            "*",
            "∪",
            "1"
        ]
    },
    "13.4 7 d)": {
        "question": "用正则表达式表达下列每个集合。集合包含这样的串：先是个数与 2mod 3 相等的一串 1，后面是偶数个 0。",
        "answer": "11(111)*(00)*",
        "answer_symbols": [
            "(",
            ")",
            "*",
            "1"
        ]
    },
    "13.4 8 a)": {
        "question": "构造确定性的有限状态自动机来识别下列包含在 I* 中的集合（其中 I 是一个字母表）。∅",
        "answer": "因为我们不希望接受任何字符串，所以我们将没有最终状态。我们只需要一个状态，即起始状态，并且在所有输入上都有从该状态到自身的转换。",
        "answer_symbols": []
    },
    "13.4 8 b)": {
        "question": "构造确定性的有限状态自动机来识别下列包含在 I* 中的集合（其中 I 是一个字母表）。{a}",
        "answer": "这与部分(a)相似，不同之处在于我们希望接受空字符串。我们的机器将有两个状态。起始状态是最终状态，另一个状态不是最终状态。在所有输入上，每个状态都有向非最终状态的转换。",
        "answer_symbols": []
    },
    "13.4 8 c)": {
        "question": "构造确定性的有限状态自动机来识别下列包含在 I* 中的集合（其中 I 是一个字母表）。{a}，其中 a∈I",
        "answer": "这次我们需要三个状态：s0（起始状态）、s1 和 s2。只有 s1 是最终状态。在输入 a 上，有一个从 s0 到 s1 的转换：这将确保 a 被接受。所有其他转换都到 s2，这是一个墓地状态：从 s0 在所有输入除 a 外，以及从 s1 和 s2 在所有输入上。(从练习中不清楚 a 是否是指 I 的一个固定元素，如我们假设的那样，还是我们是否需要接受所有长度为 1 的字符串。如果是后者，则对于每个 a ∈ I，从状态 s0 到状态 s1 都有一个转换。)",
        "answer_symbols": [
            "∈"
        ]
    },
    "13.4 9 a)": {
        "question": "构造非确定性的有限状态自动机来识别练习 8 中的每个集合。",
        "answer": "拥有起始状态 s0，非最终状态，没有任何转换。",
        "answer_symbols": []
    },
    "13.4 9 b)": {
        "question": "构造非确定性的有限状态自动机来识别练习 8 中的每个集合。{a}",
        "answer": "拥有起始状态 s0，最终状态，没有任何转换。",
        "answer_symbols": []
    },
    "13.4 9 c)": {
        "question": "构造非确定性的有限状态自动机来识别练习 8 中的每个集合。{a}，其中 a∈I",
        "answer": "拥有非最终起始状态 s0 和最终状态 s1 以及在输入 a 时从 s0 到 s1 的转换。",
        "answer_symbols": []
    },
    "13.4 11": {
        "question": "证明：若 A 是一个正则集合，则 A 中串的逆串构成的集合 A^R 也是正则的。",
        "answer": "使用归纳法证明。如果 A 的正则表达式是 ∅, λ, 或 x，则结果是显而易见的。否则，假设 A 的正则表达式是 BC。那么 A = BC，其中 B 是由 B 生成的集合，C 是由 C 生成的集合。根据归纳假设，存在正则表达式 B' 和 C' 分别生成 BR 和 CR。因为 AR = (BC)R = CRBR，所以 C'B' 是 AR 的正则表达式。如果 A 的正则表达式是 B ∪ C，则 AR 的正则表达式是 B' ∪ C'，因为 (B ∪ C)R = (BR) ∪ (CR)。最后，如果 A 的正则表达式是 B*，则容易看出 (B')* 是 AR 的正则表达式。",
        "answer_symbols": [
            "∅",
            "λ",
            "=",
            "∪",
            "(",
            ")",
            "*",
            "R"
        ]
    },
    "13.4 12 a)": {
        "question": "用克莱因定理的证明中描述的构造方法，求识别下列集合的非确定性的有限状态自动机。01*",
        "answer": "0 的机器如图 3（第三个机器）所示。1* 的机器如图 3（第二个机器）所示。我们需要将它们连接起来，所以得到以下图片：",
        "answer_symbols": [
            "*",
            "(",
            ")",
            "*"
        ]
    },
    "13.4 12 b)": {
        "question": "用克莱因定理的证明中描述的构造方法，求识别下列集合的非确定性的有限状态自动机。(0∪1)1*",
        "answer": "0 的机器如图 3（第三个机器）所示。1 的机器类似。我们需要取它们的并集。然后我们需要将这个结果与 1* 的机器（图 3 的第二个机器）连接起来。所以我们得到以下图片：",
        "answer_symbols": [
            "*",
            "(",
            ")",
            "*"
        ]
    },
    "13.4 12 c)": {
        "question": "用克莱因定理的证明中描述的构造方法，求识别下列集合的非确定性的有限状态自动机。00(1* ∪ 10)",
        "answer": "10* 的机器类似于我们对部分(a)的回答，只是 0 和 1 的角色互换。我们需要将这个结果与 1* 的机器（图 3 的第二个机器）取并集。然后我们需要在前面连接两个 0 的机器（图 3 的第三个机器），所以得到以下图片：",
        "answer_symbols": [
            "*",
            "(",
            ")",
            "*"
        ]
    },
    "13.4 13 a)": {
        "question": "用克莱因定理的证明中描述的构造方法，求识别下列集合的非确定性的有限状态自动机。0*1*",
        "answer": "s0 s1 s2 s3 s4 s5 开始 0 1 0 0 0 1 0 0 1 1",
        "answer_symbols": []
    },
    "13.4 15": {
        "question": "构造正则文法 G=(V, T, S, P)，使之生成的语言是所给的有限状态机识别的语言。开始 s0 → 0 → s1 → 0, 1 → s2 → 0, 1 s1 → 1 → s0",
        "answer": "S → 0A, S → 1B, S → 0, A → 0B, A → 1B, B → 0B, B → 1B",
        "answer_symbols": [
            "→"
        ]
    },
    "13.4 16": {
        "question": "构造正则文法 G=(V, T, S, P)，使之生成的语言是所给的有限状态机识别的语言。",
        "answer": "状态之间的转换使我们添加规则 S→ 0A, S→ 1B, A→ 0B, A→ 1A, B→ 0B 和 B→ 1A。转换到最终状态使我们添加规则 S→ 0, A→ 1 和 B→ 1。最后，由于 s0 是最终状态，我们添加规则 S→ λ。",
        "answer_symbols": [
            "→",
            "0",
            "1",
            "A",
            "B",
            "λ"
        ]
    },
    "13.4 17": {
        "question": "构造正则文法 G=(V, T, S, P)，使之生成的语言是所给的有限状态机识别的语言。",
        "answer": "S → 0C, S → 1A, S → 1, A → 1A, A → 0C, A → 1, B → 0B, B → 1B, B → 0, B → 1, C → 0C, C → 1B, C → 1",
        "answer_symbols": [
            "→"
        ]
    },
    "13.4 18": {
        "question": "在定理 2 的证明中，从正则文法构造了一个有限状态自动机。证明：此自动机识别这个文法生成的集合。",
        "answer": "这是显而易见的，因为语法中每个终端字符串的唯一推导过程正好反映在机器的操作中。正是那些生成的非空字符串驱动机器进入其最终状态，而空字符串仅当它在语言中时才被接受。",
        "answer_symbols": []
    },
    "13.4 19": {
        "question": "在定理 2 的证明中，从一个有限状态自动机构造了一个正则文法。证明：此文法生成这个自动机识别的集合。",
        "answer": "这是因为在自动机中导致最终状态的输入与语法中的推导一一对应",
        "answer_symbols": []
    },
    "13.4 20": {
        "question": "证明：每个非确定性的有限状态自动机等价于另一个这样的非确定性的有限状态自动机，它的初始状态永不会被再次访问。",
        "answer": "我们从给定的非确定有限状态自动机构造一个新的非确定有限状态自动机。添加一个新的状态 s'0（但 s0 仍然是起始状态）。新状态是最终状态当且仅当 s0 是最终状态。所有进入 s0 的转换都被重定向以结束于 s'0。然后将所有从 s0 出发的转换复制为从 s'0 出发的转换。很明显，s0 永远不会再被访问，因为所有进入它的转换都被重定向了。此外，s'0 正在扮演 s0 以前的角色（在读取一个或多个输入符号之后），因此恰好接受相同的字符串集。",
        "answer_symbols": [
            "'",
            "→"
        ]
    },
    "13.4 21": {
        "question": "设 M = (S, I, f, s0, F) 是一个确定性的有限状态自动机。证明：M 识别的语言 L(M) 是无限的当且仅当存在一个能被 M 识别的词 x 满足 l(x) ≥ |S|。",
        "answer": "“仅当”部分是清楚的，因为 I 是有限的。对于“如果”部分，设状态为 s_i0, s_i1, s_i2, ..., s_in，其中 n = l(x)。因为 n ≥ |S|，根据抽屉原理，某些状态会被重复。设 y 是导致循环的部分，所以 x = uyv 并且 y 将 s_j 映射到 s_j，对于某个 j。那么 uykv ∈ L(M) 对所有 k 都成立。因此，L(M) 是无限的",
        "answer_symbols": [
            "≥",
            "|",
            "∈",
            "∀"
        ]
    },
    "13.4 22": {
        "question": "用来证明某个集合不是正则的一个重要技术是泵引理。泵引理表述为：如果 M = (S, I, f, s0, F) 是一个确定性的有限状态自动机，x 是 M 识别的语言 L(M) 中的一个串，l(x) ≥ |S|，则存在 I 中的串 u, v 和 w，使得 x = uvw，l(uv) ≤ |S|，l(v) ≥ 1，且 uv^i w ∈ L(M)（i = 0, 1, 2, ...）。证明泵引理。[提示：使用例 5 中的思想。]",
        "answer": "设在输入 x 上遇到的状态依次为 s0, si1, si2,..., sin，其中 n = l(x)。由于给定 n ≥ |S|，根据抽屉原理，这个 n + 1 个状态的列表中必定包含重复",
        "answer_symbols": [
            "≥"
        ]
    },
    "13.4 23": {
        "question": "使用练习 22 中的泵引理证明：集合 {0^n 1^n | n = 0, 1, 2, ...} 不是正则的。",
        "answer": "假设 L = {0^(2n)1^n, n = 0, 1, 2...} 是正则的。设 S 是识别这个集合的有限状态机的状态集。令 z = 0^(2n)1^n 其中 3n ≥ |S|。根据泵引理，z = 0^(2n)1^n = uvw，l(v) ≥ 1，并且 uviw ∈ {0^(2n)1^n | n ≥ 0}。显然 v 不能同时包含 0 和 1，因为 v^2 将包含 10。所以 v 是全 0 或全 1，因此 uv^2w 包含过多的 0 或过多的 1，所以它不在 L 中。这一矛盾表明 L 不是正则的",
        "answer_symbols": [
            "=",
            "≥",
            "|",
            "∈",
            "∀",
            "^"
        ]
    },
    "13.4 24": {
        "question": "使用练习 22 中的泵引理证明：集合 {1^n | n = 0, 1, 2, ...} 不是正则的。",
        "answer": "Assume that this set is regular, accepted by a deterministic finite-state automaton with state set S. Let x = 1^n2 for some n ≥ √|S|. By the pumping lemma, we can write x = uvw with v nonempty, so that uviw is in our set for all i. Since there is only one symbol involved, we can write u = 1^r, v = 1^s, and w = 1^t, so that the statement that uviw is in our set is the statement that (r + t) + si is a perfect square. But this cannot be, since successive perfect squares differ by increasing large amounts as they grow larger, whereas the terms in the sequence (r + t) + si have a constant difference for i = 0, 1,.... This contradiction tells us that the set is not regular.",
        "answer_symbols": [
            "√",
            "≥",
            "^",
            "+",
            "(",
            ")",
            "="
        ]
    },
    "13.4 25": {
        "question": "使用练习 22 中的泵引理证明：{0, 1} 上所有回文构成的集合不是正则的。[提示：考察形如 0^N 10^N 的串。]",
        "answer": "假设 {0, 1} 上的所有回文串是正则的。设 S 是识别这个集合的有限状态机的状态集。令 z = 0^n10^n，其中 n > |S|。应用泵引理得到 uviw ∈ L 对所有非负整数 i 成立，其中 l(v) ≥ 1，且 l(uv) ≤ |S|，并且 z = 0^n10^n = uvw。那么 v 必须是一串 0（因为 n > |S|），所以 uv^2w 不是回文串。因此，回文串的集合不是正则的",
        "answer_symbols": [
            "∈",
            "≥",
            "≤",
            "|",
            "∀",
            "^"
        ]
    },
    "13.4 26": {
        "question": "证明：被有限状态自动机识别的集合是正则的。（这是克莱因定理的充分性部分。）",
        "answer": "This (far from easy) proof is similar in spirit to Warshall’s algorithm. The interested reader should consult a reference in computation theory, such as 'Elements of the Theory of Computation' by H. R. Lewis and C. H. Papadimitriou (Prentice-Hall, 1981).",
        "answer_symbols": []
    },
    "13.4 27": {
        "question": "令 L 表示所有以 01 作为结束的位串构成的集合。证明 11 和 10 关于 L 是可区分的，1 和 11 关于 L 是不可区分的。",
        "answer": "设 z = 1；那么 111 不属于 L 但 101 属于 L，所以 11 和 10 是可区分的。对于第二个问题，1z 属于 L 的唯一方式是 z 以 01 结尾，这也是 11z 属于 L 的唯一方式，所以 1 和 11 是不可区分的",
        "answer_symbols": [
            "∈",
            "∉"
        ]
    },
    "13.4 28": {
        "question": "假设 M = (S, I, f, s0, F) 是确定性的有限状态自动机。证明：如果 x 和 y 是集合 I* 中的两个关于 L(M) 可区分的串，那么 f(s0, x) ≠ f(s0, y)。",
        "answer": "It’s just a matter of untangling the definition. If x and y are distinguishable with respect to L(M), then without loss of generality there must be a string z such that xz ∈ L(M) and yz ∉ L(M). This means that the string xz drives M from its initial state to a final state, and the string yz drives M from its initial state to a nonfinal state. For a proof by contradiction, suppose that f(s_0, x) = f(s_0, y); in other words, x and y both drive M to the same state. But then xz and yz both drive M to the same state, after l(z) more steps of computation (where l(z) is the length of z), and this state can’t be both final and nonfinal. This contradiction shows that f(s_0, x) ≠ f(s_0, y).",
        "answer_symbols": [
            "∈",
            "∉",
            "=",
            "≠",
            "(",
            ")",
            ","
        ]
    },
    "13.4 29": {
        "question": "假设 L 是 I* 的子集，并且对于某个正整数 n，在集合 I* 中有 n 个串使它们关于 L 互相可区分。证明：每个能识别 L 的确定性的有限状态自动机至少具有 n 个状态。",
        "answer": "这直接从练习 28 得出，因为 n 个可区分的字符串必须将机器从初始状态驱动到 n 个不同的状态",
        "answer_symbols": []
    },
    "13.4 30": {
        "question": "令 L_n 表示位串集合，该集合中的串至少具有 n 位，并且每个串从最后数的第 n 位是 0。使用练习 29 的思想来证明能识别 L_n 的确定性的有限状态自动机至少具有 2^n 个状态。",
        "answer": "We claim that all 2^n bit strings of length n are distinguishable with respect to L. If x and y are two bit strings of length n that differ in bit i, where 1 ≤ i ≤ n, then they are distinguished by any string z of length i − 1, because one of xz and yz has a 0 in the nth position from the end and the other has a 1. Therefore by Exercise 29, any deterministic finite-state automaton recognizing L_n must have at least 2^n states.",
        "answer_symbols": [
            "^",
            "≤",
            "-",
            "(",
            ")",
            ","
        ]
    },
    "13.4 31": {
        "question": "使用练习 29 的思想来证明由回文串构成的集合是非正则的。",
        "answer": "任何两个长度相同的不同字符串相对于所有回文串的语言 P 都是可区分的，因为如果 x 和 y 是长度为 n 的不同字符串，那么 xx^R 属于 P 但 yx^R 不属于 P。因为有 2^n 个长度为 n 的不同字符串，练习 29 告诉我们，任何用于识别回文串的确定性有限状态自动机必须至少有 2^n 个状态。因为 n 是任意的，这是不可能的",
        "answer_symbols": [
            "∈",
            "∉",
            "^"
        ]
    },
    "13.5 1 a)": {
        "question": "设T是下列五元组定义的图灵机：(s0, 0, s1, 1, R), (s0, 1, s1, 0, R), (s0, B, s1, 0, R), (s1, 0, s2, 1, L), (s1, 1, s1, 0, R)和(s1, B, s2, 0, L)。对于下列的初始带，判断T停机时的最终带。假设T从初始位置开始执行。… B B 0 0 1 1 B B …",
        "answer": "当机器停止时，磁带上的非空白部分包含字符串 1111。",
        "answer_symbols": [
            "1111"
        ]
    },
    "13.5 1 b)": {
        "question": "设T是下列五元组定义的图灵机：(s0, 0, s1, 1, R), (s0, 1, s1, 0, R), (s0, B, s1, 0, R), (s1, 0, s2, 1, L), (s1, 1, s1, 0, R)和(s1, B, s2, 0, L)。对于下列的初始带，判断T停机时的最终带。假设T从初始位置开始执行。… B B 1 0 1 B B B …",
        "answer": "当机器停止时，磁带上的非空白部分包含字符串 011。",
        "answer_symbols": [
            "011"
        ]
    },
    "13.5 1 c)": {
        "question": "设T是下列五元组定义的图灵机：(s0, 0, s1, 1, R), (s0, 1, s1, 0, R), (s0, B, s1, 0, R), (s1, 0, s2, 1, L), (s1, 1, s1, 0, R)和(s1, B, s2, 0, L)。对于下列的初始带，判断T停机时的最终带。假设T从初始位置开始执行。… B B 1 1 B 0 1 B …",
        "answer": "当机器停止时，磁带上的非空白部分包含字符串 00001。",
        "answer_symbols": [
            "00001"
        ]
    },
    "13.5 1 d)": {
        "question": "设T是下列五元组定义的图灵机：(s0, 0, s1, 1, R), (s0, 1, s1, 0, R), (s0, B, s1, 0, R), (s1, 0, s2, 1, L), (s1, 1, s1, 0, R)和(s1, B, s2, 0, L)。对于下列的初始带，判断T停机时的最终带。假设T从初始位置开始执行。… B B B B B B B B …",
        "answer": "当机器停止时，磁带上的非空白部分包含字符串 00。",
        "answer_symbols": [
            "00"
        ]
    },
    "13.5 2 a)": {
        "question": "设T是下列五元组定义的图灵机：(s0, 0, s1, 1, R), (s0, 1, s1, 0, L), (s0, B, s1, 1, R), (s1, 0, s2, 1, R), (s1, 1, s1, 1, R), (s1, B, s2, 0, R)和(s2, B, s3, 0, R)。对于下列的初始带，判断T停机时的最终带。假设T从初始位置开始执行。… B B 0 1 0 1 B B …",
        "answer": "Initially the configuration is [s0]0101. Using the first five-tuple, the machine next enters configuration 0[s1]101. Thereafter it proceeds as follows: 0[s1]101 → 01[s1]01 → 011[s2]1. Since there is no five-tuple for this combination (in state s2 reading a 1), the machine halts. Thus (the nonblank portion of) the final tape reads 0111.",
        "answer_symbols": []
    },
    "13.5 2 b)": {
        "question": "设T是下列五元组定义的图灵机：(s0, 0, s1, 1, R), (s0, 1, s1, 0, L), (s0, B, s1, 1, R), (s1, 0, s2, 1, R), (s1, 1, s1, 1, R), (s1, B, s2, 0, R)和(s2, B, s3, 0, R)。对于下列的初始带，判断T停机时的最终带。假设T从初始位置开始执行。… B B 1 1 1 B B B …",
        "answer": "[s0]111 → [s1]B011 → 0[s2]011 → halt; final tape 0011",
        "answer_symbols": []
    },
    "13.5 2 c)": {
        "question": "设T是下列五元组定义的图灵机：(s0, 0, s1, 1, R), (s0, 1, s1, 0, L), (s0, B, s1, 1, R), (s1, 0, s2, 1, R), (s1, 1, s1, 1, R), (s1, B, s2, 0, R)和(s2, B, s3, 0, R)。对于下列的初始带，判断T停机时的最终带。假设T从初始位置开始执行。… B B 0 0 B 0 0 B …",
        "answer": "[s0]00B00 → 0[s1]0B00 → 01[s2]B00 → 010[s3]00 → halt; final tape 01000",
        "answer_symbols": []
    },
    "13.5 2 d)": {
        "question": "设T是下列五元组定义的图灵机：(s0, 0, s1, 1, R), (s0, 1, s1, 0, L), (s0, B, s1, 1, R), (s1, 0, s2, 1, R), (s1, 1, s1, 1, R), (s1, B, s2, 0, R)和(s2, B, s3, 0, R)。对于下列的初始带，判断T停机时的最终带。假设T从初始位置开始执行。… B B B B B B B B …",
        "answer": "[s0]B → 1[s1]B → 10[s2]B → 100[s3]B → halt; final tape 100",
        "answer_symbols": []
    },
    "13.5 3 a)": {
        "question": "对于由五元组(s0, 0, s0, 0, R), (s0, 1, s1, 0, R), (s0, B, s2, B, R), (s1, 0, s1, 0, R), (s1, 1, s0, 1, R)和(s1, B, s2, B, R)描述的图灵机，当给定11作为输入时，它能做什么？",
        "answer": "机器在输入后的空白处停止（接受），并将磁带从 11 更改为 01。",
        "answer_symbols": [
            "11",
            "01"
        ]
    },
    "13.5 3 b)": {
        "question": "对于由五元组(s0, 0, s0, 0, R), (s0, 1, s1, 0, R), (s0, B, s2, B, R), (s1, 0, s1, 0, R), (s1, 1, s0, 1, R)和(s1, B, s2, B, R)描述的图灵机，当给定任意一个位串作为输入时，它能做什么？",
        "answer": "机器将每个出现的 1（如果有）从第一个开始每隔一个更改为 0，并且其他情况下不改变字符串；当它到达字符串的末尾时停止（接受）。",
        "answer_symbols": [
            "1",
            "0"
        ]
    },
    "13.5 4 a)": {
        "question": "对于五元组(s0, 0, s0, 1, R), (s0, 1, s0, 1, R), (s0, B, s1, B, L), (s1, 1, s2, 1, R)描述的图灵机，当给定101作为输入时，它能做什么？",
        "answer": "机器从状态 s0 开始，看到第一个 1。因此使用第一个五元组，它将 1 替换为 1（即保持不变），向右移动，并保持在状态 s0。现在它看到了 0，所以，使用第二个五元组，它将 0 替换为 1，向右移动，并保持在状态 s0。当它看到第二个 1 时，它再次保持不变，向右移动，并保持在状态 s0。现在它读取空白，所以，使用第三个五元组，它保持空白不变，向左移动，并进入状态 s1。此时它看到 1 并保持不变并进入状态 s2（使用第四个五元组）。由于没有五元组告诉机器在状态 s2 应该做什么，它停止运行。注意磁带上是 111，输入被接受，因为 s2 是最终状态。\n",
        "answer_symbols": []
    },
    "13.5 4 b)": {
        "question": "对于五元组(s0, 0, s0, 1, R), (s0, 1, s0, 1, R), (s0, B, s1, B, L), (s1, 1, s2, 1, R)描述的图灵机，当给定一个任意的位串作为输入时，它能做什么？",
        "answer": "这基本上与部分 (a) 相同。磁带上的每个 0 都被更改为 1（并且 1 保持不变），输入被接受。（唯一的例外是如果初始输入为空白，则机器在一次转换后将在状态 s1 查看空白并且没有可应用的五元组。因此它会停止运行而不接受。）",
        "answer_symbols": []
    },
    "13.5 5 a)": {
        "question": "对于五元组(s0, 1, s1, 0, R), (s1, 1, s1, 1, R), (s1, 0, s2, 0, R), (s2, 0, s3, 1, L), (s2, 1, s2, 1, R), (s3, 1, s3, 1, L), (s3, 0, s4, 0, L), (s4, 1, s4, 1, R), (s4, 0, s0, 1, R)描述的图灵机，当给定11作为输入时，它能做什么？",
        "answer": "停止时磁带上为 01，不接受。",
        "answer_symbols": [
            "01"
        ]
    },
    "13.5 5 b)": {
        "question": "对于五元组(s0, 1, s1, 0, R), (s1, 1, s1, 1, R), (s1, 0, s2, 0, R), (s2, 0, s3, 1, L), (s2, 1, s2, 1, R), (s3, 1, s3, 1, L), (s3, 0, s4, 0, L), (s4, 1, s4, 1, R), (s4, 0, s0, 1, R)描述的图灵机，当给定全部由1构成的位串形成的集合作为输入时，它能做什么？",
        "answer": "第一个 1（如果有）被更改为 0，其余保持不变。输入不被接受。",
        "answer_symbols": [
            "1",
            "0"
        ]
    },
    "13.5 6": {
        "question": "构造一个带符号为0、1和B的图灵机，对于给定的输入位串，在带的最末端增加一个1，而其余符号保持不变。",
        "answer": "我们需要从左到右扫描，直到遇到空白，期间保持不变。五元组 (s0, 0, s0, 0, R) 和 (s0, 1, s0, 1, R) 完成此操作。另一个五元组将负责添加新位：(s0, B, s1, 1, R)。",
        "answer_symbols": []
    },
    "13.5 7": {
        "question": "构造一个带符号为0、1和B的图灵机，它将带上第一个0替换为1，而其余符号保持不变。",
        "answer": "(s0, 0, s1, 1, R), (s0, 1, s0, 1, R)",
        "answer_symbols": [
            "s0",
            "0",
            "s1",
            "1",
            "R"
        ]
    },
    "13.5 8": {
        "question": "构造一个带符号为0、1和B的图灵机，对于给定的输入位串，它将带上所有0替换为1，而所有的1保持不变。",
        "answer": "我们可以用一个状态完成这个任务。五元组是 (s0, 0, s0, 1, R) 和 (s0, 1, s0, 1, R)。当输入结束时，机器就会停止运行。",
        "answer_symbols": []
    },
    "13.5 9": {
        "question": "构造一个带符号为0、1和B的图灵机，对于给定的输入位串，它将带上除最左边的1以外的所有1替换为0，而其余符号保持不变。",
        "answer": "(s0, 0, s0, 0, R), (s0, 1, s1, 1, R), (s1, s1, 0, R), (s1, 1, s1, 0, R)",
        "answer_symbols": [
            "s0",
            "0",
            "s1",
            "1",
            "R"
        ]
    },
    "13.5 10": {
        "question": "构造一个带符号为0、1和B的图灵机，对于给定的输入位串，它将带上首先出现的两个连续的1替换为0，而其余符号保持不变。",
        "answer": "我们需要让机器寻找一对连续的 1。以下五元组可以完成这个任务：(s0, 0, s0, 0, R)，(s0, 1, s1, 1, R)，(s1, 0, s0, 0, R)，和 (s1, 1, s2, 0, L)。一旦机器进入状态 s2，它刚刚将第一对连续 1 中的第二个 1 替换为 0 并回退到这对中的第一个 1。因此五元组 (s2, 1, s3, 0, R) 将完成任务。\n",
        "answer_symbols": []
    },
    "13.5 11": {
        "question": "构造一个图灵机，它识别的集合是所有以0结尾的位串组成的集合。",
        "answer": "(s0, 0, s1, 0, R), (s0, 1, s0, 0, R), (s1, 0, s1, 0, R), (s1, 1, s0, 0, R), (s1, B, s2, B, R)",
        "answer_symbols": [
            "s0",
            "0",
            "s1",
            "1",
            "B",
            "R"
        ]
    },
    "13.5 12": {
        "question": "构造一个图灵机，它识别的集合是所有至少包含两个1的位串组成的集合。",
        "answer": "我们可以在状态 s0 中停留，直到遇到第一个 1；然后在状态 s1 中停留，直到遇到第二个 1。此时我们可以进入状态 s2，这是一个接受状态。如果我们仍在状态 s0 或 s1 时遇到最终的空白，则不会接受。五元组很简单：(s0, 0, s0, 0, R)，(s0, 1, s1, 1, R)，(s1, 0, s1, 0, R)，和 (s1, 1, s2, 1, R)。\n",
        "answer_symbols": []
    },
    "13.5 13": {
        "question": "构造一个图灵机，它识别的集合是所有包含偶数个1的位串组成的集合。",
        "answer": "(s0, 0, s0, 0, R), (s0, 1, s1, 1, R), (s1, 0, s1, 0, R), (s1, 1, s0, 1, R), (s0, B, s2, B, R)",
        "answer_symbols": [
            "s0",
            "0",
            "s1",
            "1",
            "B",
            "R"
        ]
    },
    "13.5 14 a)": {
        "question": "对于例3中的图灵机，若从下列每个串开始运行，写出其每一步的带内容。0011",
        "answer": "[s0]0011 → M[s1]011 → M0[s1]11 → M01[s1]1 → M011[s1]B → M01[s2]1 → M0[s3]1M → M[s3]01M → [s4]M01M → M[s0]01M → MM[s1]1M → MM1[s1]M → MM[s2]1M → M[s3]MMM → MM[s5]MM → MMM[s6]M → 停止并接受\n",
        "answer_symbols": []
    },
    "13.5 14 b)": {
        "question": "对于例3中的图灵机，若从下列每个串开始运行，写出其每一步的带内容。00011",
        "answer": "[s0]00011 → M[s1]0011 → M0[s1]011 → M00[s1]11 → M001[s1]1 → M0011[s1]B → M001[s2]1 → M00[s3]1M → M0[s3]01M → M[s4]001M → [s4]M001M → M[s0]001M → MM[s1]01M → MM0[s1]1M → MM01[s1]M → MM0[s2]1M → MM[s3]0MM → M[s4]M0MM → MM[s0]0MM → MMM[s1]MM → MM[s2]MMM → 停止并拒绝\n",
        "answer_symbols": []
    },
    "13.5 14 c)": {
        "question": "对于例3中的图灵机，若从下列每个串开始运行，写出其每一步的带内容。101100",
        "answer": "[s0]101100 → 停止并拒绝",
        "answer_symbols": []
    },
    "13.5 14 d)": {
        "question": "对于例3中的图灵机，若从下列每个串开始运行，写出其每一步的带内容。0000111",
        "answer": "[s0]000111 → M[s1]00111 → M0[s1]0111 → M00[s1]111 → M001[s1]11 → M0011[s1]1 → M00111[s1]B → M0011[s2]1 → M001[s3]1M → M00[s3]11M → M0[s3]011M → M[s4]0011M → [s4]M0011M → M[s0]0011M → MM[s1]011M → MM0[s1]11M → MM01[s1]1M → MM011[s1]M → MM01[s2]1M → MM0[s3]1MM → MM[s3]01MM → M[s4]M01MM → MM[s0]01MM → MMM[s1]1MM → MMM1[s1]MM → MMM[s2]1MM → MM[s3]MMMM → MMM[s5]MMM → MMMM[s6]MM → 停止并接受\n",
        "answer_symbols": []
    },
    "13.5 15": {
        "question": "例3中的图灵机识别一个串当且仅当此串具有形式0^n1^n（其中n是一个正整数），试说明原因。",
        "answer": "如果输入字符串为空或以 1 开头，机器将在非最终状态 s0 处停止。否则，初始的 0 将被更改为 M，机器跳过所有中间的 0 和 1，直到到达输入字符串的末尾或遇到 M。此时，它向后退一格并进入状态 s2。由于可接受的字符串必须在左边的每个 0 右边有一个 1，如果字符串是可接受的，这里必须有一个 1。因此，从 s2 出发的唯一转换发生在该方格包含 1 时。如果确实如此，机器将其替换为 M 并返回左侧；如果不，机器将在非最终状态 s2 处停止。在返回过程中，只要看到 1 就保持在 s3，然后只要看到 0 就保持在 s4。最终，要么在 s4 状态下遇到 1，此时机器停止而不接受，要么到达最初写入 0 的最右侧的 M。如果此时处于 s3 状态，则字符串中没有更多的 0，因此也不能有更多 1；这是通过转换 (s3, M, s5, M, R) 和 (s5, M, s6, M, R) 实现的，s6 是最终状态。否则，机器将在非最终状态 s5 处停止。如果在遇到此 M 时处于 s4 状态，整个过程重新开始，只是现在字符串的最左侧剩余的 0 和最右侧剩余的 1 已被 M 替换。所以机器移动，保持在状态 s4，到最左侧剩余的 0 并回到状态 s0 重复该过程。",
        "answer_symbols": [
            "s0",
            "1",
            "0",
            "M",
            "s2",
            "1",
            "s3",
            "s4",
            "s5",
            "s6",
            "R"
        ]
    },
    "13.5 16": {
        "question": "构造识别集合{0^n1^n | n ≥ 0}的图灵机。",
        "answer": "This task is similar to the task accomplished in Example 3. There is one sense in which it is simpler: since we are allowing n = 0, we do not need to make any special efforts to reject the empty string. There is one sense, of course, in which it is harder, namely the need to change two 0's to M's at the left for every one 1 changed to an M at the right. The following five-tuples should accomplish the job: (s0, 0, s1, M, R), (s0, B, s5, B, R), (s0, M, s5, M, R), (s1, 0, s2, M, R), (s2, 0, s2, 0, R), (s2, 1, s2, 1, R), (s2, M, s3, M, L), (s2, B, s3, B, L), (s3, 1, s4, M, L), (s4, 0, s4, 0, L), (s4, 1, s4, 1, L), (s4, M, s0, M, R)",
        "answer_symbols": [
            "=",
            "→"
        ]
    },
    "13.5 17": {
        "question": "构造识别集合{0^n1^n2^n | n ≥ 0}的图灵机。",
        "answer": "(s0, B, s9, B, L), (s0, 0, s1, 0, L), (s1, B, s2, E, R), (s2, M, s2, M, R), (s2, 0, s3, M, R), (s3, 0, s3, 0, R), (s3, M, s3, M, R), (s3, 1, s4, M, R), (s4, 1, s4, 1, R), (s4, M, s4, M, R), (s4, 2, s5, M, R), (s5, 2, s5, 2, R), (s5, B, s6, B, L), (s6, M, s8, M, L), (s6, 2, s7, 2, L), (s7, 0, s7, 0, L), (s7, 1, s7, 1, L), (s7, 2, s7, 2, L), (s7, M, s7, M, L), (s7, E, s2, E, R), (s8, M, s8, M, L), (s8, E, s9, E, L)，其中 M 和 E 是标记，E 标记输入的左端。",
        "answer_symbols": [
            "s0",
            "B",
            "s9",
            "L",
            "0",
            "s1",
            "s2",
            "E",
            "R",
            "M",
            "s3",
            "1",
            "s4",
            "2",
            "s5",
            "s6",
            "s7",
            "s8"
        ]
    },
    "13.5 18": {
        "question": "构造一个图灵机，它计算函数f(n) = n + 2，其中n是非负整数。",
        "answer": "This is pretty simple, since all we need to do is to put in two extra 1's. The following five-tuples will do the job: (s0, 1, s1, 1, L), (s1, B, s2, 1, L), (s2, B, s3, 1, L)",
        "answer_symbols": []
    },
    "13.5 19": {
        "question": "构造一个图灵机，它计算下列函数：当n ≥ 3时，f(n) = n - 3；当n = 0, 1, 2时，f(n) = 0，其中n是非负整数。",
        "answer": "(s0, 1, s1, B, R), (s1, 1, s2, B, R), (s2, 1, s3, B, R), (s3, 1, s4, 1, R), (s1, B, s4, 1, R), (s2, B, s4, 1, R), (s3, B, s4, 1, R)",
        "answer_symbols": [
            "s0",
            "1",
            "s1",
            "B",
            "R",
            "s2",
            "s3",
            "s4"
        ]
    },
    "13.5 20": {
        "question": "构造一个图灵机，它计算函数f(n) = n mod 3。",
        "answer": "We want to erase 1's in sets of three, as long as there are at least four 1's left. We can accomplish this by first checking for the presence of the four 1's, then erasing them, and then repositioning the tape head to repeat this task. The following five-tuples will do the job: (s0, 1, s1, 1, R), (s1, 1, s2, 1, R), (s2, 1, s3, 1, R), (s3, 1, s4, 1, L), (s4, 1, s5, B, L), (s5, 1, s6, B, L), (s6, 1, s7, B, R), (s7, B, s8, B, R), (s8, B, s0, B, R)",
        "answer_symbols": []
    },
    "13.5 21": {
        "question": "构造一个图灵机，它计算下列函数：当n ≥ 5时，f(n) = 3；当n = 0, 1, 2, 3或4时，f(n) = 0。",
        "answer": "(s0, 1, s1, B, R), (s1, 1, s2, B, R), (s1, B, s6, B, R), (s2, 1, s3, B, R), (s2, B, s6, B, R), (s3, 1, s4, B, R), (s3, B, s6, B, R), (s4, 1, s5, B, R), (s4, B, s6, B, R), (s6, B, s10, 1, R), (s5, 1, s5, B, R), (s5, B, s7, 1, R), (s7, B, s8, 1, R), (s8, B, s9, 1, R), (s9, B, s10, 1, R)",
        "answer_symbols": [
            "s0",
            "1",
            "s1",
            "B",
            "R",
            "s2",
            "s3",
            "s4",
            "s5",
            "s6",
            "s7",
            "s8",
            "s9",
            "s10"
        ]
    },
    "13.5 22": {
        "question": "构造一个图灵机，它计算下列函数：f(n) = 2n，其中n是非负整数。",
        "answer": "We start with a string of n + 1 1's, and we want to end up with a string of 2n + 1 1's. Our idea will be to replace the last 1 with a 0, then for each 1 to the left of the 0, write a new 1 to the right of the 0. To keep track of which 1's we have processed so far, we will change each left-side 1 with a 0 as we process it. At the end, we will change all the 0's back to 1's. Basically our states will mean the following (\"first\" means \"first encountered\"): s0, scan right for last 1, s1, change the last 1 to 0, s2, scan left to first 1, s3, scan right for end of tape (having replaced the 1 where we started with a 0) and add a 1 at the end, s4, scan left to first 0, s5, replace the remaining 0's with 1's, s6, halt. The needed five-tuples are as follows: (s0, 1, s0, 1, R), (s0, B, s1, B, L), (s1, 1, s2, 0, L), (s2, 0, s2, 0, L), (s2, 1, s3, 0, R), (s2, B, s5, B, R), (s3, 0, s3, 0, R), (s3, 1, s3, 1, R), (s3, B, s4, 1, L), (s4, 1, s4, 1, L), (s4, 0, s2, 0, L), (s5, 0, s5, 1, R), (s5, 1, s6, 1, R), (s5, B, s6, B, R)",
        "answer_symbols": [
            "+",
            "→"
        ]
    },
    "13.5 23": {
        "question": "构造一个图灵机，它计算下列函数：f(n) = 3n，其中n是非负整数。",
        "answer": "(s0, 1, s0, 1, R), (s0, B, s1, B, L), (s1, 1, s2, 0, L), (s2, 0, s2, 0, L), (s2, 1, s3, 0, R), (s2, B, s6, B, R), (s3, 0, s3, 0, R), (s3, 1, s3, 1, R), (s3, B, s4, 1, R), (s4, B, s5, 1, L), (s5, 1, s5, 1, L), (s5, 0, s2, 0, L), (s6, 0, s6, 1, R), (s6, 1, s7, 1, R), (s6, B, s7, B, R)",
        "answer_symbols": [
            "s0",
            "1",
            "B",
            "L",
            "s1",
            "s2",
            "0",
            "s3",
            "s4",
            "s5",
            "s6",
            "s7",
            "R"
        ]
    },
    "13.5 24": {
        "question": "构造一个图灵机，它计算下列函数：对于所有非负整数对n1和n2，f(n1, n2) = n2 + 2。",
        "answer": "We need to erase the first input, then replace the asterisk by a 1 and write one more 1. This straightforward task can be done with the following five-tuples: (s0, 1, s0, B, R), (s0, *, s1, 1, L), (s1, B, s2, 1, L)",
        "answer_symbols": [
            "*"
        ]
    },
    "13.5 25": {
        "question": "构造一个图灵机，它计算下列函数：对于所有非负整数n1和n2，f(n1, n2) = min{n1, n2}。",
        "answer": "(s0, 0, s0, 0, R), (s0, *, s5, B, R), (s3, *, s3, *, L), (s3, 0, s3, 0, L), (s3, 1, s3, 1, L), (s3, B, s0, B, R), (s5, 1, s5, B, R), (s5, 0, s5, B, R), (s5, B, s6, B, L), (s6, B, s6, B, L), (s6, 0, s7, 1, L), (s7, 0, s7, 1, L), (s0, 1, s1, 0, R), (s1, 1, s1, 1, R), (s1, *, s2, *, R), (s2, 0, s2, 0, R), (s2, 1, s3, 0, L), (s2, B, s4, B, L), (s4, 0, s4, 1, L), (s4, *, s8, B, L), (s8, 0, s8, B, L), (s8, 1, s8, B, L)",
        "answer_symbols": [
            "s0",
            "0",
            "s5",
            "B",
            "R",
            "*",
            "L",
            "s3",
            "1",
            "s6",
            "s7",
            "s1",
            "s2",
            "s4",
            "s8"
        ]
    },
    "13.5 26": {
        "question": "构造一个图灵机，它计算下列函数：对于所有非负整数n1和n2，f(n1, n2) = n1 + n2 + 1。",
        "answer": "Since the number n is represented by n + 1 1's, we need to be a little careful here. The most straightforward approach is to replace the middle asterisk by a 1 and erase one 1 from each end of the input. The following five-tuples will do the job: (s0, 1, s1, B, R), (s1, 1, s1, 1, R), (s1, *, s2, 1, R), (s2, 1, s2, 1, R), (s2, B, s3, B, L), (s3, 1, s4, B, R)",
        "answer_symbols": [
            "+",
            "*"
        ]
    },
    "13.5 27": {
        "question": "通过求练习18和练习22构造的图灵机的合成，构造一个图灵机计算函数f(n) = 2n + 2。",
        "answer": "假设 sm 是第 22 题图灵机的唯一停止状态，m 是最大的状态编号，并假设我们设计了这台机器，当机器停止时，磁带头正在读取答案的最左侧 1。将第 18 题中的每种状态重新编号，将每个下标加上 m，并取两个五元组集合的并集。",
        "answer_symbols": [
            "sm",
            "1",
            "m",
            "s0",
            "s1",
            "s2",
            "s3",
            "s4",
            "s5",
            "s6",
            "s7",
            "s8"
        ]
    },
    "13.5 28": {
        "question": "通过求练习18和练习23构造的图灵机的合成，构造一个图灵机计算函数f(n) = 3(n + 2) = 3n + 6。",
        "answer": "The discussion in the preamble tells how to take the machines from Exercises 18 and 23 and create a new machine. The only catch is that the tape head needs to be back at the leftmost 1. Suppose that sm, where m is the largest index, is the state in which the Turing machine for Exercise 18 halts after completing its work, and suppose that we have designed that machine so that when the machine halts the tape head is reading the leftmost 1 of the answer. Then we renumber each state in the machine for Exercise 23 by adding m to each subscript, and take the union of the two sets of five-tuples.",
        "answer_symbols": [
            "→"
        ]
    },
    "13.5 29 a)": {
        "question": "下列哪些问题是判定问题？比n小的最小素数是多少？",
        "answer": "不",
        "answer_symbols": []
    },
    "13.5 29 b)": {
        "question": "下列哪些问题是判定问题？图G是否是二分图？",
        "answer": "是",
        "answer_symbols": []
    },
    "13.5 29 c)": {
        "question": "下列哪些问题是判定问题？给定串的集合，是否有有限状态自动机能识别该集合？",
        "answer": "是",
        "answer_symbols": []
    },
    "13.5 29 d)": {
        "question": "下列哪些问题是判定问题？给定一个棋盘和某种类型的多格骨牌，棋盘是否可用这种类型的骨牌平铺？",
        "answer": "是",
        "answer_symbols": []
    },
    "13.5 31": {
        "question": "通过寻找下面的图灵机来证明B(2)至少是4；该图灵机有两个状态，字母表是{1, B}，在停机时，带上有4个连续的1。",
        "answer": "(s0, B, s1, 1, L), (s0, 1, s1, 1, R), (s1, B, s0, 1, R)",
        "answer_symbols": [
            "s0",
            "B",
            "s1",
            "1",
            "L",
            "R"
        ]
    },
    "13.5 32": {
        "question": "证明：函数B(n)不能用任何图灵机来计算。",
        "answer": "The technical details here are rather messy. The reader should consult the article on the busy beaver problem in A. K. Dewdney’s *The New Turing Omnibus: 66 Excursions in Computer Science* (Freeman, 1993); further references are given there.",
        "answer_symbols": []
    },
    "13 Supplementary Exercises 7": {
        "question": "设 A 和 B 是 V* 的两个有限子集，其中 V 是一个字母表。问 |AB| = |BA| 肯定成立吗？",
        "answer": "不可以，取A={1, 10}和B={0, 00}",
        "answer_symbols": [
            "{",
            "}"
        ]
    },
    "13 Supplementary Exercises 11 a)": {
        "question": "求下列正则表达式的星高度: 0*1",
        "answer": "1",
        "answer_symbols": []
    },
    "13 Supplementary Exercises 11 b)": {
        "question": "求下列正则表达式的星高度: 0*1*",
        "answer": "1",
        "answer_symbols": []
    },
    "13 Supplementary Exercises 12 a)": {
        "question": "对下列每个正则表达式, 求一个表示相同语言但具有最小星高度的正则表达式. (0*1*)*",
        "answer": "这个正则表达式等价于 (0 ∪ 1)*，其星高为 1。显然我们不能找到等价的星高为 0 的表达式。",
        "answer_symbols": [
            "*",
            "∪"
        ]
    },
    "13 Supplementary Exercises 12 b)": {
        "question": "对下列每个正则表达式, 求一个表示相同语言但具有最小星高度的正则表达式. (0(01*)*)*",
        "answer": "总是成立的是 (AB*)* 等价于 A* ∪ A(A ∪ B)*。因此我们可以用星高为 2 的表达式替换给定的表达式（其星高为 3），即 0* ∪ 0(0 ∪ 01*0)*。由于连续的 0 和 1 的子串可以任意长，但并非所有字符串都在语言中（因为每两个最大 1 子串之间必须至少有两个 0 分隔），因此不可能将星高降低到 1。",
        "answer_symbols": [
            "*",
            "∪",
            "(",
            ")"
        ]
    },
    "13 Supplementary Exercises 13": {
        "question": "构造一个带输出的有限状态机, 若到目前为止读到的输入位串中含有 4 个或 4 个以上的 1, 则它输出 1。然后再构造一个确定性的有限状态自动机来识别这个集合。",
        "answer": "开始 1, 0 1, 0 1, 0 1, 1 1, 1 0, 0 0, 0 0, 0 0, 0 0, 1 s0 s1 s2 s3 s4 开始 1 1 1 1 1 0 0 0 0 0 s0 s1 s2 s3 s4",
        "answer_symbols": [
            ",",
            "0",
            "1"
        ]
    },
    "13 Supplementary Exercises 14": {
        "question": "构造一个带输出的有限状态机器, 若到目前为止读到的输入位串中含有 4 个或 4 个以上连续的 1, 则它输出 1。然后再构造一个确定性的有限状态自动机来识别这个集合。",
        "answer": "我们仅绘制这个问题的确定有限状态自动机。输出有限状态机与此相同，只是当且仅当转换到图中的最终状态时，输出为 1。这里的思路很简单，状态 s_i 对应于刚刚看到 i 个连续的 1。",
        "answer_symbols": []
    },
    "13 Supplementary Exercises 15": {
        "question": "构造一个带输出的有限状态机器, 若到目前为止读到的输入位串以 4 个或 4 个以上连续的 1 结尾, 则它输出 1。然后再构造一个确定性的有限状态自动机来识别这个集合。",
        "answer": "开始 1, 0 1, 0 1, 0 1, 1 0, 0 s0 s1 s2 s3 s4 1, 1 0, 0 0, 0 0, 0 0, 0 开始 1 1 1 1 0 s0 s1 s2 s3 s4 1 0 0 0 0",
        "answer_symbols": [
            ",",
            "0",
            "1"
        ]
    },
    "13 Supplementary Exercises 16": {
        "question": "定义一个图灵机。",
        "answer": "如果 x 是一个字符串，s 是一个状态，那么 f(s, x) 表示如果机器当前处于状态 s，字符串 x 将机器驱动到的状态。",
        "answer_symbols": [
            "→",
            "=",
            "λ"
        ]
    },
    "13 Supplementary Exercises 19": {
        "question": "对于具有如下状态图的非确定性的自动机, 构造一个与之等价的确定性的有限状态自动机。",
        "answer": "{s0, s1, s2, s3} {s0, s1, s2,} {s0, s1, s3,} {s0, s2, s3,} {s1, s2, s3,} {s0, s1} {s0, s2} {s0, s3} {s1, s2} {s1, s3} {s2, s3} {s0} {s1} {s2} {s3} 0 0,1 0 0 0 0 1 1 1 1 0 0 0 0 0 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 0, 1 开始",
        "answer_symbols": [
            "{",
            "}",
            ",",
            "0",
            "1"
        ]
    },
    "13 Supplementary Exercises 2": {
        "question": "求产生集合 {0^n | n ≥ 0} 的一个短语结构文法。",
        "answer": "我们将构建一个语法，该语法最初生成形式为 DD... D0E 的字符串，左边有零个或多个 D，中间有一个 0，右边有一个 E。D 将穿过中间的 0，每个 D 都会使存在的 0 数量翻倍。当 D 到达右侧的 E 时，它会被吸收。因此我们的语法具有以下规则。规则 S→ A0E、A→ AD 和 A→ λ 创建上述形式的字符串。规则 D0→ 00D 导致加倍。规则 DE→ E 吸收 D。最后，我们需要添加规则 E→ λ 来完成每次推导。",
        "answer_symbols": [
            "→",
            "λ"
        ]
    },
    "13 Supplementary Exercises 4": {
        "question": "证明：L(G) 就是第 5 章补充练习 63 的导语中定义的括号的合式串集合。",
        "answer": "可以通过归纳法证明从 A 或 B 推导出的每个终端字符串都是格式正确的括号字符串。因此，由这种语法生成的语言包含在格式正确的括号字符串集中。相反，可以通过归纳法证明每个格式正确的括号字符串都可以从这个语法推导出来。",
        "answer_symbols": []
    },
    "13 Supplementary Exercises 5": {
        "question": "设文法 G = (V, T, S, P)，其中 V = {0, S}，T = {0}，S 是初始符号，产生式有 S → 0S，S → S0 和 S → 0。构造 0^² 的两个不同派生树，从而证明 G 是二义的。",
        "answer": "0 S S S 0 0 S S 0 0 0 S",
        "answer_symbols": [
            "S"
        ]
    },
    "13 Supplementary Exercises 6": {
        "question": "设文法 G = (V, T, S, P) 为：V = {0, S}，T = {0}，S 是初始符号，产生式有 S → 0S 和 S → 0。证明 G 是非二义的。",
        "answer": "对于每个 n，只有长度为 n 的一种推导，即 S⇒ 0S⇒ 00S⇒···⇒ 0^(n-1)S⇒ 0^n。因此推导树是唯一的。",
        "answer_symbols": [
            "⇒",
            "^"
        ]
    },
    "13 Supplementary Exercises 8 a)": {
        "question": "设 V 是一个字母表，A、B 和 C 是 V* 的子集。证明或反证下列各式。（a）A(B ∪ C) = AB ∪ AC.",
        "answer": "这是真的：A(B ∪ C) = { ax | a ∈ A ∧ x ∈ B ∪ C } = { ax | a ∈ A ∧ (x ∈ B ∨ x ∈ C) } = { ax | (a ∈ A ∧ x ∈ B) ∨ (a ∈ A ∧ x ∈ C) } = { ax | a ∈ A ∧ x ∈ B } ∪ { ax | a ∈ A ∧ x ∈ C } = AB ∪ AC。",
        "answer_symbols": [
            "∪",
            "∈",
            "∧",
            "∨",
            "="
        ]
    },
    "13 Supplementary Exercises 8 b)": {
        "question": "设 V 是一个字母表，A、B 和 C 是 V* 的子集。证明或反证下列各式。（b）A(B ∩ C) = AB ∩ AC.",
        "answer": "这也是真的；证明与 (a) 部分类似。",
        "answer_symbols": []
    },
    "13 Supplementary Exercises 8 c)": {
        "question": "设 V 是一个字母表，A、B 和 C 是 V* 的子集。证明或反证下列各式。（c）(AB)C = A(BC).",
        "answer": "这是真的：(AB)C = { xc | x ∈ AB ∧ c ∈ C } = { abc | a ∈ A ∧ b ∈ B ∧ c ∈ C } 并且 A(BC) 等于相同的集合。",
        "answer_symbols": [
            "=",
            "∈",
            "∧"
        ]
    },
    "13 Supplementary Exercises 8 d)": {
        "question": "设 V 是一个字母表，A、B 和 C 是 V* 的子集。证明或反证下列各式。（d）(A ∪ B)* = A* ∪ B*.",
        "answer": "这不是真的。令 A = {0} 和 B = {1}。那么 01 在左侧但不在右侧。",
        "answer_symbols": [
            "="
        ]
    },
    "13 Supplementary Exercises 9": {
        "question": "设 V 是一个字母表，A 和 B 是 V* 的子集。从 A* ⊆ B* 能否推出 A ⊆ B？",
        "answer": "不可以，取A={00, 000, 00000}和B={00, 000}",
        "answer_symbols": [
            "{",
            "}"
        ]
    },
    "13 Supplementary Exercises 10": {
        "question": "正则表达式 (2* (0 ∪ (12*))) * 表示的串集合是什么（串的符号在集合 {0, 1, 2} 中）？",
        "answer": "显然，由这个正则表达式生成的字符串没有 0 紧接在 2 之前。相反，我们可以取任何具有此属性的字符串，并通过将 2 分组在一起，将其视为来自这个正则表达式（我们需要想象每对连续的 1 之间有一组没有 2）。",
        "answer_symbols": []
    },
    "13 Supplementary Exercises 11 c)": {
        "question": "求下列正则表达式的星高度: (0*01)*",
        "answer": "2",
        "answer_symbols": []
    },
    "13 Supplementary Exercises 11 d)": {
        "question": "求下列正则表达式的星高度: ((0*1)*)*",
        "answer": "3",
        "answer_symbols": []
    },
    "13 Supplementary Exercises 11 e)": {
        "question": "求下列正则表达式的星高度: (010*)*(1*01*)*((01)*(10)*)*",
        "answer": "2",
        "answer_symbols": []
    },
    "13 Supplementary Exercises 11 f)": {
        "question": "求下列正则表达式的星高度: ((0*1)*0*)*",
        "answer": "4",
        "answer_symbols": []
    },
    "13 Supplementary Exercises 12 c)": {
        "question": "对下列每个正则表达式, 求一个表示相同语言但具有最小星高度的正则表达式. (0* ∪ (01)* ∪ 1*)*",
        "answer": "这个正则表达式等价于 (0 ∪ 1)*，其星高为 1。显然我们不能找到等价的星高为 0 的表达式。",
        "answer_symbols": [
            "*",
            "∪"
        ]
    },
    "13 Supplementary Exercises 16 a)": {
        "question": "在有限状态机中, 称状态 s' 是从状态 s 可达的, 如果存在输入串 x 使得 f(s, x) = s'。称状态 s 是瞬变的, 若没有非空输入串 x 使得 f(s, x) = s。称状态 s 是一个沉积点, 若对于任意输入串 x 都有 f(s, x) = s。哪些状态是从 s0 可达的?",
        "answer": "显然，通过跟随适当的箭头，我们可以从状态 s0 到达除 s3 以外的所有状态；例如，f(s, 01)= s5 和 f(s, λ)= s0。显然我们不能从任何其他状态到达状态 s3。",
        "answer_symbols": [
            "→",
            "=",
            "λ"
        ]
    },
    "13 Supplementary Exercises 16 b)": {
        "question": "在有限状态机中, 称状态 s' 是从状态 s 可达的, 如果存在输入串 x 使得 f(s, x) = s'。称状态 s 是瞬变的, 若没有非空输入串 x 使得 f(s, x) = s。称状态 s 是一个沉积点, 若对于任意输入串 x 都有 f(s, x) = s。哪些状态是从 s2 可达的?",
        "answer": "显然只有状态 s2 和 s5 可以从状态 s2 达到。",
        "answer_symbols": []
    },
    "13 Supplementary Exercises 16 c)": {
        "question": "在有限状态机中, 称状态 s' 是从状态 s 可达的, 如果存在输入串 x 使得 f(s, x) = s'。称状态 s 是瞬变的, 若没有非空输入串 x 使得 f(s, x) = s。称状态 s 是一个沉积点, 若对于任意输入串 x 都有 f(s, x) = s。哪些状态是瞬变的?",
        "answer": "暂态状态 s 是指不存在从 s 回到自身的路径。显然，一旦离开状态 s0 或 s1 或 s3 或 s6，我们就无法返回，因此这些是暂态状态。由于存在循环，其他状态不是暂态状态。（然而，请注意，一个状态不需要有循环才能是非暂态状态。）",
        "answer_symbols": [
            "→",
            "≠"
        ]
    },
    "13 Supplementary Exercises 16 d)": {
        "question": "在有限状态机中, 称状态 s' 是从状态 s 可达的, 如果存在输入串 x 使得 f(s, x) = s'。称状态 s 是瞬变的, 若没有非空输入串 x 使得 f(s, x) = s。称状态 s 是一个沉积点, 若对于任意输入串 x 都有 f(s, x) = s。哪些状态是沉积点?",
        "answer": "显然只有 s4 和 s5 是汇，因为其他状态都有离开它们的箭头。",
        "answer_symbols": [
            "→"
        ]
    },
    "13 Supplementary Exercises 17 a)": {
        "question": "设集合 S、I 和 O 都是有限集合, 且 |S| = n、|I| = k、|O| = m。可以构造多少个不同的有限状态机 (米兰机) M = (S, I, O, f, g, s0) (其中初始状态 s0 可以任意选择)?",
        "answer": "n^(nk+1)m^(nk)",
        "answer_symbols": [
            "^",
            "*",
            "(",
            ")"
        ]
    },
    "13 Supplementary Exercises 17 b)": {
        "question": "设集合 S、I 和 O 都是有限集合, 且 |S| = n、|I| = k、|O| = m。可以构造多少个不同的摩尔机 M = (S, I, O, f, g, s0) (其中初始状态 s0 可以任意选择)?",
        "answer": "n^(nk+1)m^n",
        "answer_symbols": [
            "^",
            "*",
            "(",
            ")"
        ]
    },
    "13 Supplementary Exercises 18 a)": {
        "question": "设集合 S 和 I 是有限集合, 且 |S| = n、|I| = k。在下列情形下, 存在多少个不同的有限状态自动机 (S, I, f, s0, F) (其中初始状态 s0 以及由 S 的终结状态构成的子集 F 可以任意选择)? 如果机器是确定性的。",
        "answer": "要指定一个确定性自动机，我们需要选择一个起始状态（有 n 种方法），需要选择一组最终状态（有 2^n 种方法），并且对于每个状态和输入对（共有 nk 对）我们需要选择一个状态进行转换（有 n^(nk) 种方法）。因此答案是 n * 2^n * n^(nk) = 2^(n * (nk + 1))。",
        "answer_symbols": [
            "*",
            "^",
            "+",
            "=",
            "(",
            ")"
        ]
    },
    "13 Supplementary Exercises 18 b)": {
        "question": "设集合 S 和 I 是有限集合, 且 |S| = n、|I| = k。在下列情形下, 存在多少个不同的有限状态自动机 (S, I, f, s0, F) (其中初始状态 s0 以及由 S 的终结状态构成的子集 F 可以任意选择)? 如果机器是非确定性的。(注意: 这包括确定性的自动机。)",
        "answer": "这与部分 (a) 相同，只是我们需要为每个状态和输入对选择 2^n 个状态子集中的一个。因此答案是 n * 2^n * (2^n)^(nk) = n * 2^(n + kn^2)。",
        "answer_symbols": [
            "*",
            "^",
            "+",
            "=",
            "(",
            ")"
        ]
    },
    "13 Supplementary Exercises 20": {
        "question": "练习 19 中的自动机识别的语言是什么?",
        "answer": "没有状态是最终状态，因此没有字符串被接受。因此这台机器识别的语言是空集。",
        "answer_symbols": []
    },
    "13 Supplementary Exercises 21 a)": {
        "question": "构造有限状态自动机识别下列集合。0*(10)*",
        "answer": "开始 s0 s1 s2 1 0 0 1",
        "answer_symbols": [
            "0",
            "1"
        ]
    },
    "13 Supplementary Exercises 21 b)": {
        "question": "构造有限状态自动机识别下列集合。(01 ∪ 111)*10*(0 ∪ 1)",
        "answer": "开始 1 0, 1 0 1 1 1 0 1 s0 s4 s5 s1 s2 s3",
        "answer_symbols": [
            ",",
            "0",
            "1"
        ]
    },
    "13 Supplementary Exercises 21 c)": {
        "question": "构造有限状态自动机识别下列集合。(001 ∪ (11)*)*",
        "answer": "开始 0 0 1 1 s0 s1 s2",
        "answer_symbols": [
            "0",
            "1"
        ]
    },
    "13 Supplementary Exercises 22 a)": {
        "question": "求表示由 0 和 1 组成的下列串集合的正则表达式。偶数个 1 与奇数个 0 交替出现。",
        "answer": "偶数个 1（假设这里指的是“正偶数”）可以表示为 11(11)*。奇数个 0 同样可以表示为 0(00)*。如果我们以积极的方式解释“交错”（坚持字符串以 1 开头并以 1 结尾），那么我们的答案是 11(11)*(0(00)*11(11)*)*。",
        "answer_symbols": [
            "*",
            "(",
            ")",
            "∪"
        ]
    },
    "13 Supplementary Exercises 22 b)": {
        "question": "求表示由 0 和 1 组成的下列串集合的正则表达式。包含至少 2 个连续的 0 或 3 个连续的 1。",
        "answer": "这个问题是直截了当的：(1 ∪ 0)*(00 ∪ 111)(1 ∪ 0)*。",
        "answer_symbols": [
            "*",
            "(",
            ")",
            "∪"
        ]
    },
    "13 Supplementary Exercises 22 c)": {
        "question": "求表示由 0 和 1 组成的下列串集合的正则表达式。不包含 3 个连续的 0 或 2 个连续的 1。",
        "answer": "这个表达式的中间部分必须是 (1(0 ∪ 00))*，以确保所需的交错。开头可能允许最多两个 0，结尾可能允许最多一个 1。因此答案是 (ε ∪ 0 ∪ 00)(1(0 ∪ 00))*(ε ∪ 1)。",
        "answer_symbols": [
            "*",
            "(",
            ")",
            "∪",
            "ε"
        ]
    },
    "13 Supplementary Exercises 23": {
        "question": "证明：若 A 是一个正则集合，则 A 也是。",
        "answer": "构建一个具有状态集S和最终状态集F的确定性有限自动机A。对于A使用相同的自动机但最终状态集为S - F。",
        "answer_symbols": [
            "-",
            "{",
            "}"
        ]
    },
    "13 Supplementary Exercises 24": {
        "question": "证明：若 A 和 B 都是正则集合，则 A ∩ B 也是。",
        "answer": "从正则表达式生成的集合的定义中可以看出，两个正则集的并集是正则的。从练习 23 我们知道正则集的补集是正则的。现在 A ∩ B = (A ∪ B)'; 因此如果 A 和 B 是正则的，那么它们的交集也是正则的。",
        "answer_symbols": [
            "∩",
            "∪",
            "'"
        ]
    },
    "13 Supplementary Exercises 25 a)": {
        "question": "求识别由 0 和 1 组成的下列串集合的有限状态自动机。以不超过 3 个连续的 0 开始，且至少包含 2 个连续的 1。",
        "answer": "开始 0, 1 s0 s1 s2 s3 s6 s4 s5 0 0 0 1 1 1 1 0 1 1 0",
        "answer_symbols": [
            ",",
            "0",
            "1"
        ]
    },
    "13 Supplementary Exercises 26": {
        "question": "用 13.4 节的练习 22 所给的泵引理证明：{0^n | n ∈ N}不是正则的。",
        "answer": "证明基本上与第 13.4 节练习 24 的解决方案相同，因为连续 2 的幂之间的差距，就像连续平方之间的差距一样，随着数字变大而增长。",
        "answer_symbols": [
            "∩",
            "∪",
            "'",
            "→",
            "≠",
            "*",
            "^",
            "+",
            "=",
            "(",
            ")",
            "ε"
        ]
    },
    "13 Supplementary Exercises 27": {
        "question": "用 13.4 节的练习 22 所给的泵引理证明：{1^p | p 是素数}不是正则的。",
        "answer": "假设 L={1p | p 是素数} 是正则的，并且令 S 是识别 L 的有限状态自动机的状态集。令 z= 1p，其中 p 是一个大于 |S| 的素数（存在这样的素数，因为有无限多个素数）。根据泵引理，必须能够将 z 写成 uvw 的形式，其中 l(uv) ≤ |S|，l(v) ≥ 1，并且对于所有非负整数 i，uviw ∈ L。由于 z 是全为 1 的字符串，u= 1a，v= 1b，w= 1c，其中 a+ b+ c= p，a+ b ≤ n，且 b ≥ 1。这意味着 uviw= 1a1bi1c= 1(a+b+c)+b(i−1)= 1p+b(i−1)。现在取 i=p+1。那么 uviw= 1p(1+b)。因为 p(1+b) 不是素数，所以 uviw 不属于 L，这与假设矛盾。",
        "answer_symbols": [
            "|",
            "{",
            "}",
            "<=",
            ">=",
            "+",
            "=",
            "-",
            "(",
            ")",
            "∈",
            "∀",
            "∃",
            "¬",
            "∧",
            "∨",
            "⇒",
            "⇔"
        ]
    },
    "13 Supplementary Exercises 28": {
        "question": "对于上下文无关语言，有与正则集合的泵引理类似的结果。设 L(G)是上下文无关语言 G 识别的语言。此结果是存在常量 N，如果 z 是 L(G)中的一个串，且 l(z) ≥ N，则 z 可以写成 uvwxy，其中 l(uvw) ≤ N，l(vx) ≥ 1，且 uv^iwx^iy 属于 L(G) (i = 0, 1, 2, 3, …)。用这个结果证明，不存在上下文无关文法 L(G)满足 {0^n1^n2^n | n = 0, 1, 2, …}。",
        "answer": "假设存在一个上下文无关文法生成这个集合，并应用上下文无关文法的泵引理的类似物，得到字符串 u, v, w, x, 和 y，使得 v 和 x 不同时为空且 uviwxiy 形式为 0^n1^n2^n 对所有 i 都成立。现在如果 v 或 x 包含两个或三个不同的符号，则 uv^2wx^2y 的符号顺序错误。因此至少有一个符号（比如 0）不在 vx 中。另一方面，至少有一个符号（比如 1）出现在 vx 中（因为 vx ≠ ε）。但那时 uviwxiy 必须在 i 很大时有更多的 1 比 0，矛盾。因此不存在这样的上下文无关文法。",
        "answer_symbols": [
            "∪",
            "∩",
            "'",
            "→",
            "≠",
            "*",
            "^",
            "+",
            "=",
            "(",
            ")",
            "ε"
        ]
    },
    "13 Supplementary Exercises 29": {
        "question": "构造一个能计算函数 f(n1, n2) = max(n1, n2) 的图灵机。",
        "answer": "(s0, *, s5, B, L), (s0, 0, s0, 0, R), (s0, 1, s1, 0, R), (s1, *, s2, *, R), (s1, 1, s1, 1, R), (s2, 0, s2, 0, R), (s2, 1, s3, 0, L), (s2, B, s4, B, L), (s3, *, s3, *, L), (s3, 0, s3, 0, L), (s3, 1, s3, 1, L), (s3, B, s0, B, R), (s4, *, s8, B, L), (s4, 0, s4, B, L), (s5, 0, s5, B, L), (s5, B, s6, B, R), (s6, 0, s7, 1, R), (s6, B, s6, B, R), (s7, 0, s7, 1, R), (s7, 1, s7, 1, R), (s8, 0, s8, 1, L), (s8, 1, s8, 1, L)",
        "answer_symbols": [
            "*",
            ",",
            "(",
            ")",
            "→",
            "←"
        ]
    },
    "13 Supplementary Exercises 30": {
        "question": "构造一个图灵机，它能计算如下函数：当 n2 ≥ n1 时，f(n1, n2) = n2 - n1；当 n2 < n1 时，f(n1, n2) = 0。",
        "answer": "输入将是一个由 n1 + 1 个 1 组成的字符串，后面跟着一个星号，再后面跟着一个由 n2 + 1 个 1 组成的字符串，磁带头位于第一个参数的最左边的 1 处。我们希望机器每在第一个参数中找到一个 1 就从第二个参数中擦除一个 1，使第二个字符串中剩余 n2 - n1 个 1（同时在过程中擦除第一个参数中的 1），然后用 1 替换星号。然而，如果 n2 < n1，我们希望机器停止时磁带上只有一个 1（因为在这种情况下答案是数字 0）。我们将采用递归方法，即一次擦除后，问题变为计算 f(n1 - 1, n2 - 1)，这将得出相同的答案。In the Turing machine tuples that follow, the intent is that **s0** is the state in which we erase a 1 from **n1** (or notice that we are essentially finished); **s1** is the state in which we scan right to find the last 1 in **n2**; **s2** is the state in which we erase a 1 from **n2** (or notice that **n2 < n1**); **s3** is the state in which we scan back to the starting point; **s4** is the clean-up state for handling the case **n2 < n1**, and **s5** is the halt state.\nThese tuples should accomplish the job:\n- (s0, 1, s1, B, R)\n- (s0, *, s5, 1, L)\n- (s1, 1, s1, 1, R)\n- (s1, *, s1, *, R)\n- (s1, B, s2, B, L)\n- (s2, 1, s3, B, L)\n- (s2, *, s4, B, L)\n- (s3, 1, s3, 1, L)\n- (s3, *, s3, *, L)\n- (s3, B, s0, B, R)\n- (s4, 1, s4, B, L)\n- (s4, B, s5, 1, L)",
        "answer_symbols": [
            "*",
            "=",
            "≠",
            "+",
            "→",
            ")",
            "ε",
            "(",
            "<",
            "^",
            "-"
        ]
    },
    "Appendix 1 1": {
        "question": "证明定理 3，它叙述实数的乘法单位元是唯一的。",
        "answer": "假设 1' 也是实数的乘法单位元。那么根据定义，我们有 1 * 1'= 1 和 1 * 1'= 1'，所以 1'= 1。",
        "answer_symbols": [
            "'",
            "*",
            "="
        ]
    },
    "Appendix 1 3": {
        "question": "证明对于所有实数 x 和 y，有 (−x) × y = x × (−y) = −(x × y)。",
        "answer": "对于第一部分，只需证明 [(-x) * y] + (x * y) = 0，因为定理 2 保证加法逆元是唯一的。因此 [(-x) * y] + (x * y) = (-x + x) * y（分配律）= 0 * y（逆元律）= y * 0（交换律）= 0（定理 5）。",
        "answer_symbols": [
            "[",
            "]",
            "(",
            ")",
            "*",
            "+",
            "=",
            "-",
            "0",
            "1"
        ]
    },
    "Appendix 1 5": {
        "question": "证明对于所有实数 x 和 y，有 (−x) × (−y) = x × y。",
        "answer": "只需证明 [(-x) * (-y)] + [-(x * y)] = 0，因为定理 2 保证加法逆元是唯一的：[(-x) * (-y)] + [-(x * y)] = [(-x) * (-y)] + [(-x) * y]（练习 3）= (-x) * [(-y) + y]（分配律）= (-x) * 0（逆元律）= 0（定理 5）。",
        "answer_symbols": [
            "[",
            "]",
            "(",
            ")",
            "*",
            "+",
            "=",
            "-",
            "0",
            "1"
        ]
    },
    "Appendix 1 7": {
        "question": "证明对于每个实数 x，有 −(−x) = x。",
        "answer": "根据定义，-(-x) 是 -x 的加法逆元。但 -x 是 x 的加法逆元，所以 x 是 -x 的加法逆元。因此 -(-x) = x（定理 2）。",
        "answer_symbols": [
            "-",
            "=",
            "0",
            "1"
        ]
    },
    "Appendix 1 9": {
        "question": "证明对于所有实数 x 和 y，有 −x − y = −(x + y)。",
        "answer": "只需证明 (-x - y) + (x + y) = 0，因为定理 2 保证加法逆元是唯一的：(-x - y) + (x + y) = [(-x) + (-y)] + (x + y)（减法定义）= [(-y) + (-x)] + (x + y)（交换律）= (-y) + [(-x) + (x + y)]（结合律）= (-y) + [(-x + x) + y]（结合律）= (-y) + (0 + y)（逆元律）= (-y) + y（恒等律）= 0（逆元律）。",
        "answer_symbols": [
            "(",
            ")",
            "+",
            "=",
            "-",
            "0",
            "1"
        ]
    },
    "Appendix 1 11": {
        "question": "证明对于所有实数 w、x、y 和 z，如果 x ≠ 0 且 z ≠ 0，则 (w / x) + (y / z) = (w × z + x × y) / (x × z)。",
        "answer": "根据除法定义和乘法逆元的唯一性（定理 4），只需证明 [(w / x) + (y / z)] * (x * z) = w * z + x * y。但这在经过几个步骤后，使用分配律、乘法的结合律和交换律以及除法就是乘以逆元的定义，可以得出结论。",
        "answer_symbols": [
            "[",
            "]",
            "(",
            ")",
            "*",
            "+",
            "=",
            "/",
            "0",
            "1"
        ]
    },
    "Appendix 1 13": {
        "question": "证明对于所有正实数 x 和 y，x × y 也是一个正实数。",
        "answer": "必须证明如果 x > 0 且 y > 0，则 x * y > 0。根据乘法相容律、交换律和定理 5，我们有 x * y > 0 * y = 0。",
        "answer_symbols": [
            ">",
            "*",
            "=",
            "0",
            "1"
        ]
    },
    "Appendix 1 15": {
        "question": "证明对于所有实数 x、y 和 z，如果 x > y 且 z < 0，则 x × z < y × z。",
        "answer": "首先注意，如果 z < 0，则 -z > 0（两边加上 -z）。现在给定 x > y 和 -z > 0，根据乘法相容律，我们有 x * (-z) > y * (-z)。但根据练习 3，这等价于 -(x * z) > -(y * z)。然后两边加上 x * z 和 y * z，并以显而易见的方式应用各种定律，得到 x * z < y * z。",
        "answer_symbols": [
            "<",
            ">",
            "*",
            "+",
            "=",
            "-",
            "0",
            "1"
        ]
    },
    "Appendix 1 17": {
        "question": "证明对于所有实数 w、x、y 和 z，如果 w < x 且 y < z，则 w + y < x + z。",
        "answer": "加法相容律告诉我们 w + y < x + y 并且（结合交换律）x + y < x + z。根据传递律，这给出了所需的结论。",
        "answer_symbols": [
            "<",
            "+",
            "=",
            "0",
            "1"
        ]
    },
    "Appendix 1 19": {
        "question": "证明对于每个正实数 x，存在一个正整数 n 使得 n × x > 1。",
        "answer": "根据定理 8，应用于 1 / x 代替 x，存在一个整数 n（必然是正的，因为 1 / x 是正的）使得 n > 1 / x。根据乘法相容律，这意味着 n * x > 1。",
        "answer_symbols": [
            ">",
            "*",
            "=",
            "/",
            "0",
            "1"
        ]
    },
    "Appendix 1 21": {
        "question": "定义正整数序偶集合上的关系 ∼ 如下：(w, x) ∼ (y, z) 当且仅当 w + z = x + y。证明运算 [(w, x)] ∼ + [(y, z)] ∼ = [(w + y, x + z)] ∼ 和 [(w, x)] ∼ × [(y, z)] ∼ = [(w × y + x × z, x × y + w × z)] ∼ 是良定义的，即它们不依赖于计算所选取的等价类的代表元。",
        "answer": "必须证明如果 (w, x) ~ (w', x') 且 (y, z) ~ (y', z')，则 (w + y, x + z) ~ (w' + y', x' + z') 且 (w * y + x * z, x * y + w * z) ~ (w' * y' + x' * z', x' * y' + w' * z')。因此我们已知 w + x' = x + w' 且 y + z' = z + y'，我们需要证明 w + y + x' + z' = x + z + w' + y' 且 w * y + x * z + x' * y' + w' * z' = x * y + w * z + w' * y' + x' * z'。对于所需结论的第一部分，将两个给定方程相加。P1: 1 ANS Rosen-2311T MHIA017-Rosen-v5.cls May 13, 2011 10:29 Answers to Odd-Numbered Exercises S-97 For the second, rewrite the given equations as w−x= w'−x' and y − z= y' − z', multiply them, and do the algebra.",
        "answer_symbols": [
            "+",
            "~",
            "(",
            "=",
            "1",
            "0",
            ")",
            "-",
            "'",
            "*"
        ]
    },
    "Appendix 2 1 a)": {
        "question": "将下列数量表达为2的幂次。（a）2 * 2^2",
        "answer": "23",
        "answer_symbols": []
    },
    "Appendix 2 1 b)": {
        "question": "将下列数量表达为2的幂次。（b）(2^2)^3",
        "answer": "26",
        "answer_symbols": []
    },
    "Appendix 2 1 c)": {
        "question": "将下列数量表达为2的幂次。（c）2^(2^2)",
        "answer": "24",
        "answer_symbols": []
    },
    "Appendix 2 3 a)": {
        "question": "假设log_4 x = y，其中x是一个正实数。计算下列各值。（a）log_2 x",
        "answer": "2y",
        "answer_symbols": [
            "*"
        ]
    },
    "Appendix 2 3 b)": {
        "question": "假设log_4 x = y，其中x是一个正实数。计算下列各值。（b）log_8 x",
        "answer": "2y/3",
        "answer_symbols": [
            "*",
            "/"
        ]
    },
    "Appendix 2 3 c)": {
        "question": "假设log_4 x = y，其中x是一个正实数。计算下列各值。（c）log_16 x",
        "answer": "y/2",
        "answer_symbols": [
            "/"
        ]
    },
    "Appendix 3 1": {
        "question": "下列两个赋值语句构成的语句组有什么区别？ a := b b := c 和 b := c a := b",
        "answer": "After the first block is executed, a has been assigned the original value of b and b has been assigned the original value of c, whereas after the second block is executed, b is assigned the original value of c and a the original value of c as well.",
        "answer_symbols": []
    },
    "Appendix 3 3": {
        "question": "证明下列形式的循环 for i := 初值 to 终值 语句 可以写成“while”结构。",
        "answer": "The following construction does the same thing. i:= initial value while i ≤ final value statement i:= i+ 1",
        "answer_symbols": [
            "≤",
            "+",
            ":="
        ]
    }
}