# K-12数学教育智能数字生态系统 - 后端架构设计

## 后端架构概述

### 设计原则
- **微服务架构**：按业务域拆分服务，独立部署和扩展
- **领域驱动设计**：以业务领域为核心组织代码结构
- **RESTful API**：统一的接口规范，易于理解和使用
- **异步处理**：消息队列解耦重计算任务
- **高可用性**：容错机制、负载均衡、服务降级

### 技术栈选择
- **Web框架**：Flask 2.1.3 (轻量级、灵活性高)
- **编程语言**：Python 3.7+ (丰富的AI/ML生态)
- **API网关**：Kong/Zuul (统一入口、限流、认证)
- **数据库**：OceanBase (高性能分布式数据库)
- **缓存**：Redis 6.x (高性能内存数据库)
- **消息队列**：RabbitMQ (可靠的消息传递)
- **任务队列**：Celery (异步任务处理)

## 微服务架构设计

### 服务拆分策略

```
┌─────────────────────────────────────────────────────────────────┐
│                        API网关层                                │
│                     (Kong/Zuul)                                │
└─────────────────────┬───────────────────────────────────────────┘
                      │
    ┌─────────────────┼─────────────────┐
    │                 │                 │
┌───▼────┐      ┌─────▼─────┐      ┌───▼────┐
│业务服务│      │ AI服务    │      │基础服务│
│        │      │           │      │        │
│• 作业  │      │• 推荐引擎 │      │• 认证  │
│• 用户  │      │• 评分系统 │      │• 文件  │
│• 知识  │      │• 符号识别 │      │• 通知  │
│• 分析  │      │• 题目生成 │      │• 配置  │
└────────┘      └───────────┘      └────────┘
```

### 核心服务设计

#### 1. 用户认证服务 (Auth Service)
```python
# services/auth_service.py
from flask import Flask, request, jsonify
from flask_jwt_extended import JWTManager, create_access_token, jwt_required, get_jwt_identity
import bcrypt
from models.user import User

class AuthService:
    def __init__(self):
        self.app = Flask(__name__)
        self.jwt = JWTManager(self.app)
        self.setup_routes()
    
    def setup_routes(self):
        @self.app.route('/auth/login', methods=['POST'])
        def login():
            data = request.get_json()
            username = data.get('username')
            password = data.get('password')
            
            user = User.authenticate(username, password)
            if user:
                access_token = create_access_token(
                    identity=user.id,
                    additional_claims={
                        'role': user.role,
                        'permissions': user.get_permissions()
                    }
                )
                return jsonify({
                    'success': True,
                    'access_token': access_token,
                    'user': user.to_dict()
                })
            
            return jsonify({'success': False, 'message': '用户名或密码错误'}), 401
        
        @self.app.route('/auth/register', methods=['POST'])
        def register():
            data = request.get_json()
            try:
                user = User.create(
                    username=data['username'],
                    password=data['password'],
                    email=data['email'],
                    role=data.get('role', 'student')
                )
                return jsonify({
                    'success': True,
                    'user': user.to_dict()
                })
            except Exception as e:
                return jsonify({'success': False, 'message': str(e)}), 400
        
        @self.app.route('/auth/profile', methods=['GET'])
        @jwt_required()
        def get_profile():
            user_id = get_jwt_identity()
            user = User.get_by_id(user_id)
            return jsonify(user.to_dict())
```

#### 2. 作业管理服务 (Homework Service)
```python
# services/homework_service.py
from flask import Flask, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from models.homework import Homework, HomeworkSubmission
from services.ai_service import AIService
from tasks.grading_tasks import grade_homework_async

class HomeworkService:
    def __init__(self):
        self.app = Flask(__name__)
        self.ai_service = AIService()
        self.setup_routes()
    
    def setup_routes(self):
        @self.app.route('/homework/list', methods=['GET'])
        @jwt_required()
        def get_homework_list():
            user_id = get_jwt_identity()
            status = request.args.get('status')
            subject = request.args.get('subject')
            
            homeworks = Homework.get_by_user(
                user_id=user_id,
                status=status,
                subject=subject
            )
            
            return jsonify({
                'success': True,
                'data': [hw.to_dict() for hw in homeworks]
            })
        
        @self.app.route('/homework/detail/<int:homework_id>', methods=['GET'])
        @jwt_required()
        def get_homework_detail(homework_id):
            user_id = get_jwt_identity()
            homework = Homework.get_by_id(homework_id)
            
            if not homework.can_access(user_id):
                return jsonify({'success': False, 'message': '无权访问'}), 403
            
            # 获取推荐内容
            recommendations = self.ai_service.get_recommendations(
                homework_id=homework_id,
                user_id=user_id
            )
            
            result = homework.to_dict()
            result['recommendations'] = recommendations
            
            return jsonify({
                'success': True,
                'data': result
            })
        
        @self.app.route('/homework/submit', methods=['POST'])
        @jwt_required()
        def submit_homework():
            user_id = get_jwt_identity()
            data = request.get_json()
            
            submission = HomeworkSubmission.create(
                homework_id=data['homework_id'],
                user_id=user_id,
                answers=data['answers'],
                submission_time=datetime.utcnow()
            )
            
            # 异步评分
            grade_homework_async.delay(submission.id)
            
            return jsonify({
                'success': True,
                'submission_id': submission.id,
                'message': '作业提交成功，正在评分中...'
            })
        
        @self.app.route('/homework/save', methods=['POST'])
        @jwt_required()
        def save_progress():
            user_id = get_jwt_identity()
            data = request.get_json()
            
            progress = HomeworkProgress.upsert(
                homework_id=data['homework_id'],
                user_id=user_id,
                answers=data['answers'],
                current_question=data.get('current_question', 0)
            )
            
            return jsonify({
                'success': True,
                'progress': progress.to_dict()
            })
```

#### 3. 推荐引擎服务 (Recommendation Service)
```python
# services/recommendation_service.py
from flask import Flask, request, jsonify
from ml_models.collaborative_filtering import CollaborativeFilteringModel
from ml_models.knowledge_graph import KnowledgeGraphModel
from ml_models.symbol_predictor import SymbolPredictorModel
import redis
import json

class RecommendationService:
    def __init__(self):
        self.app = Flask(__name__)
        self.redis_client = redis.Redis(host='localhost', port=6379, db=0)
        self.cf_model = CollaborativeFilteringModel()
        self.kg_model = KnowledgeGraphModel()
        self.symbol_model = SymbolPredictorModel()
        self.setup_routes()
    
    def setup_routes(self):
        @self.app.route('/recommend/symbols', methods=['POST'])
        def recommend_symbols():
            data = request.get_json()
            context = data.get('context', '')
            user_id = data.get('user_id')
            
            # 缓存键
            cache_key = f"symbols:{user_id}:{hash(context)}"
            
            # 检查缓存
            cached_result = self.redis_client.get(cache_key)
            if cached_result:
                return jsonify(json.loads(cached_result))
            
            # 生成推荐
            symbols = self.symbol_model.predict(context, user_id)
            
            result = {
                'success': True,
                'recommendations': symbols,
                'context': context
            }
            
            # 缓存结果（5分钟）
            self.redis_client.setex(cache_key, 300, json.dumps(result))
            
            return jsonify(result)
        
        @self.app.route('/recommend/knowledge', methods=['POST'])
        def recommend_knowledge():
            data = request.get_json()
            question_id = data.get('question_id')
            user_id = data.get('user_id')
            
            # 基于知识图谱的推荐
            knowledge_points = self.kg_model.recommend_knowledge_points(
                question_id=question_id,
                user_id=user_id
            )
            
            # 基于协同过滤的推荐
            cf_recommendations = self.cf_model.recommend_items(
                user_id=user_id,
                item_type='knowledge_point'
            )
            
            # 融合推荐结果
            final_recommendations = self._merge_recommendations(
                knowledge_points, cf_recommendations
            )
            
            return jsonify({
                'success': True,
                'recommendations': final_recommendations
            })
        
        @self.app.route('/recommend/exercises', methods=['POST'])
        def recommend_exercises():
            data = request.get_json()
            user_id = data.get('user_id')
            difficulty_level = data.get('difficulty_level', 'medium')
            topic = data.get('topic')
            
            exercises = self.cf_model.recommend_exercises(
                user_id=user_id,
                difficulty_level=difficulty_level,
                topic=topic,
                limit=10
            )
            
            return jsonify({
                'success': True,
                'recommendations': exercises
            })
    
    def _merge_recommendations(self, kg_results, cf_results):
        """融合知识图谱和协同过滤的推荐结果"""
        merged = {}
        
        # 知识图谱推荐权重0.6
        for item in kg_results:
            merged[item['id']] = {
                **item,
                'score': item['score'] * 0.6,
                'source': 'knowledge_graph'
            }
        
        # 协同过滤推荐权重0.4
        for item in cf_results:
            if item['id'] in merged:
                merged[item['id']]['score'] += item['score'] * 0.4
                merged[item['id']]['source'] = 'hybrid'
            else:
                merged[item['id']] = {
                    **item,
                    'score': item['score'] * 0.4,
                    'source': 'collaborative_filtering'
                }
        
        # 按分数排序
        result = sorted(merged.values(), key=lambda x: x['score'], reverse=True)
        return result[:10]  # 返回前10个
```

#### 4. 评分系统服务 (Grading Service)
```python
# services/grading_service.py
from flask import Flask, request, jsonify
from ml_models.auto_grader import AutoGrader
from ml_models.error_analyzer import ErrorAnalyzer
from models.grading_result import GradingResult

class GradingService:
    def __init__(self):
        self.app = Flask(__name__)
        self.auto_grader = AutoGrader()
        self.error_analyzer = ErrorAnalyzer()
        self.setup_routes()
    
    def setup_routes(self):
        @self.app.route('/grading/evaluate', methods=['POST'])
        def evaluate_submission():
            data = request.get_json()
            submission_id = data['submission_id']
            answers = data['answers']
            homework_id = data['homework_id']
            
            # 获取标准答案
            homework = Homework.get_by_id(homework_id)
            standard_answers = homework.get_standard_answers()
            
            results = []
            total_score = 0
            
            for question_id, student_answer in answers.items():
                standard_answer = standard_answers.get(question_id)
                
                # 自动评分
                score, feedback = self.auto_grader.grade(
                    student_answer=student_answer,
                    standard_answer=standard_answer,
                    question_type=homework.get_question_type(question_id)
                )
                
                # 错误分析
                error_analysis = self.error_analyzer.analyze(
                    student_answer=student_answer,
                    standard_answer=standard_answer
                )
                
                question_result = {
                    'question_id': question_id,
                    'score': score,
                    'feedback': feedback,
                    'error_analysis': error_analysis,
                    'student_answer': student_answer,
                    'standard_answer': standard_answer
                }
                
                results.append(question_result)
                total_score += score
            
            # 保存评分结果
            grading_result = GradingResult.create(
                submission_id=submission_id,
                total_score=total_score,
                max_score=len(answers) * 100,
                question_results=results,
                graded_at=datetime.utcnow()
            )
            
            return jsonify({
                'success': True,
                'grading_result': grading_result.to_dict()
            })
        
        @self.app.route('/grading/feedback/<int:submission_id>', methods=['GET'])
        def get_feedback(submission_id):
            grading_result = GradingResult.get_by_submission_id(submission_id)
            
            if not grading_result:
                return jsonify({'success': False, 'message': '评分结果不存在'}), 404
            
            return jsonify({
                'success': True,
                'feedback': grading_result.to_dict()
            })
```

## 数据访问层设计

### ORM模型设计

```python
# models/base.py
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, DateTime, create_engine
from sqlalchemy.orm import sessionmaker
from datetime import datetime

Base = declarative_base()

class BaseModel(Base):
    __abstract__ = True
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def to_dict(self):
        return {c.name: getattr(self, c.name) for c in self.__table__.columns}

# 数据库连接配置
DATABASE_URL = "mysql+pymysql://hcj:Xv0Mu8_:@obmt6zg485miazb4-mi.aliyun-cn-beijing-internet.oceanbase.cloud:3306/testccnu"
engine = create_engine(DATABASE_URL, echo=True)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
```

```python
# models/user.py
from sqlalchemy import Column, String, Integer, Boolean, Text, Enum
from sqlalchemy.orm import relationship
from models.base import BaseModel, SessionLocal
import bcrypt

class User(BaseModel):
    __tablename__ = 'users'
    
    username = Column(String(50), unique=True, nullable=False)
    email = Column(String(100), unique=True, nullable=False)
    password_hash = Column(String(255), nullable=False)
    role = Column(Enum('student', 'teacher', 'admin'), default='student')
    grade = Column(Integer)  # 年级
    school = Column(String(100))
    profile = Column(Text)  # JSON格式的用户配置
    is_active = Column(Boolean, default=True)
    
    # 关联关系
    homework_submissions = relationship("HomeworkSubmission", back_populates="user")
    learning_records = relationship("LearningRecord", back_populates="user")
    
    @classmethod
    def create(cls, username, password, email, role='student', **kwargs):
        password_hash = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())
        
        user = cls(
            username=username,
            email=email,
            password_hash=password_hash.decode('utf-8'),
            role=role,
            **kwargs
        )
        
        session = SessionLocal()
        try:
            session.add(user)
            session.commit()
            session.refresh(user)
            return user
        finally:
            session.close()
    
    @classmethod
    def authenticate(cls, username, password):
        session = SessionLocal()
        try:
            user = session.query(cls).filter_by(username=username).first()
            if user and bcrypt.checkpw(password.encode('utf-8'), user.password_hash.encode('utf-8')):
                return user
            return None
        finally:
            session.close()
    
    def get_permissions(self):
        """获取用户权限"""
        if self.role == 'admin':
            return ['*']
        elif self.role == 'teacher':
            return ['homework.create', 'homework.edit', 'homework.grade', 'student.view']
        else:  # student
            return ['homework.view', 'homework.submit', 'profile.edit']
```

```python
# models/homework.py
from sqlalchemy import Column, String, Integer, Text, DateTime, Boolean, ForeignKey, JSON
from sqlalchemy.orm import relationship
from models.base import BaseModel

class Homework(BaseModel):
    __tablename__ = 'homeworks'
    
    title = Column(String(200), nullable=False)
    description = Column(Text)
    subject = Column(String(50), nullable=False)  # 学科
    grade = Column(Integer, nullable=False)  # 年级
    difficulty_level = Column(Integer, default=3)  # 难度等级 1-5
    questions = Column(JSON)  # 题目数据
    standard_answers = Column(JSON)  # 标准答案
    due_date = Column(DateTime)
    max_score = Column(Integer, default=100)
    time_limit = Column(Integer)  # 时间限制（分钟）
    created_by = Column(Integer, ForeignKey('users.id'))
    is_published = Column(Boolean, default=False)
    
    # 关联关系
    creator = relationship("User", foreign_keys=[created_by])
    submissions = relationship("HomeworkSubmission", back_populates="homework")
    
    def can_access(self, user_id):
        """检查用户是否可以访问此作业"""
        if self.created_by == user_id:
            return True
        
        # 检查是否已发布且在截止时间内
        if self.is_published and (not self.due_date or datetime.utcnow() <= self.due_date):
            return True
        
        return False
    
    def get_question_type(self, question_id):
        """获取题目类型"""
        for question in self.questions:
            if question['id'] == question_id:
                return question.get('type', 'text')
        return 'text'
    
    def get_standard_answers(self):
        """获取标准答案"""
        return {str(q['id']): q.get('answer') for q in self.questions if 'answer' in q}

class HomeworkSubmission(BaseModel):
    __tablename__ = 'homework_submissions'
    
    homework_id = Column(Integer, ForeignKey('homeworks.id'))
    user_id = Column(Integer, ForeignKey('users.id'))
    answers = Column(JSON)  # 学生答案
    score = Column(Integer)
    max_score = Column(Integer)
    status = Column(String(20), default='submitted')  # submitted, graded
    submission_time = Column(DateTime)
    grading_time = Column(DateTime)
    
    # 关联关系
    homework = relationship("Homework", back_populates="submissions")
    user = relationship("User", back_populates="homework_submissions")
    grading_result = relationship("GradingResult", back_populates="submission", uselist=False)
```

## 缓存策略设计

### Redis缓存层

```python
# cache/redis_cache.py
import redis
import json
import pickle
from functools import wraps
from datetime import timedelta

class RedisCache:
    def __init__(self, host='localhost', port=6379, db=0):
        self.client = redis.Redis(host=host, port=port, db=db, decode_responses=True)
    
    def get(self, key):
        """获取缓存"""
        value = self.client.get(key)
        if value:
            try:
                return json.loads(value)
            except json.JSONDecodeError:
                return pickle.loads(value.encode('latin-1'))
        return None
    
    def set(self, key, value, timeout=3600):
        """设置缓存"""
        try:
            serialized_value = json.dumps(value)
        except (TypeError, ValueError):
            serialized_value = pickle.dumps(value).decode('latin-1')
        
        self.client.setex(key, timeout, serialized_value)
    
    def delete(self, key):
        """删除缓存"""
        self.client.delete(key)
    
    def exists(self, key):
        """检查缓存是否存在"""
        return self.client.exists(key)

# 缓存装饰器
def cached(timeout=3600, key_prefix=''):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # 生成缓存键
            cache_key = f"{key_prefix}:{func.__name__}:{hash(str(args) + str(kwargs))}"
            
            # 尝试从缓存获取
            cache = RedisCache()
            cached_result = cache.get(cache_key)
            if cached_result is not None:
                return cached_result
            
            # 执行函数并缓存结果
            result = func(*args, **kwargs)
            cache.set(cache_key, result, timeout)
            
            return result
        return wrapper
    return decorator

# 使用示例
@cached(timeout=1800, key_prefix='homework')
def get_homework_recommendations(user_id, homework_id):
    # 复杂的推荐计算
    return recommendation_engine.compute_recommendations(user_id, homework_id)
```

## 异步任务处理

### Celery任务队列

```python
# tasks/grading_tasks.py
from celery import Celery
from services.grading_service import GradingService
from models.homework import HomeworkSubmission

celery_app = Celery('homework_system')
celery_app.config_from_object('config.CeleryConfig')

grading_service = GradingService()

@celery_app.task(bind=True, max_retries=3)
def grade_homework_async(self, submission_id):
    """异步评分任务"""
    try:
        submission = HomeworkSubmission.get_by_id(submission_id)
        if not submission:
            raise ValueError(f"Submission {submission_id} not found")
        
        # 执行评分
        result = grading_service.evaluate_submission({
            'submission_id': submission_id,
            'answers': submission.answers,
            'homework_id': submission.homework_id
        })
        
        # 更新提交状态
        submission.status = 'graded'
        submission.score = result['grading_result']['total_score']
        submission.grading_time = datetime.utcnow()
        submission.save()
        
        # 发送通知
        send_grading_notification.delay(submission.user_id, submission_id)
        
        return result
        
    except Exception as exc:
        # 重试机制
        if self.request.retries < self.max_retries:
            raise self.retry(countdown=60, exc=exc)
        else:
            # 记录失败日志
            logger.error(f"Grading failed for submission {submission_id}: {exc}")
            raise

@celery_app.task
def send_grading_notification(user_id, submission_id):
    """发送评分完成通知"""
    from services.notification_service import NotificationService
    
    notification_service = NotificationService()
    notification_service.send_notification(
        user_id=user_id,
        type='grading_completed',
        title='作业评分完成',
        content=f'您的作业已完成评分，请查看结果。',
        data={'submission_id': submission_id}
    )

@celery_app.task
def update_recommendation_model():
    """定期更新推荐模型"""
    from ml_models.collaborative_filtering import CollaborativeFilteringModel
    
    cf_model = CollaborativeFilteringModel()
    cf_model.retrain()
    cf_model.save_model()
```

## API文档设计

### Swagger/OpenAPI规范

```python
# api_docs.py
from flask_restx import Api, Resource, fields
from flask import Blueprint

api_bp = Blueprint('api', __name__)
api = Api(
    api_bp,
    title='DIEM系统API文档',
    version='1.0',
    description='K-12数学教育智能数字生态系统API接口文档',
    doc='/docs/'
)

# 数据模型定义
homework_model = api.model('Homework', {
    'id': fields.Integer(required=True, description='作业ID'),
    'title': fields.String(required=True, description='作业标题'),
    'description': fields.String(description='作业描述'),
    'subject': fields.String(required=True, description='学科'),
    'grade': fields.Integer(required=True, description='年级'),
    'difficulty_level': fields.Integer(description='难度等级'),
    'due_date': fields.DateTime(description='截止时间'),
    'questions': fields.List(fields.Raw, description='题目列表')
})

submission_model = api.model('HomeworkSubmission', {
    'homework_id': fields.Integer(required=True, description='作业ID'),
    'answers': fields.Raw(required=True, description='答案数据'),
    'submission_time': fields.DateTime(description='提交时间')
})

# API接口定义
@api.route('/homework/list')
class HomeworkList(Resource):
    @api.doc('获取作业列表')
    @api.param('status', '作业状态', type='string', enum=['all', 'pending', 'completed'])
    @api.param('subject', '学科筛选', type='string')
    @api.marshal_list_with(homework_model)
    def get(self):
        """获取用户的作业列表"""
        pass

@api.route('/homework/<int:homework_id>')
class HomeworkDetail(Resource):
    @api.doc('获取作业详情')
    @api.marshal_with(homework_model)
    def get(self, homework_id):
        """获取指定作业的详细信息"""
        pass

@api.route('/homework/submit')
class HomeworkSubmit(Resource):
    @api.doc('提交作业')
    @api.expect(submission_model)
    def post(self):
        """提交作业答案"""
        pass
```

## 监控和日志

### 应用监控

```python
# monitoring/metrics.py
from prometheus_client import Counter, Histogram, Gauge, start_http_server
import time
from functools import wraps

# 指标定义
REQUEST_COUNT = Counter('http_requests_total', 'Total HTTP requests', ['method', 'endpoint', 'status'])
REQUEST_LATENCY = Histogram('http_request_duration_seconds', 'HTTP request latency')
ACTIVE_USERS = Gauge('active_users_total', 'Number of active users')
HOMEWORK_SUBMISSIONS = Counter('homework_submissions_total', 'Total homework submissions')

def monitor_requests(func):
    """监控HTTP请求的装饰器"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        
        try:
            result = func(*args, **kwargs)
            status = getattr(result, 'status_code', 200)
            REQUEST_COUNT.labels(
                method=request.method,
                endpoint=request.endpoint,
                status=status
            ).inc()
            return result
        except Exception as e:
            REQUEST_COUNT.labels(
                method=request.method,
                endpoint=request.endpoint,
                status=500
            ).inc()
            raise
        finally:
            REQUEST_LATENCY.observe(time.time() - start_time)
    
    return wrapper

# 启动监控服务器
def start_monitoring():
    start_http_server(8000)
```

### 日志配置

```python
# logging_config.py
import logging
import logging.handlers
from pythonjsonlogger import jsonlogger

def setup_logging():
    # 创建logger
    logger = logging.getLogger('homework_system')
    logger.setLevel(logging.INFO)
    
    # 控制台处理器
    console_handler = logging.StreamHandler()
    console_formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    console_handler.setFormatter(console_formatter)
    
    # 文件处理器
    file_handler = logging.handlers.RotatingFileHandler(
        'logs/app.log',
        maxBytes=10485760,  # 10MB
        backupCount=10
    )
    
    # JSON格式化器
    json_formatter = jsonlogger.JsonFormatter(
        '%(asctime)s %(name)s %(levelname)s %(message)s'
    )
    file_handler.setFormatter(json_formatter)
    
    # 添加处理器
    logger.addHandler(console_handler)
    logger.addHandler(file_handler)
    
    return logger

# 使用示例
logger = setup_logging()

def log_user_action(user_id, action, details=None):
    logger.info(
        f"User action: {action}",
        extra={
            'user_id': user_id,
            'action': action,
            'details': details,
            'timestamp': datetime.utcnow().isoformat()
        }
    )
```

## 安全设计

### 认证和授权

```python
# security/auth.py
from functools import wraps
from flask import request, jsonify
from flask_jwt_extended import verify_jwt_in_request, get_jwt_claims

def require_permissions(*required_permissions):
    """权限检查装饰器"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            verify_jwt_in_request()
            claims = get_jwt_claims()
            user_permissions = claims.get('permissions', [])
            
            # 检查是否有超级权限
            if '*' in user_permissions:
                return func(*args, **kwargs)
            
            # 检查具体权限
            for permission in required_permissions:
                if permission not in user_permissions:
                    return jsonify({'message': '权限不足'}), 403
            
            return func(*args, **kwargs)
        return wrapper
    return decorator

def rate_limit(max_requests=100, window=3600):
    """API限流装饰器"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            client_ip = request.remote_addr
            key = f"rate_limit:{client_ip}:{func.__name__}"
            
            current_requests = redis_client.get(key)
            if current_requests and int(current_requests) >= max_requests:
                return jsonify({'message': '请求频率过高，请稍后再试'}), 429
            
            redis_client.incr(key)
            redis_client.expire(key, window)
            
            return func(*args, **kwargs)
        return wrapper
    return decorator
```

## 总结

本后端架构设计采用微服务架构模式，通过合理的服务拆分、数据管理、缓存策略和异步处理，构建了一个高性能、高可用的教育应用后端系统。主要特点包括：

1. **微服务架构**：按业务域拆分，独立部署和扩展
2. **智能推荐**：多种推荐算法融合，提供个性化服务
3. **异步处理**：重计算任务异步执行，提升用户体验
4. **缓存优化**：多层缓存策略，减少数据库压力
5. **监控完善**：指标监控、日志记录、性能分析
6. **安全可靠**：认证授权、权限控制、API限流

该架构能够很好地支持K-12数学教育的复杂业务场景，为前端提供稳定、高效的API服务。
